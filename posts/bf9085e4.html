<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="前端,JavaScript,">





  <link rel="alternate" href="/atom.xml" title="zm.blog" type="application/atom+xml">






<meta name="description" content="这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。 JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。 JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。">
<meta name="keywords" content="前端,JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="ES5 to ESNext 自2015以来JavaScript新增的所有新特性">
<meta property="og:url" content="https://zhangmiao.cc/posts/bf9085e4.html">
<meta property="og:site_name" content="zm.blog">
<meta property="og:description" content="这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。 JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。 JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175944.png">
<meta property="og:image" content="http://5b0988e595225.cdn.sohucs.com/images/20190318/29ddbe9d6db84099ba7c67597ac82c0b.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428180419.png">
<meta property="og:updated_time" content="2021-12-24T02:05:29.960Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES5 to ESNext 自2015以来JavaScript新增的所有新特性">
<meta name="twitter:description" content="这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。 JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。 JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175944.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zhangmiao.cc/posts/bf9085e4.html">





  <title>ES5 to ESNext 自2015以来JavaScript新增的所有新特性 | zm.blog</title>
  





  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?44434226ba535875b1e807122adc3a04";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zm.blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">select * from learn</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhangmiao.cc/posts/bf9085e4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangMiao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/4081078?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zm.blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ES5 to ESNext 自2015以来JavaScript新增的所有新特性</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T10:23:46+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/bf9085e4.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="posts/bf9085e4.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/posts/bf9085e4.html" class="leancloud_visitors" data-flag-title="ES5 to ESNext 自2015以来JavaScript新增的所有新特性">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。</p>
<p>JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。</p>
<p>JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。</p>
<a id="more"></a>

<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h5 id="ECMAScript-简介"><a href="#ECMAScript-简介" class="headerlink" title="ECMAScript 简介"></a>ECMAScript 简介</h5><h5 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h5><ul>
<li>let 和 const</li>
<li>箭头函数</li>
<li>类</li>
<li>默认参数</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>增强的对象字面量</li>
<li>For-of 循环</li>
<li>Promises</li>
<li>模块</li>
<li>String 新方法</li>
<li>Object 新方法</li>
<li>展开运算符</li>
<li>Set</li>
<li>Map</li>
<li>Generators</li>
</ul>
<h5 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h5><ul>
<li>Array.prototype.includes()</li>
<li>求幂运算符</li>
</ul>
<h5 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h5><ul>
<li>字符串填充</li>
<li>Object.values()</li>
<li>Object.entries()</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>尾逗号</li>
<li>共享内存 and 原子操作</li>
</ul>
<h5 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h5><ul>
<li>Rest/Spread Properties</li>
<li>Asynchronous iteration</li>
<li>Promise.prototype.finally()</li>
<li>正则表达式改进</li>
</ul>
<h5 id="ESNext"><a href="#ESNext" class="headerlink" title="ESNext"></a>ESNext</h5><ul>
<li>Array.prototype.{flat,flatMap}</li>
<li>try/catch 可选的参数绑定</li>
<li>Object.fromEntries()</li>
<li>String.prototype.{trimStart,trimEnd}</li>
<li>Symbol.prototype.description</li>
<li>JSON improvements</li>
<li>Well-formed JSON.stringify()</li>
<li>Function.prototype.toString()</li>
</ul>
<h4 id="ECMAScript-简介-1"><a href="#ECMAScript-简介-1" class="headerlink" title="ECMAScript 简介"></a>ECMAScript 简介</h4><p>每当阅读 JavaScript 相关的文章时，我都会经常遇到如下术语： ES3, ES5, ES6, ES7, ES8, ES2015, ES2016, ES2017, ECMAScript 2017, ECMAScript 2016, ECMAScript 2015 等等，那么它们是指代的是什么？</p>
<p>它们都是指代一个名为 ECMAScript 的标准。</p>
<p>JavaScript 就是基于这个标准实现的，ECMAScript 经常缩写为 ES。</p>
<p>除了 JavaScript 以外，其它基于 ECMAScript 实现语言包括：</p>
<ul>
<li>ActionScript ( Flash 脚本语言)，由于 Adobe 将于 2020 年末停止对 Flash 的支持而逐渐失去热度。</li>
<li>JScript (微软开发的脚本语言),在第一次浏览器大战最激烈的时期，JavaScript 只被Netscape所支持，微软必须为 Internet Explorer 构建自己的脚本语言。</li>
</ul>
<p>但是现在流传最广、影响最大的基于 ES 标准的语言实现无疑就是 JavaScript了</p>
<p>为啥要用这个奇怪的名字呢？Ecma International 是瑞士标准协会，负责制定国际标准。</p>
<p>JavaScript 被创建以后，经由 Netscape 和 Sun Microsystems 公司提交给欧洲计算机制造商协会进行标准化，被采纳的 ECMA-262 别名叫 ECMAScript。</p>
<blockquote>
<p>This press release by Netscape and Sun Microsystems (the maker of Java) might help figure out the name choice, which might include legal and branding issues by Microsoft which was in the committee, according to Wikipedia.</p>
</blockquote>
<p>IE9 之后微软的浏览器中就看不到对 JScript 这个命名的引用了，取而代之都统称为 JavaScript。</p>
<p>因此，截至201x，JavaScript 成为最流行的基于 ECMAScript 规范实现的语言。</p>
<h5 id="ECMAScript-当前的版本。"><a href="#ECMAScript-当前的版本。" class="headerlink" title="ECMAScript 当前的版本。"></a>ECMAScript 当前的版本。</h5><p>目前的最新的 ECMAScript 版本是 ES2018。</p>
<p>于 2018 年 6 月发布。</p>
<h5 id="TC39-是什么？"><a href="#TC39-是什么？" class="headerlink" title="TC39 是什么？"></a>TC39 是什么？</h5><p>TC39（Technical Committee 39）是一个推动 JavaScript 发展的委员会。</p>
<p>TC39的成员包括各个主流浏览器厂商以及业务与浏览器紧密相连的公司，其中包括 Mozilla，Google ，Facebook，Apple，Microsoft，Intel，PayPal，SalesForce等。</p>
<p>每个标准版本提案都必须经过四个不同的阶段，这里有详细的解释。</p>
<h5 id="ES-Versions"><a href="#ES-Versions" class="headerlink" title="ES Versions"></a>ES Versions</h5><p>令我费解的是 ES 版本的命名依据有时根据迭代的版本号，有时却根据年份来进行命名。而这个命名的不确定性又使得人们更加容易混淆 JS/ES 这个两个概念😄。</p>
<p>在 ES2015 之前，ECMAScript 各个版本的命名规范通常与跟着标准的版本更新保持一致。因此，2009年 ECMAScript 规范更新以后的的正式版本是 ES5。</p>
<blockquote>
<p>Why does this happen? During the process that led to ES2015, the name was changed from ES6 to ES2015, but since this was done late, people still referenced it as ES6, and the community has not left the edition naming behind — the world is still calling ES releases by edition number.</p>
</blockquote>
<p>为什么会发生这一切？在ES2015诞生的过程中，名称由ES6更改为ES2015，但由于最终完成太晚，人们仍然称其为ES6，社区也没有将版本号完全抛之于后 — 世界仍然使用 ES 来定义版本号。</p>
<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428175944.png" alt></p>
<p>接下来，我们来深入了解 JavaScript 自 ES5 以来增加的特性。</p>
<h4 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h4><p>ES2015 之前, var 是唯一可以用来声明变量的语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上面语句如果你遗漏了 var，那么你会把这个值（0）赋给一个未声明的变量，其中声明和未声明变量之间存在一些差异。</p>
<p>在现代浏览器开启严格模式时，给未声明的变量赋值会抛出 ReferenceError 异常，在较老的浏览器（或者禁用严格模式）的情况下，未声明的变量在执行赋值操作时会隐式的变为全局对象的属性。</p>
<p>当你声明一个变量却没有进行初始化，那么它的值直到你对它进行赋值操作之前都是 undefined 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="comment">//typeof a === 'undefined'</span></span><br></pre></td></tr></table></figure>

<p>你可以对一个变量进行多次重新声明，并覆盖它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>你也可以在一条声明语句中一次声明多个变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>作用域是变量可访问的代码部分。</p>
<p>在函数之外用 var 声明的会分配给全局对象，这种变量可以在全局作用域中被访问到。而在函数内部声明的变量只能在函数局部作用域被访问到，这类似于函数参数。</p>
<p>在函数中定义的局部变量名如何跟全局变量重名，那么局部变量的优先级更高，在函数内无法访问到同名的全局变量。</p>
<p>需要注意的是，var 是没有块级作用域（标识符是一对花括号）的，但是 var 是有函数作用域的，所以在新创建的块级作用域或者是函数作用域里面声明变量会覆盖全局同名变量，因为 var 在这两种情况下没有创建新的作用域。</p>
<p>在函数内部，其中定义的任何变量在所有函数代码中都是可见的，因为JavaScript在执行代码之前实际上将所有变量都移到了顶层（被称为悬挂的东西）。 在函数的内部定义的变量在整个函数作用域中都是可见（可访问），即使变量是在函数体末尾被声明，但是仍然可以再函数体开头部分被引用，因为 JavaScript存在变量提升机制。为避免混淆，请在函数开头声明变量，养成良好的编码规范。</p>
<h4 id="Using-let"><a href="#Using-let" class="headerlink" title="Using let"></a>Using let</h4><p>let 是ES2015中引入的新功能，它本质上是具有块级作用域的 var 。它可以被当前作用域（函数以及块级作用域）以及子级作用域访问到。</p>
<p>现代 JavaScript 开发者在 let 和 var 的选择中可能会更倾向于前者。</p>
<blockquote>
<p>如果 let 看起来是一个很抽象的术语，当你阅读到 let color = ‘red’ 这一段，因为使用 let 定义了color 为红色，那么这一切就变的有意义了。</p>
</blockquote>
<p>在任何函数之外用 let 声明变量，和 var相反的是 它并不会创建全局变量。</p>
<h4 id="Using-const"><a href="#Using-const" class="headerlink" title="Using const"></a>Using const</h4><p>使用变量 var 或 let 声明的变量可以被重新赋值。 使用 const 声明的变量一经初始化，它的值就永远不能再改变，即不可重新被赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'test'</span></span><br></pre></td></tr></table></figure>

<p>我们不能再为 a 进行赋值操作。然而，a 如果它是一个具有属性或者方法的对象，那么我们可以改变它的属性或者方法。</p>
<p>const 并不意味着具有不可变性，只是保证用 const 声明的变量的引用地址不被变更。</p>
<p>类似于 let，const 也具有块级作用域。</p>
<p>现代 JavaScript 开发者在遇到不会进行二次赋值的变量声明时，应该尽量使用 const。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数的引入极大的改变了代码的书写风格和一些工作机制。</p>
<p>在我看来，箭头函数很受开发者欢迎，现在很少在比较新的代码库中看到 function 关键字了，虽然它并未被废弃。</p>
<p>箭头函数看起来会更加的简洁，因为它允许你使用更短的语法来书写函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数体中只包含一条语句，你甚至可以省略大括号并直接书写这条语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> doSomething()</span><br></pre></td></tr></table></figure>

<p>参数在括号中传递：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function">(<span class="params">param1, param2</span>) =&gt;</span> doSomething(param1, param2)</span><br></pre></td></tr></table></figure>

<p>如果该函数只有一个参数，那么可以省略掉括号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = param =&gt; doSomething(param)</span><br></pre></td></tr></table></figure>

<p>由于这种简短的语法，使得我们可以更便捷的使用比较简短的函数</p>
<h4 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h4><p>箭头函数支持隐式返回：可以正常的 return 一个返回值但是可以不使用 return 关键字。</p>
<p>隐式返回只在函数体内只包含一条语句的情况下生效：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'test'</span></span><br><span class="line">myFunction() <span class="comment">//'test'</span></span><br></pre></td></tr></table></figure>

<p>需要注意的一种情况，当返回一个对象时，记得将大括号括在括号中以避免产生歧义，误将其（大括号）解析为函数体的大括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">value</span>:<span class="string">'test'</span> &#125;)</span><br><span class="line">myFunction() <span class="comment">//&#123;value: 'test'&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h4><p>this 可能是一个很难掌握的概念，因为它会根据上下文而进行变化，并且会在不同的 JavaScript的模式（是否为严格模式）下表现出差异。</p>
<p>理解 this 这个概念对于箭头函数的使用很重要，因为与常规函数相比，箭头函数的表现非常不同。</p>
<p>对象的方法为常规函数时，方法中的this指向这个对象，因此可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  model:<span class="string">'Fiesta'</span>,</span><br><span class="line">  manufacturer:<span class="string">'Ford'</span>,</span><br><span class="line">  fullName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.manufacturer&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 car.fullName() 会返回 “Ford Fiesta”。</p>
<p>如果上述方法使用是是箭头函数，由于箭头中的 this 的作用域继承自执行上下文，箭头函数自身不绑定 this，因此 this 的值将在调用堆栈中查找，因此在此代码 car.fullName() 中不会返回常规函数那样的结果，实际会返回字符串 “undefined undefined”：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  model:<span class="string">'Fiesta'</span>,</span><br><span class="line">  manufacturer:<span class="string">'Ford'</span>,</span><br><span class="line">  fullName:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.manufacturer&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，箭头函数不适合作为对象方法。</p>
<p>同样，箭头函数也不适合使用在作为创建构造函数，因为在实例化对象时会抛出 TypeError。</p>
<p>所以在不需要动态上下文时请使用常规函数。</p>
<p>当然，在事件监听器上使用箭头函数也会存在问题。因为 DOM 事件侦听器会自动将 this 与目标元素绑定，如果该事件处理程序的逻辑依赖 this，那么需要常规函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.querySelector(<span class="string">'#link'</span>)</span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// this === window</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.querySelector(<span class="string">'#link'</span>)</span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this === link</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Classes类"><a href="#Classes类" class="headerlink" title="Classes类"></a>Classes类</h4><p>JavaScript 实现继承的方式比较罕见：原型继承。原型继承虽然在我看来很棒，但与其它大多数流行的编程语言的继承实现机制不同，后者是基于类的。</p>
<p>因此 Java、Python 或其它语言的开发者很难理解原型继承的方式，因此 ECMAScript 委员会决定在原型继承之上实现 class 的语法糖，这样便于让其它基于类实现继承的语言的开发者更好的理解 JavaScript 代码。</p>
<p>注意：class 并没有对 JavaScript 底层做修改，你仍然可以直接访问对象原型。</p>
<h5 id="class-定义"><a href="#class-定义" class="headerlink" title="class 定义"></a>class 定义</h5><p>如下是一个 class 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, I am '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class 具有一个标识符，我们可以使用 new ClassIdentifier() 来创建一个对象实例。</p>
<p>初始化对象时，调用 constructor方法，并将参数传递给此方法。</p>
<p>类声明语句中也可以增加类需要的一些原型方法。在这种情况下 hello 是 Person 类的一个原型方法，可以在这个类的对象实例上调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flavio = <span class="keyword">new</span> Person(<span class="string">'Flavio'</span>)</span><br><span class="line">flavio.hello()</span><br></pre></td></tr></table></figure>

<h4 id="Class-继承"><a href="#Class-继承" class="headerlink" title="Class 继承"></a>Class 继承</h4><p>一个子类可以 extend 另一个类，通过子类实例化出来的对象可以继承这两个类的所有方法。</p>
<p>如果子类中的方法与父类中的方法名重复，那么子类中的同名方法优先级更高：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">' I am a programmer.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> flavio = <span class="keyword">new</span> Programmer(<span class="string">'Flavio'</span>)</span><br><span class="line">flavio.hello()</span><br></pre></td></tr></table></figure>

<p>(上述代码会打印出：“Hello, I am Flavio. I am a programmer.”)</p>
<p>类没有显示的类变量声明，但你必须在初始化构造函数 constructor 中去初始化类成员变量。</p>
<p>在子类中，你可以通过调用super()引用父类。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>在类中，通常会把方法直接挂载到实例对象上，直接在实例对象上调用。</p>
<p>而静态方法则是直接使用类名来调用，而不是通过对象实例调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> genericHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.genericHello() <span class="comment">//Hello</span></span><br></pre></td></tr></table></figure>

<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>JavaScript 没有内置真正意义上的受保护的私有方法。</p>
<p>社区有解决方法，但我不会在这里做讲解。</p>
<h5 id="Getters-和-setters"><a href="#Getters-和-setters" class="headerlink" title="Getters 和 setters"></a>Getters 和 setters</h5><p>你可以通过增加方法 前缀 get 或者 set 创建一个 getter 和 setter，getter 和 setter会在你去获取特定值或者修改特定值的时候执行 get 或者 set内的相关方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你只有 getter，该属性无法被设置，并且设置此属性的操作都会被忽略：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你只有一个 setter，则可以更改该值，但不能从外部访问它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>函数 doSomething 接收一个 param1 参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以给 param1 设定默认值，如果在调用函数时未传入参数，那么该参数自动设定未默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1 = <span class="string">'test'</span></span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这种机制同样适用于多个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1 = <span class="string">'test'</span>, param2 = <span class="string">'test2'</span></span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如你的函数是一个具有特定属性的对象该怎么处理？</p>
<p>曾几何时，如果我们必须要取一个对象的特定属性值，为了做兼容处理（对象格式不正确），你必须在函数中添加一些代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colorize = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">    options = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> color = (<span class="string">'color'</span> <span class="keyword">in</span> options) ? options.color :<span class="string">'yellow'</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过解构，你可以给特定属性提供默认值，如此可以大大简化代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const colorize = (&#123; color = &apos;yellow&apos; &#125;) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在调用 colorize 函数时没有传递任何对象，我们同样可以得到一个默认对象作为参数以供使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spin = <span class="function">(<span class="params">&#123; color = <span class="string">'yellow'</span> &#125; = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>模板字符串不同于 ES5 以前的版本，你可以用新颖的方式使用字符串。</p>
<p>这个语法看起来非常简便，只需要使用一个反引号替换掉单引号或双引号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a_string = <span class="string">`something`</span></span><br></pre></td></tr></table></figure>

<p>这个用法是独一无二的，因为它提供了许多普通字符串所没有的功能，如下：</p>
<ul>
<li>它为定义多行字符串提供了一个很好的语法</li>
<li>它提供了一种在字符串中插入变量和表达式的简单方法</li>
<li>它允许您创建带有模板标签的DSL (DSL意味着领域特定语言，例如：就如同在 React 中使用 styled-components 定义你组件的 CSS 一样)</li>
</ul>
<p>下面让我们深入每个功能的细节。</p>
<h5 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h5><p>在 ES6 标准之前，创建跨越两行的字符串只能在一行的结尾使用 ‘’ 字符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string =</span><br><span class="line">  <span class="string">'first part</span></span><br><span class="line"><span class="string">second part'</span></span><br></pre></td></tr></table></figure>

<p>这样使得你创建的字符串虽然跨越了两汉，但是渲染时仍然表现成一行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first part second part</span><br></pre></td></tr></table></figure>

<p>需要渲染为多行的话，需要在一行结尾添加 ‘ ’，比如这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string =</span><br><span class="line">  <span class="string">'first line</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">second line'</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">'first line</span></span><br><span class="line"><span class="string">'</span>+ <span class="string">'second line'</span></span><br></pre></td></tr></table></figure>

<p>模板字符串使得定义多行字符串变得更加简便。</p>
<p>一个模板字符串由一个反引号开始，你只需要按下回车键来创建新的一行，不需要插入特殊符号，最终的渲染效果如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`Hey</span></span><br><span class="line"><span class="string">this</span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">is awesome!`</span></span><br></pre></td></tr></table></figure>

<p>需要特别留意空格在这里是有特殊意义的，如果这样做的话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`First</span></span><br><span class="line"><span class="string">                Second`</span></span><br></pre></td></tr></table></figure>

<p>那么它会创建出像下面的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">First</span><br><span class="line">                Second</span><br></pre></td></tr></table></figure>

<p>有一个简单的方法可以修复这个问题，只需要将第一行置为空，然后添加了右边的翻译好后调用一个 trim() 方法，就可以消除第一个字符前的所有空格：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`</span></span><br><span class="line"><span class="string">First</span></span><br><span class="line"><span class="string">Second`</span>.trim()</span><br></pre></td></tr></table></figure>

<h5 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h5><p>模板字符串提供了插入变量和表达式的便捷方法</p>
<p>你只需要使用 ${…} 语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">var</span> = <span class="string">'test'</span></span><br><span class="line"><span class="keyword">const</span> string = <span class="string">`something <span class="subst">$&#123;<span class="keyword">var</span>&#125;</span>`</span> <span class="comment">//something test</span></span><br></pre></td></tr></table></figure>

<p>在 ${} 里面你可以加入任何东西，甚至是表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`something <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> string2 = <span class="string">`something <span class="subst">$&#123;foo() ? <span class="string">'x'</span> : <span class="string">'y'</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<h5 id="Template-tags"><a href="#Template-tags" class="headerlink" title="Template tags"></a>Template tags</h5><p>标记模板可能是一个听起来不太有用的功能，但它实际上被许多流行的库使用，如 Styled Components 、Apollo 、GraphQL客户端/服务器库，因此了解它的工作原理至关重要。</p>
<p>在 Styled Components 模板标签中用于定义CSS字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 1.5em;</span></span><br><span class="line"><span class="string">  background-color: black;</span></span><br><span class="line"><span class="string">  color: white;</span></span><br></pre></td></tr></table></figure>

<p>在 Apollo 中，模板标签用于定义 GraphQL 查询模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> query = gql<span class="string">`</span></span><br><span class="line"><span class="string">  query &#123;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>上面两个例子中的styled.button和gql模板标签其实都是函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gql</span>(<span class="params">literals, ...expressions</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回一个字符串，可以是任意类型的计算结果。</p>
<p>字面量(literals)是一个包含了表达式插值的模板字面量的序列。 表达式(expressions)包含了所有的插值。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const string = `something $&#123;1 + 2 + 3&#125;`</span><br></pre></td></tr></table></figure>

<p>这个例子里面的字面量是由2个部分组成的序列。第1部分就是something，也就是第一个插值位置(${})之前的字符串，第2部分就是一个空字符串，从第1个插值结束的位置直到字符串的结束。</p>
<p>这个例子里面的表达式就是只包含1个部分的序列，也就是6。</p>
<p>举一个更复杂的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`something</span></span><br><span class="line"><span class="string">another <span class="subst">$&#123;<span class="string">'x'</span>&#125;</span></span></span><br><span class="line"><span class="string">new line <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">test`</span></span><br></pre></td></tr></table></figure>

<p>这个例子里面的字面量的序列里面，第1个部分是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;<span class="string">`something</span></span><br><span class="line"><span class="string">another `</span></span><br></pre></td></tr></table></figure>

<p>第2部分是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;<span class="string">`</span></span><br><span class="line"><span class="string">new line `</span></span><br></pre></td></tr></table></figure>

<p>第3部分是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;<span class="string">`</span></span><br><span class="line"><span class="string">test`</span></span><br></pre></td></tr></table></figure>

<p>这个例子里面的表达式包含了2个部分：x和6。</p>
<p>拿到了这些值的函数就可以对其做任意处理，这就是这个特性的威力所在。</p>
<p>比如最简单的处理就是字符串插值，把字面量和表达式拼接起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> interpolated = interpolate<span class="string">`I paid <span class="subst">$&#123;<span class="number">10</span>&#125;</span>€`</span></span><br></pre></td></tr></table></figure>

<p>插值的过程就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interpolate</span>(<span class="params">literals, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> string = <span class="string">``</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, val] <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">    string += literals[i] + val</span><br><span class="line">  &#125;</span><br><span class="line">  string += literals[literals.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">return</span> string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>给定一个object，你可以抽取其中的一些值并且赋值给命名的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  firstName:<span class="string">'Tom'</span>,</span><br><span class="line">  lastName:<span class="string">'Cruise'</span>,</span><br><span class="line">  actor:<span class="literal">true</span>,</span><br><span class="line">  age:<span class="number">54</span>, <span class="comment">//made up</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">firstName</span>: name, age&#125; = person</span><br></pre></td></tr></table></figure>

<p>name和age就包含了对应的值。</p>
<p>这个语法同样可以用到数组当中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [first, second] = a</span><br></pre></td></tr></table></figure>

<p>下面这个语句创建了3个新的变量，分别取的是数组a的第0、1、4下标对应的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, second, , , fifth] = a</span><br></pre></td></tr></table></figure>

<h5 id="更强大的对象字面量"><a href="#更强大的对象字面量" class="headerlink" title="更强大的对象字面量"></a>更强大的对象字面量</h5><p>ES2015赋予了对象字面量更大的威力。</p>
<p>简化了包含变量的语法<br>原来的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> something = <span class="string">'y'</span></span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  something: something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> something = <span class="string">'y'</span></span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>原型可以这样指定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anObject = &#123; <span class="attr">y</span>:<span class="string">'y'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  __proto__: anObject</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">super</span>()</span><br><span class="line"><span class="keyword">const</span> anObject = &#123; <span class="attr">y</span>:<span class="string">'y'</span>, <span class="attr">test</span>:<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'zoo'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  __proto__: anObject,</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.test() + <span class="string">'x'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">x.test() <span class="comment">//zoox</span></span><br></pre></td></tr></table></figure>

<h5 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'_'</span> + <span class="string">'b'</span>]:<span class="string">'z'</span></span><br><span class="line">&#125;</span><br><span class="line">x.a_b <span class="comment">//z</span></span><br></pre></td></tr></table></figure>

<h4 id="For-of循环"><a href="#For-of循环" class="headerlink" title="For-of循环"></a>For-of循环</h4><p>2009年的ES5引入了forEach()循环。虽然很好用，但是它跟for循环一样，没法break。</p>
<p>ES2015引入了<strong>for-of</strong> 循环，就是在forEach的基础上加上了break的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iterate over the value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get the index as well, using `entries()`</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [i, v] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">//index</span></span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>留意一下const的使用。这个循环在每次迭代中都会创建一个新的作用域，所以我们可以使用const来代替let。</p>
<p>它跟for…in的区别在于：</p>
<ul>
<li>for…of遍历属性值</li>
<li>for…in遍历属性名</li>
</ul>
<h4 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h4><p>promise的一般定义： 它是一个代理，通过它可以最终得到一个值.</p>
<p>Promise是处理异步代码的一种方式，可以少写很多回调。</p>
<p>异步函数是建立在promise API上面的，所以理解Promise是一个基本的要求。</p>
<h5 id="promise的原理简述"><a href="#promise的原理简述" class="headerlink" title="promise的原理简述"></a>promise的原理简述</h5><p>一个promise被调用的时候，首先它是处于pending状态。在promise处理的过程中，调用的函数（caller）可以继续执行，直到promise给出反馈。</p>
<p>此时，调用的函数等待的promise结果要么是resolved状态，要么是rejected状态。但是由于JavaScript是异步的，所以promise处理的过程中，函数会继续执行。</p>
<h5 id="为什么JS-API使用promises"><a href="#为什么JS-API使用promises" class="headerlink" title="为什么JS API使用promises?"></a>为什么JS API使用promises?</h5><p>除了你的代码和第三方库的代码之外，promise在用在现代的Web API中，比如：</p>
<ul>
<li>电池API</li>
<li>Fetch API</li>
<li>Service Workers</li>
</ul>
<p>在现代的JavaScript中，不使用promise是不太可能的，所以我们来深入研究下promise吧。</p>
<h5 id="创建一个promise"><a href="#创建一个promise" class="headerlink" title="创建一个promise"></a>创建一个promise</h5><p>Promise API暴露了一个Promise构造函数，可以通过new Promise()来初始化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> done = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> isItDoneYet = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">const</span> workDone = <span class="string">'Here is the thing I built'</span></span><br><span class="line">    resolve(workDone)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> why = <span class="string">'Still working on something else'</span></span><br><span class="line">    reject(why)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>promise会检查done这个全局变量，如果为true，就返回一个resolved promise，否则就返回一个rejected promise。</p>
<p>通过resolve和reject，我们可以得到一个返回值，返回值可以是字符串也可以是对象。</p>
<h5 id="使用一个promise"><a href="#使用一个promise" class="headerlink" title="使用一个promise"></a>使用一个promise</h5><p>上面讲了怎么创建一个promise，下面就讲怎么使用（consume）这个promise。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isItDoneYet = <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> checkIfItsDone = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  isItDoneYet</span><br><span class="line">    .then(<span class="function"><span class="params">ok</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ok)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行checkIfItsDone()方法时，会执行isItDoneYet()这个promise，并且等待它resolve的时候使用then回调，如果有错误，就用catch回调来处理。</p>
<h5 id="链式promise"><a href="#链式promise" class="headerlink" title="链式promise"></a>链式promise</h5><p>一个promise可以返回另一个promise，从而创建promise链条（chain）。</p>
<p>一个很好的例子就是Fetch API，它是基于XMLHttpRequest API的一个上层API，我们可以用它来获取资源，并且在获取到资源的时候链式执行一系列promise。</p>
<p>Fetch API是一个基于promise的机制，调用fetch()相当于使用new Promise()来声明我们自己的promise。</p>
<p>链式promise的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> status = <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> json = <span class="function"><span class="params">response</span> =&gt;</span> response.json()</span><br><span class="line">fetch(<span class="string">'/todos.json'</span>)</span><br><span class="line">  .then(status)</span><br><span class="line">  .then(json)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request failed'</span>, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>在这个例子当中，我们调用fetch()，从根目录的todos.json文件中获取一系列的TODO项目，并且创建一个链式promise。</p>
<p>运行fetch()方法会返回一个response，它包含很多属性，我们从中引用如下属性：</p>
<ul>
<li>status, 一个数值，表示HTTP状态码</li>
<li>statusText, 一个状态消息，当请求成功的时候返回OK</li>
<li>response还有一个json()方法，它返回一个promise，返回内容转换成JSON后的结果。</li>
</ul>
<p>所以这些promise的调用过程就是：第一个promise执行一个我们定义的status()方法，检查response status，判断是否一个成功的响应(status在200和299之间)，如果不是成功的响应，就reject这个promise。</p>
<p>这个reject操作会导致整个链式promise跳过后面的所有promise直接到catch()语句，打印Request failed和错误消息。</p>
<p>如果这个promise成功了，它会调用我们定义的json()函数。因为前面的promise成功之后返回的response对象，我们可以拿到并作为第2个promise的参数传入。</p>
<p>在这个例子里面，我们返回了JSON序列化的数据，所以第3个promise直接接收这个JSON：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们把它打印到console。</p>
<h4 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h4><p>在上一节的的例子里面，我们有一个catch接在链式promise后面。</p>
<p>当promise链中的任意一个出错或者reject的时候，就会直接跳到promise链后面最近的catch()语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'Error'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="级联错误"><a href="#级联错误" class="headerlink" title="级联错误"></a>级联错误</h5><p>如果在catch()里面抛出一个错误，你可以在后面接上第二个catch()来处理这个错误，以此类推。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="组织多个promise"><a href="#组织多个promise" class="headerlink" title="组织多个promise"></a>组织多个promise</h4><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>如果你要同时完成不同的promise,可以用Promise.all()来声明一系列的promise，然后当它们全部resolve的时候再执行一些操作。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f1 = fetch(<span class="string">'/something.json'</span>)</span><br><span class="line"><span class="keyword">const</span> f2 = fetch(<span class="string">'/something2.json'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([f1, f2])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Array of results'</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>结合ES2015的解构赋值语法，你可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([f1, f2]).then(<span class="function">(<span class="params">[res1, res2]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Results'</span>, res1, res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当然这不限于使用fetch， 这适用于任何promise.</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>Promise.race()运行所有传递进去的promise，但是只要有其中一个resolve了，就会运行回调函数，并且只执行一次回调，回调的参数就是第一个resolve的promise返回的结果。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseOne = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">500</span>, <span class="string">'one'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promiseTwo = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'two'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.race([promiseOne, promiseTwo]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// 'two'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>ES Module是用于处理模块的ECMAScript标准。</p>
<p>虽然 Node.js 多年来一直使用 CommonJS标准，但浏览器却从未有过模块系统，因为模块系统的决策首先需要 ECMAScript 标准化后才由浏览器厂商去实施实现。</p>
<p>这个标准化已经完成在 ES2015中，浏览器也开始实施实现这个标准，大家试图保持一致，以相同的方式工作。现在 ES Module 可以在 Chrome Safari Edge 和 Firefox（从60版本开始） 中使用。</p>
<p>模块非常酷，他们可以让你封装各种各样的功能，同时将这些功能作为库暴露给其它 JavaScript 文件使用。</p>
<h5 id="ES-模块语法"><a href="#ES-模块语法" class="headerlink" title="ES 模块语法"></a>ES 模块语法</h5><p>引入模块的语法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import package from 'module-name'</span><br></pre></td></tr></table></figure>

<p>CommonJS 则是这样使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> package = <span class="built_in">require</span>(<span class="string">'module-name'</span>)</span><br></pre></td></tr></table></figure>

<p>一个模块是一个 JavaScript 文件，这个文件使用 export 关键字 导出 一个或多个值（对象、函数或者变量）。例如，下面这个模块提供了一个将字符串变成大写形式的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uppercase.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str =&gt; str.toUpperCase()</span><br></pre></td></tr></table></figure>

<p>在这个例子中，这个模块定义了唯一一个 default export，因此可以是一个匿名函数。否则，需要一个名称来和其它 导出 做区分。</p>
<p>现在，任何其它的 JavaScript 模块 可以通过 import 导入 uppercase.js 的这个功能。</p>
<p>一个 HTML 页面可以通过使用了特殊的 type=module 属性的 <code>&lt;script&gt;</code> 标签添加一个模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 这个模块导入的行为就像 <em>defer</em> 脚本加载一样。具体可以看 efficiently load JavaScript with defer and async</p>
</blockquote>
<p>需要特别注意的是，任何通过 type=”module” 载入的脚本会使用 严格模式 加载。</p>
<p>在这个例子中，uppercase.js 模块定义了一个 default export，因此当我们在导入它的时候，我们可以给他起一个任何我们喜欢的名字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> toUpperCase <span class="keyword">from</span> <span class="string">'./uppercase.js'</span></span><br></pre></td></tr></table></figure>

<p>同时我们可以这样使用它:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toUpperCase(<span class="string">'test'</span>) <span class="comment">//'TEST'</span></span><br></pre></td></tr></table></figure>

<p>你也可以通过一个绝对路径来导入模块，下面是一个引用来自其它域底下定义的模块的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> toUpperCase <span class="keyword">from</span> <span class="string">'https://flavio-es-modules-example.glitch.me/uppercase.js'</span></span><br></pre></td></tr></table></figure>

<p>下面同样是一些合法的 import语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'/uppercase.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'../uppercase.js'</span></span><br></pre></td></tr></table></figure>

<p>下面是错误的使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'uppercase.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'utils/uppercase.js'</span></span><br></pre></td></tr></table></figure>

<p>因为这里既不是使用绝对地址，也不是使用的相对地址。</p>
<h5 id="其它的-import-export-语法"><a href="#其它的-import-export-语法" class="headerlink" title="其它的 import/export 语法"></a>其它的 import/export 语法</h5><p>我们了解了上面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str =&gt; str.toUpperCase()</span><br></pre></td></tr></table></figure>

<p>这里生成了一个 default export。然而，你可以通过下面的语法在一个文件里面 导出 多个功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> &#123; a, b, c &#125;</span><br></pre></td></tr></table></figure>

<p>另外一个模块可以使用下面的方式 import 导入所有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure>

<p>你也可以通过解构赋值的方式仅仅 import 导出一部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure>

<p>为了方便，你还可以使用 as 重命名任何 import 的东西：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, b <span class="keyword">as</span> two &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure>

<p>你可以导入模块中的默认出口以及通过名称导入任何非默认的出口：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure>

<p>这是一篇关于 ES 模块的文章，可以看一下： <a href="https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html" target="_blank" rel="noopener">https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html</a></p>
<h4 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS(跨域资源共享)"></a>CORS(跨域资源共享)</h4><p>进行远程获取模块的时候是遵循 CORS 机制的。这意味着当你引用远程模块的时候，必须使用合法的 CORS 请求头来允许跨域访问（例如：Access-Control-Allow-Origin: *）。</p>
<h5 id="对于不支持模块的浏览器应该怎么做？"><a href="#对于不支持模块的浏览器应该怎么做？" class="headerlink" title="对于不支持模块的浏览器应该怎么做？"></a>对于不支持模块的浏览器应该怎么做？</h5><p>结合 type=”module”、nomodule 一起使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"module.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script nomodule src=<span class="string">"fallback.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="包装模块"><a href="#包装模块" class="headerlink" title="包装模块"></a>包装模块</h5><p>ES 模块是现代浏览器中的一大特性。这些特性是 ES6 规范中的一部分，要在浏览器中全部实现这些特性的路还很漫长。</p>
<p>我们现在就能使用它们！但是我们同样需要知道，有一些模块会对我们的页面性能产生性能影响。因为浏览器必须要在运行时执行它们。</p>
<p>Webpack 可能仍然会被大量使用，即使 ES 模块可以在浏览器中执行。但是语言内置这个特性对于客户端和 nodejs 在使用模块的时候是一种巨大的统一。</p>
<h4 id="新的字符串方法"><a href="#新的字符串方法" class="headerlink" title="新的字符串方法"></a>新的字符串方法</h4><p>任何字符串有了一些实例方法：</p>
<ul>
<li>repeat()</li>
<li>codePointAt()</li>
<li>repeat()</li>
</ul>
<p>根据指定的次数重复字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Ho'</span>.repeat(<span class="number">3</span>) <span class="comment">//'HoHoHo'</span></span><br></pre></td></tr></table></figure>

<p>没有提供参数以及使用 0 作为参数的时候返回空字符串。如果给一个负数参数则会得到一个 RangeError 的错误。</p>
<h5 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h5><p>这个方法能用在处理那些需要 2 个 UTF-16 单元表示的字符上。</p>
<p>使用 charCodeAt 的话，你需要先分别得到两个 UTF-16 的编码然后结合它们。但是使用 codePointAt() 你可以直接得到整个字符。</p>
<p>下面是一个例子，中文的 “𠮷” 是由两个 UTF-16 编码组合而成的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"𠮷"</span>.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">//d842</span></span><br><span class="line"><span class="string">"𠮷"</span>.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>) <span class="comment">//dfb7</span></span><br></pre></td></tr></table></figure>

<p>如果你将两个 unicode 字符组合起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"𠮷"</span> <span class="comment">//"𠮷"</span></span><br></pre></td></tr></table></figure>

<p>你也可以用 codePointAt() 得到同样的结果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"𠮷"</span>.codePointAt(<span class="number">0</span>) <span class="comment">//20bb7</span></span><br></pre></td></tr></table></figure>

<p>如果你将得到的 unicode 编码组合起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"𠮷"</span> <span class="comment">//"𠮷"</span></span><br></pre></td></tr></table></figure>

<p>更多关于 Unicode 的使用方法，参考我的Unicode guide。</p>
<h4 id="新的对象方法"><a href="#新的对象方法" class="headerlink" title="新的对象方法"></a>新的对象方法</h4><p>ES2015 在 Object 类下引入了一些静态方法：</p>
<ul>
<li>Object.is() 确定两个值是不是同一个</li>
<li>Object.assign() 用来浅拷贝一个对象</li>
<li>Object.setPrototypeOf 设置一个对象的原型</li>
<li>Object.is()</li>
</ul>
<p>这个方法用来帮助比较对象的值：</p>
<p>使用方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(a, b)</span><br></pre></td></tr></table></figure>

<p>返回值在下列情况之外一直是 false：</p>
<ul>
<li>a 和 b 是同一个对象</li>
<li>a 和 b 是相等的字符串(用同样的字符组合在一起的字符串是相等的)</li>
<li>a 和 b 是相等的数字</li>
<li>a 和 b 都是 undefined, null, NaN, true 或者都是 false</li>
<li>0 和 -0 在 JavaScript 里面是不同的值, 所以对这种情况要多加小心（例如在比较之前，使用 + 一元操作符将所有值转换成 +0）。</li>
</ul>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p>在 ES2015 版本中引入，这个方法拷贝所有给出的对象中的可枚举的自身属性到另一个对象中。</p>
<p>这个 API 的基本用法是创建一个对象的浅拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> copied = <span class="built_in">Object</span>.assign(&#123;&#125;, original)</span><br></pre></td></tr></table></figure>

<p>作为浅拷贝，值会被复制，对象则是拷贝其引用（不是对象本身），因此当你修改了源对象的一个属性值，这个修改也会在拷贝出的对象中生效，因为内部引用的对象是相同的。:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;</span><br><span class="line">  name:<span class="string">'Fiesta'</span>,</span><br><span class="line">  car:&#123;</span><br><span class="line">    color:<span class="string">'blue'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> copied = <span class="built_in">Object</span>.assign(&#123;&#125;, original)</span><br><span class="line">original.name = <span class="string">'Focus'</span></span><br><span class="line">original.car.color = <span class="string">'yellow'</span></span><br><span class="line">copied.name <span class="comment">//Fiesta</span></span><br><span class="line">copied.car.color <span class="comment">//yellow</span></span><br></pre></td></tr></table></figure>

<p>我之前提到过，源对象可以是一个或者多个:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wisePerson = &#123;</span><br><span class="line">  isWise:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foolishPerson = &#123;</span><br><span class="line">  isFoolish:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wiseAndFoolishPerson = <span class="built_in">Object</span>.assign(&#123;&#125;, wisePerson, foolishPerson)</span><br><span class="line"><span class="built_in">console</span>.log(wiseAndFoolishPerson) <span class="comment">//&#123; isWise: true, isFoolish: true &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf()</span><br></pre></td></tr></table></figure>

<p>设置一个对象的原型。可以接受两个参数：对象以及原型。</p>
<p>使用方法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  isAnimal:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mammal = &#123;</span><br><span class="line">  isMammal:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">mammal.__proto__ = animal</span><br><span class="line">mammal.isAnimal <span class="comment">//true</span></span><br><span class="line"><span class="keyword">const</span> dog = <span class="built_in">Object</span>.create(animal)</span><br><span class="line">dog.isAnimal  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.isMammal)  <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(dog, mammal)</span><br><span class="line">dog.isAnimal <span class="comment">//true</span></span><br><span class="line">dog.isMammal <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符"></a>展开操作符</h4><p>你可以展开一个数组、一个对象甚至是一个字符串，通过使用展开操作符 …。</p>
<p>让我们以数组来举例，给出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>你可以使用下面的方式创建出一个新的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [...a, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p>你也可以像下面这样创建一个数组的拷贝：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = [...a]</span><br></pre></td></tr></table></figure>

<p>这中方式对于对象仍然有效。使用下面的方式克隆一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = &#123; ...oldObj &#125;</span><br></pre></td></tr></table></figure>

<p>用在字符串上的时候，展开操作符会以字符串中的每一个字符创建一个数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hey = <span class="string">'hey'</span></span><br><span class="line"><span class="keyword">const</span> arrayized = [...hey] <span class="comment">// ['h', 'e', 'y']</span></span><br></pre></td></tr></table></figure>

<p>这个操作符有一些非常有用的应用。其中最重要的一点就是以一种非常简单的方式使用数组作为函数参数的能力：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">foo, bar</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">f(...a)</span><br></pre></td></tr></table></figure>

<p>（在之前的语法规范中，你只能通过 f.apply(null, a) 的方式来实现，但是这种方式不是很友好和易读。）</p>
<p>剩余参数（rest element）在和数组解构（array destructuring）搭配使用的时候非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[first, second, ...others] = numbers</span><br></pre></td></tr></table></figure>

<p>下面是展开元素 （spread elements）:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> a + b + c + d + e</span><br><span class="line"><span class="keyword">const</span> sum = sum(...numbers)</span><br></pre></td></tr></table></figure>

<p>ES2018 引入了 剩余属性 ，同样的操作符但是只能用在对象上。</p>
<h4 id="剩余属性（Rest-properties）"><a href="#剩余属性（Rest-properties）" class="headerlink" title="剩余属性（Rest properties）:"></a>剩余属性（Rest properties）:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; first, second, ...others &#125; = &#123;</span><br><span class="line">  first:<span class="number">1</span>,</span><br><span class="line">  second:<span class="number">2</span>,</span><br><span class="line">  third:<span class="number">3</span>,</span><br><span class="line">  fourth:<span class="number">4</span>,</span><br><span class="line">  fifth:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">second <span class="comment">// 2</span></span><br><span class="line">others <span class="comment">// &#123; third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<p>属性展开（Spread properties）允许我们结合跟在 … 操作符之后对象的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = &#123; first, second, ...others &#125;</span><br><span class="line">items <span class="comment">//&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>一个 Set 数据结构允许我们在一个容器里面增加数据。</p>
<p>一个 Set 是一个对象或者基础数据类型（strings、numbers或者booleans）的集合，你可以将它看作是一个 Map，其中值作为映射键，map 值始终为 true。</p>
<h5 id="初始化一个-Set"><a href="#初始化一个-Set" class="headerlink" title="初始化一个 Set"></a>初始化一个 Set</h5><p>Set 可以通过下面的方式初始化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure>

<h5 id="向-Set-中添加一项"><a href="#向-Set-中添加一项" class="headerlink" title="向 Set 中添加一项"></a>向 Set 中添加一项</h5><p>你可以使用 add 方法向 Set 中添加项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="string">'one'</span>)</span><br><span class="line">s.add(<span class="string">'two'</span>)</span><br></pre></td></tr></table></figure>

<p>Set 仅会存贮唯一的元素，因此多次调用 s.add(‘one’) 不会重复添加新的元素。</p>
<p>你不可以同时向 set 中加入多个元素。你需要多次调用 add() 方法。</p>
<h5 id="检查元素是否在-set-中"><a href="#检查元素是否在-set-中" class="headerlink" title="检查元素是否在 set 中"></a>检查元素是否在 set 中</h5><p>我们可以通过下面的方式检查元素是否在 set 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.has(<span class="string">'one'</span>) <span class="comment">//true</span></span><br><span class="line">s.has(<span class="string">'three'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h5 id="从-set-中删除一个元素："><a href="#从-set-中删除一个元素：" class="headerlink" title="从 set 中删除一个元素："></a>从 set 中删除一个元素：</h5><p>使用 delete() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.delete(<span class="string">'one'</span>)</span><br></pre></td></tr></table></figure>

<h5 id="确定-set-中元素的数量"><a href="#确定-set-中元素的数量" class="headerlink" title="确定 set 中元素的数量"></a>确定 set 中元素的数量</h5><p>使用 size 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.size</span><br></pre></td></tr></table></figure>

<h5 id="删除-set-中的全部元素"><a href="#删除-set-中的全部元素" class="headerlink" title="删除 set 中的全部元素"></a>删除 set 中的全部元素</h5><p>使用 clear() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure>

<h5 id="对-set-进行迭代"><a href="#对-set-进行迭代" class="headerlink" title="对 set 进行迭代"></a>对 set 进行迭代</h5><p>使用 keys() 或者 values() 方法 - 它们等价于下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>entries() 方法返回一个迭代器，你可以这样使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const i = s.entries()</span><br><span class="line">console.log(i.next())</span><br></pre></td></tr></table></figure>

<p>调用 i.next() 将会以 { value, done = false } 对象的形式返回每一个元素，直到迭代结束，这时 done 是 true。</p>
<p>你也可以调用 set 的 forEach() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.forEach(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure>

<p>或者你就直接使用 for..of 循环吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用一些初始值初始化一个-set"><a href="#使用一些初始值初始化一个-set" class="headerlink" title="使用一些初始值初始化一个 set"></a>使用一些初始值初始化一个 set</h5><p>你可以使用一些值初始化一个 set：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p>将 set 转换为一个数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...s.keys()]</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> a = [...s.values()]</span><br></pre></td></tr></table></figure>

<h5 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h5><p>一个 WeakSet 是一个特殊的 Set.</p>
<p>在 set 中，元素不会被 gc（垃圾回收）。一个 weakSet 让它的所有元素都是可以被 gc 的。weakSet 中的每个键都是一个对象。当这个对象的引用消失的时候，对应的值就可以被 gc 了。</p>
<p>下面是主要的不同点：</p>
<ul>
<li>WeakSet 不可迭代</li>
<li>你不能清空 weakSet 中的所有元素</li>
<li>不能够得到 weakSet 的大小</li>
</ul>
<p>一个 weakSet 通常是在框架级别的代码中使用，仅仅暴露了下面的方法：</p>
<ul>
<li>add()</li>
<li>has()</li>
<li>delete()</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>一份map结构的数据允许我们建立数据和key的关系</p>
<h5 id="在ES6之前"><a href="#在ES6之前" class="headerlink" title="在ES6之前"></a>在ES6之前</h5><p>在引入Map之前，开发者通常把对象(Object)当Map使用，把某个object或value值与指定的key进行关联:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;&#125;</span><br><span class="line">car[<span class="string">'color'</span>] = <span class="string">'red'</span></span><br><span class="line">car.owner = <span class="string">'Flavio'</span></span><br><span class="line"><span class="built_in">console</span>.log(car[<span class="string">'color'</span>]) <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(car.color) <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(car.owner) <span class="comment">//Flavio</span></span><br><span class="line"><span class="built_in">console</span>.log(car[<span class="string">'owner'</span>]) <span class="comment">//Flavio</span></span><br></pre></td></tr></table></figure>

<h5 id="引入Map之后"><a href="#引入Map之后" class="headerlink" title="引入Map之后"></a>引入Map之后</h5><p>ES6引入了Map数据结构，它为我们处理这种数据结构提供了一种合适的工具</p>
<p>Map的初始化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br></pre></td></tr></table></figure>

<p>添加条目到Map中</p>
<p>你可以通过set()方法把条目设定到map中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.set(&apos;color&apos;, &apos;red&apos;)</span><br><span class="line">m.set(&apos;age&apos;, 2)</span><br></pre></td></tr></table></figure>

<p>通过key值从map中获取条目</p>
<p>你可以通过get()方法从map中取出条目:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> color = m.get(<span class="string">'color'</span>)</span><br><span class="line"><span class="keyword">const</span> age = m.get(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>

<p>通过key值从map中删除条目</p>
<p>使用delete()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.delete(<span class="string">'color'</span>)</span><br></pre></td></tr></table></figure>

<p>从map中删除所有条目</p>
<p>使用clear()方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m.clear()</span><br></pre></td></tr></table></figure>

<p>通过key值检查map中是否含有某个条目</p>
<p>使用has()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasColor = m.has(<span class="string">'color'</span>)</span><br></pre></td></tr></table></figure>

<p>获取map中的条目数量</p>
<p>使用 size 属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> size = m.size</span><br></pre></td></tr></table></figure>

<p>用value值初始化一个map</p>
<p>你可以用一组value来初始化一个map：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'color'</span>, <span class="string">'red'</span>], [<span class="string">'owner'</span>, <span class="string">'Flavio'</span>], [<span class="string">'age'</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>

<p>Map 的key值</p>
<p>任何值(对象，数组，字符串，数字)都可以作为一个map的value值(使用key-value键值的形式)，任何值也可以用作key，即使是object对象。</p>
<p>如果你想通过get()方法从map中获取不存在的key，它将会返回undefined</p>
<p>在真实世界中你几乎不可能找到的诡异情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="literal">NaN</span>, <span class="string">'test'</span>)</span><br><span class="line">m.get(<span class="literal">NaN</span>) <span class="comment">//test</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(+<span class="number">0</span>, <span class="string">'test'</span>)</span><br><span class="line">m.get(<span class="number">-0</span>) <span class="comment">//test</span></span><br></pre></td></tr></table></figure>

<p>使用Iterate迭代器获取map的keys值</p>
<p>Map提供了keys()方法，通过该方法我们可以迭代出所有的key值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Iterate迭代器获取map的values值</p>
<p>Map提供了values()方法，通过该方法我们可以迭代出所有的value值:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> m.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Iterate迭代器获取key-value组成的键值对</p>
<p>Map提供了entries()方法，通过该方法我们可以迭代出所有的键值对:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法还可以简化为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将map的keys值转换为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...m.keys()]</span><br></pre></td></tr></table></figure>

<p>将map的values值转换为数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...m.values()]</span><br></pre></td></tr></table></figure>

<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>WeakMap是一种特殊的Map</p>
<p>在一个map对象中，定义在其上数据永远不会被垃圾回收，WeakMap替而代之的是它允许在它上面定义的数据可以自由的被垃圾回收走，WeakMap的每一个key都是一个对象，当指向该对象的指针丢失，与之对应的value就会被垃圾回收走。</p>
<p>这是WeakMap的主要不同处：</p>
<ul>
<li>你不可以在WeakMap上迭代keys值和values值(或者key-value键值对)</li>
<li>你不可以从WeakMap上清除所有条目</li>
</ul>
<h5 id="你不可以获取WeakMap的大小"><a href="#你不可以获取WeakMap的大小" class="headerlink" title="你不可以获取WeakMap的大小"></a>你不可以获取WeakMap的大小</h5><p>WeakMap提供了如下几种方法，这些方法的使用和在Map中一样：</p>
<ul>
<li>get(k)</li>
<li>set(k, v)</li>
<li>has(k)</li>
<li>delete(k)</li>
</ul>
<p>关于WeakMap的用例不如Map的用例那么明显，你可能永远也不会在哪里会用到它，但从实际出发，WeakMap可以构建不会干扰到垃圾回收机制的内存敏感性缓存，还可以满足封装的严谨性及信息的隐藏性需求。</p>
<h4 id="Generators生成器"><a href="#Generators生成器" class="headerlink" title="Generators生成器"></a>Generators生成器</h4><p>Generators是一种特殊的函数，它能够暂停自身的执行并在一段时间后再继续运行，从而允许其它的代码在此期间运行(有关该主题的详细说明，请参阅完整的“javascript生成器指南”)。</p>
<p>Generators的代码决定它必须等待，因此它允许队列中的其它代码运行，并保留“当它等待的事情”完成时恢复其操作的权力。</p>
<p>所有这一切都是通过一个简单的关键字“yield`”完成的。当生成器包含该关键字时，将停止执行。</p>
<p>generator生成器可以包含许多yield关键字，从而使自己能多次停止运行，它是由*function关键字标识(不要将其与C、C++或Go等低级语言中使用的取消指针引用操作符混淆)。</p>
<p>Generators支持JavaScript中全新的编程范式，包括：</p>
<ul>
<li>在generator运行时支持双向通信</li>
<li>不会“冻结”长期运行在程序中的while循环</li>
</ul>
<p>这里有一个解释generator如何工作的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">calculator</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> doubleThat = <span class="number">2</span> * (<span class="keyword">yield</span> (input / <span class="number">2</span>))</span><br><span class="line">  <span class="keyword">var</span> another = <span class="keyword">yield</span> (doubleThat)</span><br><span class="line">  <span class="keyword">return</span> (input * doubleThat * another)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先初始化它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calc = calculator(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们在generator中开始进行iterator迭代：</p>
<h5 id="calc-next"><a href="#calc-next" class="headerlink" title="calc.next()"></a>calc.next()</h5><p>第一个迭代器开始了迭代，代码返回如下object对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">false</span></span><br><span class="line">  value:<span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体过程如下：代码运行了函数，并把input=10传入到生成器构造函数中，该函数一直运行直到抵达yield，并返回yield输出的内容: input / 2 = 5，因此，我们得到的值为5，并告知迭代器还没有done(函数只是暂停了)。</p>
<p>在第二个迭代处，我们输入7：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc.next(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们得到了结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">false</span></span><br><span class="line">  value:<span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7被作为doubleThat的值，注意：你可能会把input/2作为输入参数，但这只是第一次迭代的返回值。现在我们忽略它，使用新的输入值7，并将其乘以2.</p>
<p>然后，我们得到第二个yield的值，它返回doubleThat，因此返回值为14。</p>
<p>在下一个，也是最后一个迭代器，我们输入100</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calc.next(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这样我们得到:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">true</span></span><br><span class="line">  value:<span class="number">14000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当迭代器完成时(没有更多的yield关键字)，我们返回input <em>doubleThat</em> another，这相当于10 <em>14</em>100。</p>
<p>这些都是在2015年的ES2015引入的特性，现在我们深入了解下ES2016，它的作用域范围更小。</p>
<h4 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h4><p>该特性引入了一种更简洁的语法，同来检查数组中是否包含指定元素。</p>
<p>对于ES6及更低版本，想要检查数组中是否包含指定元素，你不得不使用indexOf方法，它检查数组中的索引，如果元素不存在，它返回-1，由于-1被计算为true，你需对其进行取反操作，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="number">1</span>,<span class="number">2</span>].indexOf(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Not found'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ES7引入的新特性，我们可以如此做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="number">1</span>,<span class="number">2</span>].includes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Not found'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求幂运算符"><a href="#求幂运算符" class="headerlink" title="求幂运算符"></a>求幂运算符</h4><p>求幂运算符**相当于Math.pow()方法，但是它不是一个函数库，而是一种语言机制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">4</span>, <span class="number">2</span>) == <span class="number">4</span> ** <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>对于需要进行密集数学运算的程序来说，这个特性是个很好的增强，在很多语言中，**运算符都是标准(包括Python、Ruby、MATLAB、Perl等其它多种语言)。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190318/29ddbe9d6db84099ba7c67597ac82c0b.png" alt="img"></p>
<p>这些都是2016年引入的特性，现在让我们进入2017年。</p>
<h4 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h4><p>字符串填充的目的是给字符串添加字符，以使其达到指定长度。</p>
<p>ES2017引入了两个String方法：padStart()和padEnd()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padStart(targetLength [, padString])</span><br><span class="line">padEnd(targetLength [, padString])</span><br></pre></td></tr></table></figure>

<p>使用例子：</p>
<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20190428180419.png" alt></p>
<h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p>该方法返回一个数组，数组包含了对象自己的所有属性，使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.values(person) <span class="comment">// ['Fred', 87]</span></span><br></pre></td></tr></table></figure>

<p>Object.values()也可以作用于数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [<span class="string">'Fred'</span>, <span class="string">'Tony'</span>]</span><br><span class="line"><span class="built_in">Object</span>.values(people) <span class="comment">// ['Fred', 'Tony']</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><p>该方法返回一个数组，数组包含了对象自己的所有属性键值对，是一个[key, value]形式的数组，使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(person) <span class="comment">// [['name', 'Fred'], ['age', 87]]</span></span><br></pre></td></tr></table></figure>

<p>Object.entries()也可以作用于数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [<span class="string">'Fred'</span>, <span class="string">'Tony'</span>]</span><br><span class="line"><span class="built_in">Object</span>.entries(people) <span class="comment">// [['0', 'Fred'], ['1', 'Tony']]</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>该方法返回自己(非继承)的所有属性描述符，JavaScript中的任何对象都有一组属性，每个属性都有一个描述符，描述符是属性的一组属性(attributes)，由以下部分组成：</p>
<ul>
<li>value: 熟悉的value值</li>
<li>writable: 属性是否可以被更改</li>
<li>get: 属性的getter函数, 当属性读取时被调用</li>
<li>set: 属性的setter函数, 当属性设置值时被调用</li>
<li>configurable: 如果为false, 不能删除该属性，除了它的value值以为，也不能更改任何属性。</li>
<li>enumerable: 该属性是否能枚举</li>
</ul>
<p>Object.getOwnPropertyDescriptors(obj)接受一个对象，并返回一个带有描述符集合的对象。</p>
<h4 id="In-what-way-is-this-useful"><a href="#In-what-way-is-this-useful" class="headerlink" title="In what way is this useful?"></a>In what way is this useful?</h4><p>ES6给我们提供了Object.assign()方法，它从一个一个或多个对象中复制所有可枚举的属性值，并返回一个新对象。</p>
<p>但是，这也存在着一个问题，因为它不能正确的复制一个具有非默认属性值的属性。</p>
<p>如果对象只有一个setter，那么它就不会正确的复制到一个新对象上，使用Object.assign()进行如下操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person1 = &#123;</span><br><span class="line">    set name(newName) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将不会起作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person2 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(person2, person1)</span><br></pre></td></tr></table></figure>

<p>但这将会起作用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person3 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person3,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(person1))</span><br></pre></td></tr></table></figure>

<p>通过一个简单的console控制台，你可以查看以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person1.name = <span class="string">'x'</span></span><br><span class="line"><span class="string">"x"</span></span><br><span class="line">person2.name = <span class="string">'x'</span></span><br><span class="line">person3.name = <span class="string">'x'</span></span><br><span class="line"><span class="string">"x"</span></span><br></pre></td></tr></table></figure>

<p>person2没有setter，它没能复制进去，对象的浅复制限定也出现在Object.create()方法中。</p>
<h4 id="尾逗号"><a href="#尾逗号" class="headerlink" title="尾逗号"></a>尾逗号</h4><p>该特性允许在函数定义时有尾逗号，在函数使用时可以有尾逗号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">var1, var2,</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">doSomething(<span class="string">'test2'</span>, <span class="string">'test2'</span>,)</span><br></pre></td></tr></table></figure>

<p>该改变将鼓励开发者停止“在一行开始时写逗号”的丑陋习惯</p>
<h4 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h4><p>JavaScript在很短的时间内从回调函数进化到Promise函数(ES2015)，并自从ES2017以来，异步JavaScript的async/wait语法变得更加简单。 异步函数是Promise和generator的结合，基本上，它是比Promise更高级的抽象，我再重复一般：async/await是基于Promise建立的</p>
<h5 id="为什么要引入async-await"><a href="#为什么要引入async-await" class="headerlink" title="为什么要引入async/await"></a>为什么要引入async/await</h5><p>它减少了围绕promise的引用，并打破了Promise — “不要打断链式调用”的限制。</p>
<p>当Promise在ES2015中引入时，它的本意是来解决异步代码的问题，它也确实做到了，但在ES2015和ES2017间隔的这两年中，大家意识到：Promise不是解决问题的终极方案。</p>
<p>Promise是为了解决著名的回调地狱而被引入的，但它本身也带来了使用复杂性和语法复杂性。</p>
<p>Promise是很好的原生特性，围绕着它开发人员可以探索出更好的语法，因此当时机成熟后，我们得到了async函数</p>
<p>async函数使代码看起来像是同步函数一样，但其背后却是异步和非堵塞的。</p>
<h5 id="它如何工作"><a href="#它如何工作" class="headerlink" title="它如何工作"></a>它如何工作</h5><p>一个async函数会返回一个promise，如下例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomethingAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你想要调用该函数时，你在前面加上了一个wait，这样调用就会被停止，直到该promise进行resolve或reject，需注意的是：外层函数必须定义为async，这是例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> doSomethingAsync())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="一个上手示例"><a href="#一个上手示例" class="headerlink" title="一个上手示例"></a>一个上手示例</h5><p>这是一个使用async/await进行异步函数的简单示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomethingAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> doSomethingAsync())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Before'</span>)</span><br><span class="line">doSomething()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'After'</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码将会在浏览器的console中打印出如下结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before</span><br><span class="line">After</span><br><span class="line">I did something <span class="comment">//after 3s</span></span><br></pre></td></tr></table></figure>

<h4 id="关于-Promise"><a href="#关于-Promise" class="headerlink" title="关于 Promise"></a>关于 Promise</h4><p>将 async 关键字标记在任何函数上，意味着这个函数都将返回一个 Promise，即使这个函数没有显式的返回，它在内部也会返回一个 Promise，这就是下面这份代码有效的原因：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aFunction = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line">aFunction().then(alert) <span class="comment">// This will alert 'test'</span></span><br></pre></td></tr></table></figure>

<p>下面的例子也一样:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aFunction = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'test'</span>)</span><br><span class="line">&#125;</span><br><span class="line">aFunction().then(alert) <span class="comment">// This will alert 'test'</span></span><br></pre></td></tr></table></figure>

<h5 id="更易于阅读的代码"><a href="#更易于阅读的代码" class="headerlink" title="更易于阅读的代码"></a>更易于阅读的代码</h5><p>正如上述的例子，我们将它与普通回调函数或链式函数进行比较，我们的代码看起来非常的简单。</p>
<p>这是一个很简单的例子，当代码足够复杂时，它会产生更多的收益。</p>
<p>例如，使用 Promise 来获取 JSON 资源并解析它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstUserData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'/users.json'</span>) <span class="comment">// get users list</span></span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()) <span class="comment">// parse JSON</span></span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> users[<span class="number">0</span>]) <span class="comment">// pick first user</span></span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> fetch(<span class="string">`/users/<span class="subst">$&#123;user.name&#125;</span>`</span>)) <span class="comment">// get user data</span></span><br><span class="line">    .then(<span class="function"><span class="params">userResponse</span> =&gt;</span> response.json()) <span class="comment">// parse JSON</span></span><br><span class="line">&#125;</span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>

<p>这是使用 async/await 实现相同功能的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstUserData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/users.json'</span>) <span class="comment">// get users list</span></span><br><span class="line">  <span class="keyword">const</span> users = <span class="keyword">await</span> response.json() <span class="comment">// parse JSON</span></span><br><span class="line">  <span class="keyword">const</span> user = users[<span class="number">0</span>] <span class="comment">// pick first user</span></span><br><span class="line">  <span class="keyword">const</span> userResponse = <span class="keyword">await</span> fetch(<span class="string">`/users/<span class="subst">$&#123;user.name&#125;</span>`</span>) <span class="comment">// get user data</span></span><br><span class="line">  <span class="keyword">const</span> userData = <span class="keyword">await</span> user.json() <span class="comment">// parse JSON</span></span><br><span class="line">  <span class="keyword">return</span> userData</span><br><span class="line">&#125;</span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>

<h5 id="串行多个异步功能"><a href="#串行多个异步功能" class="headerlink" title="串行多个异步功能"></a>串行多个异步功能</h5><p>async 函数非常容易，并且它的语法比 Promise 更易读。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseToDoSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">10000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> watchOverSomeoneDoingSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> something = <span class="keyword">await</span> promiseToDoSomething()</span><br><span class="line">  <span class="keyword">return</span> something + <span class="string">' and I watched'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> something = <span class="keyword">await</span> watchOverSomeoneDoingSomething()</span><br><span class="line">  <span class="keyword">return</span> something + <span class="string">' and I watched as well'</span></span><br><span class="line">&#125;</span><br><span class="line">watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I did something and I watched and I watched <span class="keyword">as</span> well</span><br></pre></td></tr></table></figure>

<h4 id="更简单的调试"><a href="#更简单的调试" class="headerlink" title="更简单的调试"></a>更简单的调试</h4><p>调试 Promise 就很困难，因为调试器无法跨越异步代码，但调试 async/await 就非常的简单，调试器会像调试同步代码一样来处理它。</p>
<h5 id="共享内存和原子"><a href="#共享内存和原子" class="headerlink" title="共享内存和原子"></a>共享内存和原子</h5><p>WebWorkers 可以在浏览器中创建多线程程序。</p>
<p>它们通过事件的方式来传递消息，从 ES2017 开始，你可以使用 SharedArrayBuffer 在每一个 Worker 中和它们的创建者之间共享内存数组.</p>
<p>由于不知道写入内存部分需要多长的周期来广播，因此在读取值时，任何类型的写入操作都会完成，Atomics 可以避免竞争条件的发生。</p>
<p>关于它的更多细节可以在proposal中找到。</p>
<p>这是 ES2017，接下来我将介绍 ES2018 的功能。</p>
<h5 id="Rest-Spread-Properties"><a href="#Rest-Spread-Properties" class="headerlink" title="Rest/Spread Properties"></a>Rest/Spread Properties</h5><p>ES2015 引入了解构数组的方法，当你使用时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[first, second, ...others] = numbers</span><br></pre></td></tr></table></figure>

<p>and 展开参数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> a + b + c + d + e</span><br><span class="line"><span class="keyword">const</span> sum = sum(...numbers)</span><br></pre></td></tr></table></figure>

<p>ES2018 为对象引入了同样的功能。</p>
<p>解构:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; first, second, ...others &#125; = &#123; <span class="attr">first</span>:<span class="number">1</span>, <span class="attr">second</span>:<span class="number">2</span>, <span class="attr">third</span>:<span class="number">3</span>, <span class="attr">fourth</span>:<span class="number">4</span>, <span class="attr">fifth</span>:<span class="number">5</span> &#125;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">second <span class="comment">// 2</span></span><br><span class="line">others <span class="comment">// &#123; third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<p>展开属性 允许通过组合在展开运算符之后传递的对象属性而创建新对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = &#123; first, second, ...others &#125;</span><br><span class="line">items <span class="comment">//&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h5><p>for-await-of 允许你使用异步可迭代对象做为循环迭代：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> line <span class="keyword">of</span> readLines(filePath)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为它使用的了 await，因此你只能在 async 函数中使用它。</p>
<h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h5><p>当一个 Promise 是 fulfilled 时，它会一个接一个的调用 then。</p>
<p>如果在这个过程中发生了错误，则会跳过 then 而执行 catch。</p>
<p>而 finally() 允许你运行一些代码，无论是成功还是失败：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'file.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> data.json())</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error))</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finished'</span>))</span><br></pre></td></tr></table></figure>

<h5 id="正则表达式改进"><a href="#正则表达式改进" class="headerlink" title="正则表达式改进"></a>正则表达式改进</h5><p>ES2018 对正则表达式引入了许多改进，这些都可以在 <a href="https://flaviocopes.com/javascript-regular-expressions/" target="_blank" rel="noopener">https://flaviocopes.com/javascript-regular-expressions/</a> 上找到。</p>
<p>以下是关于 ES2018 正则表达式改进的具体补充：</p>
<p>RegExp lookbehind assertions: 根据前面的内容匹配字符串</p>
<p>这是一个 lookahead: 你可以使用 ?= 来匹配字符串，后面跟随一个特定的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Roger(?=Waters)/</span><br><span class="line">/Roger(?=Waters)/.test(<span class="string">'Roger is my dog'</span>) <span class="comment">//false</span></span><br><span class="line">/Roger(?=Waters)/.test(<span class="string">'Roger is my dog and Roger Waters is a famous musician'</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>?! 可以执行逆操作，如果匹配的字符串是no而不是在此后跟随特定的子字符串的话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/Roger(?!Waters)/</span><br><span class="line">/Roger(?!Waters)/.test(<span class="string">'Roger is my dog'</span>) <span class="comment">//true</span></span><br><span class="line">/Roger(?!Waters)/.test(<span class="string">'Roger Waters is a famous musician'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>Lookaheads 使用 ?= Symbol，它们已经可以用了。</p>
<p>Lookbehinds, 是一个新功能使用?&lt;=.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=Roger)</span> <span class="attr">Waters</span>/</span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=Roger)</span> <span class="attr">Waters</span>/<span class="attr">.test</span>('<span class="attr">Pink</span> <span class="attr">Waters</span> <span class="attr">is</span> <span class="attr">my</span> <span class="attr">dog</span>') //<span class="attr">false</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=Roger)</span> <span class="attr">Waters</span>/<span class="attr">.test</span>('<span class="attr">Roger</span> <span class="attr">is</span> <span class="attr">my</span> <span class="attr">dog</span> <span class="attr">and</span> <span class="attr">Roger</span> <span class="attr">Waters</span> <span class="attr">is</span> <span class="attr">a</span> <span class="attr">famous</span> <span class="attr">musician</span>') //<span class="attr">true</span></span></span></span><br></pre></td></tr></table></figure>

<p>如果一个 lookbehind 是否定，那么使用 ?&gt;!:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">!Roger)</span> <span class="attr">Waters</span>/</span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">!Roger)</span> <span class="attr">Waters</span>/<span class="attr">.test</span>('<span class="attr">Pink</span> <span class="attr">Waters</span> <span class="attr">is</span> <span class="attr">my</span> <span class="attr">dog</span>') //<span class="attr">true</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">!Roger)</span> <span class="attr">Waters</span>/<span class="attr">.test</span>('<span class="attr">Roger</span> <span class="attr">is</span> <span class="attr">my</span> <span class="attr">dog</span> <span class="attr">and</span> <span class="attr">Roger</span> <span class="attr">Waters</span> <span class="attr">is</span> <span class="attr">a</span> <span class="attr">famous</span> <span class="attr">musician</span>') //<span class="attr">false</span></span></span></span><br></pre></td></tr></table></figure>

<h5 id="Unicode属性转义-p-…-and-P-…"><a href="#Unicode属性转义-p-…-and-P-…" class="headerlink" title="Unicode属性转义 p{…} and P{…}"></a>Unicode属性转义 p{…} and P{…}</h5><p>在正则表达式模式中，你可以使用 d 来匹配任意的数字，s 来匹配任意不是空格的字符串，w 来匹配任意字母数字字符串，以此类推。</p>
<blockquote>
<p>This new feature extends this concept to all Unicode characters introducing p{} and is negation P{}.</p>
</blockquote>
<p>这个新功能扩展了unicode字符，引入了 p{} 来处理</p>
<p>任何 unicode 字符都有一组属性，例如 script 确认语言，ASCII 是一个布尔值用于检查 ASCII 字符。你可以将此属性方在() 中，正则表达式将来检查是否为真。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'abc'</span>)   <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'ABC@'</span>)  <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'ABC🙃'</span>) <span class="comment">//❌</span></span><br></pre></td></tr></table></figure>

<p>ASCII_Hex_Digit 是另一个布尔值，用于检查字符串是否包含有效的十六进制数字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^p&#123;ASCII_Hex_Digit&#125;+$/u.test(<span class="string">'0123456789ABCDEF'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII_Hex_Digit&#125;+$/u.test(<span class="string">'h'</span>)                <span class="comment">//❌</span></span><br></pre></td></tr></table></figure>

<p>此外，还有很多其它的属性。你可以在()中添加它们的名字来检查它们，包括 Uppercase, Lowercase, White_Space, Alphabetic, Emoji等等：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^p&#123;Lowercase&#125;$/u.test(<span class="string">'h'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;Uppercase&#125;$/u.test(<span class="string">'H'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;Emoji&#125;+$/u.test(<span class="string">'H'</span>)   <span class="comment">//❌</span></span><br><span class="line">/^p&#123;Emoji&#125;+$/u.test(<span class="string">'🙃🙃'</span>) <span class="comment">//✅</span></span><br></pre></td></tr></table></figure>

<p>除了二进制属性外，你还可以检查任何 unicode 字符属性以匹配特定的值，在这个例子中，我检查字符串是用希腊语还是拉丁字母写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^p&#123;Script=Greek&#125;+$/u.test(&apos;ελληνικά&apos;) //✅</span><br><span class="line">/^p&#123;Script=Latin&#125;+$/u.test(&apos;hey&apos;) //✅</span><br></pre></td></tr></table></figure>

<p>阅读<a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank" rel="noopener">https://github.com/tc39/proposal-regexp-unicode-property-escapes</a> 获取使用所有属性的详细信息。</p>
<p>Named capturing groups<br>In ES2018 a capturing group can be assigned to a name, rather than just being assigned a slot in the result array:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/(?&lt;year&gt;d&#123;4&#125;)-(?&lt;month&gt;d&#123;2&#125;)-(?&lt;day&gt;d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">const</span> result = re.exec(<span class="string">'2015-01-02'</span>)</span><br><span class="line"><span class="comment">// result.groups.year === '2015';</span></span><br><span class="line"><span class="comment">// result.groups.month === '01';</span></span><br><span class="line"><span class="comment">// result.groups.day === '02';</span></span><br><span class="line">The s flag <span class="keyword">for</span> regular expressions</span><br><span class="line">The s flag, short <span class="keyword">for</span> single line, causes the . to match <span class="keyword">new</span> line characters <span class="keyword">as</span> well. Without it, the dot matches regular characters but not the <span class="keyword">new</span> line:</span><br><span class="line"></span><br><span class="line">/hi.welcome/.test(<span class="string">'hi</span></span><br><span class="line"><span class="string">welcome'</span>) <span class="comment">// false</span></span><br><span class="line">/hi.welcome/s.test(<span class="string">'hi</span></span><br><span class="line"><span class="string">welcome'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="ESNext-1"><a href="#ESNext-1" class="headerlink" title="ESNext"></a>ESNext</h4><p>什么是 ESNext ？</p>
<p>ESNext 是一个始终指向下一个版本 JavaScript 的名称。</p>
<p>当前的 ECMAScript 版本是 ES2018，它于2018年6月被发布。</p>
<p>历史上 JavaScript 标准化的版本都是在夏季被发布，因此我们可以预期 ECMAScript 2019 将于 2019 年的夏季被发布。</p>
<p>所以在编写本文时 ES2018 已经被发布，因此 ESNext 指的是 ES2019。</p>
<p>ECMAScript 标准的提案是分阶段组织的，第一到第三阶段属于功能性的孵化，第四阶段的功能才最终确定为新标准的一部分。</p>
<p>在编写本文时主要浏览器都实现了第四阶段大部分的功能，因此我将在本文中介绍它们。</p>
<p>其中一些变化主要在内部使用，但知道发生了什么这也很好。</p>
<p>第三阶段还有一些其它功能，可能会在接下来的几个月内升级到第四阶段，你可以在这个 Github 仓库中查看它们：<a href="https://github.com/tc39/proposals。" target="_blank" rel="noopener">https://github.com/tc39/proposals。</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.&#123;flat,flatMap&#125;</span><br></pre></td></tr></table></figure>

<p>flat() 是一个新的数组实例方法，它可以将多维数组转化成一维数组。</p>
<p>例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, <span class="string">'Wolf'</span>]].flat()</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br></pre></td></tr></table></figure>

<p>默认情况下它只能将二维的数组转化成一维的数组，但你可以添加一个参数来确定要展开的级别，如果你将这个参数设置为 Infinity 那么它将展开无限的级别到一维数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat()</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', [ 'Wolf' ] ]</span></span><br><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br></pre></td></tr></table></figure>

<p>如果你熟悉数组的 map 方法，那么你就知道使用它可以对数组的每个元素执行一个函数。</p>
<p>flatMap() 是一个新的数组实例方法，它将 flat() 和 map 结合了起来，当你期望在map函数中做一些处理时这非常有用，同时又希望结果如同 flat ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'My dog'</span>, <span class="string">'is awesome'</span>].map(<span class="function"><span class="params">words</span> =&gt;</span> words.split(<span class="string">' '</span>))</span><br><span class="line"><span class="comment">//[ [ 'My', 'dog' ], [ 'is', 'awesome' ] ]</span></span><br><span class="line">[<span class="string">'My dog'</span>, <span class="string">'is awesome'</span>].flatMap(<span class="function"><span class="params">words</span> =&gt;</span> words.split(<span class="string">' '</span>))</span><br><span class="line"><span class="comment">//[ 'My', 'dog', 'is', 'awesome' ]</span></span><br></pre></td></tr></table></figure>

<h5 id="Optional-catch-binding"><a href="#Optional-catch-binding" class="headerlink" title="Optional catch binding"></a>Optional catch binding</h5><p>有时候我们并不需要将参数绑定到 try/catch 中。</p>
<p>在以前我们不得不这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">//handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使我们从来没有通过 e 来分析错误，但现在我们可以简单的省略它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">//handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.fromEntries()</span><br><span class="line">Objects have an entries() method, since ES2017.</span><br></pre></td></tr></table></figure>

<p>从 ES2017 开始 Object将有一个 entries() 方法。</p>
<p>它将返回一个包含所有对象自身属性的数组的数组，如[key, value]：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(person) <span class="comment">// [['name', 'Fred'], ['age', 87]]</span></span><br></pre></td></tr></table></figure>

<p>ES2019 引入了一个新的 Object.fromEntries() 方法，它可以从上述的属性数组中创建一个新的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="keyword">const</span> entries = <span class="built_in">Object</span>.entries(person)</span><br><span class="line"><span class="keyword">const</span> newPerson = <span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"></span><br><span class="line">person !== newPerson <span class="comment">//true</span></span><br><span class="line"><span class="built_in">String</span>.prototype.&#123;trimStart,trimEnd&#125;</span><br></pre></td></tr></table></figure>

<p>这些功能已经被 v8/Chrome 实现了近一年的时间，它将在 ES2019 中实现标准化。</p>
<h5 id="trimStart"><a href="#trimStart" class="headerlink" title="trimStart()"></a>trimStart()</h5><p>删除字符串首部的空格并返回一个新的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing '</span>.trimStart() <span class="comment">//'Testing '</span></span><br><span class="line"><span class="string">'Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br></pre></td></tr></table></figure>

<h5 id="trimEnd"><a href="#trimEnd" class="headerlink" title="trimEnd()"></a>trimEnd()</h5><p>删除字符串尾部的空格并返回一个新的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Testing'</span>.trimEnd() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing'</span>.trimEnd() <span class="comment">//' Testing'</span></span><br><span class="line"><span class="string">' Testing '</span>.trimEnd() <span class="comment">//' Testing'</span></span><br><span class="line"><span class="string">'Testing '</span>.trimEnd() <span class="comment">//'Testing'</span></span><br></pre></td></tr></table></figure>

<h5 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h5><p>现在你可以使用 description 来获取 Symbol 的值，而不必使用 toString() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSymbol = <span class="built_in">Symbol</span>(<span class="string">'Test'</span>)</span><br><span class="line">testSymbol.description <span class="comment">// 'Test'</span></span><br></pre></td></tr></table></figure>

<h5 id="JSON-improvements"><a href="#JSON-improvements" class="headerlink" title="JSON improvements"></a>JSON improvements</h5><p>在此之前 JSON 字符串中不允许使用分隔符（）和分隔符（）。</p>
<p>使用 JSON.parse 时，这些字符会导致一个 SyntaxError 错误，但现在它们可以正确的解析并如 JSON 标准定义的那样。</p>
<h5 id="Well-formed-JSON-stringify"><a href="#Well-formed-JSON-stringify" class="headerlink" title="Well-formed JSON.stringify()"></a>Well-formed JSON.stringify()</h5><p>修复 JSON.stringify() 在处理 UTF-8 code points (U+D800 to U+DFFF)。</p>
<p>在修复之前，调用 JSON.stringify() 将返回格式错误的 Unicode 字符，如（a “�”)。</p>
<p>现在你可以安全放心的使用 JSON.stringify() 转成字符串，也可以使用 JSON.parse() 将它转换回原始表示的形态。</p>
<h5 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h5><p>函数总会有一个 toString 方法，它将返回一个包含函数代码的字符串。</p>
<p>ES2019 对返回值做了修改，以避免剥离注释和其它字符串（如：空格），将更准确的表示函数的定义。</p>
<blockquote>
<p>If previously we had</p>
</blockquote>
<p>以前也许我们这样过：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">this</span> <span class="title">is</span> <span class="title">bar</span> */ <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当时的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.toString() <span class="comment">//'function bar() &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>现在的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.toString(); <span class="comment">// 'function /* this is bar */ bar () &#123;&#125;'</span></span><br></pre></td></tr></table></figure>

<p>总结一下，我希望这篇文章可以帮助你了解一些最新的 JavaScript 以及我们在 2019 年即将看见的内容。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="ZhangMiao 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="ZhangMiao 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    ZhangMiao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zhangmiao.cc/posts/bf9085e4.html" title="ES5 to ESNext 自2015以来JavaScript新增的所有新特性">https://zhangmiao.cc/posts/bf9085e4.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/52228cda.html" rel="next" title="Java多线程看这篇就够了">
                <i class="fa fa-chevron-left"></i> Java多线程看这篇就够了
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/c4ef6275.html" rel="prev" title="android和java泛型扫盲">
                android和java泛型扫盲 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/4081078?s=460&v=4" alt="ZhangMiao">
            
              <p class="site-author-name" itemprop="name">ZhangMiao</p>
              <p class="site-description motion-element" itemprop="description">Android/Flutter Developer</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">376</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">143</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="mailto:zm@zhangmiao.cc" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://wpa.qq.com/msgrd?v=3&uin=153942241&site=qq&menu=yes" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhangmiaocc" target="_blank" title="Github">
                      
                        <i class="fa fa-fw fa-github"></i>Github</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.constore.cn/" title="Liujianhui" target="_blank">Liujianhui</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xuebin.me" title="Leo" target="_blank">Leo</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/lmj623565791" title="Hongyang" target="_blank">Hongyang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://liuwangshu.cn/" title="Liuwangshu" target="_blank">Liuwangshu</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://jspang.com/" title="Jspang" target="_blank">Jspang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blankj.com/" title="Blankj" target="_blank">Blankj</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wuxiaolong.me/" title="WuXiaoLong" target="_blank">WuXiaoLong</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://molunerfinn.com" title="Molunerfinn" target="_blank">Molunerfinn</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.ofind.cn/" title="Ofind" target="_blank">Ofind</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.gcssloop.com/" title="Gcssloop" target="_blank">Gcssloop</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ECMAScript-简介"><span class="nav-number">1.1.</span> <span class="nav-text">ECMAScript 简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES2015"><span class="nav-number">1.2.</span> <span class="nav-text">ES2015</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES2016"><span class="nav-number">1.3.</span> <span class="nav-text">ES2016</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES2017"><span class="nav-number">1.4.</span> <span class="nav-text">ES2017</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES2018"><span class="nav-number">1.5.</span> <span class="nav-text">ES2018</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ESNext"><span class="nav-number">1.6.</span> <span class="nav-text">ESNext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ECMAScript-简介-1"><span class="nav-number">2.</span> <span class="nav-text">ECMAScript 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ECMAScript-当前的版本。"><span class="nav-number">2.1.</span> <span class="nav-text">ECMAScript 当前的版本。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TC39-是什么？"><span class="nav-number">2.2.</span> <span class="nav-text">TC39 是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ES-Versions"><span class="nav-number">2.3.</span> <span class="nav-text">ES Versions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#let和const"><span class="nav-number">3.</span> <span class="nav-text">let和const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-let"><span class="nav-number">4.</span> <span class="nav-text">Using let</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-const"><span class="nav-number">5.</span> <span class="nav-text">Using const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#箭头函数"><span class="nav-number">6.</span> <span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐式返回"><span class="nav-number">7.</span> <span class="nav-text">隐式返回</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#箭头函数中的-this"><span class="nav-number">8.</span> <span class="nav-text">箭头函数中的 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Classes类"><span class="nav-number">9.</span> <span class="nav-text">Classes类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#class-定义"><span class="nav-number">9.1.</span> <span class="nav-text">class 定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class-继承"><span class="nav-number">10.</span> <span class="nav-text">Class 继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法"><span class="nav-number">11.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#私有方法"><span class="nav-number">12.</span> <span class="nav-text">私有方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Getters-和-setters"><span class="nav-number">12.1.</span> <span class="nav-text">Getters 和 setters</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认参数"><span class="nav-number">12.2.</span> <span class="nav-text">默认参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板字符串"><span class="nav-number">13.</span> <span class="nav-text">模板字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#多行字符串"><span class="nav-number">13.1.</span> <span class="nav-text">多行字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插值"><span class="nav-number">13.2.</span> <span class="nav-text">插值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Template-tags"><span class="nav-number">13.3.</span> <span class="nav-text">Template tags</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解构赋值"><span class="nav-number">14.</span> <span class="nav-text">解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#更强大的对象字面量"><span class="nav-number">14.1.</span> <span class="nav-text">更强大的对象字面量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原型"><span class="nav-number">14.2.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态属性"><span class="nav-number">14.3.</span> <span class="nav-text">动态属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#For-of循环"><span class="nav-number">15.</span> <span class="nav-text">For-of循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promises"><span class="nav-number">16.</span> <span class="nav-text">Promises</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#promise的原理简述"><span class="nav-number">16.1.</span> <span class="nav-text">promise的原理简述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么JS-API使用promises"><span class="nav-number">16.2.</span> <span class="nav-text">为什么JS API使用promises?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建一个promise"><span class="nav-number">16.3.</span> <span class="nav-text">创建一个promise</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用一个promise"><span class="nav-number">16.4.</span> <span class="nav-text">使用一个promise</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链式promise"><span class="nav-number">16.5.</span> <span class="nav-text">链式promise</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理错误"><span class="nav-number">17.</span> <span class="nav-text">处理错误</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#级联错误"><span class="nav-number">17.1.</span> <span class="nav-text">级联错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组织多个promise"><span class="nav-number">18.</span> <span class="nav-text">组织多个promise</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-all"><span class="nav-number">18.1.</span> <span class="nav-text">Promise.all()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-race"><span class="nav-number">18.2.</span> <span class="nav-text">Promise.race()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块"><span class="nav-number">19.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ES-模块语法"><span class="nav-number">19.1.</span> <span class="nav-text">ES 模块语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其它的-import-export-语法"><span class="nav-number">19.2.</span> <span class="nav-text">其它的 import/export 语法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CORS-跨域资源共享"><span class="nav-number">20.</span> <span class="nav-text">CORS(跨域资源共享)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对于不支持模块的浏览器应该怎么做？"><span class="nav-number">20.1.</span> <span class="nav-text">对于不支持模块的浏览器应该怎么做？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#包装模块"><span class="nav-number">20.2.</span> <span class="nav-text">包装模块</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新的字符串方法"><span class="nav-number">21.</span> <span class="nav-text">新的字符串方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#codePointAt"><span class="nav-number">21.1.</span> <span class="nav-text">codePointAt()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新的对象方法"><span class="nav-number">22.</span> <span class="nav-text">新的对象方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-assign"><span class="nav-number">22.1.</span> <span class="nav-text">Object.assign()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#展开操作符"><span class="nav-number">23.</span> <span class="nav-text">展开操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#剩余属性（Rest-properties）"><span class="nav-number">24.</span> <span class="nav-text">剩余属性（Rest properties）:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">25.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化一个-Set"><span class="nav-number">25.1.</span> <span class="nav-text">初始化一个 Set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#向-Set-中添加一项"><span class="nav-number">25.2.</span> <span class="nav-text">向 Set 中添加一项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检查元素是否在-set-中"><span class="nav-number">25.3.</span> <span class="nav-text">检查元素是否在 set 中</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#从-set-中删除一个元素："><span class="nav-number">25.4.</span> <span class="nav-text">从 set 中删除一个元素：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#确定-set-中元素的数量"><span class="nav-number">25.5.</span> <span class="nav-text">确定 set 中元素的数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除-set-中的全部元素"><span class="nav-number">25.6.</span> <span class="nav-text">删除 set 中的全部元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对-set-进行迭代"><span class="nav-number">25.7.</span> <span class="nav-text">对 set 进行迭代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用一些初始值初始化一个-set"><span class="nav-number">25.8.</span> <span class="nav-text">使用一些初始值初始化一个 set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WeakSet"><span class="nav-number">25.9.</span> <span class="nav-text">WeakSet</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">26.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#在ES6之前"><span class="nav-number">26.1.</span> <span class="nav-text">在ES6之前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#引入Map之后"><span class="nav-number">26.2.</span> <span class="nav-text">引入Map之后</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakMap"><span class="nav-number">27.</span> <span class="nav-text">WeakMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#你不可以获取WeakMap的大小"><span class="nav-number">27.1.</span> <span class="nav-text">你不可以获取WeakMap的大小</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Generators生成器"><span class="nav-number">28.</span> <span class="nav-text">Generators生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#calc-next"><span class="nav-number">28.1.</span> <span class="nav-text">calc.next()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-includes"><span class="nav-number">29.</span> <span class="nav-text">Array.prototype.includes()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求幂运算符"><span class="nav-number">30.</span> <span class="nav-text">求幂运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串填充"><span class="nav-number">31.</span> <span class="nav-text">字符串填充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-values"><span class="nav-number">32.</span> <span class="nav-text">Object.values()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-entries"><span class="nav-number">33.</span> <span class="nav-text">Object.entries()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getOwnPropertyDescriptors"><span class="nav-number">34.</span> <span class="nav-text">Object.getOwnPropertyDescriptors()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#In-what-way-is-this-useful"><span class="nav-number">35.</span> <span class="nav-text">In what way is this useful?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#尾逗号"><span class="nav-number">36.</span> <span class="nav-text">尾逗号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步函数"><span class="nav-number">37.</span> <span class="nav-text">异步函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要引入async-await"><span class="nav-number">37.1.</span> <span class="nav-text">为什么要引入async/await</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#它如何工作"><span class="nav-number">37.2.</span> <span class="nav-text">它如何工作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一个上手示例"><span class="nav-number">37.3.</span> <span class="nav-text">一个上手示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于-Promise"><span class="nav-number">38.</span> <span class="nav-text">关于 Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#更易于阅读的代码"><span class="nav-number">38.1.</span> <span class="nav-text">更易于阅读的代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#串行多个异步功能"><span class="nav-number">38.2.</span> <span class="nav-text">串行多个异步功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更简单的调试"><span class="nav-number">39.</span> <span class="nav-text">更简单的调试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#共享内存和原子"><span class="nav-number">39.1.</span> <span class="nav-text">共享内存和原子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Rest-Spread-Properties"><span class="nav-number">39.2.</span> <span class="nav-text">Rest/Spread Properties</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#异步迭代器"><span class="nav-number">39.3.</span> <span class="nav-text">异步迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-prototype-finally"><span class="nav-number">39.4.</span> <span class="nav-text">Promise.prototype.finally()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#正则表达式改进"><span class="nav-number">39.5.</span> <span class="nav-text">正则表达式改进</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Unicode属性转义-p-…-and-P-…"><span class="nav-number">39.6.</span> <span class="nav-text">Unicode属性转义 p{…} and P{…}</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ESNext-1"><span class="nav-number">40.</span> <span class="nav-text">ESNext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Optional-catch-binding"><span class="nav-number">40.1.</span> <span class="nav-text">Optional catch binding</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trimStart"><span class="nav-number">40.2.</span> <span class="nav-text">trimStart()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trimEnd"><span class="nav-number">40.3.</span> <span class="nav-text">trimEnd()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Symbol-prototype-description"><span class="nav-number">40.4.</span> <span class="nav-text">Symbol.prototype.description</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSON-improvements"><span class="nav-number">40.5.</span> <span class="nav-text">JSON improvements</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Well-formed-JSON-stringify"><span class="nav-number">40.6.</span> <span class="nav-text">Well-formed JSON.stringify()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Function-prototype-toString"><span class="nav-number">40.7.</span> <span class="nav-text">Function.prototype.toString()</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangMiao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








  <div>
    <script type="text/javascript">
      var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
      document.write(unescape("%3Cspan id='cnzz_stat_icon_1277928793'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1277928793%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));
    </script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://zhangmiao.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://zhangmiao.cc/posts/bf9085e4.html';
          this.page.identifier = 'posts/bf9085e4.html';
          this.page.title = 'ES5 to ESNext 自2015以来JavaScript新增的所有新特性';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://zhangmiao.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("8iIYW0IGofqyvJiiuU5R9buW-gzGzoHsz", "ssmxRx0kELJir6mA02ziW3Ql");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  


  <script type="text/javascript" src="/lib/zclip/clipboard.min.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>

</body>
</html>
