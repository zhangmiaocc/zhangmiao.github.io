<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangmiao.cc/"/>
  <updated>2022-05-26T02:26:22.544Z</updated>
  <id>https://zhangmiao.cc/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter升级到指定版本</title>
    <link href="https://zhangmiao.cc/posts/7a75b9fc.html"/>
    <id>https://zhangmiao.cc/posts/7a75b9fc.html</id>
    <published>2022-05-26T02:26:06.000Z</published>
    <updated>2022-05-26T02:26:22.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、通过命令："><a href="#一、通过命令：" class="headerlink" title="一、通过命令："></a>一、通过命令：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看版本： flutter --version</span><br><span class="line">检查环境：flutter doctor</span><br><span class="line">查看渠道：flutter channel</span><br><span class="line">切换渠道（stable, beta, dev, master）：flutter channel stable</span><br><span class="line">升级到最新版本：flutter upgrade </span><br><span class="line">升级到指定版本：flutter upgrade v2.5.0</span><br><span class="line">回退到指定版本：flutter downgrade v2.5.0</span><br></pre></td></tr></table></figure><h2 id="二、通过git回退版本："><a href="#二、通过git回退版本：" class="headerlink" title="二、通过git回退版本："></a>二、通过git回退版本：</h2><h3 id="1、进入flutter-github找到要回退的版本"><a href="#1、进入flutter-github找到要回退的版本" class="headerlink" title="1、进入flutter github找到要回退的版本"></a>1、进入<a href="https://github.com/flutter/flutter/tags" target="_blank" rel="noopener">flutter github</a>找到要回退的版本</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220526100104.png" alt><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220526100204.png" alt></p><h3 id="2、cd进入到存放flutter-sdk目录，运行回退指令-git-reset-–hard-commit-id"><a href="#2、cd进入到存放flutter-sdk目录，运行回退指令-git-reset-–hard-commit-id" class="headerlink" title="2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id]"></a>2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id]</h3><p> 例如-&gt; git reset –hard 4cc385b4b84ac2f816d939a49ea1f328c4e0b48e</p><h3 id="3、查看flutter版本"><a href="#3、查看flutter版本" class="headerlink" title="3、查看flutter版本"></a>3、查看flutter版本</h3><p> 查看版本-&gt; flutter doctor  或者 flutter –version</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、通过命令：&quot;&gt;&lt;a href=&quot;#一、通过命令：&quot; class=&quot;headerlink&quot; title=&quot;一、通过命令：&quot;&gt;&lt;/a&gt;一、通过命令：&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查看版本： flutter --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;检查环境：flutter doctor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看渠道：flutter channel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;切换渠道（stable, beta, dev, master）：flutter channel stable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;升级到最新版本：flutter upgrade &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;升级到指定版本：flutter upgrade v2.5.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;回退到指定版本：flutter downgrade v2.5.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;二、通过git回退版本：&quot;&gt;&lt;a href=&quot;#二、通过git回退版本：&quot; class=&quot;headerlink&quot; title=&quot;二、通过git回退版本：&quot;&gt;&lt;/a&gt;二、通过git回退版本：&lt;/h2&gt;&lt;h3 id=&quot;1、进入flutter-github找到要回退的版本&quot;&gt;&lt;a href=&quot;#1、进入flutter-github找到要回退的版本&quot; class=&quot;headerlink&quot; title=&quot;1、进入flutter github找到要回退的版本&quot;&gt;&lt;/a&gt;1、进入&lt;a href=&quot;https://github.com/flutter/flutter/tags&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;flutter github&lt;/a&gt;找到要回退的版本&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220526100104.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220526100204.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、cd进入到存放flutter-sdk目录，运行回退指令-git-reset-–hard-commit-id&quot;&gt;&lt;a href=&quot;#2、cd进入到存放flutter-sdk目录，运行回退指令-git-reset-–hard-commit-id&quot; class=&quot;headerlink&quot; title=&quot;2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id]&quot;&gt;&lt;/a&gt;2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id]&lt;/h3&gt;&lt;p&gt; 例如-&amp;gt; git reset –hard 4cc385b4b84ac2f816d939a49ea1f328c4e0b48e&lt;/p&gt;
&lt;h3 id=&quot;3、查看flutter版本&quot;&gt;&lt;a href=&quot;#3、查看flutter版本&quot; class=&quot;headerlink&quot; title=&quot;3、查看flutter版本&quot;&gt;&lt;/a&gt;3、查看flutter版本&lt;/h3&gt;&lt;p&gt; 查看版本-&amp;gt; flutter doctor  或者 flutter –version&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Flutter3.0 重磅发布</title>
    <link href="https://zhangmiao.cc/posts/216218f9.html"/>
    <id>https://zhangmiao.cc/posts/216218f9.html</id>
    <published>2022-05-26T02:12:56.000Z</published>
    <updated>2022-05-26T02:21:25.081Z</updated>
    
    <content type="html"><![CDATA[<p><strong>颠覆开发者开发方式的Flutter</strong></p><p>Flutter的诞生是为了彻底改变应用程序开发方式：将Web的迭代开发模式与硬件加速图形渲染和像素级控制相结合，这些以前可是游戏的专利，而现在它被来进行应用开发。自从Flutter 1.0测试版发布以来，谷歌对其不断地进行优化，让Flutter的功能日趋完善，比如添加了新的框架功能和小部件、与底层平台进行更加深入的集成、提供了丰富的软件包库，并且在性能和工具上也做了许多的改进。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2F7911e6d3j00rbreiu001xd200u0006bg00it003y.jpg&thumbnail=660x2147483647&quality=80&type=jpg" alt="img"></p><p>从1.0到3.0版本，Flutter被越来越多的开发者使用来构建应用程序。据谷歌最新用户研究报告显示：</p><ul><li>91%的开发人员认为Flutter能缩短构建和发布应用程序所需要的时间；</li><li>85%的开发人员认为Flutter使他们的应用程序更美观；</li><li>85%的人认可Flutter能使他们在更多的平台上发布他们的应用程序。</li></ul><p><strong>实现“大一统”，一个Flutter，横跨iOS、Android、Web、Windows、macOS、Linux六大平台</strong></p><p>Flutter 3.0为开发者提供了一种使用Dart编程语言为六大面向消费者的主流平台（iOS、Android、Web、Windows、macOS、Linux）目标编写应用程序的方法。基于Flutter 3，开发者能拥有从单个代码库为六个平台构建应用程序的体验，这将使其生产力大大提高。</p><p>不同于之前的版本，Flutter 3新增了对macOS和Linux应用程序的稳定支持。添加新平台的支持并不像我们想象中那么简单，其需要的不仅仅是渲染像素，还需要做很多其他的工作，比如新的输入和交互模型、编译和生成支持、可访问性和国际化以及特定于平台的集成等。Flutter不仅让用户能灵活地充分利用底层操作系统，同时能够根据需要共享尽可能多的UI。</p><p>具体来看，在macOS上，Flutter3可以通过通用二进制构建方式支持英特尔和Apple Silicon，允许应用打包在这两种架构上本机运行的可执行文件。同时，由于Dart对Apple Silicon的支持，编译速度也将更快。在Linux上，Canonical和谷歌合作提供了一个高度集成且在同类中最佳的开发选项。</p><a id="more"></a><p>另外，Flutter 3 还改进了许多基础功能，包括性能改进、Material You 支持和生产力更新。</p><p>除了上述所提到的内容，在新版本中，Flutter可以在苹果芯片上进行原生开发。虽然Flutter自发布以来，一直与搭载M1芯片的苹果设备兼容，但Flutter现在充分利用了Dart对Apple芯片的支持，可以在M1驱动的设备上实现更快的编译，并支持macOS应用程序的通用二进制文件。</p><p>另外，随着谷歌的Material Design 3在Flutter 3这个版本中基本已经完成，开发人员能够利用适应性强的跨平台设计系统，该系统提供动态配色方案和更新的视觉组件：</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2Fac3a791dj00rbreiv0068d200u000flg00it009r.jpg&thumbnail=660x2147483647&quality=80&type=jpg" alt="img"></p><p>Flutter是由Dart驱动的，Dart是一种用于多平台开发的高生产力、可移植的语言。谷歌在Dart中添加了一些新的语言功能。这些新的语言功能带来的好处颇多，比如能够减少模板、提高可读性、提供实验性的RISC-V支持，以及升级的linter和新的文档等。在专用的博客中可以获得关于Dart 2.17所有新更改的细节，可通过链接查看<a href="https://medium.com/dartlang" target="_blank" rel="noopener">https://medium.com/dartlang</a></p><p><strong>Firebase和Flutter深度集成</strong></p><p>当然，构建应用的不仅仅是UI框架。一套全面的工具在构建、开发和操作应用中也是必不可少的，比如身份验证、数据储存、云功能和设备测试等服务。而包括Sentry、AppWrite和AWS Amplify在内的很多服务都支持Flutter。</p><p>谷歌提供的应用服务Firebase使用率很高，在SlashData的开发者基准测试中，有62%的Flutter开发者表示会在开发应用程序时使用Firebase。因此，在以前的版本中，谷歌一直致力于将Flutter与Firebase更好地结合，以创造一流的的Flutter集成。为此，谷歌将Flutter中的Firebase插件提升到1.0（用于添加更好的文档和工具），以及提供像FlutterFire UI这样的新小部件（为开发人员提供可重用的UI用于身份验证和配置文件屏幕）。</p><p>今天，谷歌宣布将Flutter和Firebase的集成作为Firebase产品的核心，正在将源代码和文档移动到Firebase主存储库和站点中，而且谷歌有可能与Android和iOS同步发展Firebase对Flutter的支持。</p><p>此外，为了使用Crashlytics（Firebase广受欢迎的实时崩溃报告解决服务）谷歌还进行了以下重大改进。</p><ul><li>通过更新Flutter Crashlytics插件，可以让用户实时跟踪致命的错误，从而为用户提供与其他iOS或Android开发人员相同的功能集；</li><li>升级Crashlytics分析管道，以改进Flutter崩溃的聚类分析，从而更快地对问题进行分类、优先排序和修复；</li><li>简化了插件设置过程，因此只需几个步骤即可从用户的Dart代码中启动并运行Crashlytics。</li></ul><p><strong>Flutter休闲游戏工具包</strong></p><p>对于大多数开发者来说，Flutter只是一个应用程序框架。但是，在休闲游戏开发领域也有Flutter的一番天地。围绕休闲游戏开发的社区也在不断壮大，很多开发者利用Flutter提供的硬件加速图形支持和Flame等开源游戏引擎。</p><p>为了让休闲游戏开发者能够更能更容易上手，在今天的I/O大会上，谷歌宣布发布Flutter Casual Games Toolkit，它不仅提供了一个模板和最佳实践的入门工具包，还能带来广告和云服务的良好体验。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2F7dc50f30j00rbreix00c8d200u000c0g00it007i.jpg&thumbnail=660x2147483647&quality=80&type=jpg" alt="img"></p><p>虽然Flutter并不是为高强度的3D动作游戏而生的，但是有跨度是常有的事，即使是一些游戏也转向Flutter的非游戏UI，比如像PUBG Mobile这样拥有数亿用户的流行游戏。那么谷歌能把技术发展到什么程度呢？为了得到这个问题的答案，谷歌创建了一个有趣的弹球游戏（由Firebase和Flutter的网络支持提供支持）。</p><p>I/O弹球游戏中设计了一个带有四个吉祥物（Flutter的Dash、Firebase的Sparky、Android机器人和Chrome的恐龙）的定制桌子。玩家能在游戏中与别人一教高下，谷歌通过这种方式来展示Flutter多功能性，这很有趣。</p><p>Snearh认为，游戏开发和企业开发对性能和用户体验有着共同的追求，而Flutter团队一直在努力解决界面卡顿等问题，最终让框架能够更适用于各种类型的应用程序。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2F6d50e3e7j00rbreiz00fed200u000gvg00id00ab.jpg&thumbnail=660x2147483647&quality=80&type=jpg" alt="img"></p><p><strong>「一套代码，到处运行」，从 Flutter 3 开始</strong></p><p>作为一款开源工具，Flutter不仅仅是谷歌的框架，也是一个业界开发者都能使用的产品。无论是通过贡献新的代码或文档、创建赋予核心框架新的超能力的软件包、编写指导他人的书籍和培训课程，还是帮助组织活动和用户组等等，人人都可以参与其中。Flutter 3的发布大大地提高了开发者的效率，也终让大家都实现了「一套代码，到处运行」的梦想。</p><p>原文地址：<a href="https://medium.com/flutter/introducing-flutter-3-5eb69151622f" target="_blank" rel="noopener">https://medium.com/flutter/introducing-flutter-3-5eb69151622f</a></p><p>参考地址：<a href="https://juejin.cn/post/7096617842023333925" target="_blank" rel="noopener">https://juejin.cn/post/7096617842023333925</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;颠覆开发者开发方式的Flutter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flutter的诞生是为了彻底改变应用程序开发方式：将Web的迭代开发模式与硬件加速图形渲染和像素级控制相结合，这些以前可是游戏的专利，而现在它被来进行应用开发。自从Flutter 1.0测试版发布以来，谷歌对其不断地进行优化，让Flutter的功能日趋完善，比如添加了新的框架功能和小部件、与底层平台进行更加深入的集成、提供了丰富的软件包库，并且在性能和工具上也做了许多的改进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2F7911e6d3j00rbreiu001xd200u0006bg00it003y.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;从1.0到3.0版本，Flutter被越来越多的开发者使用来构建应用程序。据谷歌最新用户研究报告显示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;91%的开发人员认为Flutter能缩短构建和发布应用程序所需要的时间；&lt;/li&gt;
&lt;li&gt;85%的开发人员认为Flutter使他们的应用程序更美观；&lt;/li&gt;
&lt;li&gt;85%的人认可Flutter能使他们在更多的平台上发布他们的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现“大一统”，一个Flutter，横跨iOS、Android、Web、Windows、macOS、Linux六大平台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flutter 3.0为开发者提供了一种使用Dart编程语言为六大面向消费者的主流平台（iOS、Android、Web、Windows、macOS、Linux）目标编写应用程序的方法。基于Flutter 3，开发者能拥有从单个代码库为六个平台构建应用程序的体验，这将使其生产力大大提高。&lt;/p&gt;
&lt;p&gt;不同于之前的版本，Flutter 3新增了对macOS和Linux应用程序的稳定支持。添加新平台的支持并不像我们想象中那么简单，其需要的不仅仅是渲染像素，还需要做很多其他的工作，比如新的输入和交互模型、编译和生成支持、可访问性和国际化以及特定于平台的集成等。Flutter不仅让用户能灵活地充分利用底层操作系统，同时能够根据需要共享尽可能多的UI。&lt;/p&gt;
&lt;p&gt;具体来看，在macOS上，Flutter3可以通过通用二进制构建方式支持英特尔和Apple Silicon，允许应用打包在这两种架构上本机运行的可执行文件。同时，由于Dart对Apple Silicon的支持，编译速度也将更快。在Linux上，Canonical和谷歌合作提供了一个高度集成且在同类中最佳的开发选项。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Flutter混合开发组件化架构</title>
    <link href="https://zhangmiao.cc/posts/187f2070.html"/>
    <id>https://zhangmiao.cc/posts/187f2070.html</id>
    <published>2022-01-24T07:39:53.000Z</published>
    <updated>2022-01-24T08:05:41.069Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>背景</strong></li><li><strong>Flutter的四种工程类型</strong></li><li><strong>Flutter工程Pub依赖管理</strong></li><li><strong>FlutterModule集成到Native</strong></li><li><strong>Flutter与Native通信</strong></li><li><strong>Flutter组件化工程</strong></li><li><strong>后序</strong></li></ul><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>Flutter 在目前跨平台方案中有更好的平台一致性以及更优的体验。但对于本身已有成熟的业务代码的项目来说，更多的是采用混合栈的方式，在不变更原有 App 业务的基础上，将 Flutter 能力扩展为子模块进行接入和开发。这样并不影响原有的业务和原生能力，又可以结合业务需求进行技术选择。</p><h2 id="二、Flutter-的四种工程类型"><a href="#二、Flutter-的四种工程类型" class="headerlink" title="二、Flutter 的四种工程类型"></a>二、Flutter 的四种工程类型</h2><h3 id="2-1-Flutter-Application"><a href="#2-1-Flutter-Application" class="headerlink" title="2.1. Flutter Application"></a>2.1. Flutter Application</h3><p>标准的Flutter App工程，包含标准的Dart层与Native平台层</p><h3 id="2-2-Flutter-Module"><a href="#2-2-Flutter-Module" class="headerlink" title="2.2. Flutter Module"></a>2.2. Flutter Module</h3><p>Flutter组件工程，仅包含Dart层实现，Native平台层子工程为通过Flutter自动生成的隐藏工程</p><h3 id="2-3-Flutter-Plugin"><a href="#2-3-Flutter-Plugin" class="headerlink" title="2.3. Flutter Plugin"></a>2.3. Flutter Plugin</h3><p>Flutter平台插件工程，包含Dart层与Native平台层的实现</p><h3 id="2-4-Flutter-Package"><a href="#2-4-Flutter-Package" class="headerlink" title="2.4. Flutter Package"></a>2.4. Flutter Package</h3><p>Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget</p><a id="more"></a><h2 id="三、Flutter工程Pub依赖管理"><a href="#三、Flutter工程Pub依赖管理" class="headerlink" title="三、Flutter工程Pub依赖管理"></a>三、Flutter工程Pub依赖管理</h2><p>Flutter工程之间的依赖管理是通过Pub来管理的，依赖的产物是直接源码依赖，这种依赖方式和IOS中的Pod有点像，都可以进行依赖库版本号的区间限定与Git远程依赖等，其中具体声明依赖是在<strong>pubspec.yaml</strong>文件中，其中的依赖编写是基于YAML语法，YAML是一个专门用来编写文件配置的语言。</p><p>声明依赖后，通过运行<strong>flutter packages get</strong>命名，会从远程或本地拉取对应的依赖，同时会生成pubspec.lock文件，这个文件和IOS中的Podfile.lock极其相似，会在本地锁定当前依赖的库以及对应版本号，只有当执行<strong>flutter packages upgrade</strong>时，这时才会更新。</p><h2 id="四、Flutter-module-集成到-Native"><a href="#四、Flutter-module-集成到-Native" class="headerlink" title="四、Flutter module 集成到 Native"></a>四、Flutter module 集成到 Native</h2><p>上述说的如果我们要利用Flutter来开发我们现有Native工程中的一个模块或功能，肯定得不能改变Native的工程结构以及不影响现有的开发流程，那么，以何种方式进行混合开发呢？</p><h3 id="4-1-Flutter混合开发模式"><a href="#4-1-Flutter混合开发模式" class="headerlink" title="4.1 Flutter混合开发模式"></a>4.1 Flutter混合开发模式</h3><p>Flutter混合开发模式一般有两种方式：</p><ul><li>Flutter App 我们可以直接忽略，因为这是一个开发全新的Flutter App工程。</li><li>对于Flutter Module，官方提供的本地依赖便是使用Flutter Module依赖到Native App的，而对于Flutter工程来说，构建Flutter工程必须得有个main.dart主入口，恰好Flutter Module中也有主入口。</li></ul><h3 id="4-2-Flutter-Module的创建方式"><a href="#4-2-Flutter-Module的创建方式" class="headerlink" title="4.2 Flutter Module的创建方式"></a>4.2 Flutter Module的创建方式</h3><p>Flutter module创建方式一般有两种：</p><p><strong>a、通过命令来创建</strong></p><blockquote><p>flutter create -t module –org com.vhall.module vhall_flutter_module</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Creating project vhall_flutter_module...</span><br><span class="line">  vhall_flutter_module/test/widget_test.dart (created)</span><br><span class="line">  vhall_flutter_module/vhall_flutter_module.iml (created)</span><br><span class="line">  vhall_flutter_module/.gitignore (created)</span><br><span class="line">  vhall_flutter_module/.metadata (created)</span><br><span class="line">  vhall_flutter_module/pubspec.yaml (created)</span><br><span class="line">  vhall_flutter_module/README.md (created)</span><br><span class="line">  vhall_flutter_module/lib/main.dart (created)</span><br><span class="line">  vhall_flutter_module/vhall_flutter_module_android.iml (created)</span><br><span class="line">  vhall_flutter_module/analysis_options.yaml (created)</span><br><span class="line">  vhall_flutter_module/.idea/libraries/Dart_SDK.xml (created)</span><br><span class="line">  vhall_flutter_module/.idea/modules.xml (created)</span><br><span class="line">  vhall_flutter_module/.idea/workspace.xml (created)</span><br><span class="line">Running &quot;flutter pub get&quot; in vhall_flutter_module...             1,226ms</span><br><span class="line">Wrote 12 files.</span><br><span class="line"></span><br><span class="line">All done!</span><br><span class="line">Your module code is in vhall_flutter_module/lib/main.dart.</span><br></pre></td></tr></table></figure><p><strong>b、使用 As 创建 Flutter Module</strong></p><p>在 As 中选择 File-&gt;New-&gt;New Flutter Project，选择 Flutter Module 创建 Flutter Module 子项目</p><h3 id="4-3-添加Flutter的两种依赖方式"><a href="#4-3-添加Flutter的两种依赖方式" class="headerlink" title="4.3 添加Flutter的两种依赖方式"></a>4.3 添加Flutter的两种依赖方式</h3><h4 id="4-3-1-将Flutter添加到原生工程中，-有两种方式："><a href="#4-3-1-将Flutter添加到原生工程中，-有两种方式：" class="headerlink" title="4.3.1 将Flutter添加到原生工程中， 有两种方式："></a>4.3.1 将Flutter添加到原生工程中， 有两种方式：</h4><p><strong>a、以aar的方式集成到现有Android项目中</strong></p><p>创建好 Flutter Module 之后需要将其编译成 aar 的形式，可以通过如下命令进行 aar 的编译：</p><blockquote><p>cd vhall_flutter_module flutter build aar              </p></blockquote><p>在 Android 中也可以通过 As 工具来编译 aar，选择 Build-&gt;Flutter-&gt;Build AAR 来进行 aar 的编译。</p><p>然后根据提示在主项目工程的 build.grade 文件中进行相关配置，参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">💪 Building with sound null safety 💪</span><br><span class="line"></span><br><span class="line">Running Gradle task &apos;assembleAarDebug&apos;...                          22.2s</span><br><span class="line">✓ Built build/host/outputs/repo.</span><br><span class="line">Running Gradle task &apos;assembleAarProfile&apos;...                        46.1s</span><br><span class="line">✓ Built build/host/outputs/repo.</span><br><span class="line">Running Gradle task &apos;assembleAarRelease&apos;...                        37.2s</span><br><span class="line">✓ Built build/host/outputs/repo.</span><br><span class="line"></span><br><span class="line">Consuming the Module</span><br><span class="line">  1. Open &lt;host&gt;/app/build.gradle</span><br><span class="line">  2. Ensure you have the repositories configured, otherwise add them:</span><br><span class="line"></span><br><span class="line">      String storageUrl = System.env.FLUTTER_STORAGE_BASE_URL ?: &quot;https://storage.googleapis.com&quot;</span><br><span class="line">      repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &apos;/Users/zhangmiao/Documents/project/hybrid/vhall_flutter_module/build/host/outputs/repo&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &quot;$storageUrl/download.flutter.io&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  3. Make the host app depend on the Flutter module:</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">      debugImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_debug:1.0&apos;</span><br><span class="line">      profileImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_profile:1.0&apos;</span><br><span class="line">      releaseImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_release:1.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  4. Add the `profile` build type:</span><br><span class="line"></span><br><span class="line">    android &#123;</span><br><span class="line">      buildTypes &#123;</span><br><span class="line">        profile &#123;</span><br><span class="line">          initWith debug</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">To learn more, visit https://flutter.dev/go/build-aar</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>依赖一个包含 Flutter 产物的 aar 包，这个的好处就是其他不开发 flutter 的同学可以不用配置 flutter 环境，它和其他模块包无异</li></ul><p><strong>b、以 Flutet module 的方式集成到现有 Android 项目中</strong></p><p>在 setting.gradle 文件中配置 flutter module 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setBinding(new Binding([gradle: this]))</span><br><span class="line">evaluate(new File(</span><br><span class="line">  settingsDir,</span><br><span class="line">  &apos;../vhall_flutter_module/.android/include_flutter.groovy&apos;</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>在 app 项目的 build.gradle 依赖 flutter module 模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation project(&apos;:flutter&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>需要 flutter 环境，并且各个开发人员环境不一致，导致集成因为版本不一致报各种错误</li></ul><h3 id="4-3-2本地依赖的原理"><a href="#4-3-2本地依赖的原理" class="headerlink" title="4.3.2本地依赖的原理"></a>4.3.2本地依赖的原理</h3><p><strong>Android</strong></p><p>在Android中本地依赖方式为：</p><ul><li>在<strong>settings.gradle</strong>中注入<strong>include_flutter.groovy</strong>脚本</li><li>在需要依赖的app中<strong>build.gradle</strong>添加<strong>project(‘:flutter’)</strong>依赖</li></ul><p>对于Android的本地依赖，主要是由<strong>include_flutter.groovy</strong>和<strong>flutter.gradle</strong>这两个脚本负责Flutter的本地依赖和产物构建。</p><p><strong>a</strong>、<strong>include_flutter.groovy</strong></p><p>在<strong>settings.gradle</strong>中注入时，分别绑定了当前执行Gradle的上下文环境与执行<strong>include_flutter.groovy</strong>脚本，该脚本只做了下面三件事：</p><ul><li>include FlutterModule中的<strong>.android/Flutter</strong>工程</li><li>include FlutterModule中的<strong>.flutter-plugins</strong>文件中包含的Flutter工程路径下的android module</li><li>配置所有工程的<strong>build.gradle</strong>配置执行阶段都依赖于<strong>:flutter</strong>工程，也即它最先执行配置阶段</li></ul><p>其中<strong>.flutter-plugins</strong>文件，是根据当前依赖自动生成的，里面包含了当前Flutter工程所依赖（直接依赖和传递依赖）的Flutter子工程与绝对路径的K-V关系，子工程可能是一个Flutter Plugin或者是一个Flutter Package。</p><p> <strong>b</strong>、<strong>flutter.gradle</strong></p><p>该脚本位于Flutter SDK中，内容看起来很长，其实主要做了下面三件事：</p><ul><li>选择符合对应架构的Flutter引擎（flutter.so）</li><li>解析上述<strong>.flutter-plugins</strong>文件，把对应的android module添加到Native工程的依赖中（上述的include其实为这步做准备）</li><li>Hook mergeAssets/processResources Task，预先执行FlutterTask，调用<strong>flutter</strong>命令编译Dart层代码构建出<strong>flutter_assets</strong>产物，并拷贝到<strong>assets</strong>目录下</li></ul><p>有了上述三步，则直接在Native工程中运行构建即可自动构建Flutter工程中的代码并自动拷贝产物到Native中</p><p><strong>IOS</strong></p><p>在IOS中本地依赖方式为：</p><ul><li>在Podfile中通过<strong>eval binding</strong>特性注入<strong>podhelper.rb</strong>脚本，在pod install/update时会执行它</li><li>在IOS构建阶段<strong>Build Phases</strong>中注入构建时需要执行的<strong>xcode_backend.sh</strong>脚本</li></ul><p>对于IOS的本地依赖，主要是由<strong>podhelper.rb</strong>和<strong>xcode_backend.sh</strong>这两个脚本负责Flutter的Pod本地依赖和产物构建</p><p><strong>a</strong>、<strong>podhelper.rb</strong></p><p>因Podfile是通过ruby语言写的，所以该脚本也是ruby脚本，该脚本在pod install/update时主要做了三件事：</p><ul><li>Pod本地依赖Flutter引擎（Flutter.framework）与Flutter插件注册表（FlutterPluginRegistrant）</li><li>Pod本地源码依赖<strong>.flutter-plugins</strong>文件中包含的Flutter工程路径下的ios工程</li><li>在pod install执行完后<strong>post_install</strong>中，获取当前target工程对象，导入<strong>Generated.xcconfig</strong>配置，这些配置都为环境变量配置，主要为构建阶段<strong>xcode_backend.sh</strong>脚本执行做准备</li></ul><p>上述事情即可保证Flutter工程以及传递依赖的都通过pod本地依赖进Native工程了，接下来就是构建了</p><p><strong>b、xcode_backend.sh</strong></p><p>该Shell脚本位于Flutter SDK中，该脚本主要就做了两件事：</p><ul><li>调用flutter命令编译构建出产物（App.framework、flutter_assets）</li><li>把产物（<em>.framework、flutter_assets）拷贝到对应XCode构建产物中，对应产物目录为：*</em>$HOME/Library/Developer/Xcode/DerivedData/${AppName}**</li></ul><p>上述两个静态库<strong>*.framework</strong>是拷贝到<strong>${BUILT_PRODUCTS_DIR}”/“${PRODUCT_NAME}”.app/Frameworks”</strong>目录下</p><p>flutter_assets拷贝到<strong>${BUILT_PRODUCTS_DIR}”/“${PRODUCT_NAME}”.app”</strong>目录下</p><p>在XCode工程中，对应的是在<strong>${AppName}/Products/${AppName}.app</strong></p><h3 id="4-4-原生接入-flutter-页面"><a href="#4-4-原生接入-flutter-页面" class="headerlink" title="4.4 原生接入 flutter 页面"></a>4.4 原生接入 flutter 页面</h3><p>flutter 依赖提供了 FlutterActivity 来直接加载 flutter 页面，我们只需要在清单文件中配置该 Activity ：</p><p>（通常我们会创建一个 Activity 继承 FlutterActivity）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;io.flutter.embedding.android.FlutterActivity&quot;</span><br><span class="line">    android:theme=&quot;@style/Theme.Vhall_app&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode&quot;</span><br><span class="line">    android:hardwareAccelerated=&quot;true&quot;</span><br><span class="line">    android:windowSoftInputMode=&quot;adjustResize&quot;/&gt;</span><br></pre></td></tr></table></figure><p>三种打开flutter页面的方式：</p><p>1）普通跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    startActivity(</span><br><span class="line">      FlutterActivity.createDefaultIntent(currentActivity)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2）设置路由的方式跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">myButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    startActivity(</span><br><span class="line">      FlutterActivity</span><br><span class="line">        .withNewEngine()</span><br><span class="line">        .initialRoute(&quot;/my_route&quot;)</span><br><span class="line">        .build(currentActivity)</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码会在内部创建自己的 FlutterEngine 实例，每个 FlutterActivity 都创建自己的 FlutterEngine，这意味着启动一个标准的 FlutterActivity 会在界面可见时出现一短暂的延迟，可以选择使用预缓存的 FlutterEngine 来减小其延迟，实际上在内部会先检查是否存在预缓存的 FlutterEngine，如果存在则使用该 FlutterEngine，否则继续使用非预缓存的 FlutterEngine。</p><p>3）缓存 Flutter 引擎方式跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">    public FlutterEngine flutterEngine;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        // Instantiate a FlutterEngine.</span><br><span class="line">        flutterEngine = new FlutterEngine(this);</span><br><span class="line"></span><br><span class="line">       // Start executing Dart code to pre-warm the FlutterEngine.</span><br><span class="line">       flutterEngine.getDartExecutor().executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault());</span><br><span class="line"></span><br><span class="line">       // Cache the FlutterEngine to be used by FlutterActivity.</span><br><span class="line">       FlutterEngineCache.getInstance().put(&quot;my_engine_id&quot;, flutterEngine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        startActivity(</span><br><span class="line">            LoginFlutterActivity</span><br><span class="line">                  .withCachedEngine(&quot;my_engine_id&quot;)</span><br><span class="line">                  .build(MainActivity.this)</span><br><span class="line">        );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="五、Flutter与Native通信"><a href="#五、Flutter与Native通信" class="headerlink" title="五、Flutter与Native通信"></a>五、Flutter与Native通信</h2><h3 id="5-1Platform-Channel"><a href="#5-1Platform-Channel" class="headerlink" title="5.1Platform Channel"></a>5.1Platform Channel</h3><p><strong>Platform Channel</strong>为Dart和平台之间提供了相互通信的机制，将<strong>Flutter</strong>、<strong>Android</strong>、<strong>iOS</strong>连接起来。</p><p>在移动H5开发中，<strong>webview</strong>自身提供的功能往往不够用，为了解决这个问题，引入了<strong>jsbridge</strong>，即<strong>web</strong>与<strong>native</strong>之间进行数据交互的一种方法,可以方便的将native的功能扩展给<strong>webview</strong>使用，从而可以快速开发。在<strong>Flutter</strong>中，也存在和<strong>jsbridge</strong>一样的用法，那就是<strong>Platform Channel</strong>，我们可以通过<strong>Platform Channel</strong>，将<strong>Flutter</strong>和<strong>Native</strong>方便的连接在一起，架构图如下:</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220124155717.png" alt></p><p>在Channel中</p><ol><li>client发送信息</li><li>host接受信息并返回结果</li><li>而且消息和响应是以异步方式传递的</li><li>Flutter和Natvie可以互为client和host，信息传递是双向的</li></ol><h3 id="5-2-三种不同类型的Platform-Channel"><a href="#5-2-三种不同类型的Platform-Channel" class="headerlink" title="5.2 三种不同类型的Platform Channel"></a>5.2 三种不同类型的Platform Channel</h3><p>Flutter定义了三种不同类型的Platform Channel用于Flutter与Host App平台进行通信，它们分别</p><ul><li><strong>BasicMessageChannel</strong>：用于数据传递，可以双向的请求数据。</li><li><strong>MethodChannel</strong>：用于传递方法调用，即Flutter端可以调用Platform端的方法并通过Result接口回调结果数据。</li><li><strong>EventChannel</strong>: 用于传递事件，即Flutter端监听Platform端的实时消息，一旦Platform端产生了数据，立即回调到Flutter端。</li></ul><p>其构造方法都需指定一个通道标识、解编码器以及 BinaryMessenger，BinaryMessenger 是一个 Flutter 与平台的通信工具，用来传递二进制数据、设置对应的消息处理器等。</p><p>解编码器有两种分别是 MethodCodec 和 MessageCodec，前者对应方法后者对应消息，BasicMessageChannel 使用的是 MessageCodec，MethodChannel 和 EventChannel 使用的是 MethodCodec。</p><h3 id="5-3-平台数据类型对照"><a href="#5-3-平台数据类型对照" class="headerlink" title="5.3 平台数据类型对照"></a>5.3 平台数据类型对照</h3><p>Platform Channel 提供不同的消息解码机制，如 StandardMessageCodec 提供基本数据类型的解编码、JSONMessageCodec 支持 Json 的解编码等，在平台之间通信时都会自动转换，各平台数据类型对照如下：<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220124155756.png" alt></p><h2 id="六、Flutter组件化工程"><a href="#六、Flutter组件化工程" class="headerlink" title="六、Flutter组件化工程"></a>六、Flutter组件化工程</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>前面讲了Flutter和Native的混合开发模式，Flutter作为Native工程的一个Module存在，这样可以有效的将Flutter和Native进行物理隔离，但随着Flutter承载的业务越来越多，与Native交互的接口变的越来越多，带来了很多管理问题，因此我们迫切需要采用新的开发模式，即Flutter的组件化开发方案。</p><h3 id="6-2-组件化的优势"><a href="#6-2-组件化的优势" class="headerlink" title="6.2 组件化的优势"></a>6.2 组件化的优势</h3><p>采用组件化开发Flutter，将会有如下的优势：</p><ul><li>将功能模块化，相互独立，方便管理</li><li>模块之间互不影响，耦合低，一些与业务无关的模块可以开源出来，供其他APP使用，提供代码的复用。</li><li>采用组件化开发，开发时互不影响，可以提高开发效率。</li><li>方便单元测试</li></ul><h3 id="6-3-组件化架构"><a href="#6-3-组件化架构" class="headerlink" title="6.3 组件化架构"></a>6.3 组件化架构</h3><p>组件划分，通过Flutter Module作为所有通过Flutter实现的模块或功能的聚合入口，通过它进行Flutter层到Native层的双向关联。而Flutter开发代码写在哪里呢？当然可以直接写在Flutter Module中，这没问题，而如果后续开发了多个模块、组件，我们的Dart代码总不可能全部写在Flutter Module中lib/吧，如果在lib/目录下再建立子目录进行模块区分，这不失为一种最简单的方式，不过这会带来一些问题，所有模块共用一个远程Git地址，首先在组件开发隔离上完全耦合了，其次各个模块组件没有单独的版本号或Tag，且后续模块组件的增多，带来更多的测试回归成本。</p><p>正确的组件化方式为一个组件有一个独立的远程Git地址管理，这样各个组件在发正式版时都有一个版本号和Tag，且在各个组件开发上完全隔离，后续组件的增多不影响其它组件，某个组件新增需求而不需回归其它组件，带来更低的测试成本。</p><p>前面提到Flutter Plugin可以有对应Dart层代码与平台层的实现，所以可以这样设计，一个组件对应一个Flutter Plugin，一个Flutter Plugin为一个完整的Flutter工程，有独立的Git地址，而这些组件之间不能互相依赖，保持零耦合，所以这些组件都在业务层，可以叫做业务组件，这些业务组件之间的通信和公共服务可以再划分一层基础层，可以叫做基础组件，所有业务组件依赖基础层，而Flutter Module作为聚合层依赖于所有Flutter组件，这些Flutter工程之间的依赖正是通过Pub依赖进行管理的。</p><p>所以，综合上述，整体的组件化架构可以设计为：<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220124155848.png" alt></p><h3 id="6-4业务组件与基础组件的定位"><a href="#6-4业务组件与基础组件的定位" class="headerlink" title="6.4业务组件与基础组件的定位"></a>6.4业务组件与基础组件的定位</h3><p>对于上面的基础组件比如还可以进行更细粒度的划分，不过不建议划分太多，对于与Native平台层的通信，每个业务组件对应一个Channel，当然内部还可以进行更细粒度的Channel进行划分，这个Channel主要是负责Native层服务的提供，让Flutter层消费。而对于Native层调用Flutter层的Api，应该尽可能少，需要调也只有出现一些值回调时。</p><p>因为Flutter的出现最本质的就是一次开发两端运行，而如果有太多这种依赖于平台层的实现，反而出现违背了，最后只是UI写了一份而已。对于平台层的实现也要尽量保持一个原则，即：</p><p>尽量让Native平台层成为服务层，让Flutter层成为消费层调用Native层的服务，即Dart调用Native的Api，这样当两端开发人员编写好一致基础的服务接口后，Flutter的开发人员即可平滑使用和开发。</p><h2 id="七、后序"><a href="#七、后序" class="headerlink" title="七、后序"></a>七、后序</h2><p>对于现有工程使用Flutter进行混合开发，坑点还是有的，比如性能、页面栈管理等方面，加上目前Flutter上一些基础库不成熟，对于项目内的重要页面以及动态化强度比较高的页面，目前还是不建议使用Flutter进行开发，如果要使用也须做好降级方案，相反可以使用稍微轻量级点的页面，且在设计时对于Flutter与Native层的通信，应该让Flutter作为消费层消费Native层提供的服务，Native端应做尽量少的改动等等。与纯原生开发或纯 Flutter 开发相比，混合开发由于需要打通原生和 Flutter 的数据和服务，需要有大量桥接实现，各个模块互相协作也需要考虑各种异常或降级的情况。</p><p>参考：<br>将 Flutter module 集成到 Android 项目 <a href="https://flutter.cn/docs/development/add-to-app/android/project-setup" target="_blank" rel="noopener">https://flutter.cn/docs/development/add-to-app/android/project-setup</a><br>将 Flutter module 集成到 iOS 项目 <a href="https://flutter.cn/docs/development/add-to-app/ios/project-setup" target="_blank" rel="noopener">https://flutter.cn/docs/development/add-to-app/ios/project-setup</a><br>在 Android 应用中添加 Flutter 页面<a href="https://flutter.cn/docs/development/add-to-app/android/add-flutter-screen" target="_blank" rel="noopener">https://flutter.cn/docs/development/add-to-app/android/add-flutter-screen</a><br>在 iOS 应用中添加 Flutter 页面 <a href="https://flutter.cn/docs/development/add-to-app/ios/add-flutter-screen" target="_blank" rel="noopener">https://flutter.cn/docs/development/add-to-app/ios/add-flutter-screen</a><br>Add-to-App Samples <a href="https://github.com/flutter/samples/blob/beface247a/add_to_app/README.md" target="_blank" rel="noopener">https://github.com/flutter/samples/blob/beface247a/add_to_app/README.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flutter的四种工程类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flutter工程Pub依赖管理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FlutterModule集成到Native&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flutter与Native通信&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flutter组件化工程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;Flutter 在目前跨平台方案中有更好的平台一致性以及更优的体验。但对于本身已有成熟的业务代码的项目来说，更多的是采用混合栈的方式，在不变更原有 App 业务的基础上，将 Flutter 能力扩展为子模块进行接入和开发。这样并不影响原有的业务和原生能力，又可以结合业务需求进行技术选择。&lt;/p&gt;
&lt;h2 id=&quot;二、Flutter-的四种工程类型&quot;&gt;&lt;a href=&quot;#二、Flutter-的四种工程类型&quot; class=&quot;headerlink&quot; title=&quot;二、Flutter 的四种工程类型&quot;&gt;&lt;/a&gt;二、Flutter 的四种工程类型&lt;/h2&gt;&lt;h3 id=&quot;2-1-Flutter-Application&quot;&gt;&lt;a href=&quot;#2-1-Flutter-Application&quot; class=&quot;headerlink&quot; title=&quot;2.1. Flutter Application&quot;&gt;&lt;/a&gt;2.1. Flutter Application&lt;/h3&gt;&lt;p&gt;标准的Flutter App工程，包含标准的Dart层与Native平台层&lt;/p&gt;
&lt;h3 id=&quot;2-2-Flutter-Module&quot;&gt;&lt;a href=&quot;#2-2-Flutter-Module&quot; class=&quot;headerlink&quot; title=&quot;2.2. Flutter Module&quot;&gt;&lt;/a&gt;2.2. Flutter Module&lt;/h3&gt;&lt;p&gt;Flutter组件工程，仅包含Dart层实现，Native平台层子工程为通过Flutter自动生成的隐藏工程&lt;/p&gt;
&lt;h3 id=&quot;2-3-Flutter-Plugin&quot;&gt;&lt;a href=&quot;#2-3-Flutter-Plugin&quot; class=&quot;headerlink&quot; title=&quot;2.3. Flutter Plugin&quot;&gt;&lt;/a&gt;2.3. Flutter Plugin&lt;/h3&gt;&lt;p&gt;Flutter平台插件工程，包含Dart层与Native平台层的实现&lt;/p&gt;
&lt;h3 id=&quot;2-4-Flutter-Package&quot;&gt;&lt;a href=&quot;#2-4-Flutter-Package&quot; class=&quot;headerlink&quot; title=&quot;2.4. Flutter Package&quot;&gt;&lt;/a&gt;2.4. Flutter Package&lt;/h3&gt;&lt;p&gt;Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>【新技术】又双叒叕来了系列三</title>
    <link href="https://zhangmiao.cc/posts/477750ac.html"/>
    <id>https://zhangmiao.cc/posts/477750ac.html</id>
    <published>2022-01-12T05:36:43.000Z</published>
    <updated>2022-01-12T06:07:59.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-在-Android-模拟器上运行-ARM-应用"><a href="#1-在-Android-模拟器上运行-ARM-应用" class="headerlink" title="1. 在 Android 模拟器上运行 ARM 应用"></a>1. 在 Android 模拟器上运行 ARM 应用</h3><p>这算是一个非常好的消息了，之前在实际应用开发中，因为模拟器缺少对 arm 的支持，基本上都使用真机进行开发与调试。<br>随着 Android 11预览版的发布<br>Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM 指令转换成 x86 指令。开发者无需搭建高负载的 ARM 环境即可执行 ARM 二进制文件并进行测试。</p><p>详情：<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652052998&idx=1&sn=9839e5a74c1dba47123d6cb5da15c10f&scene=21#wechat_redirect" target="_blank" rel="noopener">在 Android 模拟器上运行 ARM 应用</a></p><h3 id="2-大厂对外文章分享"><a href="#2-大厂对外文章分享" class="headerlink" title="2. 大厂对外文章分享"></a>2. 大厂对外文章分享</h3><p><strong>携程技术</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697269503&idx=2&sn=f5505724dcee64ebd9904ee16a2bfedb&scene=21#wechat_redirect" target="_blank" rel="noopener"> 携程Android 10适配踩坑指南</a><br>新版本适配一直是 Android 开发者的痛楚之一，但是这件事如果长期不升就会越来越困难。加上现在应用市场比较强势，所以保持一个较高的版本的适配是有必要的。<br>携程旅行分享了他们从API 26 到 29 的适配经验，大家可以参考一波。<br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697269484&idx=1&sn=1f5dcd45f90b2314050a04492e3a1cc0&scene=21#wechat_redirect" target="_blank" rel="noopener">全网最详！暗黑模式在 Trip.com App 的实践</a></p><p>暗黑模式也最近的一个非常热门的话题，甚至微信支持暗黑模式都成为热点了。如果你对这方面感兴趣，或者刚好有暗黑实践的需求，那么可以看这一篇由携程 UED 团队+研发团队撰写的文章。<br>我个人其实一直没有体验过暗黑模式，毕竟没适配的 app 太多了，所以我不认为把手机切换为暗黑模式有很好的的体验…</p><p><strong>Google 开发者</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652052998&idx=2&sn=18715a7e33b7f7a5878bd301e9f8f935&scene=21#wechat_redirect" target="_blank" rel="noopener">在 Android 开发中使用协程 | 背景介绍</a><br>可以看一下官方的文章了解下协程的一些背景知识，用来解决什么问题，如何解决，以及性能相关的一些知识。</p><p><strong>字节跳动技术团队</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485583&idx=1&sn=a572862f110948673818d745cea5aea6&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音包大小优化-资源优化</a><br>可以看下抖音团队为了减少 apk 的体积，针对资源这一方面做了哪些<strong>极致</strong>的事情。<br>另外 apk 体积优化也可以看下 jsonchao 的文章：<br><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650830257&idx=1&sn=f94eb0e05a1c40d5a99a7384b6f736ad&chksm=80b7a12fb7c028395c18bc81f544bc4d893ca9829e7b702e079d973608bee3b6eb5a7d2c49ff&scene=21#wechat_redirect" target="_blank" rel="noopener">吹爆系列：深入探索Android包体积优化</a></p><p><strong>百度 APP 技术</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247484032&idx=1&sn=da2740910b6df7d7f1ee9e2903f5ca27&scene=21#wechat_redirect" target="_blank" rel="noopener">Gradle 与 Android 构建入门</a><br>写了一篇 Gradle 构建入门的文章，其实很多同学都非常害怕 Gradle，这篇文章会给大家解释为什么需要 Gradle，以及 Gradle 相关的一些基础知识，帮你更好的了解相关知识，比较轻松，可以一看。</p><p><strong>西瓜技术团队</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODczOQ==&mid=2247483682&idx=1&sn=883435f1fe81295ec1c3ef6d576953c9&scene=21#wechat_redirect" target="_blank" rel="noopener">AwCookieManager.nativeGetCookie crash 排查</a><br>分享了西瓜的一个CookieManager.getCookie(String url) 过程中的 native crash，分析过程较为复杂，不过给出了解决方案，解决方案涉及到 hook，西瓜用了自研的方案，开源的 lancet 应该也能做到，这篇文章也会提到 lancet。</p><a id="more"></a><p>历史分享(点击可直接访问)：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580200&idx=1&sn=c663d8be4628d74efb20aee09f1cc743&scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯Bugly:对字符串匹配算法的一点理解</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247485203&idx=1&sn=26fd99ca1201e292ea5531c814eeb881&scene=21#wechat_redirect" target="_blank" rel="noopener">爱奇艺：安卓APP崩溃捕获方案——xCrash</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485042&idx=1&sn=fe32711dbcb483f7a47dfa0e304087c4&scene=21#wechat_redirect" target="_blank" rel="noopener">字节跳动：深入理解Gradle框架之一：</a><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485042&idx=1&sn=fe32711dbcb483f7a47dfa0e304087c4&scene=21#wechat_redirect" target="_blank" rel="noopener">Plugin, Extension, buildSrc</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483745&idx=1&sn=59bf0c9bc5b584d411880617cf32f795&scene=21&token=1556389437&lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">百度APP技术：Android H5首屏优化实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE2NzIzMg==&mid=2247487670&idx=1&sn=952e44c0ce8890b27b0115a1974cc431&scene=21#wechat_redirect" target="_blank" rel="noopener">京东技术：任意URL跳转漏洞修复与JDK中getHost()方法之间的坑</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483789&idx=1&sn=f3843b9ce282ab7d4e3c6225d780f9cd&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483804&idx=1&sn=026f386cc88d07044735cde5206c1de0&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483815&idx=1&sn=c3872d2e1b86d6eb48b8665fbf6f6fa4&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝 App 构建优化解析：Android 包大小极致压缩</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==&mid=2247484874&idx=1&sn=bc0f92ccb6d1b7c6be6bc535ac491cd7&scene=21#wechat_redirect" target="_blank" rel="noopener">搜狐：深入理解Flutter多线程</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697268363&idx=1&sn=3db2dce36a912936961c671dd1f71c78&scene=21#wechat_redirect" target="_blank" rel="noopener">携程：从智行 Android 项目看组件化架构实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652049096&idx=1&sn=dc9d0a408d07d78d487974354fd5dee7&scene=21#wechat_redirect" target="_blank" rel="noopener">Google: Flutter 您需要知道的知识点 | FAQ・第三期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484937&idx=1&sn=144003c8c662eebbdd71d7a9617e3439&chksm=e9d0cdebdea744fd3f413d3667590479bb5c4e52d628d44b37807a761be6415f3b4e5c40d554&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">字节跳动：二维码扫描优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247483887&idx=1&sn=d54e3f210a4f31f477dba06c3dcd352e&scene=21#wechat_redirect" target="_blank" rel="noopener">网易传媒技术团队：AOP技术在客户端的应用与实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247483939&idx=1&sn=aa170d606c7de063a0d587aa4da1fc91&scene=21#wechat_redirect" target="_blank" rel="noopener">网易大数据|互联网产品决策秘笈: AB测试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzIwMDM5Ng==&mid=2247483750&idx=1&sn=8ba37d6b8a073c3a0fbb0dcc10b00175&scene=21#wechat_redirect" target="_blank" rel="noopener">高德：Android Native 内存泄漏系统化解决方案</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTU3MTE4NQ==&mid=2247484444&idx=1&sn=2c4c8fa957df258003c4fcfe63df3a59&chksm=ea591302dd2e9a14aebb553e3af14fa12d239dd76ef01b3855bb5b9f2a3196b42e829ce8d504&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">例说 Constraint Layout（三）—— 性能测试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTU3MTE4NQ==&mid=2247484411&idx=1&sn=f8cd93a994080a31cfdb58bda9f5dc75&chksm=ea5914e5dd2e9df35cfe04b066eefc9b876faa074569f45a5320a28c5b0031d8cad282bacdf3&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">Android P之Smart Linkif</a>y</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483830&idx=1&sn=a158b07ca3fe6a4ef8ff89d4f5b682aa&scene=21#wechat_redirect" target="_blank" rel="noopener">百度App组件化之路</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483844&idx=1&sn=59e434f601cc4ae5a3970e8751662fd2&scene=21#wechat_redirect" target="_blank" rel="noopener">百度App网络深度优化系列《三》弱网优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485061&idx=1&sn=7c935aecbb9b558e4d5d9dd2c3eb7f96&scene=21#wechat_redirect" target="_blank" rel="noopener"> 头条| 深入理解gradle框架之二：依赖实现分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750945&idx=2&sn=4c0f9c59498610ea1ce9744b8b35e61a&scene=21#wechat_redirect" target="_blank" rel="noopener">美团| Probe：Android线上OOM问题定位组件</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750923&idx=1&sn=1044e16dddeda4e7a6daaadfe9637f75&scene=21#wechat_redirect" target="_blank" rel="noopener">美团|Android静态代码扫描效率优化与实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485301&idx=1&sn=eadc3d5ebfebe32c354dcd4529cd86c5&scene=21#wechat_redirect" target="_blank" rel="noopener">头条|开源 | Scene：Android 开源页面导航和组合框架</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247484258&idx=1&sn=558555cefa7ac495b66c31dd201b1c1c&scene=21#wechat_redirect" target="_blank" rel="noopener">网易新闻客户端 H5 秒开优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mzc2Nzg1MQ==&mid=2247483669&idx=1&sn=35fcd1aeefe52bdfbae9ce37fb56cee2&scene=21#wechat_redirect" target="_blank" rel="noopener">解决支付宝包体积优化的遗留问题：</a><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mzc2Nzg1MQ==&mid=2247483669&idx=1&sn=35fcd1aeefe52bdfbae9ce37fb56cee2&scene=21#wechat_redirect" target="_blank" rel="noopener">运行时获取dexpc</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247485891&idx=1&sn=f97a596399977e5ca61333ed5d359466&scene=21#wechat_redirect" target="_blank" rel="noopener">Android篇 | 爱奇艺App启动优化实践分享</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247486037&idx=2&sn=7f095d5daceb7ecc4b70983aab410d43&scene=21#wechat_redirect" target="_blank" rel="noopener">二维码扫描优化及爱奇艺App的实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580237&idx=1&sn=de8ec4404964a46995048e2b49556b7a&scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTk0ODUxOQ==&mid=2247483782&idx=1&sn=f9eae167b217c83036b3a24cd4182cd1&scene=21#wechat_redirect" target="_blank" rel="noopener">天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDIwODQ0Mw==&mid=2247483996&idx=1&sn=585369f542e084a4857145f5793e2b9f&scene=21#wechat_redirect" target="_blank" rel="noopener">花椒Android端自动化测试实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483964&idx=1&sn=fc5c4cd18e3564a237dff075bc055a3f&scene=21#wechat_redirect" target="_blank" rel="noopener">一种简单优雅的TextView行间距适配方案</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483952&idx=1&sn=da440dcb3da286969c13fc9a9f3f1223&scene=21#wechat_redirect" target="_blank" rel="noopener">Android 10分区存储介绍及百度APP适配实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247493879&idx=1&sn=653ac0a8d0e33cc3faea6659b25d0398&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485530&idx=1&sn=c6f92a614829215d13aec273cbd1022a&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%（二）</a></li></ul><h3 id="4-一个-Android-优秀博主的文章合集"><a href="#4-一个-Android-优秀博主的文章合集" class="headerlink" title="4. 一个 Android 优秀博主的文章合集"></a>4. 一个 Android 优秀博主的文章合集</h3><p><em><a href="https://github.com/yangkun19921001/Blog" target="_blank" rel="noopener">https://github.com/yangkun19921001/Blog</a></em><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220112135542.png" alt></p><p>比较适合系统性的复习，而且作者应该比较精通音视频，我知道很多同学对音视频很好奇，苦于没有什么入门的书籍等，不妨看下这位作者系列文章。</p><h3 id="5-一个Android-面试题合集"><a href="#5-一个Android-面试题合集" class="headerlink" title="5. 一个Android 面试题合集"></a>5. 一个Android 面试题合集</h3><p>这是一个国外开发者维护的仓库，所以问题以及相关问题解答的博客都是外文。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220112135726.png" alt></p><p><em><a href="https://github.com/MindorksOpenSource/android-interview-questions" target="_blank" rel="noopener">https://github.com/MindorksOpenSource/android-interview-questions</a></em><br>上述问题在我们看来不一定能作为面试题，但是有些问题还是可以用来差缺补漏的，也能帮助大家发现一些写的比较好的外文博客。</p><h3 id="6-lancet-：一个-hook-库"><a href="#6-lancet-：一个-hook-库" class="headerlink" title="6. lancet ：一个 hook 库"></a>6. lancet ：一个 hook 库</h3><p><a href="https://github.com/eleme/lancet" target="_blank" rel="noopener">https://github.com/eleme/lancet</a><br>这个库非常久了哈，饿了么对外开源的，但是好像开发者关注度并不高。<br>实际上还是非常好用的，我们传统意义 hook 的想法，都是换掉某个实现。</p><p>比如 A 类，有个 b 方法，我们需要修改 b方法返回值，我们一般会考虑 hook 一些对象，由这些对象导致 b 方法的执行返回逻辑发生改变，但是这种hook 并不是那么容易找到突破口。</p><p>而 lancet 的概念就很有意思了，它不修改 b方法，<strong>他修改所有调用 b 方法的地方</strong>，把对b 方法的调用hook 到你准备好的方法中，所以你可以随意的控制返回值，当然这种 hook 肯定是基于编译期修改字节码的，优势就是一定能换到，只要是参与编译的代码。</p><p>我说的可能大家不太容易理解，还是建议大家了解下这个库的原理，确实是 hook 的一个非常好的新思路。</p><h3 id="7-奇思妙想"><a href="#7-奇思妙想" class="headerlink" title="7. 奇思妙想"></a>7. 奇思妙想</h3><p>见到一个库是这样的:<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220112140525.png" alt></p><p><a href="https://github.com/m-zylab/SketchyComponent" target="_blank" rel="noopener">https://github.com/m-zylab/SketchyComponent</a><br>主要是手绘风，相信大家根据之前的灰白化的文章：<br><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650830283&idx=1&sn=bb0bcebfd025805ddda7bb2c36f7231e&chksm=80b7a155b7c028437cffc35a62003f7dfcc00a275b52fe98aa3c1aa9034a6fc74b16f5f18910&scene=21#wechat_redirect" target="_blank" rel="noopener">App黑白化实现探索，有一行代码实现的方案吗？</a></p><p>都知道我们可以基于换肤的方案把一些控件换成我们自己的，那么假设我们可以提供手绘风格的：TextView,Button…等，是不是有可能可以将一个 app 瞬间变成手绘风格？ </p><h3 id="8-随便播报"><a href="#8-随便播报" class="headerlink" title="8. 随便播报"></a>8. 随便播报</h3><p><strong>appcomapt 1.1.0 版本在 android 5.0,5.1的设备上可能会造成 webview 崩溃</strong><br>这是周六的时候一个朋友遇到的问题，查了下发现的。<br>这是个官方bug:<br><a href="https://issuetracker.google.com/issues/141132133" target="_blank" rel="noopener">https://issuetracker.google.com/issues/141132133</a></p><p>一些解决方案：<br><a href="https://stackoverflow.com/questions/41025200/android-view-inflateexception-error-inflating-class-android-webkit-webview/49024931#49024931" target="_blank" rel="noopener">https://stackoverflow.com/questions/41025200/android-view-inflateexception-error-inflating-class-android-webkit-webview/49024931#49024931</a><br>如果你升级1.1.0要谨慎。</p><p>好了，祝大家元气满满！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-在-Android-模拟器上运行-ARM-应用&quot;&gt;&lt;a href=&quot;#1-在-Android-模拟器上运行-ARM-应用&quot; class=&quot;headerlink&quot; title=&quot;1. 在 Android 模拟器上运行 ARM 应用&quot;&gt;&lt;/a&gt;1. 在 Android 模拟器上运行 ARM 应用&lt;/h3&gt;&lt;p&gt;这算是一个非常好的消息了，之前在实际应用开发中，因为模拟器缺少对 arm 的支持，基本上都使用真机进行开发与调试。&lt;br&gt;随着 Android 11预览版的发布&lt;br&gt;Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM 指令转换成 x86 指令。开发者无需搭建高负载的 ARM 环境即可执行 ARM 二进制文件并进行测试。&lt;/p&gt;
&lt;p&gt;详情：&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652052998&amp;idx=1&amp;sn=9839e5a74c1dba47123d6cb5da15c10f&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在 Android 模拟器上运行 ARM 应用&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-大厂对外文章分享&quot;&gt;&lt;a href=&quot;#2-大厂对外文章分享&quot; class=&quot;headerlink&quot; title=&quot;2. 大厂对外文章分享&quot;&gt;&lt;/a&gt;2. 大厂对外文章分享&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;携程技术&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;mid=2697269503&amp;idx=2&amp;sn=f5505724dcee64ebd9904ee16a2bfedb&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 携程Android 10适配踩坑指南&lt;/a&gt;&lt;br&gt;新版本适配一直是 Android 开发者的痛楚之一，但是这件事如果长期不升就会越来越困难。加上现在应用市场比较强势，所以保持一个较高的版本的适配是有必要的。&lt;br&gt;携程旅行分享了他们从API 26 到 29 的适配经验，大家可以参考一波。&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;mid=2697269484&amp;idx=1&amp;sn=1f5dcd45f90b2314050a04492e3a1cc0&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全网最详！暗黑模式在 Trip.com App 的实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;暗黑模式也最近的一个非常热门的话题，甚至微信支持暗黑模式都成为热点了。如果你对这方面感兴趣，或者刚好有暗黑实践的需求，那么可以看这一篇由携程 UED 团队+研发团队撰写的文章。&lt;br&gt;我个人其实一直没有体验过暗黑模式，毕竟没适配的 app 太多了，所以我不认为把手机切换为暗黑模式有很好的的体验…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google 开发者&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652052998&amp;idx=2&amp;sn=18715a7e33b7f7a5878bd301e9f8f935&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在 Android 开发中使用协程 | 背景介绍&lt;/a&gt;&lt;br&gt;可以看一下官方的文章了解下协程的一些背景知识，用来解决什么问题，如何解决，以及性能相关的一些知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节跳动技术团队&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247485583&amp;idx=1&amp;sn=a572862f110948673818d745cea5aea6&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;抖音包大小优化-资源优化&lt;/a&gt;&lt;br&gt;可以看下抖音团队为了减少 apk 的体积，针对资源这一方面做了哪些&lt;strong&gt;极致&lt;/strong&gt;的事情。&lt;br&gt;另外 apk 体积优化也可以看下 jsonchao 的文章：&lt;br&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650830257&amp;idx=1&amp;sn=f94eb0e05a1c40d5a99a7384b6f736ad&amp;chksm=80b7a12fb7c028395c18bc81f544bc4d893ca9829e7b702e079d973608bee3b6eb5a7d2c49ff&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;吹爆系列：深入探索Android包体积优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;百度 APP 技术&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&amp;mid=2247484032&amp;idx=1&amp;sn=da2740910b6df7d7f1ee9e2903f5ca27&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gradle 与 Android 构建入门&lt;/a&gt;&lt;br&gt;写了一篇 Gradle 构建入门的文章，其实很多同学都非常害怕 Gradle，这篇文章会给大家解释为什么需要 Gradle，以及 Gradle 相关的一些基础知识，帮你更好的了解相关知识，比较轻松，可以一看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;西瓜技术团队&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODczOQ==&amp;mid=2247483682&amp;idx=1&amp;sn=883435f1fe81295ec1c3ef6d576953c9&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AwCookieManager.nativeGetCookie crash 排查&lt;/a&gt;&lt;br&gt;分享了西瓜的一个CookieManager.getCookie(String url) 过程中的 native crash，分析过程较为复杂，不过给出了解决方案，解决方案涉及到 hook，西瓜用了自研的方案，开源的 lancet 应该也能做到，这篇文章也会提到 lancet。&lt;/p&gt;
    
    </summary>
    
      <category term="新技术" scheme="https://zhangmiao.cc/categories/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="新技术" scheme="https://zhangmiao.cc/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大厂对外分享" scheme="https://zhangmiao.cc/tags/%E5%A4%A7%E5%8E%82%E5%AF%B9%E5%A4%96%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>【新技术】又双叒叕来了系列二</title>
    <link href="https://zhangmiao.cc/posts/2e3f2830.html"/>
    <id>https://zhangmiao.cc/posts/2e3f2830.html</id>
    <published>2022-01-11T02:09:05.000Z</published>
    <updated>2022-01-12T05:49:35.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Android-开发者峰会一些资源"><a href="#1-Android-开发者峰会一些资源" class="headerlink" title="1. Android 开发者峰会一些资源"></a>1. Android 开发者峰会一些资源</h3><p>大家可以在 B 站看到所有的内容：</p><p><a href="https://space.bilibili.com/64169458/channel/detail?cid=91608" target="_blank" rel="noopener">https://space.bilibili.com/64169458/channel/detail?cid=91608</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111103513.png" alt></p><p>有个值得关注的是，官方回复了一些 Android 开发的问题：<br>一些新技术都有涉及，比如 ViewPager2 正式发布，关于 Camerax,Camera2,Camera1 之间如何选择，以及Kotlin，Jetpack Compose 相关问题。</p><a id="more"></a><p>我当时比较好奇的一个问题是这个：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111103354.png" alt></p><p>挺奇怪的，难道官方 app 会考虑只用一个 Activity 么？</p><p>详细的大家直接看这里：<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652052419&idx=2&sn=1e1722c4dc0689c2e55bbbc4022d3d44&scene=21#wechat_redirect" target="_blank" rel="noopener">Android 开发者峰会 2019 常见问题解答</a></p><h3 id="2-百度对外开源文章详情页-webview-recyclerview-一些原生控件联动效果"><a href="#2-百度对外开源文章详情页-webview-recyclerview-一些原生控件联动效果" class="headerlink" title="2. 百度对外开源文章详情页 webview+recyclerview+一些原生控件联动效果"></a>2. 百度对外开源文章详情页 webview+recyclerview+一些原生控件联动效果</h3><p><em><a href="https://github.com/baiduapp-tec/ELinkageScroll" target="_blank" rel="noopener">https://github.com/baiduapp-tec/ELinkageScroll</a></em></p><p>如果大家每篇推文都看的话，<a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650830056&idx=1&sn=82a49b57cfcecbc78d6eac31173a6418&chksm=80b7a076b7c02960a897d20513e0c0d99311a93c3b7a8a58712430343106cdb331767ecb07c1&scene=21#wechat_redirect" target="_blank" rel="noopener">这个库我上次已经专门介绍过啦</a>。</p><p>这个效果使用非常广，基本所有的资讯类 app 都有，感谢百度开源。</p><p>历史类似文章：<br><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650828127&idx=1&sn=a41f70febd47b9813fd124073028a5d1&chksm=80b7b9c1b7c030d707dbe8393bedec01e074c672014139715a36e273dcf232f71088eab4475c&scene=21#wechat_redirect" target="_blank" rel="noopener">大厂的文章详情页 WebView与 RecyclerView如何连贯滑动的？</a></p><p>另外感谢「this 蜗牛」这位朋友留言说道 QMUI也有这个效果，还后台给我发了个截图，我也给大家补充上，大家可以一起参考。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111103856.png" alt></p><p><em><a href="https://qmuiteam.com/android" target="_blank" rel="noopener">https://qmuiteam.com/android</a></em></p><p><em><a href="https://github.com/Tencent/QMUI_Android" target="_blank" rel="noopener">https://github.com/Tencent/QMUI_Android</a></em></p><p>之前的系列我也给大家推荐过 QMUI，这样的大厂出的类库还是可以关注下，尤其针对个人开发者，在快速迭代自己项目的时候还是很有用的。</p><h3 id="3-大厂对外文章分享"><a href="#3-大厂对外文章分享" class="headerlink" title="3. 大厂对外文章分享"></a>3. 大厂对外文章分享</h3><p><strong>百度 App 技术</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483964&idx=1&sn=fc5c4cd18e3564a237dff075bc055a3f&scene=21#wechat_redirect" target="_blank" rel="noopener">一种简单优雅的TextView行间距适配方案</a></p><p>以前用 TextView就怕UI 跟我们纠结行高，因为在 Android 里面没有一个非常明确的 lineHeight 概念，百度这边分享了自己的解决方案，还是学到了一些新知识的，文章中提到的LineHeightSpan我之前就不知道，还是学到了。</p><p>方案对于中文的支持还是很不错的，值得借鉴。<br><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483952&idx=1&sn=da440dcb3da286969c13fc9a9f3f1223&scene=21#wechat_redirect" target="_blank" rel="noopener">Android 10分区存储介绍及百度APP适配实践</a><br>这个就不用介绍了吧，标题很清晰。</p><p><strong>字节跳动技术团队</strong></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247493879&idx=1&sn=653ac0a8d0e33cc3faea6659b25d0398&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485530&idx=1&sn=c6f92a614829215d13aec273cbd1022a&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%（二）</a></p><p>介绍了抖音团队自研的一个针对 4.x 级以下机型对于 MultiDex 的优化。<br>目前还没有开源，大家可以了解下原理，后续开源我也会周知大家的。<br>此外相关知识也可以学习下：<br>Android 一种在Dalvik虚拟机上多Dex加载优化的方案<br><a href="https://blog.csdn.net/sbsujjbcy/article/details/53381663" target="_blank" rel="noopener">https://blog.csdn.net/sbsujjbcy/article/details/53381663</a></p><p><strong>Google 开发者</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652052515&idx=1&sn=f10b5a01d889214a760b721cd195489f&scene=21#wechat_redirect" target="_blank" rel="noopener">Room 中的数据库关系</a><br>对于 Room 使用者，如果你对 1 对 1，1 对N，N 对 N 不知道如何处理的可以学习下。</p><p>历史分享(点击可直接访问)：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580200&idx=1&sn=c663d8be4628d74efb20aee09f1cc743&scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯Bugly:对字符串匹配算法的一点理解</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247485203&idx=1&sn=26fd99ca1201e292ea5531c814eeb881&scene=21#wechat_redirect" target="_blank" rel="noopener">爱奇艺：安卓APP崩溃捕获方案——xCrash</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485042&idx=1&sn=fe32711dbcb483f7a47dfa0e304087c4&scene=21#wechat_redirect" target="_blank" rel="noopener">字节跳动：深入理解Gradle框架之一：</a><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485042&idx=1&sn=fe32711dbcb483f7a47dfa0e304087c4&scene=21#wechat_redirect" target="_blank" rel="noopener">Plugin, Extension, buildSrc</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483745&idx=1&sn=59bf0c9bc5b584d411880617cf32f795&scene=21&token=1556389437&lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">百度APP技术：Android H5首屏优化实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE2NzIzMg==&mid=2247487670&idx=1&sn=952e44c0ce8890b27b0115a1974cc431&scene=21#wechat_redirect" target="_blank" rel="noopener">京东技术：任意URL跳转漏洞修复与JDK中getHost()方法之间的坑</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483789&idx=1&sn=f3843b9ce282ab7d4e3c6225d780f9cd&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483804&idx=1&sn=026f386cc88d07044735cde5206c1de0&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483815&idx=1&sn=c3872d2e1b86d6eb48b8665fbf6f6fa4&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝 App 构建优化解析：Android 包大小极致压缩</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==&mid=2247484874&idx=1&sn=bc0f92ccb6d1b7c6be6bc535ac491cd7&scene=21#wechat_redirect" target="_blank" rel="noopener">搜狐：深入理解Flutter多线程</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697268363&idx=1&sn=3db2dce36a912936961c671dd1f71c78&scene=21#wechat_redirect" target="_blank" rel="noopener">携程：从智行 Android 项目看组件化架构实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652049096&idx=1&sn=dc9d0a408d07d78d487974354fd5dee7&scene=21#wechat_redirect" target="_blank" rel="noopener">Google: Flutter 您需要知道的知识点 | FAQ・第三期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484937&idx=1&sn=144003c8c662eebbdd71d7a9617e3439&chksm=e9d0cdebdea744fd3f413d3667590479bb5c4e52d628d44b37807a761be6415f3b4e5c40d554&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">字节跳动：二维码扫描优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247483887&idx=1&sn=d54e3f210a4f31f477dba06c3dcd352e&scene=21#wechat_redirect" target="_blank" rel="noopener">网易传媒技术团队：AOP技术在客户端的应用与实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247483939&idx=1&sn=aa170d606c7de063a0d587aa4da1fc91&scene=21#wechat_redirect" target="_blank" rel="noopener">网易大数据|互联网产品决策秘笈: AB测试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzIwMDM5Ng==&mid=2247483750&idx=1&sn=8ba37d6b8a073c3a0fbb0dcc10b00175&scene=21#wechat_redirect" target="_blank" rel="noopener">高德：Android Native 内存泄漏系统化解决方案</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTU3MTE4NQ==&mid=2247484444&idx=1&sn=2c4c8fa957df258003c4fcfe63df3a59&chksm=ea591302dd2e9a14aebb553e3af14fa12d239dd76ef01b3855bb5b9f2a3196b42e829ce8d504&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">例说 Constraint Layout（三）—— 性能测试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTU3MTE4NQ==&mid=2247484411&idx=1&sn=f8cd93a994080a31cfdb58bda9f5dc75&chksm=ea5914e5dd2e9df35cfe04b066eefc9b876faa074569f45a5320a28c5b0031d8cad282bacdf3&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">Android P之Smart Linkif</a>y</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483830&idx=1&sn=a158b07ca3fe6a4ef8ff89d4f5b682aa&scene=21#wechat_redirect" target="_blank" rel="noopener">百度App组件化之路</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483844&idx=1&sn=59e434f601cc4ae5a3970e8751662fd2&scene=21#wechat_redirect" target="_blank" rel="noopener">百度App网络深度优化系列《三》弱网优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485061&idx=1&sn=7c935aecbb9b558e4d5d9dd2c3eb7f96&scene=21#wechat_redirect" target="_blank" rel="noopener">头条 | 深入理解gradle框架之二：依赖实现分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750945&idx=2&sn=4c0f9c59498610ea1ce9744b8b35e61a&scene=21#wechat_redirect" target="_blank" rel="noopener">美团| Probe：Android线上OOM问题定位组件</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750923&idx=1&sn=1044e16dddeda4e7a6daaadfe9637f75&scene=21#wechat_redirect" target="_blank" rel="noopener">美团|Android静态代码扫描效率优化与实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485301&idx=1&sn=eadc3d5ebfebe32c354dcd4529cd86c5&scene=21#wechat_redirect" target="_blank" rel="noopener">头条| 开源 | Scene：Android 开源页面导航和组合框架</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247484258&idx=1&sn=558555cefa7ac495b66c31dd201b1c1c&scene=21#wechat_redirect" target="_blank" rel="noopener">网易新闻客户端 H5 秒开优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mzc2Nzg1MQ==&mid=2247483669&idx=1&sn=35fcd1aeefe52bdfbae9ce37fb56cee2&scene=21#wechat_redirect" target="_blank" rel="noopener">解决支付宝包体积优化的遗留问题：</a><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mzc2Nzg1MQ==&mid=2247483669&idx=1&sn=35fcd1aeefe52bdfbae9ce37fb56cee2&scene=21#wechat_redirect" target="_blank" rel="noopener">运行时获取dexpc</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247485891&idx=1&sn=f97a596399977e5ca61333ed5d359466&scene=21#wechat_redirect" target="_blank" rel="noopener">Android篇 | 爱奇艺App启动优化实践分享</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247486037&idx=2&sn=7f095d5daceb7ecc4b70983aab410d43&scene=21#wechat_redirect" target="_blank" rel="noopener">二维码扫描优化及爱奇艺App的实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580237&idx=1&sn=de8ec4404964a46995048e2b49556b7a&scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTk0ODUxOQ==&mid=2247483782&idx=1&sn=f9eae167b217c83036b3a24cd4182cd1&scene=21#wechat_redirect" target="_blank" rel="noopener">天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDIwODQ0Mw==&mid=2247483996&idx=1&sn=585369f542e084a4857145f5793e2b9f&scene=21#wechat_redirect" target="_blank" rel="noopener">花椒Android端自动化测试实践</a></li></ul><h3 id="4-Github-找-Android-项目姿势"><a href="#4-Github-找-Android-项目姿势" class="headerlink" title="4. Github 找 Android 项目姿势"></a>4. Github 找 Android 项目姿势</h3><p>上次有同学留言问我怎么在 Github 找 Android项目，大家能想到的肯定是看 trending:<br><a href="https://github.com/trending/java" target="_blank" rel="noopener">https://github.com/trending/java</a></p><p>不过现在能上 trending 的 Android 项目太少了，毕竟和 Java 项目在一个分类。<br>其实 Github 有主题的概念，直接选择 Android 主题就可以了：<br><a href="https://github.com/topics/android" target="_blank" rel="noopener">https://github.com/topics/android</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111104421.png" alt><br>可以看到有9W+项目。</p><p>也可以按条件筛选：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111104509.png" alt></p><h3 id="5-一些Android-逆向-攻防-相关的话题"><a href="#5-一些Android-逆向-攻防-相关的话题" class="headerlink" title="5. 一些Android 逆向*攻防*相关的话题"></a>5. 一些Android 逆向*<em>攻防*</em>相关的话题</h3><p>有这么一个仓库：<br><a href="https://github.com/Hack-with-Github/Awesome-Hacking" target="_blank" rel="noopener">https://github.com/Hack-with-Github/Awesome-Hacking</a><br>看名字大家就知道介绍啥了，是一个安全相关的仓库汇总，里面包含了太多的子项目，例如有些工具不知道在哪下载，在这里面很好找：<br><a href="https://github.com/carpedm20/awesome-hacking" target="_blank" rel="noopener">https://github.com/carpedm20/awesome-hacking</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111104734.png" alt></p><h3 id="6-播报一些最近发现更新的开源库"><a href="#6-播报一些最近发现更新的开源库" class="headerlink" title="6. 播报一些最近发现更新的开源库"></a>6. 播报一些最近发现更新的开源库</h3><p><strong>LeakCanary 不再使用 haha</strong><br>我们熟悉的 LeakCanary 已经<strong>不再使用之前的 haha 做内存分析，换成了自研的 Shark</strong>。<br><a href="https://square.github.io/leakcanary/shark/" target="_blank" rel="noopener">https://square.github.io/leakcanary/shark/</a></p><p><strong>RxJava 已经更新了 3.0.0 版本</strong><br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">https://github.com/ReactiveX/RxJava</a><br>不过 Retrofit2 暂时还无法使用 RxJava3，因为相关 Adapter 库还未适配 RxJava3。</p><p>好了，祝大家元气满满！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Android-开发者峰会一些资源&quot;&gt;&lt;a href=&quot;#1-Android-开发者峰会一些资源&quot; class=&quot;headerlink&quot; title=&quot;1. Android 开发者峰会一些资源&quot;&gt;&lt;/a&gt;1. Android 开发者峰会一些资源&lt;/h3&gt;&lt;p&gt;大家可以在 B 站看到所有的内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://space.bilibili.com/64169458/channel/detail?cid=91608&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://space.bilibili.com/64169458/channel/detail?cid=91608&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111103513.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;有个值得关注的是，官方回复了一些 Android 开发的问题：&lt;br&gt;一些新技术都有涉及，比如 ViewPager2 正式发布，关于 Camerax,Camera2,Camera1 之间如何选择，以及Kotlin，Jetpack Compose 相关问题。&lt;/p&gt;
    
    </summary>
    
      <category term="新技术" scheme="https://zhangmiao.cc/categories/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="新技术" scheme="https://zhangmiao.cc/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大厂对外分享" scheme="https://zhangmiao.cc/tags/%E5%A4%A7%E5%8E%82%E5%AF%B9%E5%A4%96%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>【新技术】又双叒叕来了系列一</title>
    <link href="https://zhangmiao.cc/posts/3eabe808.html"/>
    <id>https://zhangmiao.cc/posts/3eabe808.html</id>
    <published>2022-01-10T03:22:32.000Z</published>
    <updated>2022-01-10T03:45:56.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些中文独立博客分享"><a href="#一些中文独立博客分享" class="headerlink" title="一些中文独立博客分享"></a>一些中文独立博客分享</h3><p>目前随着移动端的兴起，早期的很多中文 PC 博客已经很少有人去阅读了，也很难被大家所发现。</p><p>因为我之前关注一个小伙的创业实验，比较好奇他最终会不会成功，也好奇他的灵感，他的下一个产品是一个中文博客相关的 RSS 产品。</p><p>所以他收集了一波中文博客列表，推荐给大家：</p><p><a href="https://github.com/timqian/chinese-independent-blogs" target="_blank" rel="noopener">https://github.com/timqian/chinese-independent-blogs</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220110113859.png" alt></p><p>大概有 300 多位中文博客列表，偶尔读一些这上面的文章，应该还是能激发不少灵感的。</p><p>其实如果这些独立博客数量够多，可以聚合起来，做一个阅读 app，支持订阅也是不错的。</p><a id="more"></a><h3 id="官方发布的代码检索工具"><a href="#官方发布的代码检索工具" class="headerlink" title="官方发布的代码检索工具"></a>官方发布的代码检索工具</h3><p>实际使用起来，实在太好用了，强烈推荐下。</p><p>注意：需要网络良好。</p><p><a href="https://cs.android.com/" target="_blank" rel="noopener">https://cs.android.com/</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220110114308.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220110114357.png" alt></p><p>其他一些在线源码阅读工具：</p><p><a href="https://www.androidos.net.cn/sourcecode" target="_blank" rel="noopener">https://www.androidos.net.cn/sourcecode</a></p><p><a href="http://aospxref.com/" target="_blank" rel="noopener">http://aospxref.com/</a></p><h3 id="字节跳动开源一系列插件"><a href="#字节跳动开源一系列插件" class="headerlink" title="字节跳动开源一系列插件"></a>字节跳动开源一系列插件</h3><p><a href="https://github.com/bytedance/ByteX" target="_blank" rel="noopener">https://github.com/bytedance/ByteX</a></p><p>基本都是编译时字节码相关的，目前应用于多款字节跳动产品上。</p><ul><li>access-inline-plugin（access方法内联）</li><li>shrink-r-plugin（R文件瘦身和无用资源检查）</li><li>closeable-check-plugin（文件流的close检查）</li><li>const-inline-plugin（常量内联）</li><li>field-assign-opt-plugin（优化多余赋值指令）</li><li>getter-setter-inline-plugin （getter和setter方法内联）</li><li>method-call-opt-plugin（干净地删除某些方法调用，如Log.d）</li><li>coverage-plugin（线上代码覆盖率）</li><li>refer-check-plugin（检查是否有调用不存在的方法和引用不存在的字段）</li><li>serialization-check-plugin（序列化检查）</li><li>SourceFileKiller（删除SourceFile和行号属性）</li></ul><p>一方面这个可以接入，做一些产品上的安全、优化。</p><p>另一方面是学习的好资料，如果都能看明白，AS 的 Transform 和字节码算是已经玩转了。</p><p>相关的开源项目就是滴滴的 booster:</p><p><a href="https://github.com/didi/booster" target="_blank" rel="noopener">https://github.com/didi/booster</a></p><h3 id="大厂对外分享"><a href="#大厂对外分享" class="headerlink" title="大厂对外分享"></a>大厂对外分享</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247486037&idx=2&sn=7f095d5daceb7ecc4b70983aab410d43&scene=21#wechat_redirect" target="_blank" rel="noopener">1. 二维码扫描优化及爱奇艺App的实践</a></p><p>说了一些方案，实践还是之前字节跳动给出的方案更适合：</p><p>字节跳动：<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484937&idx=1&sn=144003c8c662eebbdd71d7a9617e3439&chksm=e9d0cdebdea744fd3f413d3667590479bb5c4e52d628d44b37807a761be6415f3b4e5c40d554&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">二维码扫描优化</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580237&idx=1&sn=de8ec4404964a46995048e2b49556b7a&scene=21#wechat_redirect" target="_blank" rel="noopener">2. 腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用</a></p><p>动态下发 so库，是减少 apk 体积非常明显的一个方案，之前在百度的时候，也搞过这样的方案，一度是瘦身黑科技，当然坑也不少，so 这玩意搞不好崩溃就比较多，如果需要可以参考目前一些插件化方案、热修方案去做。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTk0ODUxOQ==&mid=2247483782&idx=1&sn=f9eae167b217c83036b3a24cd4182cd1&scene=21#wechat_redirect" target="_blank" rel="noopener">3. 天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析）</a></p><p>恩…技术文章还是很赞的。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDIwODQ0Mw==&mid=2247483996&idx=1&sn=585369f542e084a4857145f5793e2b9f&scene=21#wechat_redirect" target="_blank" rel="noopener">4. 花椒Android端自动化测试实践</a></p><p>Android 测试一直被忽略，我也没有太多这方面涉猎，当然还是值得了解下。</p><p>好了，祝大家元气满满！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一些中文独立博客分享&quot;&gt;&lt;a href=&quot;#一些中文独立博客分享&quot; class=&quot;headerlink&quot; title=&quot;一些中文独立博客分享&quot;&gt;&lt;/a&gt;一些中文独立博客分享&lt;/h3&gt;&lt;p&gt;目前随着移动端的兴起，早期的很多中文 PC 博客已经很少有人去阅读了，也很难被大家所发现。&lt;/p&gt;
&lt;p&gt;因为我之前关注一个小伙的创业实验，比较好奇他最终会不会成功，也好奇他的灵感，他的下一个产品是一个中文博客相关的 RSS 产品。&lt;/p&gt;
&lt;p&gt;所以他收集了一波中文博客列表，推荐给大家：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/timqian/chinese-independent-blogs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/timqian/chinese-independent-blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220110113859.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;大概有 300 多位中文博客列表，偶尔读一些这上面的文章，应该还是能激发不少灵感的。&lt;/p&gt;
&lt;p&gt;其实如果这些独立博客数量够多，可以聚合起来，做一个阅读 app，支持订阅也是不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="新技术" scheme="https://zhangmiao.cc/categories/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="新技术" scheme="https://zhangmiao.cc/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大厂对外分享" scheme="https://zhangmiao.cc/tags/%E5%A4%A7%E5%8E%82%E5%AF%B9%E5%A4%96%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>《老大不小》观后感</title>
    <link href="https://zhangmiao.cc/posts/e984f211.html"/>
    <id>https://zhangmiao.cc/posts/e984f211.html</id>
    <published>2022-01-01T04:01:28.000Z</published>
    <updated>2022-01-01T04:23:59.462Z</updated>
    
    <content type="html"><![CDATA[<p>电影里对自己感触最深的一句话是爸爸在病床上对他大儿子雷子说的：‘’我走了，我对小硕一百个放心，他有个沟沟坎坎的，还有你这个哥，可是，大磊子，我走了你还有谁啊？‘’</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101120439.png" alt></p><a id="more"></a><p>再有两年就奔三了，自己一直北漂在外，爸妈身体一直是自己比较担心的，总是把最好的都给我们，他们自己的毛病只是不经常跟做儿女的说。陪伴家人的时间也是屈指可数，自己不是一个称职的儿子，只希望自己努力的脚步能超越父母慢慢变老的速度。</p><p>就像剧里的爸爸忍着胃癌晚期的疼痛不让家里的孩子知道一样，用生命在为自己的儿子铺路，存下了那两张银行卡。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121150.png" alt></p><p>真正戳到我泪点的是弟弟写给哥哥的那封说不出口的些话，再叛逆的孩子内心深处都存在着最真挚、最纯粹的感情，只是有些时候不会表达出来，比如父亲病床桌子上的一杯水；早上喂了父亲生前总喂的猫。其实生活中真的有好多情感难以用语言表达出来，但是我们彼此都真诚，都愿意付出。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121320.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121338.png" alt></p><p>关于哥哥的友情和爱情。他能有一个真正不离不弃的好哥们，在他需要的时候挺身而出，真的挺幸运的。包括兄弟说的那句话“有的人是靠脸活着，而有的人是为了脸活着。”</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121401.png" alt></p><p>成年人的世界可能就是这样吧，有生活的重担连恋爱的勇气都没有，但最后他俩在一起真的很开心。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121435.png" alt></p><p>整体而言看完这部电影，</p><p>不是职业的电影评论。</p><p>可以说这部电影制作很成功了。</p><p>一个没有上过大学的哥哥，一个青春期叛逆的弟弟，和一个为了家努力的父亲。</p><p>成年人的世界，没有容易二字，每个人都有压力，哥哥觉得弟弟不争气，去跟已故的父亲聊聊天，收拾收拾心情还是再次回到家。</p><p>弟弟从最初的不表达爱和不接受这些爱，变成了一个懂事的孩子，每个孩子年少的时候都会经历叛逆时候。后来也会发现，当初是有多么不懂事。</p><p>弟弟打那个孩子，错了么？没错，对了么？不对。以前打架是发泄情绪，现在打架是打钱，挺好一句话，现在孩子看了可以想一想，打那个架为了什么？</p><p>整个剧可以说环环相扣，从最初哥哥每天都给那个流浪汉钱，是傻么？只是活的乐观而已。</p><p>弟弟逃学打游戏，没有光为了打游戏，打游戏得的奖品也去送给了父亲，唯一一个过错就是没有当着面叫他一声爸。</p><p>哥哥只要点点头，就能得到一份挣钱的工作，但是他没有，他活着要着一张脸，可以通过自己的努力去挣这个钱，但不想靠感情来挣这个钱。</p><p>一个简单的故事，很温暖，源于生活。</p><p>里面有句话挺好，有人是靠脸活着，有人为了脸活着。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电影里对自己感触最深的一句话是爸爸在病床上对他大儿子雷子说的：‘’我走了，我对小硕一百个放心，他有个沟沟坎坎的，还有你这个哥，可是，大磊子，我走了你还有谁啊？‘’&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101120439.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>十个思维方式如何改变我的人生</title>
    <link href="https://zhangmiao.cc/posts/bdeaaf0.html"/>
    <id>https://zhangmiao.cc/posts/bdeaaf0.html</id>
    <published>2021-12-22T09:50:39.000Z</published>
    <updated>2021-12-24T02:05:30.003Z</updated>
    
    <content type="html"><![CDATA[<p>1、你不需要是个天才，才有资格分享知识——《Show Your Work》<br>2、除了目标，还要关注实现目标的体系，享受提升自我的过程<br>3、1%定律：每天提升1%——《Atomic Habits》<br>4、多样化收入来源<br>5、你觉得很普通的事情，在别人看来可能会很了不起——《Anything You Want》<br>6、每日重点：梳理待办事项的优先级——《Make Time》<br>7、勇敢去做：不一定要遵循既定规则去过人生——《Do What You Can’t》<br>8、家庭、个人、工作的平衡——《平衡的智慧》<br>9、找个人谈谈心——《你当像鸟飞往你的山》、《也许你该找人聊聊》<br>10、成功的公式——Y2b：Ali Abdaal</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、你不需要是个天才，才有资格分享知识——《Show Your Work》&lt;br&gt;2、除了目标，还要关注实现目标的体系，享受提升自我的过程&lt;br&gt;3、1%定律：每天提升1%——《Atomic Habits》&lt;br&gt;4、多样化收入来源&lt;br&gt;5、你觉得很普通的事情，在别人看来可能会很了不起——《Anything You Want》&lt;br&gt;6、每日重点：梳理待办事项的优先级——《Make Time》&lt;br&gt;7、勇敢去做：不一定要遵循既定规则去过人生——《Do What You Can’t》&lt;br&gt;8、家庭、个人、工作的平衡——《平衡的智慧》&lt;br&gt;9、找个人谈谈心——《你当像鸟飞往你的山》、《也许你该找人聊聊》&lt;br&gt;10、成功的公式——Y2b：Ali Abdaal&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 2.8 发布 | 性能及工具链优化、Firebase 功能、WebView 3.0</title>
    <link href="https://zhangmiao.cc/posts/7916835e.html"/>
    <id>https://zhangmiao.cc/posts/7916835e.html</id>
    <published>2021-12-13T03:16:13.000Z</published>
    <updated>2021-12-24T02:05:30.003Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213111841.png" alt></p><blockquote><p>官方发布说明：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fwhats-new-in-flutter-2-8-d085b763d181" target="_blank" rel="noopener">medium.com/flutter/wha…</a></p></blockquote><p>北半球的冬意已至，黄叶与气温均随风而落，而年终的最后一个稳定版本已悄然来到你的面前。 让我们向 <strong>Flutter 2.8</strong> 打声招呼～ 本次更新包含了 <strong>207 位贡献者和 178 位审核者</strong> 的辛勤劳作， 所有人共同产出了 <strong>2424 个 PR</strong>，关闭了 <strong>2976 个 issue</strong>。 在此特别感谢本次发布中最突出的社区贡献者：来自 Very Good Ventures 的 Flutter 开发工程师 Bartosz Selwesiuk， 他专注于 Web 平台的 camera 插件并提交了 23 个 PR。</p><p>以上的所有产出让 Flutter engine 和 DevTools 都有了非常显著的性能提升， 同时带来的还有 <strong>Google 移动端广告 SDK Flutter 版本的稳定版发布、 一系列针对 Firebase 的新功能和优化、Flutter WebView 3.0、 新的 Flutter Favorite package、向桌面端 Stable 迈出的一大步， 以及支持更多 package 的新版本 DartPad</strong>。 虽然这是今年最后一个稳定版本，但它并不是最不重要的。让我们一起来看看！</p><a id="more"></a><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>Flutter 的首要目标是一如既往地保证其质量。 我们花费了大量时间以确保 Flutter 在多种多样的设备上都能流畅且稳定地运行。</p><h3 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h3><p>本次更新优化了应用启动的延迟。 我们在拥有一百万行以上的代码量的 GPay 应用上进行了测试，以确保改动在实际生产的应用上有效。 这些改动将 GPay <strong>在低端 Android 设备上启动的时间减少了约 50%，高端设备上减少了约 10%</strong>。</p><p>我们对 Flutter 调用 Dart VM 的 GC 策略也做了一些改进，以此避免在程序启动期间出现不合时宜的 GC。 例如，在 Android 设备上渲染出第一帧前，Flutter <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F90551" target="_blank" rel="noopener">仅在 <code>TRIM_LEVEL_RUNNING_CRITYCAL</code> 及高于其等级的信号出现时，通知 Dart VM 有内存压力</a> 。 在本地测试中，<strong>低端 Android 设备的初始帧出现间隔时间最多减少了约 300ms</strong>。</p><p>在先前的 Flutter 版本中， <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29145%23pullrequestreview-778935616" target="_blank" rel="noopener">出于谨慎考虑</a> ， 在创建 PlatformView 时会阻塞平台线程。 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F91711" target="_blank" rel="noopener">在经过仔细的推理和测试后</a> ， 我们删除了部分序列化的步骤，使得 GPay <strong>在低端设备上的启动时间至少减少了 100ms</strong>。</p><p>长久以来，在初始化首个 Dart isolate 前初始化默认的字体管理器会引入人为的延迟。 由于它是首要的延迟瓶颈，所以 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29291" target="_blank" rel="noopener">将默认字体管理器的初始化延迟</a> 到与首个 Dart isolate 同时运行，降低了启动的延迟，并让上述的所有启动优化的表现更加明显。</p><h3 id="应用内存"><a href="#应用内存" class="headerlink" title="应用内存"></a>应用内存</h3><p>由于 Flutter 会尽可能快地加载 Dart VM 的服务 isolate， 并将其和绑定在应用内的 AOT 代码一并加载到内存中， 这会导致 Flutter 开发人员在部分内存 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F91382" target="_blank" rel="noopener">有限制的设备上难以追踪内存指标</a> 。 在 Flutter 2.8 版本中，Android 设备上 Dart VM 的服务 isolate <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29245" target="_blank" rel="noopener">已被拆分至单独的 bundle 中</a> ， 可以单独加载，减少了在其加载前约 40MB 的内存使用。 原本 Dart VM 向操作系统发送 AOT 程序的内存用量的通知， 已转由一个无需多次读取的文件支持，后续的内存占用量进一步减少了约 10%。 因此，先前保存了文件数据拷贝的内存可以回收并用于其他用途。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>某些场景下，开发者希望能同时看到 Flutter 和 Android 的性能追踪事件， 又或者是在生产模式下查看追踪事件来更好地了解应用的性能问题。 为了这一需求，Flutter 2.8 现在可以选择在应用启动后， 将性能追踪事件发送至 Android 的事件记录器，在生产模式下也同样如此。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113455.png" alt></p><p>此外，一些开发人员想要更多的关于光栅缓存行为的性能跟踪信息， 以减少制作动画效果时的卡顿，这允许 Flutter 快速地对昂贵的、重复使用的图片进行复用而不是重新绘制。 性能跟踪中的新的 <strong>流事件</strong>让开发人员可以跟踪光栅缓存图片的生命周期。</p><h3 id="Flutter-DevTools"><a href="#Flutter-DevTools" class="headerlink" title="Flutter DevTools"></a>Flutter DevTools</h3><p>对于调试性能问题，新版的 DevTools 添加了一个新的「增强跟踪」功能， 用来帮助开发者诊断消耗较大的构建、布局和绘制操作引起的 UI 卡顿。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113531.png" alt></p><p>启用任何一个追踪功能后，时间轴中将视情况展示 Widget 的构建、RenderObject 布局和 RenderObject 绘制的事件。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113633.png" alt></p><p>此外，新版的 DevTools 增加了应用程序启动性能的分析支持。 该配置文件包含从 Dart VM 初始化到第一个 Flutter 帧渲染的 CPU 样本。 在你按下「Profile app start up」按钮并加载应用程序启动配置文件后， 你将看到为配置文件选择了「AppStartUp」用户标签。 你还可以通过在可用用户标签列表中选择此用户标签过滤器（如果存在）来加载应用程序启动配置文件。 选择此标签会显示你的应用程序启动的个人资料数据。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113719.png" alt></p><h3 id="Web-平台的平台视图-PlatformView"><a href="#Web-平台的平台视图-PlatformView" class="headerlink" title="Web 平台的平台视图 (PlatformView)"></a>Web 平台的平台视图 (PlatformView)</h3><p>不仅仅是 Android 和 iOS 平台获得了性能提升，本次发布同时包含了对 Flutter Web 平台视图的性能优化。 平台视图是从宿主平台向 Flutter 嵌入 UI 组件的媒介。 Flutter Web 使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fapi.flutter-io.cn%2Fflutter%2Fwidgets%2FHtmlElementView-class.html" target="_blank" rel="noopener"><code>HtmlElementView</code></a> widget 实现了这一功能，让你能在 Flutter Web 应用中嵌入 HTML 元素。 如果你正在使用 google_maps_flutter 插件或 video_player 插件的网络版本， 或者你正在遵循 Flutter 团队关于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fdevelopment%2Fplatform-integration%2Fweb-images%23use-img-in-a-platform-view" target="_blank" rel="noopener">如何优化网络上显示图像</a> 的建议，那么你正在使用平台视图。</p><p>在之前版本的 Flutter 中，嵌入平台视图会创建一个新的 canvas，每嵌入一个平台视图都会新增一个 canvas。 创建额外的 canvas 是十分消耗性能的操作，因为每个 canvas 的大小都与整个窗口相等。 在 Flutter 2.8 中，将 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F28087" target="_blank" rel="noopener">复用为先前的平台视图创建的 canvas</a> ， 因此，你不会在应用程序的整个生命周期内产生每秒 60 倍的成本，而是只有一次创建的成本。 这意味着你可以在 Web 应用程序中拥有多个 <code>HtmlElementView</code> 实例而不会降低性能， 同时还可以减少使用平台视图时的滚动卡顿。</p><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><p>Flutter 不仅仅是框架、引擎和工具——pub.dev 上现有超过 2w 个与 Flutter 兼容的包和插件，而且每天都在增加。 Flutter 开发人员大量的日常操作也是庞大的生态系统的一部分， 所以让我们来看看自上一个版本以来 Flutter 生态系统中有什么改变。</p><h3 id="适用于-Flutter-广告的-Google-广告"><a href="#适用于-Flutter-广告的-Google-广告" class="headerlink" title="适用于 Flutter 广告的 Google 广告"></a>适用于 Flutter 广告的 Google 广告</h3><p>首先也是最重要的是， <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fannouncing-general-availability-for-the-google-mobile-ads-sdk-for-flutter-574e51ea6783" target="_blank" rel="noopener">Google Mobile SDK for Flutter 已于 11 月正式发布</a> 。 此版本支持 5 种广告格式，集成了 AdMob 和 Ad Manager 支持， 并包含一个新的中转功能的测试版，可以帮助你优化广告展现的效果。 有关将 Google Ads 集成到 Flutter 应用程序以及其他货币化选项的更多信息， 请查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fmonetization" target="_blank" rel="noopener">flutter.dev 上的页面</a> 。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113810.png" alt></p><h3 id="WebView-3-0"><a href="#WebView-3-0" class="headerlink" title="WebView 3.0"></a>WebView 3.0</h3><p>这次 Flutter 附带的另一个新版本是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fwebview_flutter" target="_blank" rel="noopener">webview_flutter 插件</a> 的 3.0 版本。 因为新功能的数量增加，我们提升了主要版本号，但也因为 Web 视图在 Android 上的工作方式可能发生了重大变化。 在之前的 <code>webview_flutter</code> 版本中，Hybrid composition 已经可用，但不是默认的。 而现在它修复了先前默认以虚拟显示模式运行的许多问题。 根据用户反馈和我们的问题跟踪，我们认为是时候让 Hybrid composition 成为默认设置了。 此外，<code>webview_flutter</code> 还增加了一些呼声极高的功能：</p><ul><li>支持使用 POST 和 GET 来加载内容</li><li>加载文件或字符串内容为 HTML</li><li>支持透明背景</li><li>在加载内容前设置 Cookies</li></ul><p>此外，在 3.0 版本中，<code>webview_flutter</code> 为新平台提供了初步支持：Flutter Web。 已经有很多人要求能够在 Flutter Web 应用程序中托管 Web 视图， 这允许开发者利用单个源代码库构建移动或 Web 应用程序。 在 Flutter Web 应用程序中托管 Web 视图是什么样的？ 从编写代码的角度来看，其实是一样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/foundation.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:webview_flutter/webview_flutter.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:webview_flutter_web/webview_flutter_web.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(<span class="keyword">const</span> MaterialApp(home: HomePage()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HomePage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;HomePage&gt; createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// required while web support is in preview</span></span><br><span class="line">    <span class="keyword">if</span> (kIsWeb) WebView.platform = WebWebViewPlatform();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">    appBar: AppBar(title: <span class="keyword">const</span> Text(<span class="string">'Flutter WebView example'</span>)),</span><br><span class="line">    body: <span class="keyword">const</span> WebView(initialUrl: <span class="string">'https://flutter.dev'</span>),</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Flutter Web 上运行时，它会按你的预期工作：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113920.png" alt></p><p>请注意，当前 <code>webview_flutter</code> 的 web 实现有许多限制，因为它是使用 iframe 构建的， iframe 仅支持简单的 URL 加载，无法控制加载的内容或与加载的内容交互。 但是，由于需求呼声太高，我们决定将 webview_flutter_web 作为未经认可的插件提供。 如果你想尝试一下，请将以下内容添加到你的 pubspec.yaml 中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  webview_flutter:</span> <span class="string">^3.0.0</span></span><br><span class="line"><span class="attr">  webview_flutter_web:</span> <span class="string">^0.1.0</span> <span class="comment"># 显式依赖未经认可的插件</span></span><br></pre></td></tr></table></figure><p>如果你对 webview_flutter v3.0 有任何反馈，无论是否是关于 Web 平台， 请<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues" target="_blank" rel="noopener">将问题记录在 Flutter 仓库中</a> 。 此外，如果你之前没有使用过 webview 或者你想复习一下， 请查看<a href="https://link.juejin.cn?target=https%3A%2F%2Fcodelabs.developers.google.com%2Fcodelabs%2Fflutter-webview" target="_blank" rel="noopener">新的 webview codelab</a> ， 它将带你逐步完成在 Flutter 应用程序中托管 web 内容的过程。</p><h3 id="Flutter-Favorites"><a href="#Flutter-Favorites" class="headerlink" title="Flutter Favorites"></a>Flutter Favorites</h3><p>Flutter 生态系统委员会再次召开会议，将以下 package 指定为 Flutter Favorite 的 package：</p><ul><li>新路由 API（又名 Navigator 2）的三个自定义路由 package： <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fbeamer" target="_blank" rel="noopener">beamer</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Froutemaster" target="_blank" rel="noopener">routemaster</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fgo_router" target="_blank" rel="noopener">go_router</a> ；</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fdrift" target="_blank" rel="noopener">drift</a> ， 对 Flutter 和 Dart 已经功能强大且流行的响应式持久性库的重命名，基于 sqlite 构建；</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Ffreezed" target="_blank" rel="noopener">freezed</a> ， 一个 Dart「语言补丁」，为定义模型、克隆对象、模式匹配等提供简单的语法；</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fdart_code_metrics" target="_blank" rel="noopener">dart_code_metrics</a> ；</li><li>以及有着漂亮界面的 package： <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fflex_color_scheme" target="_blank" rel="noopener">flex_color_scheme</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fflutter_svg" target="_blank" rel="noopener">flutter_svg</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Ffeedback" target="_blank" rel="noopener">feedback</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Ftoggle_switch" target="_blank" rel="noopener">toggle_switch</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fauto_size_text" target="_blank" rel="noopener">auto_size_text</a> 。</li></ul><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114109.png" alt></p><p>祝贺这些 package 的作者，并感谢你通过你的辛勤工作支持 Flutter 社区。 如果你有兴趣提名你最喜欢的 Flutter 包加入 Flutter Favorite 嘉奖， 请按照 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fdevelopment%2Fpackages-and-plugins%2Ffavorites" target="_blank" rel="noopener">Flutter Favorite 计划页面</a> 上的指南和说明进行操作。</p><h3 id="特定平台的插件-plugin-package"><a href="#特定平台的插件-plugin-package" class="headerlink" title="特定平台的插件 (plugin package)"></a>特定平台的插件 (plugin package)</h3><p>如果你是插件作者，你必须决定你将支持哪些平台。 如果你正在使用特定于平台的原生代码构建插件， 你可以 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fdevelopment%2Fpackages-and-plugins%2Fdeveloping-packages%23plugin-platforms" target="_blank" rel="noopener">使用项目 pubspec.yaml 中的 pluginClass 属性</a> 来实现，该属性将指定提供原生功能的原生类名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  plugin:</span></span><br><span class="line"><span class="attr">    platforms:</span></span><br><span class="line"><span class="attr">      android:</span></span><br><span class="line"><span class="attr">        package:</span> <span class="string">com.example.hello</span></span><br><span class="line"><span class="attr">        pluginClass:</span> <span class="string">HelloPlugin</span></span><br><span class="line"><span class="attr">      ios:</span></span><br><span class="line"><span class="attr">        pluginClass:</span> <span class="string">HelloPlugin</span></span><br></pre></td></tr></table></figure><p>然而，随着 Dart FFI 变得更加成熟，有可能使用 100% 的 Dart 实现特定平台的功能， 就像 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fpath_provider_windows" target="_blank" rel="noopener">path_provider_windows package</a> 所做的那样。在这种情况下，你没有任何本地类可以使用， 但你仍然希望将你的包指定为仅支持某些平台。 此时你可以改用 dartPluginClass 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  plugin:</span></span><br><span class="line"><span class="attr">    implements:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    platforms:</span></span><br><span class="line"><span class="attr">      windows:</span></span><br><span class="line"><span class="attr">        dartPluginClass:</span> <span class="string">HelloPluginWindows</span></span><br></pre></td></tr></table></figure><p>经过这样的设置后，即使你没有任何本机代码，也可以为特定平台定制插件。 你还必须提供 Dart 插件的类， 有关详细内容，你可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fdevelopment%2Fpackages-and-plugins%2Fdeveloping-packages%23dart-only-platform-implementations" target="_blank" rel="noopener">flutter.dev 上的仅 Dart 平台实现文档</a> 中进行扩展阅读。</p><h2 id="桌面平台"><a href="#桌面平台" class="headerlink" title="桌面平台"></a>桌面平台</h2><p>Flutter 2.8 版本在 Windows、macOS 和 Linux 稳定版本的道路上又迈出了一大步。 我们的目标质量标准很高，包括国际化和本地化支持， 例如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29620" target="_blank" rel="noopener">新的中文输入法支持</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F24713" target="_blank" rel="noopener">韩语输入法支持</a> 以及刚刚合并的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29761" target="_blank" rel="noopener">Kanji（日文）输入法</a> 支持。 或者，就像我们在紧密构建 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F77838" target="_blank" rel="noopener">Windows 辅助功能的支持</a> 一样。 对于 Flutter 来说，在 Stable 渠道的 desktop 上运行是不够的， 它必须在世界各地的语言和文化以及不同能力的设备上运行良好。 我们还没有达到我们想要的目标，但未来可期！</p><p>其中一个例子是我们重构了 Flutter 处理键盘事件以允许同步响应的架构。 这使 widget 能够处理按键并拦截它在整个 widget tree 中的其余部分中的传递。 我们在 Flutter 2.5 中完成了这项工作的落地，并在 Flutter 2.8 中修复了许多问题。 这是对我们如何处理特定于设备的键盘输入的方式的重新设计， 和重构 Flutter 处理文本编辑方式的持续工作的补充， 所有这些都是用键盘这样输入密集型的桌面应用程序所必需的。</p><p>此外，我们还在继续 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F89353" target="_blank" rel="noopener">向 Flutter 扩展视觉密度的定义</a> ， 暴露对话框对齐方式的设置，以便开发者可以实现更加友好的桌面 UI。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114157.png" alt></p><p>最后，Flutter 团队并不是唯一一个在为了 Flutter desktop 付出心血的团队。 举个例子，Canonical 的桌面团队正在与 Invertase 合作， 在 Linux 和 Windows 上开发最流行的 Flutter Firebase 插件。</p><p>你可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Finvertase.io%2Fblog%2Fannouncing-flutterfire-desktop" target="_blank" rel="noopener">Invertase 博客上</a> 阅读有关预览版的更多信息。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114223.png" alt></p><h2 id="DartPad"><a href="#DartPad" class="headerlink" title="DartPad"></a>DartPad</h2><p>如果没有工具的改进，那么这个 Flutter 新版本的发布是不完整的。 我们将重点介绍 DartPad 的改进，其中最大的改进是对更多软件包的支持。 事实上，目前共有 23 个 package 可供导入使用。除了几个 Firebase 服务之外，该列表还包括诸如 bloc、characters、collection、google_fonts 和 flutter_riverpod 等流行的 package。 DartPad 团队会继续添加新的 package，如果你想查看当前支持哪些软件包，可以单击右下角的信息图标。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114247.png" alt></p><p>如果你想了解随着时间的推移向 DartPad 添加新包的计划， 请查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdart-lang%2Fdart-pad%2Fwiki%2FAdding-support-for-a-new-package" target="_blank" rel="noopener">Dart wiki 上的这篇文章</a> 。 还有另一个新的 DartPad 功能也非常方便。 在此之前，DartPad 总是以运行最新的 stable 版本运行。 在新版本中，你可以使用状态栏中新的 <strong>渠道菜单</strong> 来切换最新的 Beta 渠道版本以及之前的 stable 版本（称为“旧渠道”）。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114312.png" alt></p><p>如果你正在撰写一篇博客文章，而最新的稳定版本还不够新，这将非常有用。 （其实方便了切换不同的渠道进行调试和 BUG 验证。）</p><h2 id="移除-Dev-渠道"><a href="#移除-Dev-渠道" class="headerlink" title="移除 Dev 渠道"></a>移除 Dev 渠道</h2><p>Flutter「渠道」决定了 Flutter 框架和引擎在你的开发机器上变化的速度， stable 代表最少的变更，而 master 代表最多。 受到团队资源的限制，我们最近将停止更新 dev 渠道。 虽然我们确实收到了一些相关的问题，但我们发现只有不到 3% 的 Flutter 开发人员使用 dev 渠道。 因此，我们决定启动正式停用 dev 渠道的进程。 虽然很少有开发人员使用 dev 渠道，但 Flutter 工程师需要花费大量时间和精力来维护它。 如果你将所有时间都花在 stable 渠道上（正如超过 90% 的 Flutter 开发人员所做的那样）， 那么这项改动将不会影响你的日常开发。 通过放弃它，你可以少做一个决定，而 Flutter 团队可以将时间和精力花在其他事情上。 你可以使用 <code>flutter channel</code> 命令来决定你想要哪个渠道。 以下是 Flutter 团队对每个渠道的看法：</p><ul><li><strong>Stable 渠道</strong> 代表我们拥有的最高质量的构建。它们每季度（大致）发布一次，并针对中间的关键问题进行热修复。 这是「慢」通道：安全、成熟、长期服务。</li><li><strong>Beta 渠道</strong> 为那些习惯于更快节奏的开发者提供了一种快速调整的替代方案。 目前每月发布，发布前稳定。这是「快速」通道。如果 dev 渠道正在满足 beta 渠道无法满足的需求， 我们可能会改变我们对 beta 渠道的看法来满足这些需求 （例如，加速发布 beta 的节奏或降低我们对 beta 执行的测试和热修复级别）。</li><li><strong>Master 渠道</strong> 是我们活跃的开发渠道。我们不提供对该渠道的支持，但我们针对它运行了一套全面的单元测试。 对于对不稳定的构建感到满意的贡献者或高级开发者而言，这是适合他们的渠道。 在这个频道上，我们跑得很快，打破了一些东西（然后会很快地修复它们）。</li></ul><p>当我们在未来几个月停用 dev 渠道时，请考虑使用 beta 或 master 渠道， 这取决于你对变更的容忍度以及你对最新和最好的 SDK 的平衡点。</p><h2 id="破坏性更改"><a href="#破坏性更改" class="headerlink" title="破坏性更改"></a>破坏性更改</h2><p>与往常一样，我们努力减少每个版本中破坏性更改的数量。 在此版本中，Flutter 2.8 除了已过期并根据我们的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fwiki%2FTree-hygiene%23handling-breaking-changes" target="_blank" rel="noopener">重大变更政策</a> 被删除的已弃用 API 之外，没有重大变更。</p><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90292" target="_blank" rel="noopener">90292</a> Remove autovalidate deprecations</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90293" target="_blank" rel="noopener">90293</a> Remove FloatingHeaderSnapConfiguration.vsync  deprecation</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90294" target="_blank" rel="noopener">90294</a> Remove AndroidViewController.id deprecation</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90295" target="_blank" rel="noopener">90295</a> Remove BottomNavigationBarItem.title deprecation</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90296" target="_blank" rel="noopener">90296</a> Remove deprecated text input formatting classes</li></ul><p>如果你仍在使用这些 API 并想了解如何迁移代码，你可以阅读 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Frelease%2Fbreaking-changes%2F2-5-deprecations" target="_blank" rel="noopener">flutter.dev 上的迁移指南</a> 。 与往常一样，非常感谢社区 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Ftests%2Fblob%2Fmaster%2FREADME.md" target="_blank" rel="noopener">贡献了测试用例</a> ， 帮助我们识别这些重大更改。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我们结束 2021 年并展望 2022 年之际，Flutter 团队要对整个 Flutter 社区的工作和支持表示感谢。 诚然，我们正在为世界上越来越多的开发人员构建 Flutter， 但如果没有你和每位开发者的存在，我们也无法维护并构建它。 Flutter 社区与众不同，我们感谢你所做的一切。 祝你假期愉快，我们新的一年见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213111841.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官方发布说明：&lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fwhats-new-in-flutter-2-8-d085b763d181&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;medium.com/flutter/wha…&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;北半球的冬意已至，黄叶与气温均随风而落，而年终的最后一个稳定版本已悄然来到你的面前。 让我们向 &lt;strong&gt;Flutter 2.8&lt;/strong&gt; 打声招呼～ 本次更新包含了 &lt;strong&gt;207 位贡献者和 178 位审核者&lt;/strong&gt; 的辛勤劳作， 所有人共同产出了 &lt;strong&gt;2424 个 PR&lt;/strong&gt;，关闭了 &lt;strong&gt;2976 个 issue&lt;/strong&gt;。 在此特别感谢本次发布中最突出的社区贡献者：来自 Very Good Ventures 的 Flutter 开发工程师 Bartosz Selwesiuk， 他专注于 Web 平台的 camera 插件并提交了 23 个 PR。&lt;/p&gt;
&lt;p&gt;以上的所有产出让 Flutter engine 和 DevTools 都有了非常显著的性能提升， 同时带来的还有 &lt;strong&gt;Google 移动端广告 SDK Flutter 版本的稳定版发布、 一系列针对 Firebase 的新功能和优化、Flutter WebView 3.0、 新的 Flutter Favorite package、向桌面端 Stable 迈出的一大步， 以及支持更多 package 的新版本 DartPad&lt;/strong&gt;。 虽然这是今年最后一个稳定版本，但它并不是最不重要的。让我们一起来看看！&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose 入门学习</title>
    <link href="https://zhangmiao.cc/posts/7b2baf2a.html"/>
    <id>https://zhangmiao.cc/posts/7b2baf2a.html</id>
    <published>2021-11-15T03:40:42.000Z</published>
    <updated>2021-12-24T02:05:30.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Jetpack Compose：利用声明式编程构建Android原生界面（UI）的 工具包</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>更少的代码、代码量锐减</li><li>强大的工具/组件支持</li><li>直观的 Kotlin API</li><li>简单易用</li></ul><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><ul><li><p><strong>声明性编程范式</strong>：声明性的函数构建一个简单的界面组件，无需修改任何 XML 布局，也不需要使用布局编辑器，只需要调用 Jetpack Compose 函数来声明想要的元素，Compose 编译器即会完成后面的所有工作。</p></li><li><p><strong>简单的组合函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  Text(text = <span class="string">"Hello <span class="variable">$name</span>!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115115340.png" alt></p></li><li><p><strong>声明性范式转变</strong>：在 Compose 的声明性方法中，微件相对无状态，并且不提供 setter 或 getter 函数。实际上，微件不会以对象形式提供。您可以通过调用带有不同参数的同一可组合函数来更新界面。这使得向架构模式（如 ViewModel）提供状态变得很容易，如应用架构指南中所述。然后，可组合项负责在每次可观察数据更新时将当前应用状态转换为界面。</p></li><li><p><strong>动态</strong> ：组合函数是用 Kotlin 而不是 XML 编写</p></li><li><p><strong>重组</strong>：在 Compose 中，您可以使用新数据再次调用可组合函数。这样做会导致函数进行重组 – 系统会根据需要使用新数据重新绘制函数发出的微件。Compose 框架可以智能地仅重组已更改的组件。</p><ul><li>可组合函数可以按任何顺序执行</li><li>可组合函数可以并行运行</li><li>重组会跳过尽可能多的内容</li><li>重组是乐观的操作</li><li>可组合函数可能会非常频繁地运行</li></ul></li></ul><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li><p>Arctic Fox 2020-3-1 版本以上，<a href="https://developer.android.com/studio" target="_blank" rel="noopener">下载最新AndroidStudio</a><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115145212.png" alt></p></li><li><p>ComposeApp仅支持Kotlin 最低sdk 版本为21，Android 5.0<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115145308.png" alt></p></li><li><p>Gradle Compose相关依赖</p>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">   id <span class="string">'com.android.application'</span></span><br><span class="line">   id <span class="string">'kotlin-android'</span></span><br><span class="line">&#125;</span><br><span class="line">android &#123;</span><br><span class="line">   compileSdk <span class="number">31</span></span><br><span class="line"></span><br><span class="line">   defaultConfig &#123;</span><br><span class="line">       applicationId <span class="string">"com.zm.myjetpackcompose"</span></span><br><span class="line">       minSdk <span class="number">21</span></span><br><span class="line">       targetSdk <span class="number">31</span></span><br><span class="line">       versionCode <span class="number">1</span></span><br><span class="line">       versionName <span class="string">"1.0"</span></span><br><span class="line">   </span><br><span class="line">       testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">       vectorDrawables &#123;</span><br><span class="line">           useSupportLibrary <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   buildTypes &#123;</span><br><span class="line">       release &#123;</span><br><span class="line">           minifyEnabled <span class="literal">false</span></span><br><span class="line">           proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   compileOptions &#123;</span><br><span class="line">       sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">       targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">   &#125;</span><br><span class="line">   kotlinOptions &#123;</span><br><span class="line">       jvmTarget = <span class="string">'1.8'</span></span><br><span class="line">       useIR = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   buildFeatures &#123;</span><br><span class="line">       compose <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   composeOptions &#123;</span><br><span class="line">       kotlinCompilerExtensionVersion compose_version</span><br><span class="line">       kotlinCompilerVersion <span class="string">'1.5.21'</span></span><br><span class="line">   &#125;</span><br><span class="line">   packagingOptions &#123;</span><br><span class="line">       resources &#123;</span><br><span class="line">           excludes += <span class="string">'/META-INF/&#123;AL2.0,LGPL2.1&#125;'</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">   implementation <span class="string">'androidx.core:core-ktx:1.3.2'</span></span><br><span class="line">   implementation <span class="string">'androidx.appcompat:appcompat:1.2.0'</span></span><br><span class="line">   implementation <span class="string">'com.google.android.material:material:1.3.0'</span></span><br><span class="line">   implementation <span class="string">"androidx.compose.ui:ui:$compose_version"</span></span><br><span class="line">   implementation <span class="string">"androidx.compose.material:material:$compose_version"</span></span><br><span class="line">   implementation <span class="string">"androidx.compose.ui:ui-tooling-preview:$compose_version"</span></span><br><span class="line">   implementation <span class="string">'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1'</span></span><br><span class="line">   implementation <span class="string">'androidx.activity:activity-compose:1.3.0-alpha06'</span></span><br><span class="line">   testImplementation <span class="string">'junit:junit:4.+'</span></span><br><span class="line">   androidTestImplementation <span class="string">'androidx.test.ext:junit:1.1.2'</span></span><br><span class="line">   androidTestImplementation <span class="string">'androidx.test.espresso:espresso-core:3.3.0'</span></span><br><span class="line">   androidTestImplementation <span class="string">"androidx.compose.ui:ui-test-junit4:$compose_version"</span></span><br><span class="line">   debugImplementation <span class="string">"androidx.compose.ui:ui-tooling:$compose_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要安装最新Java11， java 8 环境会报以下错误</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8.</span><br><span class="line">    You can try some of the following options:</span><br><span class="line">      - changing the IDE settings.</span><br><span class="line">      - changing the JAVA_HOME environment variable.</span><br><span class="line">      - changing `org.gradle.java.home` in `gradle.properties`.</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115150103.png" alt></p></li><li><p>@Preview生效，则环境正常<br>  <img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115150241.png" alt></p></li></ul><h2 id="UI布局"><a href="#UI布局" class="headerlink" title="UI布局"></a>UI布局</h2><h3 id="Compose"><a href="#Compose" class="headerlink" title="@Compose"></a>@Compose</h3><p>所有关于构建View的方法都必须添加<code>@Compose</code>注解才可以。并且<code>@Compose</code>协程的<code>Suspend</code>的使用方法比较类似,被<code>@Compose</code>注解的方法只能在同样被<code>@Comopse</code>解的方法中才能被调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Text(text = <span class="string">"Hello <span class="variable">$name</span>!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preview"><a href="#Preview" class="headerlink" title="@Preview"></a>@Preview</h3><p><code>@Preview</code>注解的方法可以在不运行App的情况下就可以确认布局的情况。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115153114.png" alt><br>常用的参数:</p><ul><li><code>name</code>: String: 为该Preview命名，该名字会在布局预览中显示。</li><li><code>showBackground</code>: Boolean: 是否显示背景，true为显示。</li><li><code>backgroundColor</code>: Long: 设置背景的颜色。</li><li><code>showDecoration</code>: Boolean: 是否显示Statusbar和Toolbar，true为显示。</li><li><code>group</code>: String: 为该Preview设置group名字，可以在UI中以group为单位显示。</li><li><code>fontScale</code>: Float: 可以在预览中对字体放大，范围是从0.01。</li><li><code>widthDp</code>: Int: 在Compose中渲染的最大宽度，单位为dp。</li><li><code>heightDp</code>: Int: 在Compose中渲染的最大高度，单位为dp。<br>上面的参数都是可选参数，还有像背景设置等的参数并不是对实际的App进行设置，只是对Preview中的背景进行设置，为了更容易看清布局。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true,name = <span class="meta-string">"Text UI"</span>,backgroundColor = 0xFF888888)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">DefaultPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyJetpackComposeTheme &#123;</span><br><span class="line">        Greeting(<span class="string">"Android"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="setContent"><a href="#setContent" class="headerlink" title="setContent"></a>setContent</h3><p>setContent的作用是和Layout/View中的setContentView是一样的。<br>setContent的方法也是有@Compose注解的方法。所以，在setContent中写入关于UI的@Compopse方法，即可在Activity中显示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            MyJetpackComposeTheme &#123;</span><br><span class="line">                <span class="comment">// A surface container using the 'background' color from the theme</span></span><br><span class="line">                Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class="line">                    Greeting(<span class="string">"Android"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><p>在创建新的Compose项目时会自动创建一个Theme.kt文件。 我们可以通过更改颜色来完成对主题颜色的设置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zm.myjetpackcompose.ui.theme</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.isSystemInDarkTheme</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.MaterialTheme</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.darkColors</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.lightColors</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Composable</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> DarkColorPalette = darkColors(</span><br><span class="line">    primary = Purple200,</span><br><span class="line">    primaryVariant = Purple700,</span><br><span class="line">    secondary = Teal200</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> LightColorPalette = lightColors(</span><br><span class="line">    primary = Purple500,</span><br><span class="line">    primaryVariant = Purple700,</span><br><span class="line">    secondary = Teal200</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Other default colors to override</span></span><br><span class="line"><span class="comment">    background = Color.White,</span></span><br><span class="line"><span class="comment">    surface = Color.White,</span></span><br><span class="line"><span class="comment">    onPrimary = Color.White,</span></span><br><span class="line"><span class="comment">    onSecondary = Color.Black,</span></span><br><span class="line"><span class="comment">    onBackground = Color.Black,</span></span><br><span class="line"><span class="comment">    onSurface = Color.Black,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyJetpackComposeTheme</span><span class="params">(darkTheme: <span class="type">Boolean</span> = isSystemInDarkTheme()</span></span>, content: <span class="meta">@Composable()</span> () -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> colors = <span class="keyword">if</span> (darkTheme) &#123;</span><br><span class="line">        DarkColorPalette</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LightColorPalette</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaterialTheme(</span><br><span class="line">        colors = colors,</span><br><span class="line">        typography = Typography,</span><br><span class="line">        shapes = Shapes,</span><br><span class="line">        content = content</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h3><p><a href="https://developer.android.com/jetpack/compose/modifiers-list" target="_blank" rel="noopener">Modifier</a>是各个Compose的UI组件一定会用到的一个类。它是被用于设置UI的摆放位置，padding等信息的类。</p><h4 id="padding-设置各个UI的padding"><a href="#padding-设置各个UI的padding" class="headerlink" title="padding 设置各个UI的padding"></a>padding 设置各个UI的padding</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Modifier.padding(<span class="number">10.</span>dp) <span class="comment">// 给上下左右设置成同一个值</span></span><br><span class="line">Modifier.padding(<span class="number">10.</span>dp, <span class="number">11.</span>dp, <span class="number">12.</span>dp, <span class="number">13.</span>dp) <span class="comment">// 分别为上下左右设值</span></span><br><span class="line">Modifier.padding(<span class="number">10.</span>dp, <span class="number">11.</span>dp) <span class="comment">// 分别为上下和左右设值</span></span><br><span class="line">Modifier.padding(InnerPadding(<span class="number">10.</span>dp, <span class="number">11.</span>dp, <span class="number">12.</span>dp, <span class="number">13.</span>dp))<span class="comment">// 分别为上下左右设值</span></span><br></pre></td></tr></table></figure><h4 id="plus-可以把其他的Modifier加入到当前的Modifier中。"><a href="#plus-可以把其他的Modifier加入到当前的Modifier中。" class="headerlink" title="plus 可以把其他的Modifier加入到当前的Modifier中。"></a>plus 可以把其他的Modifier加入到当前的Modifier中。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modifier.plus(otherModifier) <span class="comment">// 把otherModifier的信息加入到现有的modifier中</span></span><br></pre></td></tr></table></figure><h4 id="fillMaxHeight、fillMaxWidth、fillMaxSize-类似于match-parent、填充整个父layout。"><a href="#fillMaxHeight、fillMaxWidth、fillMaxSize-类似于match-parent、填充整个父layout。" class="headerlink" title="fillMaxHeight、fillMaxWidth、fillMaxSize 类似于match_parent、填充整个父layout。"></a>fillMaxHeight、fillMaxWidth、fillMaxSize 类似于match_parent、填充整个父layout。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modifier.fillMaxHeight() <span class="comment">// 填充整个高度</span></span><br></pre></td></tr></table></figure><h4 id="width、heigh、size-设置Content的宽度和高度。"><a href="#width、heigh、size-设置Content的宽度和高度。" class="headerlink" title="width、heigh、size 设置Content的宽度和高度。"></a>width、heigh、size 设置Content的宽度和高度。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modifier.width(<span class="number">2.</span>dp) <span class="comment">// 设置宽度</span></span><br><span class="line">Modifier.height(<span class="number">3.</span>dp)  <span class="comment">// 设置高度</span></span><br><span class="line">Modifier.size(<span class="number">4.</span>dp, <span class="number">5.</span>dp) <span class="comment">// 设置高度和宽度 复制代码</span></span><br></pre></td></tr></table></figure><h4 id="widthIn-heightIn-sizeIn-设置Content的宽度和高度的最大值和最小值。"><a href="#widthIn-heightIn-sizeIn-设置Content的宽度和高度的最大值和最小值。" class="headerlink" title="widthIn, heightIn, sizeIn 设置Content的宽度和高度的最大值和最小值。"></a>widthIn, heightIn, sizeIn 设置Content的宽度和高度的最大值和最小值。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modifier.widthIn(<span class="number">2.</span>dp) <span class="comment">// 设置最大宽度</span></span><br><span class="line">Modifier.heightIn(<span class="number">3.</span>dp) <span class="comment">// 设置最大高度</span></span><br><span class="line">Modifier.sizeIn(<span class="number">4.</span>dp, <span class="number">5.</span>dp, <span class="number">6.</span>dp, <span class="number">7.</span>dp) <span class="comment">// 设置最大最小的宽度和高度</span></span><br></pre></td></tr></table></figure><h4 id="gravity-在Column中元素的位置。"><a href="#gravity-在Column中元素的位置。" class="headerlink" title="gravity 在Column中元素的位置。"></a>gravity 在Column中元素的位置。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modifier.gravity(Alignment.CenterHorizontally) <span class="comment">// 横向居中</span></span><br><span class="line">Modifier.gravity(Alignment.Start) <span class="comment">// 横向居左</span></span><br><span class="line">Modifier.gravity(Alignment.End) <span class="comment">// 横向居右</span></span><br></pre></td></tr></table></figure><h4 id="rtl、ltr-开始布局UI的方向。"><a href="#rtl、ltr-开始布局UI的方向。" class="headerlink" title="rtl、ltr 开始布局UI的方向。"></a>rtl、ltr 开始布局UI的方向。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Modifier.rtl  <span class="comment">// 从右到左</span></span><br><span class="line">Modifier.ltr  <span class="comment">// 从左到右</span></span><br><span class="line"></span><br><span class="line">Modifier的方法都返回Modifier的实例的链式调用，所以只要连续调用想要使用的方法即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"> Text(text = <span class="string">"Hello <span class="variable">$name</span>!"</span>, modifier = Modifier.padding(<span class="number">20.</span>dp).fillMaxSize())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Column，Row"><a href="#Column，Row" class="headerlink" title="Column，Row"></a>Column，Row</h3><blockquote><p>Column 线性布局 ≈ Android LinearLayout-VERTICAL<br>Row 水平布局 ≈ Android LinearLayout-HORIZONTAL</p></blockquote><p>Column和Row可以理解为在View/Layout体系中的纵向和横向的ViewGroup。</p><ul><li>Modifier 用上述的方法传入已经按需求设置好的Modifier即可。</li><li>Arrangement.Horizontal, Arrangement.Vertical 需要给Row传入Arrangement.Horizontal，为Column传入Arrangement.Vertical。 这些值决定如何布置内部UI组件。<br>可传入的值为Center, Start, End, SpaceEvenly, SpaceBetween, SpaceAround。</li><li>Alignment.Vertical, Alignment.Horizontal 需要给Row传入Alignment.Vertical，为Column传入Alignment.Horizontal。 使用方法和Modifier的gravity中传入参数的用法是一样的.</li><li>@Composable ColumnScope.() -&gt; Unit 需要传入标有@Compose的UI方法。但是这里我们会有lamda函数的写法来实现。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Column &#123;</span><br><span class="line">        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceAround, verticalAlignment = Alignment.CenterVertically) &#123;</span><br><span class="line">            Text(text = <span class="string">"Hello <span class="variable">$name</span>!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h3><p>帧布局≈Android FrameLayout，可将一个元素放在另一个元素上，如需在 Row 中设置子项的位置，请设置 horizontalArrangement 和 verticalAlignment 参数。对于 Column，请设置 verticalArrangement 和 horizontalAlignment 参数</p><h3 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h3><p>需要引入<code>implementation &quot;androidx.constraintlayout:constraintlayout-compose:1.0.0-beta02&quot;</code></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li><p>可以滚动的布局</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们可以使用 verticalScroll() 修饰符使 Column 可滚动，但以上布局并无法实现重用，可能导致性能问题</span></span><br><span class="line">   Column(</span><br><span class="line">       modifier = Modifier.verticalScroll(rememberScrollState())</span><br><span class="line">   ) &#123;</span><br><span class="line">       messages.forEach &#123; message -&gt;</span><br><span class="line">           MessageRow(message)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>LazyColumn/LazyRow == RecylerView/listView 列表布局，解决了滚动时的性能问题，LazyColumn和LazyRow之间的区别就在于它们的列表项布局和滚动方向不同。</p><ul><li>内边距   <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LazyColumn(</span><br><span class="line">      contentPadding = PaddingValues(horizontal = <span class="number">16.</span>dp, vertical = <span class="number">8.</span>dp),</span><br><span class="line">  ) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>item间距</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LazyColumn(</span><br><span class="line">     verticalArrangement = Arrangement.spacedBy(<span class="number">4.</span>dp),</span><br><span class="line"> ) &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>浮动列表的浮动标题，使用 LazyColumn 实现粘性标题，可以使用stickyHeader()函数</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">ListWithHeader</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">Item</span>&gt;)</span></span> &#123;</span><br><span class="line">     LazyColumn &#123;</span><br><span class="line">         stickyHeader &#123;</span><br><span class="line">             Header()</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         items(items) &#123; item -&gt;</span><br><span class="line">             ItemRow(item)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>网格布局LazyVerticalGrid</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">PhotoGrid</span><span class="params">(photos: <span class="type">List</span>&lt;<span class="type">Photo</span>&gt;)</span></span> &#123;</span><br><span class="line">    LazyVerticalGrid(</span><br><span class="line">        cells = GridCells.Adaptive(minSize = <span class="number">128.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        items(photos) &#123; photo -&gt;</span><br><span class="line">            PhotoItem(photo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h3><h4 id="通过重组基础布局实现"><a href="#通过重组基础布局实现" class="headerlink" title="通过重组基础布局实现"></a>通过重组基础布局实现</h4><h4 id="Canvas绘制"><a href="#Canvas绘制" class="headerlink" title="Canvas绘制"></a>Canvas绘制</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Canvas(modifier = Modifier.fillMaxSize()) &#123;</span><br><span class="line">        <span class="keyword">val</span> canvasWidth = size.width</span><br><span class="line">        <span class="keyword">val</span> canvasHeight = size.height</span><br><span class="line">        <span class="comment">//drawCircle 画圆</span></span><br><span class="line">        <span class="comment">//drawRectangle 画矩形</span></span><br><span class="line">        <span class="comment">//drawLine //画线</span></span><br><span class="line">        drawCircle(</span><br><span class="line">            color = Color.DarkGray,</span><br><span class="line">            center = Offset(x = canvasWidth / <span class="number">2</span>, y = canvasHeight / <span class="number">2</span>),</span><br><span class="line">            radius = size.minDimension / <span class="number">4</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115161558.png" alt></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li><code>Compose</code>整体来看，布局实现上相对于xml更加简单高效，也是官方日后力推的开发方式。</li><li><code>Compose</code>写法与<code>Flutter</code>代码上有很高的相似之处，都是通过响应式的快速搭建UI布局。<br>（PS：响应式的UI开发模式在大前端的各个语言中越来越相似了）</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/jetpack/compose" target="_blank" rel="noopener">https://developer.android.com/jetpack/compose</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Jetpack Compose：利用声明式编程构建Android原生界面（UI）的 工具包&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;更少的代码、代码量锐减&lt;/li&gt;
&lt;li&gt;强大的工具/组件支持&lt;/li&gt;
&lt;li&gt;直观的 Kotlin API&lt;/li&gt;
&lt;li&gt;简单易用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;编程思想&quot;&gt;&lt;a href=&quot;#编程思想&quot; class=&quot;headerlink&quot; title=&quot;编程思想&quot;&gt;&lt;/a&gt;编程思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;声明性编程范式&lt;/strong&gt;：声明性的函数构建一个简单的界面组件，无需修改任何 XML 布局，也不需要使用布局编辑器，只需要调用 Jetpack Compose 函数来声明想要的元素，Compose 编译器即会完成后面的所有工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;简单的组合函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Composable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Greeting&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Text(text = &lt;span class=&quot;string&quot;&gt;&quot;Hello &lt;span class=&quot;variable&quot;&gt;$name&lt;/span&gt;!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115115340.png&quot; alt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;声明性范式转变&lt;/strong&gt;：在 Compose 的声明性方法中，微件相对无状态，并且不提供 setter 或 getter 函数。实际上，微件不会以对象形式提供。您可以通过调用带有不同参数的同一可组合函数来更新界面。这使得向架构模式（如 ViewModel）提供状态变得很容易，如应用架构指南中所述。然后，可组合项负责在每次可观察数据更新时将当前应用状态转换为界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态&lt;/strong&gt; ：组合函数是用 Kotlin 而不是 XML 编写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;重组&lt;/strong&gt;：在 Compose 中，您可以使用新数据再次调用可组合函数。这样做会导致函数进行重组 – 系统会根据需要使用新数据重新绘制函数发出的微件。Compose 框架可以智能地仅重组已更改的组件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可组合函数可以按任何顺序执行&lt;/li&gt;
&lt;li&gt;可组合函数可以并行运行&lt;/li&gt;
&lt;li&gt;重组会跳过尽可能多的内容&lt;/li&gt;
&lt;li&gt;重组是乐观的操作&lt;/li&gt;
&lt;li&gt;可组合函数可能会非常频繁地运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Jetpack" scheme="https://zhangmiao.cc/categories/Android/Jetpack/"/>
    
    
      <category term="Kotlin" scheme="https://zhangmiao.cc/tags/Kotlin/"/>
    
      <category term="Jetpack" scheme="https://zhangmiao.cc/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Alfred进阶教程，自定义Workflows</title>
    <link href="https://zhangmiao.cc/posts/fa126efb.html"/>
    <id>https://zhangmiao.cc/posts/fa126efb.html</id>
    <published>2021-11-08T08:25:42.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://zhangmiao.cc/posts/d083e6c8.html">《Mac装机必备-Alfred的基础使用教程》</a>中，已为大家介绍了Alfred的基础功能。其实除了Alfred已有的功能外，Alfred还支持用户自定义工作流。</p><p>通过设置好触发器、输入、操作、实用程序、输出，就可以自由搭建工作流。在本教程中，我将创建一个简单的热键工作流，用来一键启动我每天多次使用的一些应用程序和网页。</p><p>进入Alfred的偏好设置中的<em>workflows*标签页，点击左下角的“</em>+<em>”，然后选择</em>Templates &gt; Files and Apps &gt; Launch file group from hotkey*，创建一个用热键打开的工作流。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108163119.png" alt></p><a id="more"></a><p>然后为你的工作流编辑名称、图标等信息，便于识别。（图标可以直接拖入）</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108165131.png" alt></p><p>编辑完成后，点击右下角的Save即可创建出一个名为work的工作流。左边图标是热键，右边图标是你要创建的动作。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108165131.png" alt></p><p>双击左边图标，打开热键设置窗口，选中输入框，直接在键盘上键入你想要设置的热键，然后保存。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108165216.png" alt></p><p>双击右侧图标，打开动作设置窗口，你可以选择一次启动多个Mac软件或文件夹，比如我想要一次打开AndroidStudio、Safari、Sourcetree三个应用程序，直接将它们拖入此窗口即可。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108170007.png" alt></p><p>Alfred除了能设置打开多个Mac软件外，还可以设置打开多个网页。比如我们想同时打开马可菠萝网站，可以在窗口任意位置右键，选择Actions &gt; Open URL。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108170352.png" alt></p><p>在弹窗中将马可菠萝的网址 <a href="https://zhangmiao.cc/">https://zhangmiao.cc/</a> 复制粘贴进去，并选好默认浏览器，保存即可。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108170432.png" alt></p><p>最后再把这个新的动作链接到热键的后面，即完成打开马可菠萝网站的设置了。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108170809.png" alt></p><p>了解Alfred的工作流程，能够帮助你轻松完成各种重复任务，让你以前所未有的方式在Mac上提高效率！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇&lt;a href=&quot;https://zhangmiao.cc/posts/d083e6c8.html&quot;&gt;《Mac装机必备-Alfred的基础使用教程》&lt;/a&gt;中，已为大家介绍了Alfred的基础功能。其实除了Alfred已有的功能外，Alfred还支持用户自定义工作流。&lt;/p&gt;
&lt;p&gt;通过设置好触发器、输入、操作、实用程序、输出，就可以自由搭建工作流。在本教程中，我将创建一个简单的热键工作流，用来一键启动我每天多次使用的一些应用程序和网页。&lt;/p&gt;
&lt;p&gt;进入Alfred的偏好设置中的&lt;em&gt;workflows*标签页，点击左下角的“&lt;/em&gt;+&lt;em&gt;”，然后选择&lt;/em&gt;Templates &amp;gt; Files and Apps &amp;gt; Launch file group from hotkey*，创建一个用热键打开的工作流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108163119.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://zhangmiao.cc/categories/Mac/"/>
    
      <category term="Alfred" scheme="https://zhangmiao.cc/categories/Mac/Alfred/"/>
    
    
      <category term="Mac" scheme="https://zhangmiao.cc/tags/Mac/"/>
    
      <category term="Alfred" scheme="https://zhangmiao.cc/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>Mac装机必备Alfred</title>
    <link href="https://zhangmiao.cc/posts/d083e6c8.html"/>
    <id>https://zhangmiao.cc/posts/d083e6c8.html</id>
    <published>2021-11-08T08:04:43.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装Alfred"><a href="#安装Alfred" class="headerlink" title="安装Alfred"></a>安装<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a></h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108160814.png" alt></p><a id="more"></a><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>为了快速打开<code>Alfred</code>，我们需要为它设置一个快捷键，打开<code>Alfred</code>偏好设置的<code>General</code>选项卡，选中<code>Alfred Hotkey</code>输入框，直接使用键盘键入你喜欢的快捷键即可。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108160920.png" alt></p><p>我使用的<code>alt+空格键</code>，当初设置时，由于这个快捷键被Mac系统的Spotlight占用了，无法设置成功。如遇到相同的情况，需要先到<code>系统偏好设置-键盘-快捷键-聚焦</code>中取消勾选<code>alt+空格键</code>打开“聚焦”搜索的设置，然后再返回到<code>Alfred</code>中设置即可。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161042.png" alt></p><h3 id="自定义外观"><a href="#自定义外观" class="headerlink" title="自定义外观"></a>自定义外观</h3><p>进入<code>Appearance</code>选项卡，Alfred为我们提供了几种外观样式，如果你都不喜欢，也可以自定义外观。点击左下角的“+”，创建你的专属样式。通过双击相应的组件，即可打开系统的调色器，可以自由的搭配自己喜欢的颜色。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161114.png" alt></p><p>进入<code>Features</code>选项卡，在左侧列表中，罗列的是<code>Alfred</code>的基础功能，包括默认<code>搜索</code>、<code>文件搜索</code>、<code>网页搜索</code>、<code>网页书签</code>、<code>计算器</code>、<code>字典</code>、<code>联系人</code>、<code>剪贴板</code>、<code>iTunes</code>、<code>系统操作</code>、<code>终端</code>等。</p><h3 id="默认搜索（Default-Results）"><a href="#默认搜索（Default-Results）" class="headerlink" title="默认搜索（Default Results）"></a>默认搜索（Default Results）</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161251.png" alt></p><p>Essentials和Extras设置我们的搜索类型，可以设置搜索应用程序、联系人、偏好设置、文件夹、文本文件、压缩文件、文档、图片、脚本等。</p><p>Unintelligent建议不要勾选，会影响我们的搜索速度以及搜索结果。</p><p>Search Scope可以设置Alfred的搜索范围，点击右上角的”+”，可以添加其他的搜索范围；或者选中某项，按<code>Delete</code>键移除该搜索范围。</p><h3 id="文件搜索（File-Search）"><a href="#文件搜索（File-Search）" class="headerlink" title="文件搜索（File Search）"></a>文件搜索（File Search）</h3><p>默认搜索会搜索出所有类型的内容，包括邮件、联系人等其他内容，都是我根本不想搜索到的文件类型，这时就可以使用文件搜索，把一些不需要的类型过滤掉。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161334.png" alt></p><ul><li>空格键 + 关键字：文件搜索</li><li>find + 关键字：打开文件所在的Finder</li><li>in + 关键字：搜索文件内容中带有该关键字的文件</li></ul><h3 id="网页搜索（Web-Search）"><a href="#网页搜索（Web-Search）" class="headerlink" title="网页搜索（Web Search）"></a>网页搜索（Web Search）</h3><p>这是小编使用频率最高的功能，有了它，再也不怕记不住网址了。Alfred中已经默认设置了很多国外的网站，但大多数都是用不上的，不需要的只要取消勾选就行。点击右下角的<code>“Add Custom Search”</code>，即可添加新的网站搜索。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161453.png" alt></p><p>比如添加马可菠萝网站，只要到马可菠萝的搜索页面随便搜索一个内容，然后复制结果页面的网址，把具体的内容改成<code>{query}</code>即可，关键字填写macbl，然后保存。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161529.png" alt></p><ul><li>马可菠萝：<a href="https://www.macbl.com/search/{query}" target="_blank" rel="noopener">https://www.macbl.com/search/{query}</a></li><li>百度：<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}" target="_blank" rel="noopener">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</a></li><li>Dribbble：<a href="https://dribbble.com/search?q={query}" target="_blank" rel="noopener">https://dribbble.com/search?q={query}</a></li></ul><p>使用时，在Alfred中输入 macbl Alfred，按回车键即可打开马可菠萝搜索页面，找到Alfred啦！</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161804.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161833.png" alt></p><h3 id="剪贴板（Clipboard）"><a href="#剪贴板（Clipboard）" class="headerlink" title="剪贴板（Clipboard）"></a>剪贴板（Clipboard）</h3><p>剪贴板功能是我选择Alfred的主要原因，可以查看Alfred的所有剪贴历史记录，节省了重复操作的时间，非常强大</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161903.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/1557323280715908.gif" alt></p><h3 id="系统操作（System）"><a href="#系统操作（System）" class="headerlink" title="系统操作（System）"></a>系统操作（System）</h3><p>用简单的命令，来控制系统操作，比如最常用的清空垃圾桶(enptytrash)，休眠(sleep)，强制退出应用程序(forcequit)等，快捷键都可以自由设置。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108162116.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装Alfred&quot;&gt;&lt;a href=&quot;#安装Alfred&quot; class=&quot;headerlink&quot; title=&quot;安装Alfred&quot;&gt;&lt;/a&gt;安装&lt;a href=&quot;https://www.alfredapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alfred&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108160814.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="https://zhangmiao.cc/categories/Mac/"/>
    
      <category term="Alfred" scheme="https://zhangmiao.cc/categories/Mac/Alfred/"/>
    
    
      <category term="Mac" scheme="https://zhangmiao.cc/tags/Mac/"/>
    
      <category term="Alfred" scheme="https://zhangmiao.cc/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>Flutter完整学习路线解读</title>
    <link href="https://zhangmiao.cc/posts/829f290.html"/>
    <id>https://zhangmiao.cc/posts/829f290.html</id>
    <published>2021-10-27T07:01:31.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 作为一门新的技术，确实相关的资料书籍不太多。但就 Flutter 生态的影响力而言，已经是越来越强了。譬如，在 StackOverflow 网站上2021年度最受欢迎的技术中，Dart 语言排在了第7位。随着谷歌对 Flutter 跨平台解决方案的推进，估计会有越来越多的开发者使用 Flutter 构建他们的应用。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211027150220.png" alt></p><h2 id="学习线路思维导图"><a href="#学习线路思维导图" class="headerlink" title="学习线路思维导图"></a>学习线路思维导图</h2><p>先上一份思维导图，让大家有个整体认识。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211027150434.png" alt></p><a id="more"></a><h2 id="Dart语言"><a href="#Dart语言" class="headerlink" title="Dart语言"></a>Dart语言</h2><p>在学习 Dart 语言前，若没有任何编程基础，建议先了解一下计算机基础知识。Dart 作为一门现代化的面向对象编程语言，具备了市面上大多数编程语言的特点，具体来说会分为下面这些内容：</p><ul><li>变量定义、赋值：这是最基础的部分，至少要知道什么是变量，如何赋值。final，var 和 const 的区别。</li><li>基本数学运算：加、减、乘、除、整除、取余等运算；</li><li>条件分支：if…else if…else 控制程序逻辑走向，或是 switch 分支；</li><li>循环：使用循环完成重复性的工作；</li><li>容器类：如List、Map 和 Set 的应用；</li><li>函数和参数：一个是使用函数编写可复用的逻辑处理代码，二是需要注意在 Dart 中函数也是对象。同时需要区分函数的命名参数、可选参数的使用；</li><li>面向对象编程：了解面向对象编程的概念和思想，能够合理地使用类来封装代码提高复用性和降低耦合；</li><li>继承、多态和抽象类：这是提高代码复用、降低代码耦合度十分重要的概念，建议是多看看一些源码和设计思想（如设计模式），然后在遇到复杂业务的时候先思考如何抽象和组织代码结构。</li><li>mixin：mixin 提供了一种更为灵活的代码复用方式，可以将功能组合到现有类中，从而避免了继承的一些缺点。</li><li>泛型：使用泛型来做工具类是再好不过的选择了，通过泛型可以一套代码处理多种数据类型。</li><li>Future：有点类似前端的 promise，通过 Future 可以让异步编程变得更加简单。</li><li>null safety：空安全现在基本上是高级语言的标配了。通过空安全可以让团队遵循同一个规范，提高了代码的健壮性。</li></ul><h2 id="Flutter组件"><a href="#Flutter组件" class="headerlink" title="Flutter组件"></a>Flutter组件</h2><p>作为一个合格的App 开发，能够将一个UI 界面还原出来是基本的要求。建议一开始需要熟悉Flutter框架提供的自带组件，然后可以通过自带的组件组合成为自己的自定义组件。这部分内容包括：</p><ul><li>运行 Hello World 程序，跑通整个应用。</li><li>了解应用程序的结构，知道如何设计你的代码目录结构。</li><li>布局类组件：如 <code>Container</code>，<code>SizedBox</code>，<code>Padding，Stack</code>，<code>ListView</code>，<code>GridView</code> 等组件。</li><li>业务类组件：如 <code>TextField</code>，按钮，文本，图片，图标等组件。</li><li>自定义组件：利用布局类组件和业务类组件组合，构成自己的可复用的组件。</li><li>自有组件库：根据产品特性和公司需要，抽取复用的组件构成自有的组件库，从而提升整个公司的开发效率。</li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>应用中，表单在界面中出现的频率很高。如何处理表单对开发效率的影响很大。建议可以一开始从简单的表单页面开始，例如登录页、注册页。然后再做一些复杂的表单页面，具体如下：</p><ul><li>简单表单页面的实现：登录页、注册页、绑定手机号这类的页面；</li><li>不同表单的实现：例如普通文本、密码、数字、日期、单选、多选等表单的实现；</li><li>表单校验：封装表单校验库，将通用的校验规则放置在校验库中，比如长度、手机号校验、密码强度校验、日期格式校验等等。通过前端的提前校验可以避免后端请求压力，也能够提升用户体验。</li><li>表单封装：封装一套通用的表单组件，供整个团队复用，提高生产效率，也能减少 bug 的产生。</li></ul><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>状态管理是 Flutter 的核心，如何处理数据实体、业务逻辑、界面之间的关系对代码的可维护性十分关键，而这都依赖于状态管理的实现。对于状态管理，建议按如下方式学习：</p><ul><li>有状态组件和无状态组件的区别，可以阅读一下<code>StatefulWidget</code> 和 <code>StatelessWidget</code>的源码，会有更深刻的理解。</li><li>理解组件的渲染机制：虽然我们开发中很少关注组件如何渲染，但是当应用状态管理插件时，我们通过渲染机制能够知道状态数据更新时如何减少刷新的范围，实现局部刷新，从而提升性能。</li><li>主流状态插件应用：对比主流状态插件，从中选择一个合适自己团队的应用。对于长期用的状态管理插件，建议深入了解具体的实现机制，以便再遇到问题时能够快速定位，快速解决。</li><li>按需刷新：相比 setState 这种简单粗暴的全局更新，状态管理插件的一大优势就是可以实现局部刷新。通过按需刷新可以极大地提高页面的流畅度。</li></ul><p>关于状态管理的内容，可以通过阅读下面两篇文章来进行了解：</p><p>🚩🚩🚩建议收藏<br><a href="https://juejin.cn/post/7016485596046557198" target="_blank" rel="noopener">Flutter状态管理插件哪家强？请看岛上码农的排行榜！</a><br><a href="https://juejin.cn/post/7016141866194173988" target="_blank" rel="noopener">Flutter 入门与实战（九十二）：状态管理系列大汇总</a></p><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>App 的业务功能开发，相当一部分工作是在与和后端对接口、联调接口。了解与后端的数据交互，封装好网络请求库非常重要。这里建议按如下的方式进行学习：</p><ul><li>JSON 数据的认识：这个其实很简单，基本上一看就明白。但更重要的是和后端约定返回数据的格式，避免每个接口的格式都不同，那样很难做统一封装。</li><li>JSON 数据转对象：曾几何时，我是直接拿 JSON 对象（实际已经转成 Map 了）的 key 去取所需的值的。结果遭受了惨痛的教训，比如后端问题变成 null 了会导致闪退。而且每次都需要敲 key的名称，编码效率极低。而将 JSON 数据转为对象，一方面是对象可以在整个工程里复用，二是可以通过对象属性访问，编码有提示。同时，可以应用 null safety 属性直接知道哪个属性是否可能为空。</li><li>RESTful接口调试：早期的接口都是 GET 和 POST 请求，但是其实语义上并不明确。建议是统一和后端约定使用 RESTful 风格接口。</li><li>Mock 数据：后端接口没出来之前，使用 Mock 数据来完成业务逻辑的模拟非常重要。建议 Mock 的数据获取接口和后端的接口保持一致（统一实现相同的接口），这样在后端接口就绪后可以直接切换接口实现类就可以了。</li><li>网络请求插件使用与封装：Flutter 目前最为流行的网络请求插件是 Dio，对应的封装版本有 Retrofit。建议不要上来一开始就有用封装好的版本。而是自己一个个调试，然后尝试自己封装，这样会更好地理解封装的过程。</li><li><code>Headers</code> 和 <code>Cookie</code>：App 和浏览器不同，浏览器会自己管理<code>Cookie</code>。而 App 需要自己管理 <code>Cookie</code>。因此有必要了解如何设置请求头<code>Headers</code>，以及如何获取后端的 <code>Cookie</code> 并回写到<code>Headers</code> 里面。</li></ul><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>当你对界面、状态管理、网络请求都掌握差不多到时候，使用 <code>Flutter</code> 开发基本的 App 就基本没问题了。这个时候需要考虑应用结构如何优化。对于<code>Dart</code> 而言，提供了 <code>Stream</code> 和 <code>StreamListener</code> 这样的工具来通过流的方式驱动关联业务或界面更新，实现响应式编程。这里面典型的是 <code>BLoC</code> 模式 （<code>BLoC</code> 也可以用于状态管理）。了解一下 <code>BLoC</code> 的理念对设计整个应用程序框架十分有帮助。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>当你掌握上述的基本技能后，你看到别人 App 的酷炫动效时肯定心痒痒，想自己偶尔也能玩一下这类高大上的东西。这个时候就需要了解动画的实现了，<code>Flutter</code> 提供了很多动画构建方式，比如：</p><ul><li>基础动画组件：例如 <code>AnimatedContainer</code>，<code>AnimatedOpacity</code> 等等，通过这些组件可以实现简单但有趣的动画。</li><li>动画复用：使用 <code>AnimatedBuilder</code> 可以构建可复用的动效。</li><li>动画曲线：<code>Flutter</code> 自带了很多动画曲线效果，如果不满足也可以实现自定义曲线。有了动画曲线，你就可以定义一些自己的动画过渡效果了。</li><li>动画插件：<a href="https://pub.dev/" target="_blank" rel="noopener">pub.dev</a>上也提供了很多动画插件，例如<code>Lottie</code> 就可以将 AE 的动画转换为 <code>Flutter</code> 动画。如何查找动画插件，这需要懂得搜索，比如搜索关键字 <code>Animation</code>，或者经常逛一些技术社区，会让你的视野开拓很多，也许，不经意间就能发现一个酷炫的插件。</li></ul><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>当你的动画都能搞定的时候，你会发现产品和设计可能已经对你刮目想看了，这个时候他们提出的交互或者界面效果会提高（千万别觉得升级自己的技能是在给自己挖坑）。比如，可能会出一个奇怪的外形，然后需要你实现，这个时候就需要用到绘图了。绘图其实需要挺高的数学知识辅助的，你可能需要提前复习一下高等数学、线性代数知识😜😜😜 —— 所以大厂筛选学校和学历其实也有一定的道理的，这些筛选出来的人的基础知识一般都不会差。</p><ul><li><code>ClipPath</code>：自定义裁剪路径对于绘制有规律的形状来说可以轻松搞定，当然有些复杂的可能需要一些贝塞尔曲线知识。</li><li><code>CustomPaint</code>和 <code>Canvas</code>：使用 <code>CustomPaint</code> 和 <code>Canvas</code> 可以随心所欲地绘图，包括你想搞个小游戏也行。但是，这个也是很烧脑的一环，说到底，数学真的很重要！</li><li>计算机图形学（CG）：这算是绘图的理论支撑，有计算机图形学知识的支撑，会让你绘制自定义图形时候得心应手。</li></ul><h2 id="本地数据存储"><a href="#本地数据存储" class="headerlink" title="本地数据存储"></a>本地数据存储</h2><p>随着网络的升级，本地数据存储可能不像之前那么重要。但是，不论是对用户体验还是减轻后端压力都是必不可少的。譬如，微信就把整个个人的聊天记录存储在了本地 —— 既节省了服务器的存储空间和加载请求量，还能够对外宣称是“保护个人隐私”。本地存储主要有三个方面：</p><ul><li>简单键值对的存储：可以存储一些配置信息、登录会话信息，避免反复从服务器读取。在 <code>Flutter</code> 通常是使用 <code>SharedPreferences</code> 实现。</li><li>文件存储：比如应用内下载的文件管理，日志文件等，可以使用文件管理实现。通常会使用到 <code>path_provider</code> 插件实现。</li><li>关系型数据库：移动端大部分都采用了 <code>SQLite</code> 数据库，<code>SQLite</code> 的数据库操作语法和 <code>MySQL</code> 这类的标准 <code>SQL</code> 基本一致，可以用于存储关系数据。在<code>Flutter</code> 中也有不少封装好的插件，比如 <code>sqflite</code>。</li></ul><h2 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h2><p>实际上页面导航在一开始就会用到，大部分情况下，自带的导航和路由管理都能够满足需求。对于路由可以按如下方式进阶：</p><ul><li>自带路由的掌握：比如匿名路由，命名路由，路由传参，路由拦截等；</li><li>路由插件的应用：了解如 <code>fluro</code>、<code>GetX</code> 的路由管理的优缺点，选择使用自带的路由管理还是使用第三方插件。</li><li>2.0路由：这个如果是在 Web端的话建议了解一下，App 端个人感觉有点重，学习成本相对较高。当然，因为刚出来没多久，估计以后也会有简单易用的插件帮助我们使用。</li></ul><h2 id="自有插件"><a href="#自有插件" class="headerlink" title="自有插件"></a>自有插件</h2><p>如果你的公司业务条线比较多，也许此时已经成为公司大神的你会被邀请做基础设施建设，或者是你自己想为开源社区做做贡献，这个时候就需要构建自有插件或开源插件了。Flutter 提供了插件构建模板工程，你可以按步骤构建自有插件，然后供整个公司的各个业务条线使用，提高各个业务条线的生产力。</p><h2 id="原生交互"><a href="#原生交互" class="headerlink" title="原生交互"></a>原生交互</h2><p>原生交互分为三个部分：</p><ul><li>Flutter为原生提供服务</li><li>Flutter 使用原生提供的接口</li><li>原生页面与 Flutter 页面之间的跳转</li></ul><p>这块对于混编的应用来说是必不可少的，此时你的知识体系需要升级了，你需要学习安卓的 kotlin 开发，iOS 的 Swift 开发（呃，本来想一站式搞定，结果又绕回来了）。当然，到这个阶段，相信这些已经难不倒你了！</p><h2 id="应用发布"><a href="#应用发布" class="headerlink" title="应用发布"></a>应用发布</h2><p>恭喜你！你的应用可以在各大应用市场上架了！记得我的第一个应用在 AppStore过审的时候别提多兴奋了（之前被拒了好几次😂😂😂）！如何进行应用打包这个搜索一下就能搞定了，但是如何应对AppStore 每年都变的审查规则也是一场斗智斗勇的过程。 而安卓，如果搞定碎片化的操作系统分布也是头疼的一件事情。建议提前在应用内做应用统计，以及异常上报，避免发布后在用户机器上出现奇怪的问题。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>技术永无止境，再往后，你可能会深入去做性能优化、应用架构设计。这些方面很大程度靠个人平时的积累，多输入新的知识，同时了解其他的应用框架和特性（不限于 Dart，比如 Java 的 Spring 框架，Web 端的 React、Vue）都会让你对当前的应用架构设计有新的认识。扩充视野和技术深度，也许你就是下一个 CTO 的人选💪🏻💪🏻💪🏻！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Flutter 作为一门新的技术，确实相关的资料书籍不太多。但就 Flutter 生态的影响力而言，已经是越来越强了。譬如，在 StackOverflow 网站上2021年度最受欢迎的技术中，Dart 语言排在了第7位。随着谷歌对 Flutter 跨平台解决方案的推进，估计会有越来越多的开发者使用 Flutter 构建他们的应用。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211027150220.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;学习线路思维导图&quot;&gt;&lt;a href=&quot;#学习线路思维导图&quot; class=&quot;headerlink&quot; title=&quot;学习线路思维导图&quot;&gt;&lt;/a&gt;学习线路思维导图&lt;/h2&gt;&lt;p&gt;先上一份思维导图，让大家有个整体认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211027150434.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter如何开发web端</title>
    <link href="https://zhangmiao.cc/posts/b683bca5.html"/>
    <id>https://zhangmiao.cc/posts/b683bca5.html</id>
    <published>2021-10-16T02:46:21.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<p>flutter开发移动端与开发web端有些区别，开发移动端会涉及到各自原生系统里特有的一些内容，iOS端与Android通过插件的形式引入的项目当中，但不需要考虑响应式布局。而web端开发需要考虑到窗口的大小变化，需要考虑响应式布局。</p><p>开启对web开发的支持<br>flutter开发要支持web，需要在命令行中输入以下命令打开支持的平台（以下列举了各个平台支持的命令行）：</p><blockquote><p>flutter config —enable-web-desktop<br>flutter config —enable-windows-desktop<br>flutter config —enable-macos-desktop<br>flutter config —enable-linux-desktop </p></blockquote><p>之后再次输入 <code>flutter config</code>检测开启的情况，如果检测到如下图所示则表示开启成功。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022110841.png" alt></p><p>这时候可以创建项目了，创建的时候勾选Web选项即可。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111535.png" alt></p><a id="more"></a><h2 id="web开发的注意事项"><a href="#web开发的注意事项" class="headerlink" title="web开发的注意事项"></a>web开发的注意事项</h2><h3 id="支持响应式布局的控件"><a href="#支持响应式布局的控件" class="headerlink" title="支持响应式布局的控件"></a>支持响应式布局的控件</h3><p>A. MediaQuery<br>响应式布局的本质是监听浏览器宽高的变化进而修改UI的样式，所以需要能够监听宽高的变化，此时可以使用MediaQuery控件。MediaQuery控件继承自InheritedWidget，通过<code>MediaQuery.of(context).size</code>的方式实时获取到浏览器宽高的变化，进而对全局的UI进行调整。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111054.png" alt></p><p>B.  LayoutBuilder<br>LayoutBuilder是MediaQuery的简化版本，可以实时监控父控件尺寸的变化（不是浏览器宽高的变化），进而对当前控件的UI进行调整。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111103.png" alt></p><p>C. AspectRatio<br>这是一个指定宽高比例的控件，会随着浏览器宽度变化进行等比例缩小或者放大。如果要保证某个控件的宽高保持一致，则需要使用AspectRatio。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111112.png" alt></p><p>D. Flexible 与 Expanded<br>Flexible与Expanded是用在Row或者Column中的控件，前者可以用来控制控件在Row或者Column中占用的比例，后者则用来填充Row或者Column中剩余的空间。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111121.png" alt></p><p>E. FractionallySizedBox<br>这是一个设置占位比例的控件，跟AspectRatio类似，可以设置占有父控件多大比例。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111132.png" alt></p><h3 id="响应式布局支持的开源库"><a href="#响应式布局支持的开源库" class="headerlink" title="响应式布局支持的开源库"></a>响应式布局支持的开源库</h3><p>A. responsive_framework<br>这个库支持屏幕尺寸变化时对所用控件进行缩放控制或者进行实时UI调整，支持手机、平板、电脑尺寸的设置，使用方便。支持缩放控制是其最大亮点。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111159.png" alt></p><p>B. responsive_builder<br>这个库支持屏幕尺寸的变化时对所有控件进行实时UI调整，并能检测移动端横竖屏变化。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/dd792057-6327-497f-98e1-b06144334e10.gif" alt></p><h3 id="引用开源库的注意点"><a href="#引用开源库的注意点" class="headerlink" title="引用开源库的注意点"></a>引用开源库的注意点</h3><p>如果要做到开发web的时候也需要支持移动端，在引入开源库时要注意其支持的平台种类。如下图中支持的平台就包含了安卓、iOS、Linux、MacOS、Web以及windows。最好引入的开源库支持全平台。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111227.png" alt></p><p>参考资料：<br><a href="https://betterprogramming.pub/how-to-build-responsive-apps-with-flutter-widgets-review-b22c6dec6904" target="_blank" rel="noopener">https://betterprogramming.pub/how-to-build-responsive-apps-with-flutter-widgets-review-b22c6dec6904</a><br><a href="https://medium.com/flutter-community/seven-things-you-should-know-before-starting-with-flutter-web-8e48555d819e" target="_blank" rel="noopener">https://medium.com/flutter-community/seven-things-you-should-know-before-starting-with-flutter-web-8e48555d819e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flutter开发移动端与开发web端有些区别，开发移动端会涉及到各自原生系统里特有的一些内容，iOS端与Android通过插件的形式引入的项目当中，但不需要考虑响应式布局。而web端开发需要考虑到窗口的大小变化，需要考虑响应式布局。&lt;/p&gt;
&lt;p&gt;开启对web开发的支持&lt;br&gt;flutter开发要支持web，需要在命令行中输入以下命令打开支持的平台（以下列举了各个平台支持的命令行）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;flutter config —enable-web-desktop&lt;br&gt;flutter config —enable-windows-desktop&lt;br&gt;flutter config —enable-macos-desktop&lt;br&gt;flutter config —enable-linux-desktop &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之后再次输入 &lt;code&gt;flutter config&lt;/code&gt;检测开启的情况，如果检测到如下图所示则表示开启成功。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022110841.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这时候可以创建项目了，创建的时候勾选Web选项即可。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111535.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter cached_network_image 图片加载流程分析</title>
    <link href="https://zhangmiao.cc/posts/a931c363.html"/>
    <id>https://zhangmiao.cc/posts/a931c363.html</id>
    <published>2021-09-28T09:14:46.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>组件<a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fcached_network_image" target="_blank" rel="noopener">CachedNetworkImage</a>可以支持直接使用或者通过<code>ImageProvider</code>。</p><p><strong>引入依赖</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  cached_network_image:</span> <span class="string">^3.1.0</span></span><br></pre></td></tr></table></figure><p>执行<code>flutter pub get</code>，项目中使用</p><p><strong>Import it</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:cached_network_image/cached_network_image.dart'</span>;</span><br></pre></td></tr></table></figure><p><strong>添加占位图</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CachedNetworkImage(</span><br><span class="line">        imageUrl: <span class="string">"http://via.placeholder.com/350x150"</span>,</span><br><span class="line">        placeholder: (context, url) =&gt; CircularProgressIndicator(),</span><br><span class="line">        errorWidget: (context, url, error) =&gt; Icon(Icons.error),</span><br><span class="line">     ),</span><br></pre></td></tr></table></figure><p><strong>进度条展示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CachedNetworkImage(</span><br><span class="line">        imageUrl: <span class="string">"http://via.placeholder.com/350x150"</span>,</span><br><span class="line">        progressIndicatorBuilder: (context, url, downloadProgress) =&gt; </span><br><span class="line">                CircularProgressIndicator(value: downloadProgress.progress),</span><br><span class="line">        errorWidget: (context, url, error) =&gt; Icon(Icons.error),</span><br><span class="line">     ),</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>原生组件Image配合</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image(image: CachedNetworkImageProvider(url))</span><br></pre></td></tr></table></figure><p><strong>使用占位图并提供provider给其他组件使用</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CachedNetworkImage(</span><br><span class="line">  imageUrl: <span class="string">"http://via.placeholder.com/200x150"</span>,</span><br><span class="line">  imageBuilder: (context, imageProvider) =&gt; Container(</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">      image: DecorationImage(</span><br><span class="line">          image: imageProvider,</span><br><span class="line">          fit: BoxFit.cover,</span><br><span class="line">          colorFilter:</span><br><span class="line">              ColorFilter.mode(Colors.red, BlendMode.colorBurn)),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  placeholder: (context, url) =&gt; CircularProgressIndicator(),</span><br><span class="line">  errorWidget: (context, url, error) =&gt; Icon(Icons.error),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>这样就可以加载网络图片了，而且，图片加载完成时，就被缓存到本地了，首先看下图片的加载流程</p><blockquote><p>官网说了，它现在不包含缓存，缓存功能实际上是另一个库<code>flutter_cache_manager</code>中实现的</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="加载-amp-显示"><a href="#加载-amp-显示" class="headerlink" title="加载&amp;显示"></a>加载&amp;显示</h3><blockquote><p>这里我们仅梳理图片加载和缓存的主流程，对于一些其他分支流程，或无关参数不做过多分析</p></blockquote><p>首先，页面上使用的构造函数接收了一个必传参数imageUrl，用于生成ImageProvider提供图片加载</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedNetworkImage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="comment">/// image提供</span></span><br><span class="line">  <span class="keyword">final</span> CachedNetworkImageProvider _image;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 构造函数</span></span><br><span class="line">  CachedNetworkImage(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.imageUrl,</span><br><span class="line">    <span class="comment">/// 省略部分</span></span><br><span class="line">    <span class="keyword">this</span>.cacheManager,</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(imageUrl != <span class="keyword">null</span>),</span><br><span class="line">        <span class="comment">/// ...</span></span><br><span class="line">        _image = CachedNetworkImageProvider(</span><br><span class="line">          imageUrl,</span><br><span class="line">          headers: httpHeaders,</span><br><span class="line">          cacheManager: cacheManager,</span><br><span class="line">          cacheKey: cacheKey,</span><br><span class="line">          imageRenderMethodForWeb: imageRenderMethodForWeb,</span><br><span class="line">          maxWidth: maxWidthDiskCache,</span><br><span class="line">          maxHeight: maxHeightDiskCache,</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">super</span>(key: key);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> octoPlaceholderBuilder =</span><br><span class="line">        placeholder != <span class="keyword">null</span> ? _octoPlaceholderBuilder : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">var</span> octoProgressIndicatorBuilder =</span><br><span class="line">        progressIndicatorBuilder != <span class="keyword">null</span> ? _octoProgressIndicatorBuilder : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OctoImage(</span><br><span class="line">      image: _image,</span><br><span class="line">      <span class="comment">/// ...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，构造函数初始化了一个本地变量<code>_image</code> 类型是<code>CachedNetworkImageProvider</code>，它继承ImageProvider提供图片加载，看下它的构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 提供网络图片加载Provider并缓存</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedNetworkImageProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">CachedNetworkImageProvider</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// Creates an object that fetches the image at the given URL.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> CachedNetworkImageProvider(</span><br><span class="line">    <span class="built_in">String</span> url, &#123;</span><br><span class="line">    <span class="built_in">int</span> maxHeight,</span><br><span class="line">    <span class="built_in">int</span> maxWidth,</span><br><span class="line">    <span class="built_in">String</span> cacheKey,</span><br><span class="line">    <span class="built_in">double</span> scale,</span><br><span class="line">    <span class="meta">@Deprecated</span>(<span class="string">'ErrorListener is deprecated, use listeners on the imagestream'</span>)</span><br><span class="line">        ErrorListener errorListener,</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers,</span><br><span class="line">    BaseCacheManager cacheManager,</span><br><span class="line">    ImageRenderMethodForWeb imageRenderMethodForWeb,</span><br><span class="line">  &#125;) = image_provider.CachedNetworkImageProvider;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 可选cacheManager. 默认使用 DefaultCacheManager()</span></span><br><span class="line">  <span class="comment">/// 当运行在web时,cacheManager没有使用.</span></span><br><span class="line">  BaseCacheManager <span class="keyword">get</span> cacheManager;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求url.</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 缓存key</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> cacheKey;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ImageStreamCompleter load(</span><br><span class="line">      CachedNetworkImageProvider key, DecoderCallback decode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的构造函数调用了<code>image_provider.CachedNetworkImageProvider</code>的实例在<code>_image_provider_io.dart</code>中是加载的具体实现类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// IO implementation of the CachedNetworkImageProvider; the ImageProvider to</span></span><br><span class="line"><span class="comment">/// load network images using a cache.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedNetworkImageProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">image_provider</span>.<span class="title">CachedNetworkImageProvider</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">image_provider</span>.<span class="title">CachedNetworkImageProvider</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Creates an ImageProvider which loads an image from the [url], using the [scale].</span></span><br><span class="line">  <span class="comment">/// When the image fails to load [errorListener] is called.</span></span><br><span class="line">  <span class="keyword">const</span> CachedNetworkImageProvider(</span><br><span class="line">    <span class="keyword">this</span>.url, &#123;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(url != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(scale != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">final</span> BaseCacheManager cacheManager;</span><br><span class="line"><span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;CachedNetworkImageProvider&gt; obtainKey(</span><br><span class="line">      ImageConfiguration configuration) &#123;</span><br><span class="line">    <span class="keyword">return</span> SynchronousFuture&lt;CachedNetworkImageProvider&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 核心方法加载图片入口</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ImageStreamCompleter load(</span><br><span class="line">      image_provider.CachedNetworkImageProvider key, DecoderCallback decode) &#123;</span><br><span class="line">    <span class="keyword">final</span> chunkEvents = StreamController&lt;ImageChunkEvent&gt;();</span><br><span class="line">    <span class="comment">/// 多图加载</span></span><br><span class="line">    <span class="keyword">return</span> MultiImageStreamCompleter(</span><br><span class="line">      codec: _loadAsync(key, chunkEvents, decode),</span><br><span class="line">      chunkEvents: chunkEvents.stream,</span><br><span class="line">      scale: key.scale,</span><br><span class="line">      informationCollector: () <span class="keyword">sync</span>* &#123;</span><br><span class="line">        <span class="keyword">yield</span> DiagnosticsProeperty&lt;ImageProvider&gt;(</span><br><span class="line">          <span class="string">'Image provider: $this \n Image key: $key'</span>,</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          style: DiagnosticsTreeStyle.errorProperty,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的load方法即是图片加载的启动入口，它会在页面可见时被调用</p><p>它返回了一个<code>MultiImageStreamCompleter</code>传入<code>_loadAsync</code>，看下这个方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 异步加载</span></span><br><span class="line">  Stream&lt;ui.Codec&gt; _loadAsync(</span><br><span class="line">    CachedNetworkImageProvider key,</span><br><span class="line">    StreamController&lt;ImageChunkEvent&gt; chunkEvents,</span><br><span class="line">    DecoderCallback decode,</span><br><span class="line">  ) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">assert</span>(key == <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/// 默认缓存管理器</span></span><br><span class="line">      <span class="keyword">var</span> mngr = cacheManager ?? DefaultCacheManager();</span><br><span class="line">      <span class="keyword">assert</span>(</span><br><span class="line">          mngr <span class="keyword">is</span> ImageCacheManager || (maxWidth == <span class="keyword">null</span> &amp;&amp; maxHeight == <span class="keyword">null</span>),</span><br><span class="line">          <span class="string">'To resize the image with a CacheManager the '</span></span><br><span class="line">          <span class="string">'CacheManager needs to be an ImageCacheManager. maxWidth and '</span></span><br><span class="line">          <span class="string">'maxHeight will be ignored when a normal CacheManager is used.'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/// 下载逻辑放在ImageCacheManager，得到下载stream</span></span><br><span class="line">      <span class="keyword">var</span> stream = mngr <span class="keyword">is</span> ImageCacheManager</span><br><span class="line">          ? mngr.getImageFile(key.url,</span><br><span class="line">              maxHeight: maxHeight,</span><br><span class="line">              maxWidth: maxWidth,</span><br><span class="line">              withProgress: <span class="keyword">true</span>,</span><br><span class="line">              headers: headers,</span><br><span class="line">              key: key.cacheKey)</span><br><span class="line">          : mngr.getFileStream(key.url,</span><br><span class="line">              withProgress: <span class="keyword">true</span>, headers: headers, key: key.cacheKey);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> result <span class="keyword">in</span> stream) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">is</span> FileInfo) &#123;</span><br><span class="line">          <span class="keyword">var</span> file = result.file;</span><br><span class="line">          <span class="keyword">var</span> bytes = <span class="keyword">await</span> file.readAsBytes();</span><br><span class="line">          <span class="keyword">var</span> decoded = <span class="keyword">await</span> decode(bytes);</span><br><span class="line">          <span class="comment">/// 下载完成返回结果</span></span><br><span class="line">          <span class="keyword">yield</span> decoded;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">/// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> chunkEvents.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到了默认缓存管理器<code>cacheManager</code>创建的地方，为<code>DefaultCacheManager</code>，那么它如何缓存的呢，后边再分析。</p><p>下载的逻辑也是放在了<code>ImageCacheManager</code>下了，返回结果是一个<code>stream</code>完成多图下载的支持，下载完成通过yield 返回给ui解码最终显示。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">MultiImageStreamCompleter`支持多图加载继承自`ImageStreamCompleter</span><br><span class="line"><span class="comment">/// An ImageStreamCompleter with support for loading multiple images.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiImageStreamCompleter</span> <span class="keyword">extends</span> <span class="title">ImageStreamCompleter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// The constructor to create an MultiImageStreamCompleter. The [codec]</span></span><br><span class="line">  <span class="comment">/// should be a stream with the images that should be shown. The</span></span><br><span class="line">  <span class="comment">/// [chunkEvents] should indicate the [ImageChunkEvent]s of the first image</span></span><br><span class="line">  <span class="comment">/// to show.</span></span><br><span class="line">  MultiImageStreamCompleter(&#123;</span><br><span class="line">    <span class="meta">@required</span> Stream&lt;ui.Codec&gt; codec,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">double</span> scale,</span><br><span class="line">    Stream&lt;ImageChunkEvent&gt; chunkEvents,</span><br><span class="line">    InformationCollector informationCollector,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(codec != <span class="keyword">null</span>),</span><br><span class="line">        _informationCollector = informationCollector,</span><br><span class="line">        _scale = scale &#123;</span><br><span class="line">    <span class="comment">/// 显示逻辑</span></span><br><span class="line">    codec.listen((event) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        _nextImageCodec = event;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _handleCodecReady(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, onError: (<span class="keyword">dynamic</span> error, StackTrace stack) &#123;</span><br><span class="line">      reportError(</span><br><span class="line">        context: ErrorDescription(<span class="string">'resolving an image codec'</span>),</span><br><span class="line">        exception: error,</span><br><span class="line">        stack: stack,</span><br><span class="line">        informationCollector: informationCollector,</span><br><span class="line">        silent: <span class="keyword">true</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 处理解码完成</span></span><br><span class="line">  <span class="keyword">void</span> _handleCodecReady(ui.Codec codec) &#123;</span><br><span class="line">    _codec = codec;</span><br><span class="line">    <span class="keyword">assert</span>(_codec != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">      _decodeNextFrameAndSchedule();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 解码下一帧并绘制</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _decodeNextFrameAndSchedule() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _nextFrame = <span class="keyword">await</span> _codec.getNextFrame();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      reportError(</span><br><span class="line">        context: ErrorDescription(<span class="string">'resolving an image frame'</span>),</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        informationCollector: _informationCollector,</span><br><span class="line">        silent: <span class="keyword">true</span>,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_codec.frameCount == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// ImageStreamCompleter listeners removed while waiting for next frame to</span></span><br><span class="line">      <span class="comment">// be decoded.</span></span><br><span class="line">      <span class="comment">// There's no reason to emit the frame without active listeners.</span></span><br><span class="line">      <span class="keyword">if</span> (!hasListeners) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This is not an animated image, just return it and don't schedule more</span></span><br><span class="line">      <span class="comment">// frames.</span></span><br><span class="line">      _emitFrame(ImageInfo(image: _nextFrame.image, scale: _scale));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _scheduleAppFrame();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了显示逻辑，和最终转化成flutter上帧的处理，<code>_scheduleAppFrame</code>完成发送帧的处理</p><h3 id="下载-amp-缓存"><a href="#下载-amp-缓存" class="headerlink" title="下载&amp;缓存"></a>下载&amp;缓存</h3><p>上边的<code>mngr</code>调用了<code>ImageCacheManager</code>中的<code>getImageFile</code>方法现在就到了<code>flutter_cache_manager</code>这个三方库当中，它是被隐式依赖的，文件是<code>image_cache_manager.dart</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mixin ImageCacheManager on BaseCacheManager &#123;</span><br><span class="line">Stream&lt;FileResponse&gt; getImageFile(</span><br><span class="line">    <span class="built_in">String</span> url, &#123;</span><br><span class="line">    <span class="built_in">String</span> key,</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers,</span><br><span class="line">    <span class="built_in">bool</span> withProgress,</span><br><span class="line">    <span class="built_in">int</span> maxHeight,</span><br><span class="line">    <span class="built_in">int</span> maxWidth,</span><br><span class="line">  &#125;) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxHeight == <span class="keyword">null</span> &amp;&amp; maxWidth == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* getFileStream(url,</span><br><span class="line">          key: key, headers: headers, withProgress: withProgress);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileStream`方法实现在子类`cache_manager.dart`文件中的`CacheManager</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheManager</span> <span class="keyword">implements</span> <span class="title">BaseCacheManager</span> </span>&#123;</span><br><span class="line"> <span class="comment">/// 缓存管理</span></span><br><span class="line">  CacheStore _store;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the underlying store helper</span></span><br><span class="line">  CacheStore <span class="keyword">get</span> store =&gt; _store;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 下载管理</span></span><br><span class="line">  WebHelper _webHelper;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the underlying web helper</span></span><br><span class="line">  WebHelper <span class="keyword">get</span> webHelper =&gt; _webHelper;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 从下载或者缓存读取file返回stream</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;FileResponse&gt; getFileStream(<span class="built_in">String</span> url,</span><br><span class="line">      &#123;<span class="built_in">String</span> key, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers, <span class="built_in">bool</span> withProgress&#125;) &#123;</span><br><span class="line">    key ??= url;</span><br><span class="line">    <span class="keyword">final</span> streamController = StreamController&lt;FileResponse&gt;();</span><br><span class="line">    _pushFileToStream(</span><br><span class="line">        streamController, url, key, headers, withProgress ?? <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> streamController.stream;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _pushFileToStream(StreamController streamController, <span class="built_in">String</span> url,</span><br><span class="line">      <span class="built_in">String</span> key, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers, <span class="built_in">bool</span> withProgress) <span class="keyword">async</span> &#123;</span><br><span class="line">    key ??= url;</span><br><span class="line">    FileInfo cacheFile;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/// 缓存判断</span></span><br><span class="line">      cacheFile = <span class="keyword">await</span> getFileFromCache(key);</span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/// 有缓存直接返回</span></span><br><span class="line">        streamController.add(cacheFile);</span><br><span class="line">        withProgress = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(</span><br><span class="line">          <span class="string">'CacheManager: Failed to load cached file for $url with error:\n$e'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 没有缓存或者过期下载</span></span><br><span class="line">    <span class="keyword">if</span> (cacheFile == <span class="keyword">null</span> || cacheFile.validTill.isBefore(<span class="built_in">DateTime</span>.now())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> response</span><br><span class="line">            <span class="keyword">in</span> _webHelper.downloadFile(url, key: key, authHeaders: headers)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (response <span class="keyword">is</span> DownloadProgress &amp;&amp; withProgress) &#123;</span><br><span class="line">            streamController.add(response);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (response <span class="keyword">is</span> FileInfo) &#123;</span><br><span class="line">            streamController.add(response);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(() &#123;</span><br><span class="line">          <span class="built_in">print</span>(</span><br><span class="line">              <span class="string">'CacheManager: Failed to download file from $url with error:\n$e'</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;());</span><br><span class="line">        <span class="keyword">if</span> (cacheFile == <span class="keyword">null</span> &amp;&amp; streamController.hasListener) &#123;</span><br><span class="line">          streamController.addError(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unawaited(streamController.close());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存判断逻辑在<code>CacheStore</code>提供两级缓存</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheStore</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Duration</span> cleanupRunMinInterval = <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">10</span>);</span><br><span class="line"><span class="comment">/// 未下载完成缓存</span></span><br><span class="line">  <span class="keyword">final</span> _futureCache = &lt;<span class="built_in">String</span>, Future&lt;CacheObject&gt;&gt;&#123;&#125;;</span><br><span class="line">  <span class="comment">/// 已下载完缓存</span></span><br><span class="line">  <span class="keyword">final</span> _memCache = &lt;<span class="built_in">String</span>, CacheObject&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">  Future&lt;FileInfo&gt; getFile(<span class="built_in">String</span> key, &#123;<span class="built_in">bool</span> ignoreMemCache = <span class="keyword">false</span>&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> cacheObject =</span><br><span class="line">        <span class="keyword">await</span> retrieveCacheData(key, ignoreMemCache: ignoreMemCache);</span><br><span class="line">    <span class="keyword">if</span> (cacheObject == <span class="keyword">null</span> || cacheObject.relativePath == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> file = <span class="keyword">await</span> fileSystem.createFile(cacheObject.relativePath);</span><br><span class="line">    <span class="keyword">return</span> FileInfo(</span><br><span class="line">      file,</span><br><span class="line">      FileSource.Cache,</span><br><span class="line">      cacheObject.validTill,</span><br><span class="line">      cacheObject.url,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; putFile(CacheObject cacheObject) <span class="keyword">async</span> &#123;</span><br><span class="line">    _memCache[cacheObject.key] = cacheObject;</span><br><span class="line">    <span class="keyword">await</span> _updateCacheDataInDatabase(cacheObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;CacheObject&gt; retrieveCacheData(<span class="built_in">String</span> key,</span><br><span class="line">      &#123;<span class="built_in">bool</span> ignoreMemCache = <span class="keyword">false</span>&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">/// 判断是否已缓存过</span></span><br><span class="line">    <span class="keyword">if</span> (!ignoreMemCache &amp;&amp; _memCache.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">await</span> _fileExists(_memCache[key])) &#123;</span><br><span class="line">        <span class="keyword">return</span> _memCache[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 未缓存的 已加入futureCache中的key直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!_futureCache.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">final</span> completer = Completer&lt;CacheObject&gt;();</span><br><span class="line">      <span class="comment">/// 未加入的添加到futureCache</span></span><br><span class="line">      unawaited(_getCacheDataFromDatabase(key).then((cacheObject) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheObject != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">await</span> _fileExists(cacheObject)) &#123;</span><br><span class="line">          <span class="keyword">final</span> provider = <span class="keyword">await</span> _cacheInfoRepository;</span><br><span class="line">          <span class="keyword">await</span> provider.delete(cacheObject.id);</span><br><span class="line">          cacheObject = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _memCache[key] = cacheObject;</span><br><span class="line">        completer.complete(cacheObject);</span><br><span class="line">        unawaited(_futureCache.remove(key));</span><br><span class="line">      &#125;));</span><br><span class="line">      _futureCache[key] = completer.future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _futureCache[key];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/// ...</span></span><br><span class="line">  <span class="comment">/// 更新到数据库</span></span><br><span class="line">  Future&lt;<span class="keyword">dynamic</span>&gt; _updateCacheDataInDatabase(CacheObject cacheObject) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> provider = <span class="keyword">await</span> _cacheInfoRepository;</span><br><span class="line">    <span class="keyword">return</span> provider.updateOrInsert(cacheObject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_cacheInfoRepository</code>缓存仓库是<code>CacheObjectProvider</code>使用的数据库缓存对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheObjectProvider</span> <span class="keyword">extends</span> <span class="title">CacheInfoRepository</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">CacheInfoRepositoryHelperMethods</span> </span>&#123;</span><br><span class="line">  Database db;</span><br><span class="line">  <span class="built_in">String</span> _path;</span><br><span class="line">  <span class="built_in">String</span> databaseName;</span><br><span class="line"></span><br><span class="line">  CacheObjectProvider(&#123;<span class="built_in">String</span> path, <span class="keyword">this</span>.databaseName&#125;) : _path = path;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 打开</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; open() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!shouldOpenOnNewConnection()) &#123;</span><br><span class="line">      <span class="keyword">return</span> openCompleter.future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> path = <span class="keyword">await</span> _getPath();</span><br><span class="line">    <span class="keyword">await</span> File(path).parent.create(recursive: <span class="keyword">true</span>);</span><br><span class="line">    db = <span class="keyword">await</span> openDatabase(path, version: <span class="number">3</span>,</span><br><span class="line">        onCreate: (Database db, <span class="built_in">int</span> version) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> db.execute(<span class="string">'''</span></span><br><span class="line"><span class="string">      create table $_tableCacheObject ( </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnId&#125;</span> integer primary key, </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnUrl&#125;</span> text, </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnKey&#125;</span> text, </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnPath&#125;</span> text,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnETag&#125;</span> text,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnValidTill&#125;</span> integer,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnTouched&#125;</span> integer,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnLength&#125;</span> integer</span></span><br><span class="line"><span class="string">        );</span></span><br><span class="line"><span class="string">        create unique index $_tableCacheObject<span class="subst">$&#123;CacheObject.columnKey&#125;</span> </span></span><br><span class="line"><span class="string">        ON $_tableCacheObject (<span class="subst">$&#123;CacheObject.columnKey&#125;</span>);</span></span><br><span class="line"><span class="string">      '''</span>);</span><br><span class="line">    &#125;, onUpgrade: (Database db, <span class="built_in">int</span> oldVersion, <span class="built_in">int</span> newVersion) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="comment">/// ...</span></span><br><span class="line">    <span class="keyword">return</span> opened();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">dynamic</span>&gt; updateOrInsert(CacheObject cacheObject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheObject.id == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> insert(cacheObject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> update(cacheObject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;CacheObject&gt; insert(CacheObject cacheObject,</span><br><span class="line">      &#123;<span class="built_in">bool</span> setTouchedToNow = <span class="keyword">true</span>&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="keyword">await</span> db.insert(</span><br><span class="line">      _tableCacheObject,</span><br><span class="line">      cacheObject.toMap(setTouchedToNow: setTouchedToNow),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> cacheObject.copyWith(id: id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;CacheObject&gt; <span class="keyword">get</span>(<span class="built_in">String</span> key) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&gt; maps = <span class="keyword">await</span> db.query(_tableCacheObject,</span><br><span class="line">        columns: <span class="keyword">null</span>, where: <span class="string">'<span class="subst">$&#123;CacheObject.columnKey&#125;</span> = ?'</span>, whereArgs: [key]);</span><br><span class="line">    <span class="keyword">if</span> (maps.isNotEmpty) &#123;</span><br><span class="line">      <span class="keyword">return</span> CacheObject.fromMap(maps.first.cast&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="built_in">int</span>&gt; delete(<span class="built_in">int</span> id) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.delete(_tableCacheObject,</span><br><span class="line">        where: <span class="string">'<span class="subst">$&#123;CacheObject.columnId&#125;</span> = ?'</span>, whereArgs: [id]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见数据库缓存的是<code>CacheObject</code>对象，保存了url、key、relativePath等信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnId = <span class="string">'_id'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnUrl = <span class="string">'url'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnKey = <span class="string">'key'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnPath = <span class="string">'relativePath'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnETag = <span class="string">'eTag'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnValidTill = <span class="string">'validTill'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnTouched = <span class="string">'touched'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnLength = <span class="string">'length'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有缓存下调用了<code>_webHelper.downloadFile</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebHelper</span> </span>&#123;</span><br><span class="line">  WebHelper(<span class="keyword">this</span>._store, FileService fileFetcher)</span><br><span class="line">      : _memCache = &#123;&#125;,</span><br><span class="line">        fileFetcher = fileFetcher ?? HttpFileService();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> CacheStore _store;</span><br><span class="line">  <span class="meta">@visibleForTesting</span></span><br><span class="line">  <span class="keyword">final</span> FileService fileFetcher;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, BehaviorSubject&lt;FileResponse&gt;&gt; _memCache;</span><br><span class="line">  <span class="keyword">final</span> Queue&lt;QueueItem&gt; _queue = Queue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">///Download the file from the url</span></span><br><span class="line">  Stream&lt;FileResponse&gt; downloadFile(<span class="built_in">String</span> url,</span><br><span class="line">      &#123;<span class="built_in">String</span> key,</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; authHeaders,</span><br><span class="line">      <span class="built_in">bool</span> ignoreMemCache = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    key ??= url;</span><br><span class="line">    <span class="keyword">if</span> (!_memCache.containsKey(key) || ignoreMemCache) &#123;</span><br><span class="line">      <span class="keyword">var</span> subject = BehaviorSubject&lt;FileResponse&gt;();</span><br><span class="line">      _memCache[key] = subject;</span><br><span class="line">      <span class="comment">/// 下载或者加入队列</span></span><br><span class="line">      unawaited(_downloadOrAddToQueue(url, key, authHeaders));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _memCache[key].stream;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _downloadOrAddToQueue(</span><br><span class="line">    <span class="built_in">String</span> url,</span><br><span class="line">    <span class="built_in">String</span> key,</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; authHeaders,</span><br><span class="line">  ) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//如果太多请求被执行，加入队列等待</span></span><br><span class="line">    <span class="keyword">if</span> (concurrentCalls &gt;= fileFetcher.concurrentFetches) &#123;</span><br><span class="line">      _queue.add(QueueItem(url, key, authHeaders));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    concurrentCalls++;</span><br><span class="line">    <span class="keyword">var</span> subject = _memCache[key];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> result</span><br><span class="line">          <span class="keyword">in</span> _updateFile(url, key, authHeaders: authHeaders)) &#123;</span><br><span class="line">        subject.add(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stackTrace) &#123;</span><br><span class="line">      subject.addError(e, stackTrace);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      concurrentCalls--;</span><br><span class="line">      <span class="keyword">await</span> subject.close();</span><br><span class="line">      _memCache.remove(key);</span><br><span class="line">      _checkQueue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">///下载资源</span></span><br><span class="line">  Stream&lt;FileResponse&gt; _updateFile(<span class="built_in">String</span> url, <span class="built_in">String</span> key,</span><br><span class="line">      &#123;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; authHeaders&#125;) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">var</span> cacheObject = <span class="keyword">await</span> _store.retrieveCacheData(key);</span><br><span class="line">    cacheObject = cacheObject == <span class="keyword">null</span></span><br><span class="line">        ? CacheObject(url, key: key)</span><br><span class="line">        : cacheObject.copyWith(url: url);</span><br><span class="line">    <span class="comment">/// 请求得到response</span></span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> _download(cacheObject, authHeaders);</span><br><span class="line">    <span class="keyword">yield</span>* _manageResponse(cacheObject, response);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  Stream&lt;FileResponse&gt; _manageResponse(</span><br><span class="line">      CacheObject cacheObject, FileServiceResponse response) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    <span class="keyword">if</span> (statusCodesNewFile.contains(response.statusCode)) &#123;</span><br><span class="line">      <span class="built_in">int</span> savedBytes;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> progress <span class="keyword">in</span> _saveFile(newCacheObject, response)) &#123;</span><br><span class="line">        savedBytes = progress;</span><br><span class="line">        <span class="keyword">yield</span> DownloadProgress(</span><br><span class="line">            cacheObject.url, response.contentLength, progress);</span><br><span class="line">      &#125;</span><br><span class="line">      newCacheObject = newCacheObject.copyWith(length: savedBytes);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/// 加入缓存</span></span><br><span class="line">    unawaited(_store.putFile(newCacheObject).then((_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newCacheObject.relativePath != oldCacheObject.relativePath) &#123;</span><br><span class="line">        _removeOldFile(oldCacheObject.relativePath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> file = <span class="keyword">await</span> _store.fileSystem.createFile(</span><br><span class="line">      newCacheObject.relativePath,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">yield</span> FileInfo(</span><br><span class="line">      file,</span><br><span class="line">      FileSource.Online,</span><br><span class="line">      newCacheObject.validTill,</span><br><span class="line">      newCacheObject.url,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; _saveFile(CacheObject cacheObject, FileServiceResponse response) &#123;</span><br><span class="line">    <span class="keyword">var</span> receivedBytesResultController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    unawaited(_saveFileAndPostUpdates(</span><br><span class="line">      receivedBytesResultController,</span><br><span class="line">      cacheObject,</span><br><span class="line">      response,</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> receivedBytesResultController.stream;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Future _saveFileAndPostUpdates(</span><br><span class="line">      StreamController&lt;<span class="built_in">int</span>&gt; receivedBytesResultController,</span><br><span class="line">      CacheObject cacheObject,</span><br><span class="line">      FileServiceResponse response) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">/// 根据路径创建file</span></span><br><span class="line">    <span class="keyword">final</span> file = <span class="keyword">await</span> _store.fileSystem.createFile(cacheObject.relativePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> receivedBytes = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/// 写文件</span></span><br><span class="line">      <span class="keyword">final</span> sink = file.openWrite();</span><br><span class="line">      <span class="keyword">await</span> response.content.map((s) &#123;</span><br><span class="line">        receivedBytes += s.length;</span><br><span class="line">        receivedBytesResultController.add(receivedBytes);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;).pipe(sink);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stacktrace) &#123;</span><br><span class="line">      receivedBytesResultController.addError(e, stacktrace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> receivedBytesResultController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>cached_network_image</code>图片加载流程依赖<code>ImageProvider</code>，缓存和下载逻辑放在另一个库<code>flutter_cache_manager</code>下载文件在<code>WebHelper</code>中提供队列管理，依赖传入<code>FileService</code>做具体获取文件方便扩展默认实现<code>HttpFileService</code>，下载完成后路径保存在<code>CacheObject</code>保存在<code>sqflite</code>数据库</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;p&gt;组件&lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fcached_network_image&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CachedNetworkImage&lt;/a&gt;可以支持直接使用或者通过&lt;code&gt;ImageProvider&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引入依赖&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;dependencies:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  cached_network_image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;^3.1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行&lt;code&gt;flutter pub get&lt;/code&gt;，项目中使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Import it&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;package:cached_network_image/cached_network_image.dart&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;添加占位图&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CachedNetworkImage(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        imageUrl: &lt;span class=&quot;string&quot;&gt;&quot;http://via.placeholder.com/350x150&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        placeholder: (context, url) =&amp;gt; CircularProgressIndicator(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errorWidget: (context, url, error) =&amp;gt; Icon(Icons.error),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ),&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;进度条展示&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CachedNetworkImage(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        imageUrl: &lt;span class=&quot;string&quot;&gt;&quot;http://via.placeholder.com/350x150&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        progressIndicatorBuilder: (context, url, downloadProgress) =&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                CircularProgressIndicator(value: downloadProgress.progress),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errorWidget: (context, url, error) =&amp;gt; Icon(Icons.error),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ),&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter" scheme="https://zhangmiao.cc/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>北京环球影城游玩攻略</title>
    <link href="https://zhangmiao.cc/posts/cf2918cf.html"/>
    <id>https://zhangmiao.cc/posts/cf2918cf.html</id>
    <published>2021-09-23T02:13:35.000Z</published>
    <updated>2021-12-24T02:05:30.001Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s3.bmp.ovh/imgs/2021/09/0ebc0f368298bf55.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://s3.bmp.ovh/imgs/2021/09/0ebc0f368298bf55.jpeg&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《批判性思维》随笔记</title>
    <link href="https://zhangmiao.cc/posts/7bd80167.html"/>
    <id>https://zhangmiao.cc/posts/7bd80167.html</id>
    <published>2021-09-11T02:48:07.000Z</published>
    <updated>2021-12-24T02:05:30.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><p>然而在这样一个信息过载的时代里，形形色色的声音与观点鱼龙混杂。生活在信息洪流中的我们，应该如何避免随波逐流，做到真正的独立思考？</p><p>或许可以了解一下“CriticalThinking”——「批判性思维」。</p><h2 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h2><p>批判性思维是以一种<strong>合理的、反思的、心灵开放的方式进行思考</strong>，从而能够清晰准确地表达、逻辑严谨地推理、合理地论证，以及培养思辨精神。</p><p>在批判性思维的情感倾向方面，科南特(J．Kurland)于1995年提出：批判性思维与<strong>过分情感主义、智力懒惰和封闭思维相反</strong>，它关注<strong>证据、智力、诚实和开放思维</strong>。因此批判性思维强调依靠证据而非情感，<strong>全面考虑各种可能的观点和解释，警惕个人动机和偏见的影响，更关注寻求真理，不拒绝非流行的观点，意识到自己的偏见、歧视，自觉避免或减少这些偏见对判断的影响</strong>。此外，具有批判性思维并不意味着总是对任何人和任何事持否定态度和吹毛求疵，<strong>批判精神意味着敏锐的思维、好奇的探究、对推理的热情、对可靠信息的渴望。</strong></p><a id="more"></a><h2 id="How"><a href="#How" class="headerlink" title="How?"></a>How?</h2><p>当我们面对外界信息或是他人的论证时，可以在脑海里思考这些问题：</p><ul><li>准确地说, 它的中心议题和观点是什么？</li><li>我全部同意、部分同意还是不认同它的观点？为什么？</li><li>它的结论实际上是建立在某种假设上吗？如果是，这假设合理吗？</li><li>它的结论是否仅在某些条件下有效，如果是，那是什么？</li><li>我需要限定或解释论述中的关键词语的意思吗？</li><li>什么样的理由支持我采取这样的立场？</li><li>对方会用什么样的理由来反驳或削弱我的立场？</li><li>我该怎样承认或反驳他们的观点？</li></ul><p>当我们需要表达自己的观点、建构自己的论证时，可以遵循以下的方法：</p><ul><li>确定问题，理清概念，有目的性思考；</li><li>针对这个问题，明确有哪些不同角度的论点和看法（这些角度有何不同？是否存在相应的理论或框架？如何利用这些不同的观点来解释问题？）；</li><li>从不同的角度、正反两方面来评估论点和论据（信息是否可靠？是否切题、相关？是否充足，是否存在偏见或不合理的隐含假设等）；</li><li>综合不同角度的思考，得出自己的结论（并反思自己的理由是否相关、充足？是否存在偏见？有何优势和劣势等）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Why&quot;&gt;&lt;a href=&quot;#Why&quot; class=&quot;headerlink&quot; title=&quot;Why?&quot;&gt;&lt;/a&gt;Why?&lt;/h2&gt;&lt;p&gt;然而在这样一个信息过载的时代里，形形色色的声音与观点鱼龙混杂。生活在信息洪流中的我们，应该如何避免随波逐流，做到真正的独立思考？&lt;/p&gt;
&lt;p&gt;或许可以了解一下“CriticalThinking”——「批判性思维」。&lt;/p&gt;
&lt;h2 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;What?&quot;&gt;&lt;/a&gt;What?&lt;/h2&gt;&lt;p&gt;批判性思维是以一种&lt;strong&gt;合理的、反思的、心灵开放的方式进行思考&lt;/strong&gt;，从而能够清晰准确地表达、逻辑严谨地推理、合理地论证，以及培养思辨精神。&lt;/p&gt;
&lt;p&gt;在批判性思维的情感倾向方面，科南特(J．Kurland)于1995年提出：批判性思维与&lt;strong&gt;过分情感主义、智力懒惰和封闭思维相反&lt;/strong&gt;，它关注&lt;strong&gt;证据、智力、诚实和开放思维&lt;/strong&gt;。因此批判性思维强调依靠证据而非情感，&lt;strong&gt;全面考虑各种可能的观点和解释，警惕个人动机和偏见的影响，更关注寻求真理，不拒绝非流行的观点，意识到自己的偏见、歧视，自觉避免或减少这些偏见对判断的影响&lt;/strong&gt;。此外，具有批判性思维并不意味着总是对任何人和任何事持否定态度和吹毛求疵，&lt;strong&gt;批判精神意味着敏锐的思维、好奇的探究、对推理的热情、对可靠信息的渴望。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 2.5 重大改版发布</title>
    <link href="https://zhangmiao.cc/posts/1a5e05d8.html"/>
    <id>https://zhangmiao.cc/posts/1a5e05d8.html</id>
    <published>2021-09-10T09:52:17.000Z</published>
    <updated>2021-12-24T02:05:30.001Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20210910181120.png" alt></p><blockquote><p>原文链接 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fwhats-new-in-flutter-2-5-6f080c3f3dc" target="_blank" rel="noopener">medium.com/flutter/wha…</a></p></blockquote><p><strong>Flutter 2.5 是 Flutter 版本历史上排名第二的大版本更新</strong>，该版本：</p><ul><li>关闭了 4600 个 issues；</li><li>合并了 252 contributors 和 216 reviewers 的 3932 个 PR；</li></ul><p>回顾过去一年，可以看到有 1337 位 contributors 创建了 21,072 个 PR 这样庞大的数据，其中有15,172 个被合并。</p><p>事实上该版本依然是对性能和开发工具进行了改进，同时还有增加许多新功能，包括：</p><ul><li>对 Android 的全屏支持、更多 Material You（也称为 v3）支持；</li><li>更新文本编辑功能以支持可切换的键盘快捷键；</li><li>Widget Inspector 可查阅更多详细信息；</li><li>Visual Studio Code 项目中对添加依赖项增加新的支持；</li><li>IntelliJ/Android Studio 中新增测试运行获取覆盖率信息；</li><li>一个全新的应用程序模板，为 Flutter 应用程序提供更好的开发基础；</li></ul><a id="more"></a><h2 id="性能：iOS-着色器预热、异步任务、GC-和消息传递"><a href="#性能：iOS-着色器预热、异步任务、GC-和消息传递" class="headerlink" title="性能：iOS 着色器预热、异步任务、GC 和消息传递"></a>性能：iOS 着色器预热、异步任务、GC 和消息传递</h2><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F25644" target="_blank" rel="noopener">#25644</a> 中的第一个 PR 就是<strong>用于离线训练运行 Metal 着色器预编译</strong>，如基准测试所示，它将最坏情况的帧光栅化时间减少了 2/3 秒，将第 99 个百分位帧减少了一半。</p><p>然而着色器预热只是卡顿的来源之一，在<strong>之前的版本处理来自网络、文件系统、插件或其他 isolate 的异步事件都可能会中断动画</strong>，这是另一个卡顿的来源。</p><p>所以 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F25789" target="_blank" rel="noopener">#25789</a> 改进了调度策略，在此版本 isolate 的 UI 事件循环里，帧处理现在优先于处理其他异步事件，从而在测试中消除了此类的卡顿。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af9df2fd08b54e79b81ba0dc11fb9e23~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>另一个导致卡顿的原因是<strong>垃圾收集器 (GC) 暂停 UI 线程以回收内存</strong>。</p><p>以前某些图像的内存在响应 Dart VM 的 GC 执行时会延迟回收，作为早期版本中的解决方法，Flutter 引擎会通过 Dart VM 的 GC 回收暗示图像内存可以回收，这在理论上可以实现了更及时的内存回收。</p><p>不幸的是这也导致了太多的主要 GC，并且有时仍然无法足够快地回收内存，以避免内存受限设备上的低内存情况，而<strong>在这个版本中未使用的图像的内存被急切地回收</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F26219" target="_blank" rel="noopener">#26219</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F82883" target="_blank" rel="noopener">#82883</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F84740" target="_blank" rel="noopener">#84740</a>），大大减少了 GC。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/caf1e11cf9c3482080a5246abe892b94~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>例如在一项测试用例中，<strong>播放 20 秒动画 GIF 从需要 400 多次 GC 变为只需要 4 次</strong>，更少的主要 GC 意味着涉及图像出现和消失的动画将减少卡顿，并消耗更少的 CPU 和功率。</p><p>Flutter 2.5 的另一个性能改进是在 <strong>Dart 和 Objective-C/Swift (iOS) 或 Dart 和 Java/Kotlin (Android) 之间发送消息时的延迟。</strong></p><p>通常作为<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1oNLxJr_ZqjENVhF94-PqxsGPx0qGXx-pRJxXL6LSagc%2Fedit%23heading%3Dh.9gabvat7tlxf" target="_blank" rel="noopener">调整</a> 消息频道的一部分，从消息编解码器中删除不必要的副本可将延迟减少高达 50% ，当然具体取决于消息大小和设备（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F25988" target="_blank" rel="noopener">#25988</a>，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F26331" target="_blank" rel="noopener">#26331</a>）。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/265c291001d742d4ad2a91d23d6b3591~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><blockquote><p>你可以在此链接获取到更多关于平台通道性能的信息： <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fimproving-platform-channel-performance-in-flutter-e5b4e5df04af" target="_blank" rel="noopener">medium.com/flutter/imp…</a></p></blockquote><h2 id="Dart-2-14：格式、语言特性、发布和-linting-开箱即用"><a href="#Dart-2-14：格式、语言特性、发布和-linting-开箱即用" class="headerlink" title="Dart 2.14：格式、语言特性、发布和 linting 开箱即用"></a>Dart 2.14：格式、语言特性、发布和 linting 开箱即用</h2><p>此版本的 Flutter 和 Dart 2.14 一起发布。</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40mit.mit%2Fannouncing-dart-2-14-b48b9bb2fb67" target="_blank" rel="noopener">新版本的 Dart</a> 带有新的格式，使<a href="https://link.juejin.cn?target=https%3A%2F%2Fdart.dev%2Fguides%2Flanguage%2Flanguage-tour%23cascade-notation" target="_blank" rel="noopener">级联</a> 更加清晰，<strong>新的 pub 支持忽略文件，以及新的语言功能，包括三重移位运算符的回归</strong>。</p><p><strong>此外 Dart 2.14 创建了一组标准的 lint，在新的 Dart 和 Flutter 项目之间共享，开箱即用</strong>。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4684d1ffe484ad2bb19bfa73c812bc7~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>开发者不仅会在创建新的 Dart 或 Flutter 项目时获得这些 lint，而且只需几个步骤就可以将相同的分析添加到现有应用程序中。</p><blockquote><p>合并迁移lint：<a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Frelease%2Fbreaking-changes%2Fflutter-lints-package%23migration-guide" target="_blank" rel="noopener">flutter.dev/docs/releas…</a></p><p>有关这些 lint 的详细信息、新语言功能等，请查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fdartlang%2Fannouncing-dart-2-13-c6d547b57067" target="_blank" rel="noopener">medium.com/dartlang/an…</a></p></blockquote><h2 id="Framework：Android-全屏、Material-You-amp-文本编辑快捷方式"><a href="#Framework：Android-全屏、Material-You-amp-文本编辑快捷方式" class="headerlink" title="Framework：Android 全屏、Material You &amp; 文本编辑快捷方式"></a>Framework：Android 全屏、Material You &amp; 文本编辑快捷方式</h2><p>从 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F81303" target="_blank" rel="noopener">#81303</a> 开始, <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F81303" target="_blank" rel="noopener">我们修复了 Android 一系列与全屏模式相关的问题</a>，此更改还添加了一种在其他模式下收听全屏更改的方法。</p><blockquote><p>例如用户与应用互动时，当系统 UI 返回时，<strong>开发人员现在可以编写代码在返回全屏时执行其他操作</strong>。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/219be089ceb4401b9db96504f7fae782~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><blockquote><p><em>新的 Android 全屏模式：普通模式（左）、边到边模式（中）、带有自定义 SystemUIOverlayStyle 的边到边（右）</em></p></blockquote><p>在此版本中，我们对新 Material You（又名 v3）的规范增加了支持，<strong>包括对浮动操作按钮大小和主题的更新</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F86441" target="_blank" rel="noopener">#86441</a>），在<code>MaterialState.scrolledUnder</code> 可以使用 Demo 中的示例代码查看的新状态 PR 式例 ( <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F79999" target="_blank" rel="noopener">#79999</a> )。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d473dd316248447c9e10ab71a8f29537~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/905298291fc941689658b4ef94fcc4b3~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><blockquote><p><em>新的 MaterialState.scrolledUnder 状态在起作用</em></p></blockquote><p>另一个改进是<strong>添加了 scroll metrics notifications</strong>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F85221" target="_blank" rel="noopener">#85221</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F85499" target="_blank" rel="noopener">#85499</a>），即使用户没有滚动，它也会提供可滚动区域的通知，例如下面显示了 <code>ListView</code> 根据的基础大小适当地出现或消失滚动条：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef7ff30a75e144ed8a7c724dee8fb5dd~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>在这种情况下不必编写任何代码，但如果想捕获 <code>ScrollMetricNotification</code> 更改，则可以通过此监听来完成。</p><blockquote><p>特别感谢社区贡献者<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxu-baolin" target="_blank" rel="noopener">xu-baoolin</a>，他为此付出了努力并提出了一个很好的解决方案。</p></blockquote><p>另一个出色的社区贡献是为 <code>ScaffoldMessenger</code> ， 你可能还记得 Flutter 2.0 开始 <code>ScaffoldMessenger</code> 作为一个更强大的方式来显示 <code>SnackBars</code> ， 在屏幕的底部为用户提供通知，而在 <strong>Flutter 2.5 中，现在可以在 <code>Scaffold</code> 的顶部添加一个横幅</strong>，该横幅会一直保持到用户关闭它为止。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3aa064f9022c4ba2a21844ba5d8d93e3~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>应用程序可以通过调用以下 <code>showMaterialBanner</code> 方法来获得此行为 <code>ScaffoldMessenger</code> ：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HomePage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">'The MaterialBanner is below'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: ElevatedButton(</span><br><span class="line">            child: <span class="keyword">const</span> Text(<span class="string">'Show MaterialBanner'</span>),</span><br><span class="line">            onPressed: () =&gt; ScaffoldMessenger.of(context).showMaterialBanner(</span><br><span class="line">              MaterialBanner(</span><br><span class="line">                content: <span class="keyword">const</span> Text(<span class="string">'Hello, I am a Material Banner'</span>),</span><br><span class="line">                leading: <span class="keyword">const</span> Icon(Icons.info),</span><br><span class="line">                backgroundColor: Colors.yellow,</span><br><span class="line">                actions: [</span><br><span class="line">                  TextButton(</span><br><span class="line">                    child: <span class="keyword">const</span> Text(<span class="string">'Dismiss'</span>),</span><br><span class="line">                    onPressed: () =&gt; ScaffoldMessenger.of(context)</span><br><span class="line">                        .hideCurrentMaterialBanner(),</span><br><span class="line">                  ),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmaterial.io%2Fcomponents%2Fbanners%23usage" target="_blank" rel="noopener">Material 指南规定</a> 开发者的应用<a href="https://link.juejin.cn?target=https%3A%2F%2Fmaterial.io%2Fcomponents%2Fbanners%23usage" target="_blank" rel="noopener">横幅</a>一次只能显示一个，因此如果你调用多次 <code>showMaterialBanner</code>，<code>ScaffoldMessenger</code> 它将维护一个队列，在前一个横幅已被关闭之后，再显示一个新横幅。</p><blockquote><p>感谢 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCalamity210" target="_blank" rel="noopener">Calamity210</a> 对 Flutter 中的 Material 支持做出了如此出色的补充！</p></blockquote><p>在此版本中，我们添加了<strong>文本编辑键盘快捷键可覆盖的功能</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F85381" target="_blank" rel="noopener">#85381</a>，这是在 Flutter 2.0 及其新的文本编辑功能的基础上进一步构建，例如文本选择以及能够在处理键盘事件后停止它的传播。</p><blockquote><p>如果您希望 <strong>Ctrl-A</strong> 执行一些自定义操作而不是选择所有文本。</p></blockquote><p><code>DefaultTextEditingShortcuts</code> 类包含每个平台上受支持的键盘快捷键列表，如果开发者想覆盖任何内容，可以使用 Flutter 的现有 <code>Shortcuts</code> 将任何快捷方式重新映射到现有或自定义意图。</p><blockquote><p>API 参考: <a href="https://link.juejin.cn?target=https%3A%2F%2Fapi.flutter.dev%2Fflutter%2Fwidgets%2FDefaultTextEditingShortcuts-class.html" target="_blank" rel="noopener">api.flutter.dev/flutter/wid…</a></p></blockquote><h2 id="插件：相机、图像选择器和-plus-插件"><a href="#插件：相机、图像选择器和-plus-插件" class="headerlink" title="插件：相机、图像选择器和 plus 插件"></a>插件：相机、图像选择器和 plus 插件</h2><p>另一个具有有很多改进的插件是<a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fcamera" target="_blank" rel="noopener">相机插件</a>：</p><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F3795" target="_blank" rel="noopener">#3795</a> [相机] android-rework 第 1 部分：支持 Android 相机功能的基类</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F3796" target="_blank" rel="noopener">#3796</a> [相机] android-rework 第 2 部分：Android 自动对焦功能</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F3797" target="_blank" rel="noopener">#3797</a> [camera] android-rework part 3：Android曝光相关功能</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F3798" target="_blank" rel="noopener">#3798</a> [相机] android-rework 第 4 部分：Android 闪光和变焦功能</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F3799" target="_blank" rel="noopener">#3799</a> [相机] android-rework 第 5 部分：Android FPS 范围、分辨率和传感器方向功能</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4039" target="_blank" rel="noopener">#4039</a> [相机] android-rework 第 6 部分：Android 曝光和焦点功能</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4052" target="_blank" rel="noopener">#4052</a> [camera] android-rework part 7：Android降噪功能</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4054" target="_blank" rel="noopener">#4054</a> [相机] android-rework 第 8 部分：最终实现的支持模块</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4010" target="_blank" rel="noopener">#4010</a> [camera] 在 iOS 上不触发设备方向</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4158" target="_blank" rel="noopener">#4158</a> [相机] 修复坐标旋转以在 iOS 上设置焦点和曝光点</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4197" target="_blank" rel="noopener">#4197</a> [相机] 修复相机预览并不总是在方向改变时重建</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F3992" target="_blank" rel="noopener">#3992</a> [camera] 设置不受支持的 FocusMode 时防止崩溃</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4151" target="_blank" rel="noopener">#4151</a> [camera] 引入camera_web包</li></ul><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fimage_picker" target="_blank" rel="noopener">image_picker 插件</a> 也做了很多工作，专注于端到端的相机体验：</p><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F3898" target="_blank" rel="noopener">#3898</a> [image_picker] 图像选择器修复相机设备</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F3956" target="_blank" rel="noopener">#3956</a> [image_picker] 将相机捕获的存储位置更改为 Android 上的内部缓存，以符合新的 Google Play 存储要求</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4001" target="_blank" rel="noopener">#4001</a> [image_picker] 删除了对相机权限的冗余请求</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4019" target="_blank" rel="noopener">#4019</a> [image_picker] 当相机是 source 时修复旋转</li></ul><p>这项工作改进了 Android 的相机和 image_picker 插件的功能和稳健性。</p><p>此外你会注意到 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fcamera_web" target="_blank" rel="noopener">摄像头插件</a> 的早期版本可用于网络支持 ( <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fplugins%2Fpull%2F4151" target="_blank" rel="noopener">#4151</a> )。</p><p>此预览为在 Web 上查看相机预览、拍照、使用闪光灯和缩放控件提供基本支持，它目前还不是被<a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Fdevelopment%2Fpackages-and-plugins%2Fdeveloping-packages%23endorsed-federated-plugin" target="_blank" rel="noopener">认可的插件</a>，因此您需要<a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fcamera_web%2Finstall" target="_blank" rel="noopener">明确添加它</a>以在才能在 web 中使用。</p><blockquote><p>详细内容: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fcamera_web%2Finstall" target="_blank" rel="noopener">pub.dev/packages/ca…</a></p></blockquote><p>在此版本的 Flutter 中，Flutter 团队的每个相应插件现在都带有一个类似 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fbattery" target="_blank" rel="noopener">电池</a> 的建议：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cfd3fcea6564e349cab83bb1aacdc63~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>此外，由于这些插件不再被积极维护，它们不再被标记为 Flutter 最喜欢的插件，我们建议使用以下插件的 plus 版本：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4e8916b678048188abdfe31e7fbed24~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h2 id="Flutter-DevTools：性能、Widget-检查器和-Polish"><a href="#Flutter-DevTools：性能、Widget-检查器和-Polish" class="headerlink" title="Flutter DevTools：性能、Widget 检查器和 Polish"></a>Flutter DevTools：性能、Widget 检查器和 Polish</h2><p>首先最重要的是 DevTools 中增加利用引擎更新的支持（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F26205" target="_blank" rel="noopener">#26205</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F26233" target="_blank" rel="noopener">#26233</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F26237" target="_blank" rel="noopener">#26237</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F26970" target="_blank" rel="noopener">#26970</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F27074" target="_blank" rel="noopener">#27074</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F26617" target="_blank" rel="noopener">#26617</a>）。</p><p>其中一组更新使 <strong>Flutter 能够更好地将跟踪事件与特定框架相关联</strong>，这有助于开发人员确定框架可能超出预算的原因。</p><p>可以在 DevTools Frames 图表中看到这一点，该图表已被重建为“实时”，可以在应用程序呈现时填充在此图表中，从此图表中选择一个帧导航到该帧的时间线事件：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c251725fc944474fa1c9abe32f9bc5f7~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>Flutter 引擎现在还可以识别时间线中的着色器编译事件，Flutter DevTools 使用这些事件来帮助诊断应用程序中的着色器编译卡顿。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/235651f95d6a4ba4adcee7ca1e7b22de~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>借助这项新功能，DevTools 会检测何时因着色器编译丢失帧，以便可以解决卡顿问题。</p><p>在 <code>flutter run</code> 时与 <code>--purge-persistent-cache</code> 标志一起使用，这会清除缓存以确保重现用户在 “首次运行” 或 “重新打开” (iOS) 体验中看到的环境。</p><blockquote><p>此功能仍在开发中，如果有任何问题，可以查阅：<a href="https://link.juejin.cn?target=https%3A%2F%2Fb.corp.google.com%2Fissues%2Fnew%3Fcomponent%3D775375%26template%3D1369639" target="_blank" rel="noopener">b.corp.google.com/issues/new?…</a></p></blockquote><p>此外跟踪应用程序中的 CPU 性能问题时，可能会被来自 Dart 和 Flutter 库或引擎本机代码的分析数据淹没，如果想关闭其中任何一个以专注于您自己的代码，您可以<strong>使用新的 CPU Profiler 功能 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F3236" target="_blank" rel="noopener">#3236</a> 来实现，该功能可以从这些来源中隐藏分析器信息</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b09c42d4d54e81a82a65c86f058b7d~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>对于没有过滤掉的任何类别，它们现在已经进行了颜色编码（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F3310" target="_blank" rel="noopener">#3310</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fdevtools%2Fpull%2F3324" target="_blank" rel="noopener">#3324</a>），以便可以轻松查看 <strong>CPU 帧图表来自系统的哪些部分</strong>。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/088ef306a2db4947a8700c3777464513~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><blockquote><p>彩色框架图，用于识别应用中的应用、原生、Dart 和 Flutter 代码活动</p></blockquote><p>性能并不时调试的唯一因素，此版本的 DevTools 附带了对 Widget Inspector 的更新，<strong>允许将鼠标悬停在 Widget 时评估对象、视图属性、小部件状态等</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d5ba984533f4d5ab2f1379adf9711a7~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>而当选择一个 Widget 时，它会自动填充在新的小部件检查器控制台中，这样就可以在其中浏览 Widget 的属性。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64a41be71b7b4d3dad2845135e5b9d6b~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p><strong>在断点处暂停时还可以从控制台计算表达式</strong>。</p><p>除了新功能外 Widget Inspector 还进行了翻新，为了让 DevTools 成为了解和调试 Flutter 应用程序的更有用，我们与芬兰的一家创意技术机构<a href="https://link.juejin.cn?target=https%3A%2F%2Fcodemate.com%2F" target="_blank" rel="noopener">Codemate</a>合作进行了一些更新。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90e6c4d7528c4c5084f446e4a9d724bc~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>在此屏幕截图中可以看到以下更改：</p><ul><li><strong>更好地传达调试切换按钮的作用</strong>——这些按钮具有新图标、面向任务的标签，以及描述它们的作用和何时使用它们的丰富工具提示，每个工具提示进一步链接到该功能的详细文档。</li><li><strong>更容易扫描和定位感兴趣的 Widgets</strong>——Flutter 框架中常用的 Widget 现在在检查器左侧的 Widget 树视图中显示图标，它们根据类别进一步进行颜色编码，例如布局 Widget 显示为蓝色，而内容Widget 显示为绿色。此外每个文本 Widget 现在显示其内容的预览。</li><li><strong>对齐布局资源管理器和小部件树的配色方案</strong>- 现在可以更轻松地从布局资源管理器和 Widget 树中识别相同的 Widget。例如屏幕截图中的“列” Widget 位于布局浏览器中的蓝色背景上，并且在 Widget 树视图中具有蓝色图标。</li></ul><h2 id="IntelliJ-Android-Studio：集成测试、测试覆盖率和图标预览"><a href="#IntelliJ-Android-Studio：集成测试、测试覆盖率和图标预览" class="headerlink" title="IntelliJ/Android Studio：集成测试、测试覆盖率和图标预览"></a>IntelliJ/Android Studio：集成测试、测试覆盖率和图标预览</h2><p>Flutter 的 IntelliJ/Android Studio 插件在此版本中也进行了许多改进，首先是运行集成测试的能力 ( <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter-intellij%2Fpull%2F5459" target="_blank" rel="noopener">#5459</a> )。</p><p>集成测试是在设备上运行的整个应用程序测试，位于 integration_test 目录中，并使用与<code>testWidgets()</code> 单元测试相同的功能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee0ae860aedd42ab9a3b9f2a5d80b9fa~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>要将集成测试添加到项目，请 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Ftesting%2Fintegration-tests" target="_blank" rel="noopener">按照 flutter.dev 上的说明进行操作</a>，要将测试与 IntelliJ 或 Android Studio 连接，请添加启动集成测试的运行配置并连接设备以供测试使用，运行配置可以让开发者运行测试，包括设置断点、步进等。</p><p>此外，Flutter 最新的 IJ/AS 插件允许查看单元测试和集成测试运行的覆盖率信息，可以从“调试”按钮旁边的工具栏按钮访问它：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fb75f257cfc488c9a2c2dfebd9b6957~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>覆盖信息在编辑器的装订线中使用红色和绿色条显示，在这个例子中第 9-13 行被测试，但第 3 和 4 行没有被测试。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa4fd00528ed4fbb8ed45b781ac113d2~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>最新版本还包括预览来自 pub.dev 包中使用的图标的新功能，这些包是围绕 TrueType 字体文件（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter-intellij%2Fpull%2F5504" target="_blank" rel="noopener">#5504</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter-intellij%2Fpull%2F5595" target="_blank" rel="noopener">#5595</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter-intellij%2Fpull%2F5677" target="_blank" rel="noopener">#5677</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter-intellij%2Fpull%2F5704" target="_blank" rel="noopener">#5704</a>）构建的，就像 Material 和 Cupertino 图标支持预览一样。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/623184eee8b24d57b4176aafb181879a~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>要启用图标预览，您需要告诉插件您正在使用哪些软件包，settings/preferences 中有一个新的文本字段：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ad59f02d8a84b73b86bc1fe8b316bd9~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>请注意，如屏幕截图中的示例代码所示，此设置仅适用于在类中定义为静态常量的图标，它不适用于表达式，例如 <code>LineIcons.addressBook()</code> or <code>LineIcons.values[&#39;code&#39;]</code> 。</p><h2 id="Visual-Studio-Code：依赖项、Fix-All-和-Test-Runner"><a href="#Visual-Studio-Code：依赖项、Fix-All-和-Test-Runner" class="headerlink" title="Visual Studio Code：依赖项、Fix All 和 Test Runner"></a>Visual Studio Code：依赖项、Fix All 和 Test Runner</h2><p>Flutter 的 Visual Studio Code 插件也在此版本中得到了改进，两个新命令 “Dart: Add Dependency” and “Dart: Add Dev Dependency” (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDart-Code%2FDart-Code%2Fissues%2F3306" target="_blank" rel="noopener">#3306</a>, <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDart-Code%2FDart-Code%2Fissues%2F3474" target="_blank" rel="noopener">#3474</a>)。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cacc50458fbf4a8ea4158c37bce573c0~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>这些命令提供的功能类似于<a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Djeroen-meijer.pubspec-assist" target="_blank" rel="noopener">Jeroen Meijer 的 Pubspec Assist 插件</a>，新命令开箱即用，并提供定期从 pub.dev 获取的包类型过滤列表。</p><p>开发者可能还对适用于 Dart 文件的“Fix All”命令（<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDart-Code%2FDart-Code%2Fissues%2F3445" target="_blank" rel="noopener">#3445</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDart-Code%2FDart-Code%2Fissues%2F3469" target="_blank" rel="noopener">#3469</a>）感兴趣，并且可以一步修复所有与<a href="https://link.juejin.cn?target=https%3A%2F%2Fdart.dev%2Ftools%2Fdart-fix" target="_blank" rel="noopener">dart fix</a>相同的问题。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b64fed76e81d4f2aa596cc1f99f5b0d0~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>这也可以通过添加 <code>source.fixAll</code> 到 <code>editor.codeActionsOnSave</code> 的 VS Code 设置来设置为在保存时运行，或者想尝试预览功能，可以启用该 <code>dart.previewVsCodeTestRunner</code> 设置并查看通过新的 Visual Studio Code 测试运行程序运行的 Dart 和 Flutter 测试。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d760bf0332e8447090e8aff9e4e8d358~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>Visual Studio Code 测试运行器看起来与当前的 Dart 和 Flutter 测试运行器略有不同，它将跨会话保留结果。Visual Studio Code 测试运行器还添加了新的装订线图标，显示测试的最后状态，可以单击以运行测试（或右键单击以获取上下文菜单）。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0a5dfbac48b43e9b48669c0efe3e9a4~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>在即将发布的版本中，现有的 Dart 和 Flutter 测试运行器将被移除，以支持新的 Visual Studio Code 测试运行器。</p><h2 id="工具：异常、新应用模板和-Pigeon-1-0"><a href="#工具：异常、新应用模板和-Pigeon-1-0" class="headerlink" title="工具：异常、新应用模板和 Pigeon 1.0"></a>工具：异常、新应用模板和 Pigeon 1.0</h2><p>在此版本中，调试器现在可以在未处理的异常上正确中断，而这些异常以前时被 framework 捕获 ( <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F17007" target="_blank" rel="noopener">#17007</a> )。</p><p>这改善了调试体验，<strong>因为调试器现在可以直接指向他们在代码中的抛出行，而不是指向框架深处的随机行。</strong></p><p>一个相关的新功能使开发者能够决定 FutureBuilder 是否应该重新抛出或吞下错误 (<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F84308" target="_blank" rel="noopener">#84308</a>），这应该会为开发者提供大量额外的例外情况，以帮助追踪 Flutter 应用程序中的问题。</p><p>自 Flutter 诞生以来，就出现了 Counter 应用模板，它具有许多优点：</p><ul><li>它展示了 Dart 语言的许多特性；</li><li>展示了几个关键的 Flutter 概念，并且它足够小；</li><li>可以放入单个文件中，即使有很多的解释性评论；</li></ul><p>然而它没有为Flutter 应用程序提供一个特别好的起点，在此版本中，通过以下命令提供了一个新模板 ( <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F83530" target="_blank" rel="noopener">#83530</a> )：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter create -t skeleton my_app</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da738d001d44f7d9fb7811691ba31cf~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>骨架模板生成一个遵循社区最佳实践的两页列表视图，它的开发经过大量内部和外部审查，为构建生产质量应用程序提供了更好的基础，并支持以下功能：</p><ul><li>用于 <code>ChangeNotifier</code> 协调多个 Widget</li><li>默认情况下使用 arb 文件生成本地化</li><li>包括示例图像并为图像资产建立 1x、2x 和 3x 文件夹</li><li>使用“功能优先”的文件夹组织</li><li>支持共享首选项</li><li>支持明暗主题</li><li>支持多页面间导航</li></ul><p>随着时间的推移，随着 Flutter 最佳实践的发展预计这个新模板也会随之发展。</p><p>另一方面，<strong>如果你正在开发插件而不是应用程序，那么可能会对 Pigeon 的 1.0 版本感兴趣</strong>。</p><p>Pigeon 是一个代码生成工具，用于在 Flutter 及其主机平台之间生成类型安全的互操作代码，它允许定义插件 API 的描述，并为 Dart、Java 和 Objective-C（分别可用于 Kotlin 和 Swift）生成框架代码。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1553cacae8446bba93b51b812abe7a7~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>Flutter 团队的一些插件中已经使用了 Pigeon，在此版本中它提供了更多有用的错误消息，增加了对泛型、原始数据类型作为参数和返回类型以及多个参数的支持，预计开发者将来会更频繁地使用它。</p><h2 id="重大更改和弃用"><a href="#重大更改和弃用" class="headerlink" title="重大更改和弃用"></a>重大更改和弃用</h2><p>以下是 Flutter 2.5 版本中的重大变化：</p><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Frelease%2Fbreaking-changes%2Fdefault-scroll-behavior-drag" target="_blank" rel="noopener">默认拖动滚动设备</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Frelease%2Fbreaking-changes%2F2-2-deprecations" target="_blank" rel="noopener">在 v2.2 之后删除了弃用的 API</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Frelease%2Fbreaking-changes%2Fflutter-lints-package" target="_blank" rel="noopener">引入包：flutter_lints</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Frelease%2Fbreaking-changes%2Ftheme-data-accent-properties" target="_blank" rel="noopener">ThemeData 的 accent 属性已被弃用</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Frelease%2Fbreaking-changes%2Fgesture-recognizer-add-allowed-pointer" target="_blank" rel="noopener">GestureRecognizer Cleanup</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Frelease%2Fbreaking-changes%2Fanimation-sheet-builder-display" target="_blank" rel="noopener">用 collate 替换 AnimationSheetBuilder.display</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Frelease%2Fbreaking-changes%2Fplatform-views-using-html-slots-web" target="_blank" rel="noopener">使用 HTML 插槽在 Web 中呈现平台视图</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F80756" target="_blank" rel="noopener">将 LogicalKeySet 迁移到 SingleActivator</a></li></ul><p>随着继续更新 Flutter Fix（在您的 IDE 中和通过<code>dart fix</code>命令可用），总共有 157 条规则来自动迁移受这些或过去的重大更改以及任何弃用影响的代码。</p><p>此外随着 Flutter 2.5 的发布，<strong>我们将弃用<a href="https://link.juejin.cn?target=http%3A%2F%2Fflutter.dev%2Fgo%2Frfc-ios8-deprecation" target="_blank" rel="noopener">2020 年 9 月宣布的</a>对 iOS 8 的支持</strong>。放弃对市场份额不到 1% 的 iOS 8 的支持，使 Flutter 团队能够专注于更广泛使用的新平台，弃用意味着这些平台可以工作，但我们不会在这些平台上测试 Flutter 的新版本或插件。</p><blockquote><p>您可以在 flutter.dev 上查看当前支持的 Flutter 平台列表: <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Fdevelopment%2Ftools%2Fsdk%2Frelease-notes%2Fsupported-platforms" target="_blank" rel="noopener">flutter.dev/docs/develo…</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20210910181120.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://link.juejin.cn/?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fwhats-new-in-flutter-2-5-6f080c3f3dc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;medium.com/flutter/wha…&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Flutter 2.5 是 Flutter 版本历史上排名第二的大版本更新&lt;/strong&gt;，该版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭了 4600 个 issues；&lt;/li&gt;
&lt;li&gt;合并了 252 contributors 和 216 reviewers 的 3932 个 PR；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回顾过去一年，可以看到有 1337 位 contributors 创建了 21,072 个 PR 这样庞大的数据，其中有15,172 个被合并。&lt;/p&gt;
&lt;p&gt;事实上该版本依然是对性能和开发工具进行了改进，同时还有增加许多新功能，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对 Android 的全屏支持、更多 Material You（也称为 v3）支持；&lt;/li&gt;
&lt;li&gt;更新文本编辑功能以支持可切换的键盘快捷键；&lt;/li&gt;
&lt;li&gt;Widget Inspector 可查阅更多详细信息；&lt;/li&gt;
&lt;li&gt;Visual Studio Code 项目中对添加依赖项增加新的支持；&lt;/li&gt;
&lt;li&gt;IntelliJ/Android Studio 中新增测试运行获取覆盖率信息；&lt;/li&gt;
&lt;li&gt;一个全新的应用程序模板，为 Flutter 应用程序提供更好的开发基础；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="https://zhangmiao.cc/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>能量层级（正/负）</title>
    <link href="https://zhangmiao.cc/posts/4caf75c5.html"/>
    <id>https://zhangmiao.cc/posts/4caf75c5.html</id>
    <published>2021-06-21T05:52:42.000Z</published>
    <updated>2021-12-24T02:05:30.001Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/21/aq38AwlJKp2rbyR.jpg" alt="hhh.png"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/21/aq38AwlJKp2rbyR.jpg&quot; alt=&quot;hhh.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="https://zhangmiao.cc/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="https://zhangmiao.cc/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GooglePlay新增付款功能一览表</title>
    <link href="https://zhangmiao.cc/posts/5fd712a2.html"/>
    <id>https://zhangmiao.cc/posts/5fd712a2.html</id>
    <published>2021-06-10T11:57:18.000Z</published>
    <updated>2021-12-24T02:05:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>随着移动行业全球化，Google Play 也陆续加入各种不同的付款方式，让用户可以选择喜好的付款方式。请注意，Google Play 帐号的国家/地区设置会影响能选择的付款方式。</p><p>如果要更改国家/地区，您需要在 Google Play 中设置一个新的国家/地区。要设置新的国家/地区，用户必须位于相应国家/地区，并且在新的国家/地区有受支持的付款方式。</p><p>请注意:</p><ul><li>您每年只能更改一次 Play 国家/地区设置。因此，如果您更改国家/地区，则在 1 年之内无法改回之前的国家/地区。</li><li>您更改国家/地区后，将无法在新的国家/地区使用您在之前的国家/地区拥有的 Google Play 余额。</li><li>您可能会无法再享用某些图书、电影、电视节目、游戏和应用。</li></ul><p>以下列举 Google Play 中部分采用中文语言的国家/地区常用的付款方式:</p><a id="more"></a><h2 id="中国香港地区"><a href="#中国香港地区" class="headerlink" title="中国香港地区"></a><strong>中国香港地区</strong></h2><ul><li>信用卡及借记卡: 维萨、万事达、及美国运通卡</li><li>手机代扣，参与的运营商有:<ul><li>3</li><li>CSL/1O1O</li><li>Smartone</li><li>中国移动香港</li><li>SUN Mobile</li><li>Telin</li></ul></li><li>Octopus O ! ePay</li><li>AlipayHK <em>– *</em>new!***</li><li>Google Play 礼品卡<ul><li>若想使用礼品卡或促销代码，您所居住的国家/地区与 Google Play 帐号的国家/地区设置必须与提供礼品卡或促销代码的国家/地区一致，否则会无法充值及交易。</li></ul></li><li>PayPal</li></ul><h2 id="新加坡"><a href="#新加坡" class="headerlink" title="新加坡"></a><strong>新加坡</strong></h2><ul><li>信用卡及借记卡: 威萨、万事达、及美国运通卡</li><li>手机代扣，参与的运营商有:<ul><li>M1</li><li>SingTel</li><li>StarHub</li></ul></li><li>PayPal</li></ul><h2 id="马来西亚"><a href="#马来西亚" class="headerlink" title="马来西亚"></a><strong>马来西亚</strong></h2><ul><li>信用卡及借记卡: 威萨、万事达、及美国运通卡</li><li>手机代扣，参与的运营商有:<ul><li>Celcom</li><li>Digi</li><li>Maxis</li><li>U Mobile</li><li>webe</li><li>Yes</li></ul></li><li>Touch ‘n Go Wallet</li><li>Google Play 礼品卡<ul><li>若想使用礼品卡或促销代码，您所居住的国家/地区与 Google Play 帐号的国家/地区设置必须与提供礼品卡或促销代码的国家/地区一致，否则会无法充值及交易。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着移动行业全球化，Google Play 也陆续加入各种不同的付款方式，让用户可以选择喜好的付款方式。请注意，Google Play 帐号的国家/地区设置会影响能选择的付款方式。&lt;/p&gt;
&lt;p&gt;如果要更改国家/地区，您需要在 Google Play 中设置一个新的国家/地区。要设置新的国家/地区，用户必须位于相应国家/地区，并且在新的国家/地区有受支持的付款方式。&lt;/p&gt;
&lt;p&gt;请注意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;您每年只能更改一次 Play 国家/地区设置。因此，如果您更改国家/地区，则在 1 年之内无法改回之前的国家/地区。&lt;/li&gt;
&lt;li&gt;您更改国家/地区后，将无法在新的国家/地区使用您在之前的国家/地区拥有的 Google Play 余额。&lt;/li&gt;
&lt;li&gt;您可能会无法再享用某些图书、电影、电视节目、游戏和应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下列举 Google Play 中部分采用中文语言的国家/地区常用的付款方式:&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://zhangmiao.cc/categories/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/categories/Android/Android-Tips/"/>
    
    
      <category term="Android" scheme="https://zhangmiao.cc/tags/Android/"/>
    
      <category term="Android Tips" scheme="https://zhangmiao.cc/tags/Android-Tips/"/>
    
  </entry>
  
</feed>
