<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zm.blog</title>
  
  <subtitle>select * from learn</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-12-11T09:30:34.964Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZhangMiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI生成BGM音乐调研</title>
    <link href="http://yoursite.com/posts/f928d1c8.html"/>
    <id>http://yoursite.com/posts/f928d1c8.html</id>
    <published>2024-09-11T08:39:26.000Z</published>
    <updated>2024-12-11T09:30:34.964Z</updated>
    
    <content type="html"><![CDATA[<p>AI生成BGM</p><p>BGM猫</p><p>• 可以通过BGM猫平台 <a href="http://bgmcat.com/home" target="_blank" rel="noopener">http://bgmcat.com/home</a> 生成AI音乐</p><p>• 使用描述 : 我走在田间的马路上,听着小歌曲,跳着走</p><p>• 提示 : 默认生成的bgm是没有商用版权的,可以通过购买专业创作者会员或单曲购买商业用途,目前感觉没必要购买</p><p>Mubert</p><p>• 可以通过mubert平台 <a href="https://mubert.com/render?authBy=google" target="_blank" rel="noopener">https://mubert.com/render?authBy=google</a> ⽣成AI⾳乐</p><p>• 使⽤描述 : I was walking on the road in the field, listening to little songs, dancing (规定只能使⽤英⽂)</p><p>BGM去除⼈声Spleeter</p><p>• 通过 <a href="https://makenweb.com/SpleeterGUI" target="_blank" rel="noopener">https://makenweb.com/SpleeterGUI</a> 可以下载免费的Windows版本(2022-10-12),MAC⽆对应软件。</p><p>• 通过 <a href="https://bbs.huaweicloud.com/forum/thread-117164-1-1.html" target="_blank" rel="noopener">https://bbs.huaweicloud.com/forum/thread-117164-1-1.html</a> 链接教程(2021-03-30有点过时), 调⽤的是Spleeter库,调⽤的流程和Windows版软件命令⼀致,⽆须搭建使⽤了.</p><p>Moises</p><p>可以通过 <a href="https://studio.moises.ai/library/" target="_blank" rel="noopener">https://studio.moises.ai/library/</a> 实现⾳轨分离,下载去除⼈声后的⽂件,预期效果没问题 (缺点:免费版5次/单⽉/单账号)</p><p>vocalremover</p><p>• 通过 <a href="https://vocalremover.org/zh/" target="_blank" rel="noopener">https://vocalremover.org/zh/</a> 可以分离人声和音乐,界面如下图</p><p>• 优点 :</p><ol><li>使用成本低,不需要本地安装各种python库,直接在线上传/下载音频文件</li><li><ol start="2"><li>免费次数无限制,没有必须开通包月包年或者单次付费的限制</li></ol></li></ol><p>uvr5</p><p>• 最新方式uvr5, github开源库 <a href="https://github.com/A/Anjok07/ultimatevocalremovergui" target="_blank" rel="noopener">https://github.com/A/Anjok07/ultimatevocalremovergui</a></p><p>• 如果vocalremover不可用时, 可用这种方案, 免费。</p><p>• 优点:</p><p>1 : 稳定性。不再受网页影响, 原去除人声方案vocalremover上午频繁出现与vpn冲突,短暂性无法使用,现已恢复</p><p>2 : 简捷性。使用uvr5转换,可以批量选择多个本地文件,无须在网页中大量上传原音频/下载新音频的传输过程了</p><p>3 : 高效性。使用本地软件执行转换, 依靠本地GPU, 执行效率更快</p><p>• 使用说明 :</p><p>1 为输入目录(可批量)</p><p>2为输出目录</p><p>3 为输出文件格式</p><p>4 为输出计算模型</p><p>5 为使用GPU只导出去除人声音频</p><p>6 为开始转换</p><p>7 为转换完成</p><p>结论</p><p>• 使用 bgm猫 <a href="http://bgmcat.com/home" target="_blank" rel="noopener">http://bgmcat.com/home</a> + vocalremover <a href="https://vocalremover.org/zh/" target="_blank" rel="noopener">https://vocalremover.org/zh/</a> 的方式,可以得到无人声水印的AI音频,免费且无次数限制。</p><p>• 以60s时长音频左右,走完一套流程4、5分钟,即可得到无水印AI音频</p><p>• 生成AI音频的方式包括但不限于bgm猫, 去除水印方式vocalremover可以免费无限次使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AI生成BGM&lt;/p&gt;
&lt;p&gt;BGM猫&lt;/p&gt;
&lt;p&gt;• 可以通过BGM猫平台 &lt;a href=&quot;http://bgmcat.com/home&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bgmcat.com/home&lt;/a&gt; 生成AI音乐
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Web加载慢问题优化和解决方案</title>
    <link href="http://yoursite.com/posts/eea7bb08.html"/>
    <id>http://yoursite.com/posts/eea7bb08.html</id>
    <published>2023-08-09T07:34:32.000Z</published>
    <updated>2023-08-09T08:43:57.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优化重点项"><a href="#优化重点项" class="headerlink" title="优化重点项"></a>优化重点项</h2><p>将以下资源本地化，打包到项目中</p><ul><li>canvaskit.js和canvaskit.wasm</li><li>KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf</li><li>css2?family=Noto_Sans+SC</li></ul><p>ps：最初canvaskit资源上传到阿里云，采用国内镜像资源加载。这次为了保险起见，也放入到本地。<br>好处：只要服务器正常能访问，这些资源文件就能够正常加载成功，最大程度上规避页面加载异常的风险！<br>最终项目中添加一些配置文件，如下图：<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809163641.png" alt></p><a id="more"></a><p><code>index.html</code>文件中更改canvaskit加载方式为本地<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809163718.png" alt></p><h2 id="下载相关"><a href="#下载相关" class="headerlink" title="下载相关"></a>下载相关</h2><h3 id="下载canvaskit-wasm和canvaskit-js"><a href="#下载canvaskit-wasm和canvaskit-js" class="headerlink" title="下载canvaskit.wasm和canvaskit.js"></a>下载canvaskit.wasm和canvaskit.js</h3><p><a href="https://unpkg.com/canvaskit-wasm@0.35.0/bin/canvaskit.js" target="_blank" rel="noopener">https://unpkg.com/canvaskit-wasm@0.35.0/bin/canvaskit.js</a><br><a href="https://unpkg.com/canvaskit-wasm@0.35.0/bin/canvaskit.wasm" target="_blank" rel="noopener">https://unpkg.com/canvaskit-wasm@0.35.0/bin/canvaskit.wasm</a><br>下载地址方式获取：F12 -&gt;Network<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809163733.png" alt></p><h3 id="下载KFOmCnqEu92Fr1Me5WZLCzYlKw-ttf"><a href="#下载KFOmCnqEu92Fr1Me5WZLCzYlKw-ttf" class="headerlink" title="下载KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf"></a>下载KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf</h3><p><a href="https://fonts.gstatic.com/s/roboto/v20/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf" target="_blank" rel="noopener">https://fonts.gstatic.com/s/roboto/v20/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf</a></p><h3 id="下载字体CSS"><a href="#下载字体CSS" class="headerlink" title="下载字体CSS"></a>下载字体CSS</h3><p><a href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC" target="_blank" rel="noopener">https://fonts.googleapis.com/css2?family=Noto+Sans+SC</a><br>下载的样式保存在本地，命名为 localfonts.css<br>更改CSS中引用的woff2字体文件，更改为本地路径<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809163747.png" alt></p><h3 id="字体文件批量下载"><a href="#字体文件批量下载" class="headerlink" title="字体文件批量下载"></a>字体文件批量下载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https:<span class="comment">//fonts.gstatic.com/s/notosanssc/v26/k3kXo84MPvpLmixcA63oeALhLIiP-Q-87KaAaH7rzeAODp22mF0qmF4CSjmPC6A0Rg5g1igg1w.[1-120].woff2</span></span><br></pre></td></tr></table></figure><p>下载的文件装入到woff2文件夹放在 web/canvaskit 路径下<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809163811.png" alt></p><h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><p>执行flutter build web打包命令后生成build/web文件<br>由于打包后的文件资源引用还是url链接形式，故需要修改build/web目录下的main.dart.js</p><h3 id="替换远端路径为本地路径"><a href="#替换远端路径为本地路径" class="headerlink" title="替换远端路径为本地路径"></a>替换远端路径为本地路径</h3><p>将<code>https://fonts.gstatic.com/s/roboto/v20/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf</code>替换成<code>canvaskit/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf</code><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809164058.png" alt><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809164106.png" alt></p><p>将<code>https://fonts.googleapis.com/css2?family=&quot;+A.bF(o,&quot; &quot;,&quot;+&quot;)</code>替换成<code>canvaskit/localfonts.css</code><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809164133.png" alt><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809164141.png" alt></p><h2 id="脚本自动打包-amp-替换资源引用路径"><a href="#脚本自动打包-amp-替换资源引用路径" class="headerlink" title="脚本自动打包&amp;替换资源引用路径"></a>脚本自动打包&amp;替换资源引用路径</h2><p>flutter_build.sh脚本自动打包以及打完包后修改build/web目录下的main.dart.js中资源引用路径替换成本地路径<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809164243.png" alt><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809164254.png" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">BLACK="\033[30m"</span><br><span class="line">RED="\033[31m"</span><br><span class="line">GREEN="\033[32m"</span><br><span class="line">YELLOW="\033[33m"</span><br><span class="line">BLUE="\033[34m"</span><br><span class="line">PINK="\033[35m"</span><br><span class="line">CYAN="\033[36m"</span><br><span class="line">WHITE="\033[37m"</span><br><span class="line">NORMAL="\033[0;39m"</span><br><span class="line">END="\033[0m"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定文件路径</span></span><br><span class="line">filepath="./build/web/main.dart.js"</span><br><span class="line"></span><br><span class="line">function chooseBuildTypeFunc &#123;</span><br><span class="line"></span><br><span class="line">    echo</span><br><span class="line">    echo "[$RED 1 $END]$CYAN 构建release包$END"</span><br><span class="line">    echo "[$CYAN q $END] 退出"</span><br><span class="line">    echo</span><br><span class="line"></span><br><span class="line">    echo "$GREEN请输入对应的数字或q退出:$END"</span><br><span class="line">    read param</span><br><span class="line">    echo</span><br><span class="line"></span><br><span class="line">    # 检测空格是否存在</span><br><span class="line">    if [[ -z $param ]]; then</span><br><span class="line">        echo "$RED输入有误,请重新输入$END"</span><br><span class="line">        chooseCommitTypeFunc;</span><br><span class="line">        return</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    if [ $param = "1" ]; then</span><br><span class="line">        buildFunc;</span><br><span class="line">    elif [ $param = "q" ]; then</span><br><span class="line">        echo</span><br><span class="line">    else</span><br><span class="line">        echo "$RED输入有误,请重新输入$END"</span><br><span class="line">        echo</span><br><span class="line">        chooseCommitTypeFunc;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function buildFunc &#123;</span><br><span class="line"></span><br><span class="line">    # 开始打包</span><br><span class="line">    flutter build web --web-renderer canvaskit --dart-define=BROWSER_IMAGE_DECODING_ENABLED=false --release</span><br><span class="line">    # 结束打包</span><br><span class="line"></span><br><span class="line">    # 定义 URL</span><br><span class="line">    old_url="https:\/\/fonts.gstatic.com\/s\/roboto\/v20"</span><br><span class="line">    new_url="canvaskit"</span><br><span class="line"></span><br><span class="line">    # 使用 sed 命令查找并替换 URL</span><br><span class="line">    sed -i '' "s~$old_url~$new_url~g" $filepath</span><br><span class="line"></span><br><span class="line">    # 定义字符串</span><br><span class="line">    old_string="https:\/\/fonts.googleapis.com\/css2?family="</span><br><span class="line">    new_string="canvaskit\/localfonts.css"</span><br><span class="line"></span><br><span class="line">    # 使用 sed 命令查找并替换字符串</span><br><span class="line">    # 我们使用 "|" 作为定界符，而不是常用的 "/"</span><br><span class="line">    sed -i '' "s|$old_string|$new_string|g" $filepath</span><br><span class="line"></span><br><span class="line">    # 定义所有可能的字母</span><br><span class="line">    LETTERS=(&#123;a..z&#125; &#123;A..Z&#125;)</span><br><span class="line"></span><br><span class="line">    # 使用 for 循环遍历所有字母</span><br><span class="line">    for letter in "$&#123;LETTERS[@]&#125;"; do</span><br><span class="line">      # 使用 grep 来匹配字符串</span><br><span class="line">      if grep -Fq "+A.b$&#123;letter&#125;(o,\" \",\"+\")" $filepath; then</span><br><span class="line">        # 定义字符串</span><br><span class="line">        old_string="+A.b$letter(o,\" \",\"+\")"</span><br><span class="line">        new_string=""</span><br><span class="line"></span><br><span class="line">        # 使用 perl 的 -i 选项进行原地编辑（直接修改文件）</span><br><span class="line">        # 使用 \Q...\E 将目标字符串视为文字而不是正则表达式</span><br><span class="line">        perl -i -pe 's/\Q'$old_string'\E/'$new_string'/g' $filepath</span><br><span class="line">        break # 停止循环，因为我们已经找到了匹配的字符串</span><br><span class="line">      fi</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo "$CYAN============================ SUCCESS ============================$END"</span><br><span class="line">&#125;</span><br><span class="line">chooseBuildTypeFunc;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优化重点项&quot;&gt;&lt;a href=&quot;#优化重点项&quot; class=&quot;headerlink&quot; title=&quot;优化重点项&quot;&gt;&lt;/a&gt;优化重点项&lt;/h2&gt;&lt;p&gt;将以下资源本地化，打包到项目中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;canvaskit.js和canvaskit.wasm&lt;/li&gt;
&lt;li&gt;KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf&lt;/li&gt;
&lt;li&gt;css2?family=Noto_Sans+SC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ps：最初canvaskit资源上传到阿里云，采用国内镜像资源加载。这次为了保险起见，也放入到本地。&lt;br&gt;好处：只要服务器正常能访问，这些资源文件就能够正常加载成功，最大程度上规避页面加载异常的风险！&lt;br&gt;最终项目中添加一些配置文件，如下图：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20230809163641.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter状态管理Provider和Get分析</title>
    <link href="http://yoursite.com/posts/7ff52b5f.html"/>
    <id>http://yoursite.com/posts/7ff52b5f.html</id>
    <published>2022-06-27T02:46:30.000Z</published>
    <updated>2022-06-27T02:54:51.119Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627104743.png" alt></p><p><em>文/ Nayuta，CFUG 社区</em></p><p>状态管理一直是 Flutter 开发中一个火热的话题。谈到状态管理框架，社区也有诸如有以 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fget" target="_blank" rel="noopener">Get</a>、<a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fprovider" target="_blank" rel="noopener">Provider</a> 为代表的多种方案，它们有各自的优缺点。 面对这么多的选择，你可能会想：「我需要使用状态管理么？哪种框架更适合我？」 本文将从作者的实际开发经验出发，分析状态管理解决的问题以及思路，希望能帮助你做出选择。</p><h2 id="为什么需要状态管理？"><a href="#为什么需要状态管理？" class="headerlink" title="为什么需要状态管理？"></a>为什么需要状态管理？</h2><p>首先，为什么需要状态管理？ 根据笔者的经验，这是因为 Flutter 基于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fresources%2Farchitectural-overview%23reactive-user-interfaces" target="_blank" rel="noopener"><strong>声明式</strong></a> 构建 UI ， 使用状态管理的目的之一就是解决「声明式」开发带来的问题。</p><p>「声明式」开发是一种区别于传原生的方式，所以我们没有在原生开发中听到过状态管理，那如何理解「声明式」开发呢？</p><a id="more"></a><h3 id="「声明式」VS「命令式」分析"><a href="#「声明式」VS「命令式」分析" class="headerlink" title="「声明式」VS「命令式」分析"></a>「声明式」VS「命令式」分析</h3><p>以最经典的的计数器例子分析：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105414.png" alt></p><p>如上图所示：点击右下角按钮，显示的文本数字加一。 Android 中可以这么实现：当右下角按钮点中时， 拿到 <code>TextView</code> 的对象，手动设置其展示的文本。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一、定义展示的内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mCount =<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 二、中间展示数字的控件 TextView</span></span><br><span class="line"><span class="keyword">private</span> TextView mTvCount;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 三、关联 TextView 与 xml 中的组件</span></span><br><span class="line">mTvCount = findViewById(R.id.tv_count)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 四、点击按钮控制组件更新</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">( )</span></span>&#123; </span><br><span class="line">mCount++;</span><br><span class="line">mTvCounter.setText(mCount.toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 Flutter 中，我们只需要使变量增加之后调用 <code>setState((){})</code> 即可。<code>setState</code> 会刷新整个页面，使得中间展示的值进行变更。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一、声明变量</span></span><br><span class="line"><span class="built_in">int</span> _counter =<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 二、展示变量 </span></span><br><span class="line">Text(<span class="string">'$_counter'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  三、变量增加，更新界面</span></span><br><span class="line">setState(() &#123;</span><br><span class="line">   _counter++; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以发现，Flutter 中只对 <code>_counter</code> 属性进行了修改，并没有对 Text 组件进行任何的操作，整个界面随着状态的改变而改变。</p><p>所以在 Flutter 中有这么一种说法: <strong>UI = f(state)</strong>:</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105353.png" alt></p><p>上面的例子中，状态 (state) 就是 <code>_counter</code> 的值，调用 <code>setState</code> 驱动 <code>f</code> build 方法生成新的 UI。</p><p>那么，声明式有哪些优势，并带来了哪些问题呢？</p><p><strong>优势: 让开发者摆脱组件的繁琐控制，聚焦于状态处理</strong></p><p>习惯 Flutter 开发之后，回到原生平台开发，你会发现当多个组件之间相互关联时，对于 View 的控制非常麻烦。</p><p>而在 Flutter 中我们只需要处理好状态即可 (复杂度转移到了状态 -&gt; UI 的映射，也就是 Widget 的构建)。包括 Jetpack Compose、Swift 等技术的最新发展，也是在朝着「声明式」的方向演进。</p><p><strong>声明式开发带来的问题</strong></p><p>没有使用状态管理，直接「声明式」开发的时候，遇到的问题总结有三个:</p><ol><li>逻辑和页面 UI 耦合，导致无法复用/单元测试、修改混乱等</li><li>难以跨组件 (跨页面) 访问数据</li><li>无法轻松的控制刷新范围 (页面 setState 的变化会导致全局页面的变化)</li></ol><p>接下来，我先带领大家逐个了解这些问题，下一章向大家详细描述状态管理框架如何解决这些问题。</p><p><strong>1) 逻辑和页面 UI 耦合，导致无法复用/单元测试、修改混乱等</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105323.png" alt></p><p>一开始业务不复杂的时候，所有的代码都直接写到 widget 中，随着业务迭代， 文件越来越大，其他开发者很难直观地明白里面的业务逻辑。 并且一些通用逻辑，例如网络请求状态的处理、分页等，在不同的页面来回粘贴。</p><p>这个问题在原生上同样存在，后面也衍生了诸如 MVP 设计模式的思路去解决。</p><p><strong>2) 难以跨组件 (跨页面) 访问数据</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105312.png" alt></p><p>第二点在于跨组件交互，比如在 Widget 结构中， 一个子组件想要展示父组件中的 <code>name</code> 字段， 可能需要层层进行传递。</p><p>又或者是要在两个页面之间共享筛选数据， 并没有一个很优雅的机制去解决这种跨页面的数据访问。</p><p><strong>3) 无法轻松的控制刷新范围 (页面 setState 的变化会导致全局页面的变化)</strong></p><p>最后一个问题也是上面提到的优点，很多场景我们只是部分状态的修改，例如按钮的颜色。 但是整个页面的 <code>setState</code> 会使得其他不需要变化的地方也进行重建， 带来不必要的开销。</p><h2 id="Provider、Get-状态管理框架设计分析"><a href="#Provider、Get-状态管理框架设计分析" class="headerlink" title="Provider、Get 状态管理框架设计分析"></a>Provider、Get 状态管理框架设计分析</h2><p>Flutter 中状态管理框架的核心在于这三个问题的解决思路， 下面一起看看 Provider、Get 是如何解决的：</p><h3 id="解决逻辑和页面-UI-耦合问题"><a href="#解决逻辑和页面-UI-耦合问题" class="headerlink" title="解决逻辑和页面 UI 耦合问题"></a>解决逻辑和页面 UI 耦合问题</h3><p>传统的原生开发同样存在这个问题，Activity 文件也可能随着迭代变得难以维护， 这个问题可以通过 MVP 模式进行解耦。</p><p>简单来说就是将 View 中的逻辑代码抽离到 Presenter 层， View 只负责视图的构建。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105259.png" alt></p><p>这也是 Flutter 中几乎所有状态管理框架的解决思路， 上图的 Presenter 你可以认为是 Get 中的 <code>GetController</code>、 Provider 中的 <code>ChangeNotifier</code> 或者 Bloc 中的 <code>Bloc</code>。 值得一提的是，具体做法上 Flutter 和原生 MVP 框架有所不同。</p><p>我们知道在经典 MVP 模式中， 一般 View 和 Presenter 以接口定义自身行为 (action)， <strong>相互持有接口进行调用</strong> 。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105246.png" alt></p><p>但 Flutter 中不太适合这么做， 从 Presenter → View 关系上 View 在 Flutter 中对应 Widget， 但在 Flutter 中 Widget 只是用户声明 UI 的配置， 直接控制 Widget 实例并不是好的做法。</p><p>而在从 View → Presenter 的关系上， Widget 可以确实可以直接持有 Presenter， 但是这样又会带来难以数据通信的问题。</p><p>这一点不同状态管理框架的解决思路不一样，从实现上他们可以分为两大类：</p><ul><li>通过 <strong>Flutter 树机制</strong> 解决，例如 Provider；</li><li>通过 <strong>依赖注入</strong>，例如 Get。</li></ul><p><strong>1) 通过 Flutter 树机制处理 V → P 的获取</strong></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105232.png" alt></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123; </span><br><span class="line"><span class="comment">/// 当前 Element 的父节点</span></span><br><span class="line"><span class="built_in">Element</span>? _parent; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line"><span class="comment">/// 查找父节点中的T类型的State</span></span><br><span class="line">T findAncestorState0fType&lt;T <span class="keyword">extends</span> State&gt;( );</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 遍历子元素的element对象</span></span><br><span class="line"><span class="keyword">void</span> visitChildElements(ElementVisitor visitor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 查找父节点中的T类型的 InheritedWidget 例如 MediaQuery 等</span></span><br><span class="line">T dependOnInheritedWidget0fExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;(&#123; </span><br><span class="line"><span class="built_in">Object</span> aspect &#125;);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Element 实现了父类 BuildContext 中操作树结构的方法 </p><p>我们知道 Flutter 中存在三棵树，Widget、Element 和 RenderObject。 所谓的 <strong>Widget 树其实只是我们描述组件嵌套关系的一种说法，是一种虚拟的结构</strong>。 但 Element 和 RenderObject 在运行时实际存在， 可以看到 Element 组件中包含了 <code>_parent</code> 属性，存放其父节点。 而它实现了 <code>BuildContext</code> 接口，包含了诸多对于树结构操作的方法， 例如 <code>findAncestorStateOfType</code>，向上查找父节点； <code>visitChildElements</code> 遍历子节点。</p><p>在一开始的例子中，我们可以通过 <code>context.findAncestorStateOfType</code> 一层一层地向上查找到需要的 Element 对象， 获取 Widget 或者 State 后即可取出需要的变量。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105216.png" alt></p><p>provider 也是借助了这样的机制，完成了 View -&gt; Presenter 的获取。 通过 <code>Provider.of</code> 获取顶层 Provider 组件中的 Present 对象。 显然，所有 Provider 以下的 Widget 节点， 都可以通过自身的 context 访问到 Provider 中的 Presenter， 很好地解决了跨组件的通信问题。</p><p><strong>2) 通过依赖注入的方式解决 V → P</strong></p><p>树机制很不错，但依赖于 context，这一点有时很让人抓狂。 我们知道 Dart 是一种单线程的模型， 所以不存在多线程下对于对象访问的竞态问题。 基于此 Get 借助一个全局单例的 Map 存储对象。 通过依赖注入的方式，实现了对 Presenter 层的获取。 这样在任意的类中都可以获取到 Presenter。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105204.png" alt></p><p>这个 Map 对应的 key 是 <code>runtimeType</code> + <code>tag</code>， 其中 tag 是可选参数，而 value 对应 <code>Object</code>， 也就是说我们可以存入任何类型的对象，并且在任意位置获取。</p><h3 id="解决难以跨组件-跨页面-访问数据的问题"><a href="#解决难以跨组件-跨页面-访问数据的问题" class="headerlink" title="解决难以跨组件 (跨页面) 访问数据的问题"></a>解决难以跨组件 (跨页面) 访问数据的问题</h3><p>这个问题其实和上一部分的思考基本类似，所以我们可以总结一下两种方案特点：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105148.png" alt></p><p><strong>Provider</strong></p><ul><li>依赖树机制，必须基于 context</li><li>提供了子组件访问上层的能力</li></ul><p><strong>Get</strong></p><ul><li>全局单例，任意位置可以存取</li><li>存在类型重复，内存回收问题</li></ul><h3 id="解决高层级-setState-引起不必要刷新的问题"><a href="#解决高层级-setState-引起不必要刷新的问题" class="headerlink" title="解决高层级 setState 引起不必要刷新的问题"></a>解决高层级 setState 引起不必要刷新的问题</h3><p>最后就是我们提到的高层级 <code>setState</code> 引起不必要刷新的问题， Flutter 通过采用观察者模式解决，其关键在于两步：</p><ol><li>观察者去订阅被观察的对象；</li><li>被观察的对象通知观察者。</li></ol><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105132.png" alt></p><p>系统也提供了 <code>ValueNotifier</code> 等组件的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 声明可能变化的数据</span></span><br><span class="line">ValueNotifier&lt;<span class="built_in">int</span>&gt; _statusNotifier = ValueNotifier(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">ValueListenableBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line"><span class="comment">// 建立与 _statusNotifier 的绑定关系 </span></span><br><span class="line">valueListenable: _statusNotifier, </span><br><span class="line">builder: (c, data, _) &#123;</span><br><span class="line"><span class="keyword">return</span> Text(<span class="string">'$data'</span>); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">///数据变化驱动 ValueListenableBuilder 局部刷新 </span></span><br><span class="line">_statusNotifier.value += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>了解到最基础的观察者模式后，看看不同框架中提供的组件：</p><p>比如 Provider 中提供了 <code>ChangeNotifierProvider</code>:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="title">extend</span> <span class="title">ChangeNotifier</span> </span>&#123; </span><br><span class="line"><span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用此方法更新所有观察节点</span></span><br><span class="line"><span class="keyword">void</span> increment() &#123;</span><br><span class="line">count++;</span><br><span class="line">notifyListeners(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123; </span><br><span class="line">runApp(</span><br><span class="line">ChangeNotifierProvider(</span><br><span class="line"><span class="comment">///  返回一个实现 ChangeNotifier 接口的对象 </span></span><br><span class="line">create: (_) =&gt; Counter(),</span><br><span class="line">child: <span class="keyword">const</span> MyApp( ), </span><br><span class="line">),</span><br><span class="line">);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  子节点通过 Consumer 获取 Counter 对象 </span></span><br><span class="line">Consumer&lt;Counter&gt;(</span><br><span class="line">builder:(_, counter, _) =&gt; Text(counter.count.toString())</span><br></pre></td></tr></table></figure><p>还是之前计数器的例子，这里 <code>Counter</code> 继承了 <code>ChangeNotifier</code> 通过顶层的 Provider 进行存储。 子节点通过 Consumer 即可获取实例， 调用了 <code>increment</code> 方法之后，只有对应的 Text 组件进行变化。</p><p>同样的功能，在 Get 中， 只需要提前调用 <code>Get.put</code> 方法存储 <code>Counter</code> 对象， 为 <code>GetBuilder</code> 组件指定 <code>Counter</code> 作为泛型。 因为 Get 基于单例，所以 <code>GetBuilder</code> 可以直接通过泛型获取到存入的对象， 并在 builder 方法中暴露。这样 <code>Counter</code> 便与组件建立了监听关系， 之后 <code>Counter</code> 的变动，只会驱动以它作为泛型的 <code>GetBuilder</code> 组件更新。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">GetxController</span> </span>&#123; </span><br><span class="line"><span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> increase() &#123; </span><br><span class="line">count++;</span><br><span class="line">update(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 提前进行存储</span></span><br><span class="line"><span class="keyword">final</span> counter = Get.put(Counter( )); </span><br><span class="line"></span><br><span class="line"><span class="comment">/// 直接通过泛型获取存储好的实例</span></span><br><span class="line">GetBuilder&lt;Counter&gt;(</span><br><span class="line">builder: (Counter counter) =&gt; Text(<span class="string">'<span class="subst">$&#123;counter.count&#125;</span>'</span>) );</span><br></pre></td></tr></table></figure><h2 id="实践中的常见问题"><a href="#实践中的常见问题" class="headerlink" title="实践中的常见问题"></a>实践中的常见问题</h2><p>在使用这些框架过程中，可能会遇到以下的问题：</p><h3 id="Provider-中-context-层级过高"><a href="#Provider-中-context-层级过高" class="headerlink" title="Provider 中 context 层级过高"></a>Provider 中 context 层级过高</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Provider(</span><br><span class="line">      create: (_) =&gt; <span class="keyword">const</span> Count(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        home: Scaffold(</span><br><span class="line">          body: Center(child: Text(<span class="string">'<span class="subst">$&#123;Provider.of&lt;Counter&gt;(context).count&#125;</span>'</span>)),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105115.png" alt></p><p>如代码所示，当我们直接将 Provider 与组件嵌套于同一层级时， 这时代码中的 <code>Provider.of(context)</code> 运行时抛出 <code>ProviderNotFoundException</code>。 因为此处我们使用的 context 来自于 MyApp， 但 Provider 的 element 节点位于 MyApp 的下方， 所以 <code>Provider.of(context)</code> 无法获取到 Provider 节点。 这个问题可以有两种改法，如下方代码所示：</p><p><strong>改法 1: 通过嵌套 Builder 组件，使用子节点的 context 访问:</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Provider(</span><br><span class="line">      create: (_) =&gt; <span class="keyword">const</span> Count(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        home: Scaffold(</span><br><span class="line">          body: Center(</span><br><span class="line">            child: Builder(builder: (builderContext) &#123;</span><br><span class="line">              <span class="keyword">return</span> Text(<span class="string">'<span class="subst">$&#123;Provider.of&lt;Counter&gt;(builderContext).count&#125;</span>'</span>);</span><br><span class="line">            &#125;),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改法 2: 将 Provider 提至顶层:</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    Provider(</span><br><span class="line">      create: (_) =&gt; Counter(),</span><br><span class="line">      child: <span class="keyword">const</span> MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Center(child: Text(<span class="string">'<span class="subst">$&#123;Provider.of&lt;Counter&gt;(context).count&#125;</span>'</span>)),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Get-由于全局单例带来的问题"><a href="#Get-由于全局单例带来的问题" class="headerlink" title="Get 由于全局单例带来的问题"></a>Get 由于全局单例带来的问题</h3><p>正如前面提到 Get 通过全局单例，默认以 <code>runtimeType</code> 为 key 进行对象的存储， 部分场景可能获取到的对象不符合预期，例如商品详情页之间跳转。 由于不同的详情页实例对应的是同一 Class，即 <code>runtimeType</code> 相同。 如果不添加 tag 参数，在某个页面调用 <code>Get.find</code> 会获取到其它页面已经存储过的对象。 同时 Get 中一定要注意考虑到对象的回收，不然很有可能引起内存泄漏。 要么手动在页面 <code>dispose</code> 的时候做 <code>delete</code> 操作， 要么完全使用 Get 中提供的组件，例如 <code>GetBuilder</code>， 它会在 <code>dispose</code> 中释放。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627105054.png" alt></p><p><code>GetBuilder</code> 中在 <code>dispose</code> 阶段进行回收:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> dispose() &#123;</span><br><span class="line">  <span class="keyword">super</span>.dispose();</span><br><span class="line">  widget.dispose?.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">if</span> (_isCreator! || widget.assignId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (widget.autoRemove &amp;&amp; GetInstance().isRegistered&lt;T&gt;(tag: widget.tag)) &#123;</span><br><span class="line">      GetInstance().delete&lt;T&gt;(tag: widget.tag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _remove?.call();</span><br><span class="line"></span><br><span class="line">  controller = <span class="keyword">null</span>;</span><br><span class="line">  _isCreator = <span class="keyword">null</span>;</span><br><span class="line">  _remove = <span class="keyword">null</span>;</span><br><span class="line">  _filter = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Get-与-Provider-优缺点总结"><a href="#Get-与-Provider-优缺点总结" class="headerlink" title="Get 与 Provider 优缺点总结"></a>Get 与 Provider 优缺点总结</h2><p>通过本文，我向大家介绍了状态管理的必要性、它解决了 Flutter 开发中的哪些问题以及是如何解决的， 与此同时，我也为大家总结了在实践中常见的问题等，看到这里你可能还会有些疑惑，到底是否需要使用状态管理？</p><p>在我看来，框架是为了解决问题而存在。所以这取决于你是否也在经历一开始提出的那些问题。 如果有，那么你可以尝试使用状态管理解决；如果没有，则没必要过度设计，为了使用而使用。</p><p>其次，如果使用状态管理，那么 Get 和 Provider 哪个更好？</p><p>这两个框架各有优缺点，我认为如果你或者你的团队刚接触 Flutter， 使用 Provider 能帮助你们更快理解 Flutter 的核心机制。 而如果已经对 Flutter 的原理有了解，Get 丰富的功能和简洁的 API， 则能帮助你很好地提高开发效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220627104743.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;文/ Nayuta，CFUG 社区&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;状态管理一直是 Flutter 开发中一个火热的话题。谈到状态管理框架，社区也有诸如有以 &lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fget&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Get&lt;/a&gt;、&lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fprovider&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Provider&lt;/a&gt; 为代表的多种方案，它们有各自的优缺点。 面对这么多的选择，你可能会想：「我需要使用状态管理么？哪种框架更适合我？」 本文将从作者的实际开发经验出发，分析状态管理解决的问题以及思路，希望能帮助你做出选择。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要状态管理？&quot;&gt;&lt;a href=&quot;#为什么需要状态管理？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要状态管理？&quot;&gt;&lt;/a&gt;为什么需要状态管理？&lt;/h2&gt;&lt;p&gt;首先，为什么需要状态管理？ 根据笔者的经验，这是因为 Flutter 基于 &lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fresources%2Farchitectural-overview%23reactive-user-interfaces&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;声明式&lt;/strong&gt;&lt;/a&gt; 构建 UI ， 使用状态管理的目的之一就是解决「声明式」开发带来的问题。&lt;/p&gt;
&lt;p&gt;「声明式」开发是一种区别于传原生的方式，所以我们没有在原生开发中听到过状态管理，那如何理解「声明式」开发呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="http://yoursite.com/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="http://yoursite.com/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>FlutterAPP生命周期监听</title>
    <link href="http://yoursite.com/posts/b07d1684.html"/>
    <id>http://yoursite.com/posts/b07d1684.html</id>
    <published>2022-06-20T05:56:43.000Z</published>
    <updated>2022-06-20T06:03:03.870Z</updated>
    
    <content type="html"><![CDATA[<p>State 的生命周期，定义了 Widget 的加载到构建的全过程，可以利用其回调机制根据 Widget 的状态选择合适的时机做合适的事情。而 APP 的生命周期，则定义了 APP 从启动到退出的全过程。</p><p>如果想在对应的 APP 的生命周期事件中做相应的处理，比如 APP 从后台进入前台、从前台退到后台，或是在 UI 绘制完后做一些处理，则可以应用 WidgetsBindingObserver 类来实现。</p><p><strong>WidgetsBindingObserver 中的回调方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Accessibility 相关特性回调</span><br><span class="line">void didChangeAccessibilityFeatures() &#123; &#125;</span><br><span class="line"></span><br><span class="line">// App 生命周期改变回调</span><br><span class="line">void didChangeAppLifecycleState(AppLifecycleState state) &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 本地化语言改变回调</span><br><span class="line">void didChangeLocales(List&lt;Locale&gt; locale) &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 系统窗口相关改变回调</span><br><span class="line">void didChangeMetrics() &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 系统亮度改变回调</span><br><span class="line">void didChangePlatformBrightness() &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 文本缩放系数改变回调</span><br><span class="line">void didChangeTextScaleFactor() &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 内存不足警告回调</span><br><span class="line">void didHaveMemoryPressure() &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 页面 pop</span><br><span class="line">Future&lt;bool&gt; didPopRoute() =&gt; Future&lt;bool&gt;.value(false);</span><br><span class="line"></span><br><span class="line">// 页面 push</span><br><span class="line">Future&lt;bool&gt; didPushRoute(String route) =&gt; Future&lt;bool&gt;.value(false);</span><br></pre></td></tr></table></figure><p>要使用以上回调方法，只需通过给 WidgetsBindingObserver 单例对象设置监听器即可监听相关回调方法</p><a id="more"></a><h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p>didChangeAppLifecycleState 回调方法中，有一个参数类型为 AppLifecycleState 的枚举类，这个枚举类是 Flutter 对 App 生命周期状态的封装，常用的状态包括 inactive、paused、resumed</p><ul><li>inactive：处在不活动状态，无法处理用户响应</li><li>paused：不可见且不能响应用户的输入，但在后台继续活动中</li><li>resumed：可见的，且能响应用户的输入</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppLifecycleReactor</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AppLifecycleReactor(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AppLifecycleReactorState createState() =&gt; _AppLifecycleReactorState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AppLifecycleReactorState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AppLifecycleReactor</span>&gt; <span class="title">with</span> <span class="title">WidgetsBindingObserver</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    WidgetsBinding.instance.addObserver(<span class="keyword">this</span>);<span class="comment">// 注册监听器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    WidgetsBinding.instance.removeObserver(<span class="keyword">this</span>);<span class="comment">// 移除监听器</span></span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AppLifecycleState _notification;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeAppLifecycleState(AppLifecycleState state) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"$state"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以试着切换下前后台，观察下控制台输出的 App 状态</p><ul><li><p>从前台退到后台，控制台打印的 App 生命周期变化如下：</p><p>AppLifecycleState.resumed-&gt;AppLifecycleState.inactive-&gt;AppLifecycleState.paused</p></li><li><p>从后台切换回前台，控制台打印的 App 生命周期变化如下：</p><p>AppLifecycleState.paused-&gt;AppLifecycleState.inactive-&gt;AppLifecycleState.resumed</p></li></ul><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220620140229.png" alt></p><h3 id="帧绘制回调"><a href="#帧绘制回调" class="headerlink" title="帧绘制回调"></a>帧绘制回调</h3><p>有时除了需要监听 App 的生命周期回调外，还需要在组件完成渲染后做一些与显示相关的其他处理，比如切换线程等，此时可以使用 WidgetsBinding 来实现</p><p>WidgetsBinding 提供了单次 Frame 绘制回调及实时 Frame 绘制回调两种机制</p><ul><li><p>单次 Frame 绘制回调：通过 addPostFrameCallback 实现。在当前 Frame 绘制完后进行回调，且只会回调一次，如果需要多次回调则需设置多次</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBindingObserver.instance.addPostFrameCallback((_)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"addPostFrameCallback 绘制回调"</span>); <span class="comment">// 只回调一次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>实时 Frame 绘制回调：通过 addPersistentFrameCallback 实现。在每次绘制 Frame 结束后进行回调</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBindingObserver.instance.addPersistentFrameCallback((_)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"addPersistentFrameCallback 绘制回调"</span>); <span class="comment">// 每帧都回调</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;State 的生命周期，定义了 Widget 的加载到构建的全过程，可以利用其回调机制根据 Widget 的状态选择合适的时机做合适的事情。而 APP 的生命周期，则定义了 APP 从启动到退出的全过程。&lt;/p&gt;
&lt;p&gt;如果想在对应的 APP 的生命周期事件中做相应的处理，比如 APP 从后台进入前台、从前台退到后台，或是在 UI 绘制完后做一些处理，则可以应用 WidgetsBindingObserver 类来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WidgetsBindingObserver 中的回调方法&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Accessibility 相关特性回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void didChangeAccessibilityFeatures() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// App 生命周期改变回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void didChangeAppLifecycleState(AppLifecycleState state) &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 本地化语言改变回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void didChangeLocales(List&amp;lt;Locale&amp;gt; locale) &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 系统窗口相关改变回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void didChangeMetrics() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 系统亮度改变回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void didChangePlatformBrightness() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 文本缩放系数改变回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void didChangeTextScaleFactor() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 内存不足警告回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void didHaveMemoryPressure() &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 页面 pop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Future&amp;lt;bool&amp;gt; didPopRoute() =&amp;gt; Future&amp;lt;bool&amp;gt;.value(false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 页面 push&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Future&amp;lt;bool&amp;gt; didPushRoute(String route) =&amp;gt; Future&amp;lt;bool&amp;gt;.value(false);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要使用以上回调方法，只需通过给 WidgetsBindingObserver 单例对象设置监听器即可监听相关回调方法&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="http://yoursite.com/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="http://yoursite.com/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Flutter升级到指定版本</title>
    <link href="http://yoursite.com/posts/7a75b9fc.html"/>
    <id>http://yoursite.com/posts/7a75b9fc.html</id>
    <published>2022-05-26T02:26:06.000Z</published>
    <updated>2022-05-26T02:27:19.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、通过命令："><a href="#一、通过命令：" class="headerlink" title="一、通过命令："></a>一、通过命令：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看版本： flutter --version</span><br><span class="line">检查环境：flutter doctor</span><br><span class="line">查看渠道：flutter channel</span><br><span class="line">切换渠道（stable, beta, dev, master）：flutter channel stable</span><br><span class="line">升级到最新版本：flutter upgrade </span><br><span class="line">升级到指定版本：flutter upgrade v2.5.0</span><br><span class="line">回退到指定版本：flutter downgrade v2.5.0</span><br></pre></td></tr></table></figure><h2 id="二、通过git回退版本："><a href="#二、通过git回退版本：" class="headerlink" title="二、通过git回退版本："></a>二、通过git回退版本：</h2><h3 id="1、进入flutter-github找到要回退的版本"><a href="#1、进入flutter-github找到要回退的版本" class="headerlink" title="1、进入flutter github找到要回退的版本"></a>1、进入<a href="https://github.com/flutter/flutter/tags" target="_blank" rel="noopener">flutter github</a>找到要回退的版本</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220526100104.png" alt><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220526100204.png" alt></p><h3 id="2、cd进入到存放flutter-sdk目录，运行回退指令-git-reset-–hard-commit-id"><a href="#2、cd进入到存放flutter-sdk目录，运行回退指令-git-reset-–hard-commit-id" class="headerlink" title="2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id]"></a>2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id]</h3><p> 例如-&gt; git reset –hard 4cc385b4b84ac2f816d939a49ea1f328c4e0b48e</p><h3 id="3、查看flutter版本"><a href="#3、查看flutter版本" class="headerlink" title="3、查看flutter版本"></a>3、查看flutter版本</h3><p> 查看版本-&gt; flutter doctor  或者 flutter –version</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、通过命令：&quot;&gt;&lt;a href=&quot;#一、通过命令：&quot; class=&quot;headerlink&quot; title=&quot;一、通过命令：&quot;&gt;&lt;/a&gt;一、通过命令：&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;查看版本： flutter --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;检查环境：flutter doctor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看渠道：flutter channel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;切换渠道（stable, beta, dev, master）：flutter channel stable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;升级到最新版本：flutter upgrade &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;升级到指定版本：flutter upgrade v2.5.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;回退到指定版本：flutter downgrade v2.5.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;二、通过git回退版本：&quot;&gt;&lt;a href=&quot;#二、通过git回退版本：&quot; class=&quot;headerlink&quot; title=&quot;二、通过git回退版本：&quot;&gt;&lt;/a&gt;二、通过git回退版本：&lt;/h2&gt;&lt;h3 id=&quot;1、进入flutter-github找到要回退的版本&quot;&gt;&lt;a href=&quot;#1、进入flutter-github找到要回退的版本&quot; class=&quot;headerlink&quot; title=&quot;1、进入flutter github找到要回退的版本&quot;&gt;&lt;/a&gt;1、进入&lt;a href=&quot;https://github.com/flutter/flutter/tags&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;flutter github&lt;/a&gt;找到要回退的版本&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220526100104.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220526100204.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、cd进入到存放flutter-sdk目录，运行回退指令-git-reset-–hard-commit-id&quot;&gt;&lt;a href=&quot;#2、cd进入到存放flutter-sdk目录，运行回退指令-git-reset-–hard-commit-id&quot; class=&quot;headerlink&quot; title=&quot;2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id]&quot;&gt;&lt;/a&gt;2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id]&lt;/h3&gt;&lt;p&gt; 例如-&amp;gt; git reset –hard 4cc385b4b84ac2f816d939a49ea1f328c4e0b48e&lt;/p&gt;
&lt;h3 id=&quot;3、查看flutter版本&quot;&gt;&lt;a href=&quot;#3、查看flutter版本&quot; class=&quot;headerlink&quot; title=&quot;3、查看flutter版本&quot;&gt;&lt;/a&gt;3、查看flutter版本&lt;/h3&gt;&lt;p&gt; 查看版本-&amp;gt; flutter doctor  或者 flutter –version&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="http://yoursite.com/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="http://yoursite.com/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Flutter3.0 重磅发布</title>
    <link href="http://yoursite.com/posts/216218f9.html"/>
    <id>http://yoursite.com/posts/216218f9.html</id>
    <published>2022-05-26T02:12:56.000Z</published>
    <updated>2022-05-26T02:21:25.081Z</updated>
    
    <content type="html"><![CDATA[<p><strong>颠覆开发者开发方式的Flutter</strong></p><p>Flutter的诞生是为了彻底改变应用程序开发方式：将Web的迭代开发模式与硬件加速图形渲染和像素级控制相结合，这些以前可是游戏的专利，而现在它被来进行应用开发。自从Flutter 1.0测试版发布以来，谷歌对其不断地进行优化，让Flutter的功能日趋完善，比如添加了新的框架功能和小部件、与底层平台进行更加深入的集成、提供了丰富的软件包库，并且在性能和工具上也做了许多的改进。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2F7911e6d3j00rbreiu001xd200u0006bg00it003y.jpg&thumbnail=660x2147483647&quality=80&type=jpg" alt="img"></p><p>从1.0到3.0版本，Flutter被越来越多的开发者使用来构建应用程序。据谷歌最新用户研究报告显示：</p><ul><li>91%的开发人员认为Flutter能缩短构建和发布应用程序所需要的时间；</li><li>85%的开发人员认为Flutter使他们的应用程序更美观；</li><li>85%的人认可Flutter能使他们在更多的平台上发布他们的应用程序。</li></ul><p><strong>实现“大一统”，一个Flutter，横跨iOS、Android、Web、Windows、macOS、Linux六大平台</strong></p><p>Flutter 3.0为开发者提供了一种使用Dart编程语言为六大面向消费者的主流平台（iOS、Android、Web、Windows、macOS、Linux）目标编写应用程序的方法。基于Flutter 3，开发者能拥有从单个代码库为六个平台构建应用程序的体验，这将使其生产力大大提高。</p><p>不同于之前的版本，Flutter 3新增了对macOS和Linux应用程序的稳定支持。添加新平台的支持并不像我们想象中那么简单，其需要的不仅仅是渲染像素，还需要做很多其他的工作，比如新的输入和交互模型、编译和生成支持、可访问性和国际化以及特定于平台的集成等。Flutter不仅让用户能灵活地充分利用底层操作系统，同时能够根据需要共享尽可能多的UI。</p><p>具体来看，在macOS上，Flutter3可以通过通用二进制构建方式支持英特尔和Apple Silicon，允许应用打包在这两种架构上本机运行的可执行文件。同时，由于Dart对Apple Silicon的支持，编译速度也将更快。在Linux上，Canonical和谷歌合作提供了一个高度集成且在同类中最佳的开发选项。</p><a id="more"></a><p>另外，Flutter 3 还改进了许多基础功能，包括性能改进、Material You 支持和生产力更新。</p><p>除了上述所提到的内容，在新版本中，Flutter可以在苹果芯片上进行原生开发。虽然Flutter自发布以来，一直与搭载M1芯片的苹果设备兼容，但Flutter现在充分利用了Dart对Apple芯片的支持，可以在M1驱动的设备上实现更快的编译，并支持macOS应用程序的通用二进制文件。</p><p>另外，随着谷歌的Material Design 3在Flutter 3这个版本中基本已经完成，开发人员能够利用适应性强的跨平台设计系统，该系统提供动态配色方案和更新的视觉组件：</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2Fac3a791dj00rbreiv0068d200u000flg00it009r.jpg&thumbnail=660x2147483647&quality=80&type=jpg" alt="img"></p><p>Flutter是由Dart驱动的，Dart是一种用于多平台开发的高生产力、可移植的语言。谷歌在Dart中添加了一些新的语言功能。这些新的语言功能带来的好处颇多，比如能够减少模板、提高可读性、提供实验性的RISC-V支持，以及升级的linter和新的文档等。在专用的博客中可以获得关于Dart 2.17所有新更改的细节，可通过链接查看<a href="https://medium.com/dartlang" target="_blank" rel="noopener">https://medium.com/dartlang</a></p><p><strong>Firebase和Flutter深度集成</strong></p><p>当然，构建应用的不仅仅是UI框架。一套全面的工具在构建、开发和操作应用中也是必不可少的，比如身份验证、数据储存、云功能和设备测试等服务。而包括Sentry、AppWrite和AWS Amplify在内的很多服务都支持Flutter。</p><p>谷歌提供的应用服务Firebase使用率很高，在SlashData的开发者基准测试中，有62%的Flutter开发者表示会在开发应用程序时使用Firebase。因此，在以前的版本中，谷歌一直致力于将Flutter与Firebase更好地结合，以创造一流的的Flutter集成。为此，谷歌将Flutter中的Firebase插件提升到1.0（用于添加更好的文档和工具），以及提供像FlutterFire UI这样的新小部件（为开发人员提供可重用的UI用于身份验证和配置文件屏幕）。</p><p>今天，谷歌宣布将Flutter和Firebase的集成作为Firebase产品的核心，正在将源代码和文档移动到Firebase主存储库和站点中，而且谷歌有可能与Android和iOS同步发展Firebase对Flutter的支持。</p><p>此外，为了使用Crashlytics（Firebase广受欢迎的实时崩溃报告解决服务）谷歌还进行了以下重大改进。</p><ul><li>通过更新Flutter Crashlytics插件，可以让用户实时跟踪致命的错误，从而为用户提供与其他iOS或Android开发人员相同的功能集；</li><li>升级Crashlytics分析管道，以改进Flutter崩溃的聚类分析，从而更快地对问题进行分类、优先排序和修复；</li><li>简化了插件设置过程，因此只需几个步骤即可从用户的Dart代码中启动并运行Crashlytics。</li></ul><p><strong>Flutter休闲游戏工具包</strong></p><p>对于大多数开发者来说，Flutter只是一个应用程序框架。但是，在休闲游戏开发领域也有Flutter的一番天地。围绕休闲游戏开发的社区也在不断壮大，很多开发者利用Flutter提供的硬件加速图形支持和Flame等开源游戏引擎。</p><p>为了让休闲游戏开发者能够更能更容易上手，在今天的I/O大会上，谷歌宣布发布Flutter Casual Games Toolkit，它不仅提供了一个模板和最佳实践的入门工具包，还能带来广告和云服务的良好体验。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2F7dc50f30j00rbreix00c8d200u000c0g00it007i.jpg&thumbnail=660x2147483647&quality=80&type=jpg" alt="img"></p><p>虽然Flutter并不是为高强度的3D动作游戏而生的，但是有跨度是常有的事，即使是一些游戏也转向Flutter的非游戏UI，比如像PUBG Mobile这样拥有数亿用户的流行游戏。那么谷歌能把技术发展到什么程度呢？为了得到这个问题的答案，谷歌创建了一个有趣的弹球游戏（由Firebase和Flutter的网络支持提供支持）。</p><p>I/O弹球游戏中设计了一个带有四个吉祥物（Flutter的Dash、Firebase的Sparky、Android机器人和Chrome的恐龙）的定制桌子。玩家能在游戏中与别人一教高下，谷歌通过这种方式来展示Flutter多功能性，这很有趣。</p><p>Snearh认为，游戏开发和企业开发对性能和用户体验有着共同的追求，而Flutter团队一直在努力解决界面卡顿等问题，最终让框架能够更适用于各种类型的应用程序。</p><p><img src="https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2F6d50e3e7j00rbreiz00fed200u000gvg00id00ab.jpg&thumbnail=660x2147483647&quality=80&type=jpg" alt="img"></p><p><strong>「一套代码，到处运行」，从 Flutter 3 开始</strong></p><p>作为一款开源工具，Flutter不仅仅是谷歌的框架，也是一个业界开发者都能使用的产品。无论是通过贡献新的代码或文档、创建赋予核心框架新的超能力的软件包、编写指导他人的书籍和培训课程，还是帮助组织活动和用户组等等，人人都可以参与其中。Flutter 3的发布大大地提高了开发者的效率，也终让大家都实现了「一套代码，到处运行」的梦想。</p><p>原文地址：<a href="https://medium.com/flutter/introducing-flutter-3-5eb69151622f" target="_blank" rel="noopener">https://medium.com/flutter/introducing-flutter-3-5eb69151622f</a></p><p>参考地址：<a href="https://juejin.cn/post/7096617842023333925" target="_blank" rel="noopener">https://juejin.cn/post/7096617842023333925</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;颠覆开发者开发方式的Flutter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flutter的诞生是为了彻底改变应用程序开发方式：将Web的迭代开发模式与硬件加速图形渲染和像素级控制相结合，这些以前可是游戏的专利，而现在它被来进行应用开发。自从Flutter 1.0测试版发布以来，谷歌对其不断地进行优化，让Flutter的功能日趋完善，比如添加了新的框架功能和小部件、与底层平台进行更加深入的集成、提供了丰富的软件包库，并且在性能和工具上也做了许多的改进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2022%2F0512%2F7911e6d3j00rbreiu001xd200u0006bg00it003y.jpg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;从1.0到3.0版本，Flutter被越来越多的开发者使用来构建应用程序。据谷歌最新用户研究报告显示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;91%的开发人员认为Flutter能缩短构建和发布应用程序所需要的时间；&lt;/li&gt;
&lt;li&gt;85%的开发人员认为Flutter使他们的应用程序更美观；&lt;/li&gt;
&lt;li&gt;85%的人认可Flutter能使他们在更多的平台上发布他们的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实现“大一统”，一个Flutter，横跨iOS、Android、Web、Windows、macOS、Linux六大平台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flutter 3.0为开发者提供了一种使用Dart编程语言为六大面向消费者的主流平台（iOS、Android、Web、Windows、macOS、Linux）目标编写应用程序的方法。基于Flutter 3，开发者能拥有从单个代码库为六个平台构建应用程序的体验，这将使其生产力大大提高。&lt;/p&gt;
&lt;p&gt;不同于之前的版本，Flutter 3新增了对macOS和Linux应用程序的稳定支持。添加新平台的支持并不像我们想象中那么简单，其需要的不仅仅是渲染像素，还需要做很多其他的工作，比如新的输入和交互模型、编译和生成支持、可访问性和国际化以及特定于平台的集成等。Flutter不仅让用户能灵活地充分利用底层操作系统，同时能够根据需要共享尽可能多的UI。&lt;/p&gt;
&lt;p&gt;具体来看，在macOS上，Flutter3可以通过通用二进制构建方式支持英特尔和Apple Silicon，允许应用打包在这两种架构上本机运行的可执行文件。同时，由于Dart对Apple Silicon的支持，编译速度也将更快。在Linux上，Canonical和谷歌合作提供了一个高度集成且在同类中最佳的开发选项。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter Tips" scheme="http://yoursite.com/categories/Android/Flutter-Tips/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter Tips" scheme="http://yoursite.com/tags/Flutter-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Flutter混合开发组件化架构</title>
    <link href="http://yoursite.com/posts/187f2070.html"/>
    <id>http://yoursite.com/posts/187f2070.html</id>
    <published>2022-01-24T07:39:53.000Z</published>
    <updated>2022-01-24T08:05:41.069Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>背景</strong></li><li><strong>Flutter的四种工程类型</strong></li><li><strong>Flutter工程Pub依赖管理</strong></li><li><strong>FlutterModule集成到Native</strong></li><li><strong>Flutter与Native通信</strong></li><li><strong>Flutter组件化工程</strong></li><li><strong>后序</strong></li></ul><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>Flutter 在目前跨平台方案中有更好的平台一致性以及更优的体验。但对于本身已有成熟的业务代码的项目来说，更多的是采用混合栈的方式，在不变更原有 App 业务的基础上，将 Flutter 能力扩展为子模块进行接入和开发。这样并不影响原有的业务和原生能力，又可以结合业务需求进行技术选择。</p><h2 id="二、Flutter-的四种工程类型"><a href="#二、Flutter-的四种工程类型" class="headerlink" title="二、Flutter 的四种工程类型"></a>二、Flutter 的四种工程类型</h2><h3 id="2-1-Flutter-Application"><a href="#2-1-Flutter-Application" class="headerlink" title="2.1. Flutter Application"></a>2.1. Flutter Application</h3><p>标准的Flutter App工程，包含标准的Dart层与Native平台层</p><h3 id="2-2-Flutter-Module"><a href="#2-2-Flutter-Module" class="headerlink" title="2.2. Flutter Module"></a>2.2. Flutter Module</h3><p>Flutter组件工程，仅包含Dart层实现，Native平台层子工程为通过Flutter自动生成的隐藏工程</p><h3 id="2-3-Flutter-Plugin"><a href="#2-3-Flutter-Plugin" class="headerlink" title="2.3. Flutter Plugin"></a>2.3. Flutter Plugin</h3><p>Flutter平台插件工程，包含Dart层与Native平台层的实现</p><h3 id="2-4-Flutter-Package"><a href="#2-4-Flutter-Package" class="headerlink" title="2.4. Flutter Package"></a>2.4. Flutter Package</h3><p>Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget</p><a id="more"></a><h2 id="三、Flutter工程Pub依赖管理"><a href="#三、Flutter工程Pub依赖管理" class="headerlink" title="三、Flutter工程Pub依赖管理"></a>三、Flutter工程Pub依赖管理</h2><p>Flutter工程之间的依赖管理是通过Pub来管理的，依赖的产物是直接源码依赖，这种依赖方式和IOS中的Pod有点像，都可以进行依赖库版本号的区间限定与Git远程依赖等，其中具体声明依赖是在<strong>pubspec.yaml</strong>文件中，其中的依赖编写是基于YAML语法，YAML是一个专门用来编写文件配置的语言。</p><p>声明依赖后，通过运行<strong>flutter packages get</strong>命名，会从远程或本地拉取对应的依赖，同时会生成pubspec.lock文件，这个文件和IOS中的Podfile.lock极其相似，会在本地锁定当前依赖的库以及对应版本号，只有当执行<strong>flutter packages upgrade</strong>时，这时才会更新。</p><h2 id="四、Flutter-module-集成到-Native"><a href="#四、Flutter-module-集成到-Native" class="headerlink" title="四、Flutter module 集成到 Native"></a>四、Flutter module 集成到 Native</h2><p>上述说的如果我们要利用Flutter来开发我们现有Native工程中的一个模块或功能，肯定得不能改变Native的工程结构以及不影响现有的开发流程，那么，以何种方式进行混合开发呢？</p><h3 id="4-1-Flutter混合开发模式"><a href="#4-1-Flutter混合开发模式" class="headerlink" title="4.1 Flutter混合开发模式"></a>4.1 Flutter混合开发模式</h3><p>Flutter混合开发模式一般有两种方式：</p><ul><li>Flutter App 我们可以直接忽略，因为这是一个开发全新的Flutter App工程。</li><li>对于Flutter Module，官方提供的本地依赖便是使用Flutter Module依赖到Native App的，而对于Flutter工程来说，构建Flutter工程必须得有个main.dart主入口，恰好Flutter Module中也有主入口。</li></ul><h3 id="4-2-Flutter-Module的创建方式"><a href="#4-2-Flutter-Module的创建方式" class="headerlink" title="4.2 Flutter Module的创建方式"></a>4.2 Flutter Module的创建方式</h3><p>Flutter module创建方式一般有两种：</p><p><strong>a、通过命令来创建</strong></p><blockquote><p>flutter create -t module –org com.vhall.module vhall_flutter_module</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Creating project vhall_flutter_module...</span><br><span class="line">  vhall_flutter_module/test/widget_test.dart (created)</span><br><span class="line">  vhall_flutter_module/vhall_flutter_module.iml (created)</span><br><span class="line">  vhall_flutter_module/.gitignore (created)</span><br><span class="line">  vhall_flutter_module/.metadata (created)</span><br><span class="line">  vhall_flutter_module/pubspec.yaml (created)</span><br><span class="line">  vhall_flutter_module/README.md (created)</span><br><span class="line">  vhall_flutter_module/lib/main.dart (created)</span><br><span class="line">  vhall_flutter_module/vhall_flutter_module_android.iml (created)</span><br><span class="line">  vhall_flutter_module/analysis_options.yaml (created)</span><br><span class="line">  vhall_flutter_module/.idea/libraries/Dart_SDK.xml (created)</span><br><span class="line">  vhall_flutter_module/.idea/modules.xml (created)</span><br><span class="line">  vhall_flutter_module/.idea/workspace.xml (created)</span><br><span class="line">Running &quot;flutter pub get&quot; in vhall_flutter_module...             1,226ms</span><br><span class="line">Wrote 12 files.</span><br><span class="line"></span><br><span class="line">All done!</span><br><span class="line">Your module code is in vhall_flutter_module/lib/main.dart.</span><br></pre></td></tr></table></figure><p><strong>b、使用 As 创建 Flutter Module</strong></p><p>在 As 中选择 File-&gt;New-&gt;New Flutter Project，选择 Flutter Module 创建 Flutter Module 子项目</p><h3 id="4-3-添加Flutter的两种依赖方式"><a href="#4-3-添加Flutter的两种依赖方式" class="headerlink" title="4.3 添加Flutter的两种依赖方式"></a>4.3 添加Flutter的两种依赖方式</h3><h4 id="4-3-1-将Flutter添加到原生工程中，-有两种方式："><a href="#4-3-1-将Flutter添加到原生工程中，-有两种方式：" class="headerlink" title="4.3.1 将Flutter添加到原生工程中， 有两种方式："></a>4.3.1 将Flutter添加到原生工程中， 有两种方式：</h4><p><strong>a、以aar的方式集成到现有Android项目中</strong></p><p>创建好 Flutter Module 之后需要将其编译成 aar 的形式，可以通过如下命令进行 aar 的编译：</p><blockquote><p>cd vhall_flutter_module flutter build aar              </p></blockquote><p>在 Android 中也可以通过 As 工具来编译 aar，选择 Build-&gt;Flutter-&gt;Build AAR 来进行 aar 的编译。</p><p>然后根据提示在主项目工程的 build.grade 文件中进行相关配置，参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">💪 Building with sound null safety 💪</span><br><span class="line"></span><br><span class="line">Running Gradle task &apos;assembleAarDebug&apos;...                          22.2s</span><br><span class="line">✓ Built build/host/outputs/repo.</span><br><span class="line">Running Gradle task &apos;assembleAarProfile&apos;...                        46.1s</span><br><span class="line">✓ Built build/host/outputs/repo.</span><br><span class="line">Running Gradle task &apos;assembleAarRelease&apos;...                        37.2s</span><br><span class="line">✓ Built build/host/outputs/repo.</span><br><span class="line"></span><br><span class="line">Consuming the Module</span><br><span class="line">  1. Open &lt;host&gt;/app/build.gradle</span><br><span class="line">  2. Ensure you have the repositories configured, otherwise add them:</span><br><span class="line"></span><br><span class="line">      String storageUrl = System.env.FLUTTER_STORAGE_BASE_URL ?: &quot;https://storage.googleapis.com&quot;</span><br><span class="line">      repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &apos;/Users/zhangmiao/Documents/project/hybrid/vhall_flutter_module/build/host/outputs/repo&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &quot;$storageUrl/download.flutter.io&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  3. Make the host app depend on the Flutter module:</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">      debugImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_debug:1.0&apos;</span><br><span class="line">      profileImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_profile:1.0&apos;</span><br><span class="line">      releaseImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_release:1.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  4. Add the `profile` build type:</span><br><span class="line"></span><br><span class="line">    android &#123;</span><br><span class="line">      buildTypes &#123;</span><br><span class="line">        profile &#123;</span><br><span class="line">          initWith debug</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">To learn more, visit https://flutter.dev/go/build-aar</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>依赖一个包含 Flutter 产物的 aar 包，这个的好处就是其他不开发 flutter 的同学可以不用配置 flutter 环境，它和其他模块包无异</li></ul><p><strong>b、以 Flutet module 的方式集成到现有 Android 项目中</strong></p><p>在 setting.gradle 文件中配置 flutter module 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setBinding(new Binding([gradle: this]))</span><br><span class="line">evaluate(new File(</span><br><span class="line">  settingsDir,</span><br><span class="line">  &apos;../vhall_flutter_module/.android/include_flutter.groovy&apos;</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>在 app 项目的 build.gradle 依赖 flutter module 模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation project(&apos;:flutter&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>需要 flutter 环境，并且各个开发人员环境不一致，导致集成因为版本不一致报各种错误</li></ul><h3 id="4-3-2本地依赖的原理"><a href="#4-3-2本地依赖的原理" class="headerlink" title="4.3.2本地依赖的原理"></a>4.3.2本地依赖的原理</h3><p><strong>Android</strong></p><p>在Android中本地依赖方式为：</p><ul><li>在<strong>settings.gradle</strong>中注入<strong>include_flutter.groovy</strong>脚本</li><li>在需要依赖的app中<strong>build.gradle</strong>添加<strong>project(‘:flutter’)</strong>依赖</li></ul><p>对于Android的本地依赖，主要是由<strong>include_flutter.groovy</strong>和<strong>flutter.gradle</strong>这两个脚本负责Flutter的本地依赖和产物构建。</p><p><strong>a</strong>、<strong>include_flutter.groovy</strong></p><p>在<strong>settings.gradle</strong>中注入时，分别绑定了当前执行Gradle的上下文环境与执行<strong>include_flutter.groovy</strong>脚本，该脚本只做了下面三件事：</p><ul><li>include FlutterModule中的<strong>.android/Flutter</strong>工程</li><li>include FlutterModule中的<strong>.flutter-plugins</strong>文件中包含的Flutter工程路径下的android module</li><li>配置所有工程的<strong>build.gradle</strong>配置执行阶段都依赖于<strong>:flutter</strong>工程，也即它最先执行配置阶段</li></ul><p>其中<strong>.flutter-plugins</strong>文件，是根据当前依赖自动生成的，里面包含了当前Flutter工程所依赖（直接依赖和传递依赖）的Flutter子工程与绝对路径的K-V关系，子工程可能是一个Flutter Plugin或者是一个Flutter Package。</p><p> <strong>b</strong>、<strong>flutter.gradle</strong></p><p>该脚本位于Flutter SDK中，内容看起来很长，其实主要做了下面三件事：</p><ul><li>选择符合对应架构的Flutter引擎（flutter.so）</li><li>解析上述<strong>.flutter-plugins</strong>文件，把对应的android module添加到Native工程的依赖中（上述的include其实为这步做准备）</li><li>Hook mergeAssets/processResources Task，预先执行FlutterTask，调用<strong>flutter</strong>命令编译Dart层代码构建出<strong>flutter_assets</strong>产物，并拷贝到<strong>assets</strong>目录下</li></ul><p>有了上述三步，则直接在Native工程中运行构建即可自动构建Flutter工程中的代码并自动拷贝产物到Native中</p><p><strong>IOS</strong></p><p>在IOS中本地依赖方式为：</p><ul><li>在Podfile中通过<strong>eval binding</strong>特性注入<strong>podhelper.rb</strong>脚本，在pod install/update时会执行它</li><li>在IOS构建阶段<strong>Build Phases</strong>中注入构建时需要执行的<strong>xcode_backend.sh</strong>脚本</li></ul><p>对于IOS的本地依赖，主要是由<strong>podhelper.rb</strong>和<strong>xcode_backend.sh</strong>这两个脚本负责Flutter的Pod本地依赖和产物构建</p><p><strong>a</strong>、<strong>podhelper.rb</strong></p><p>因Podfile是通过ruby语言写的，所以该脚本也是ruby脚本，该脚本在pod install/update时主要做了三件事：</p><ul><li>Pod本地依赖Flutter引擎（Flutter.framework）与Flutter插件注册表（FlutterPluginRegistrant）</li><li>Pod本地源码依赖<strong>.flutter-plugins</strong>文件中包含的Flutter工程路径下的ios工程</li><li>在pod install执行完后<strong>post_install</strong>中，获取当前target工程对象，导入<strong>Generated.xcconfig</strong>配置，这些配置都为环境变量配置，主要为构建阶段<strong>xcode_backend.sh</strong>脚本执行做准备</li></ul><p>上述事情即可保证Flutter工程以及传递依赖的都通过pod本地依赖进Native工程了，接下来就是构建了</p><p><strong>b、xcode_backend.sh</strong></p><p>该Shell脚本位于Flutter SDK中，该脚本主要就做了两件事：</p><ul><li>调用flutter命令编译构建出产物（App.framework、flutter_assets）</li><li>把产物（<em>.framework、flutter_assets）拷贝到对应XCode构建产物中，对应产物目录为：*</em>$HOME/Library/Developer/Xcode/DerivedData/${AppName}**</li></ul><p>上述两个静态库<strong>*.framework</strong>是拷贝到<strong>${BUILT_PRODUCTS_DIR}”/“${PRODUCT_NAME}”.app/Frameworks”</strong>目录下</p><p>flutter_assets拷贝到<strong>${BUILT_PRODUCTS_DIR}”/“${PRODUCT_NAME}”.app”</strong>目录下</p><p>在XCode工程中，对应的是在<strong>${AppName}/Products/${AppName}.app</strong></p><h3 id="4-4-原生接入-flutter-页面"><a href="#4-4-原生接入-flutter-页面" class="headerlink" title="4.4 原生接入 flutter 页面"></a>4.4 原生接入 flutter 页面</h3><p>flutter 依赖提供了 FlutterActivity 来直接加载 flutter 页面，我们只需要在清单文件中配置该 Activity ：</p><p>（通常我们会创建一个 Activity 继承 FlutterActivity）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;io.flutter.embedding.android.FlutterActivity&quot;</span><br><span class="line">    android:theme=&quot;@style/Theme.Vhall_app&quot;</span><br><span class="line">    android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode&quot;</span><br><span class="line">    android:hardwareAccelerated=&quot;true&quot;</span><br><span class="line">    android:windowSoftInputMode=&quot;adjustResize&quot;/&gt;</span><br></pre></td></tr></table></figure><p>三种打开flutter页面的方式：</p><p>1）普通跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    startActivity(</span><br><span class="line">      FlutterActivity.createDefaultIntent(currentActivity)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2）设置路由的方式跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">myButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">    startActivity(</span><br><span class="line">      FlutterActivity</span><br><span class="line">        .withNewEngine()</span><br><span class="line">        .initialRoute(&quot;/my_route&quot;)</span><br><span class="line">        .build(currentActivity)</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码会在内部创建自己的 FlutterEngine 实例，每个 FlutterActivity 都创建自己的 FlutterEngine，这意味着启动一个标准的 FlutterActivity 会在界面可见时出现一短暂的延迟，可以选择使用预缓存的 FlutterEngine 来减小其延迟，实际上在内部会先检查是否存在预缓存的 FlutterEngine，如果存在则使用该 FlutterEngine，否则继续使用非预缓存的 FlutterEngine。</p><p>3）缓存 Flutter 引擎方式跳转：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">    public FlutterEngine flutterEngine;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        // Instantiate a FlutterEngine.</span><br><span class="line">        flutterEngine = new FlutterEngine(this);</span><br><span class="line"></span><br><span class="line">       // Start executing Dart code to pre-warm the FlutterEngine.</span><br><span class="line">       flutterEngine.getDartExecutor().executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault());</span><br><span class="line"></span><br><span class="line">       // Cache the FlutterEngine to be used by FlutterActivity.</span><br><span class="line">       FlutterEngineCache.getInstance().put(&quot;my_engine_id&quot;, flutterEngine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myButton.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View view) &#123;</span><br><span class="line">        startActivity(</span><br><span class="line">            LoginFlutterActivity</span><br><span class="line">                  .withCachedEngine(&quot;my_engine_id&quot;)</span><br><span class="line">                  .build(MainActivity.this)</span><br><span class="line">        );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="五、Flutter与Native通信"><a href="#五、Flutter与Native通信" class="headerlink" title="五、Flutter与Native通信"></a>五、Flutter与Native通信</h2><h3 id="5-1Platform-Channel"><a href="#5-1Platform-Channel" class="headerlink" title="5.1Platform Channel"></a>5.1Platform Channel</h3><p><strong>Platform Channel</strong>为Dart和平台之间提供了相互通信的机制，将<strong>Flutter</strong>、<strong>Android</strong>、<strong>iOS</strong>连接起来。</p><p>在移动H5开发中，<strong>webview</strong>自身提供的功能往往不够用，为了解决这个问题，引入了<strong>jsbridge</strong>，即<strong>web</strong>与<strong>native</strong>之间进行数据交互的一种方法,可以方便的将native的功能扩展给<strong>webview</strong>使用，从而可以快速开发。在<strong>Flutter</strong>中，也存在和<strong>jsbridge</strong>一样的用法，那就是<strong>Platform Channel</strong>，我们可以通过<strong>Platform Channel</strong>，将<strong>Flutter</strong>和<strong>Native</strong>方便的连接在一起，架构图如下:</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220124155717.png" alt></p><p>在Channel中</p><ol><li>client发送信息</li><li>host接受信息并返回结果</li><li>而且消息和响应是以异步方式传递的</li><li>Flutter和Natvie可以互为client和host，信息传递是双向的</li></ol><h3 id="5-2-三种不同类型的Platform-Channel"><a href="#5-2-三种不同类型的Platform-Channel" class="headerlink" title="5.2 三种不同类型的Platform Channel"></a>5.2 三种不同类型的Platform Channel</h3><p>Flutter定义了三种不同类型的Platform Channel用于Flutter与Host App平台进行通信，它们分别</p><ul><li><strong>BasicMessageChannel</strong>：用于数据传递，可以双向的请求数据。</li><li><strong>MethodChannel</strong>：用于传递方法调用，即Flutter端可以调用Platform端的方法并通过Result接口回调结果数据。</li><li><strong>EventChannel</strong>: 用于传递事件，即Flutter端监听Platform端的实时消息，一旦Platform端产生了数据，立即回调到Flutter端。</li></ul><p>其构造方法都需指定一个通道标识、解编码器以及 BinaryMessenger，BinaryMessenger 是一个 Flutter 与平台的通信工具，用来传递二进制数据、设置对应的消息处理器等。</p><p>解编码器有两种分别是 MethodCodec 和 MessageCodec，前者对应方法后者对应消息，BasicMessageChannel 使用的是 MessageCodec，MethodChannel 和 EventChannel 使用的是 MethodCodec。</p><h3 id="5-3-平台数据类型对照"><a href="#5-3-平台数据类型对照" class="headerlink" title="5.3 平台数据类型对照"></a>5.3 平台数据类型对照</h3><p>Platform Channel 提供不同的消息解码机制，如 StandardMessageCodec 提供基本数据类型的解编码、JSONMessageCodec 支持 Json 的解编码等，在平台之间通信时都会自动转换，各平台数据类型对照如下：<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220124155756.png" alt></p><h2 id="六、Flutter组件化工程"><a href="#六、Flutter组件化工程" class="headerlink" title="六、Flutter组件化工程"></a>六、Flutter组件化工程</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>前面讲了Flutter和Native的混合开发模式，Flutter作为Native工程的一个Module存在，这样可以有效的将Flutter和Native进行物理隔离，但随着Flutter承载的业务越来越多，与Native交互的接口变的越来越多，带来了很多管理问题，因此我们迫切需要采用新的开发模式，即Flutter的组件化开发方案。</p><h3 id="6-2-组件化的优势"><a href="#6-2-组件化的优势" class="headerlink" title="6.2 组件化的优势"></a>6.2 组件化的优势</h3><p>采用组件化开发Flutter，将会有如下的优势：</p><ul><li>将功能模块化，相互独立，方便管理</li><li>模块之间互不影响，耦合低，一些与业务无关的模块可以开源出来，供其他APP使用，提供代码的复用。</li><li>采用组件化开发，开发时互不影响，可以提高开发效率。</li><li>方便单元测试</li></ul><h3 id="6-3-组件化架构"><a href="#6-3-组件化架构" class="headerlink" title="6.3 组件化架构"></a>6.3 组件化架构</h3><p>组件划分，通过Flutter Module作为所有通过Flutter实现的模块或功能的聚合入口，通过它进行Flutter层到Native层的双向关联。而Flutter开发代码写在哪里呢？当然可以直接写在Flutter Module中，这没问题，而如果后续开发了多个模块、组件，我们的Dart代码总不可能全部写在Flutter Module中lib/吧，如果在lib/目录下再建立子目录进行模块区分，这不失为一种最简单的方式，不过这会带来一些问题，所有模块共用一个远程Git地址，首先在组件开发隔离上完全耦合了，其次各个模块组件没有单独的版本号或Tag，且后续模块组件的增多，带来更多的测试回归成本。</p><p>正确的组件化方式为一个组件有一个独立的远程Git地址管理，这样各个组件在发正式版时都有一个版本号和Tag，且在各个组件开发上完全隔离，后续组件的增多不影响其它组件，某个组件新增需求而不需回归其它组件，带来更低的测试成本。</p><p>前面提到Flutter Plugin可以有对应Dart层代码与平台层的实现，所以可以这样设计，一个组件对应一个Flutter Plugin，一个Flutter Plugin为一个完整的Flutter工程，有独立的Git地址，而这些组件之间不能互相依赖，保持零耦合，所以这些组件都在业务层，可以叫做业务组件，这些业务组件之间的通信和公共服务可以再划分一层基础层，可以叫做基础组件，所有业务组件依赖基础层，而Flutter Module作为聚合层依赖于所有Flutter组件，这些Flutter工程之间的依赖正是通过Pub依赖进行管理的。</p><p>所以，综合上述，整体的组件化架构可以设计为：<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220124155848.png" alt></p><h3 id="6-4业务组件与基础组件的定位"><a href="#6-4业务组件与基础组件的定位" class="headerlink" title="6.4业务组件与基础组件的定位"></a>6.4业务组件与基础组件的定位</h3><p>对于上面的基础组件比如还可以进行更细粒度的划分，不过不建议划分太多，对于与Native平台层的通信，每个业务组件对应一个Channel，当然内部还可以进行更细粒度的Channel进行划分，这个Channel主要是负责Native层服务的提供，让Flutter层消费。而对于Native层调用Flutter层的Api，应该尽可能少，需要调也只有出现一些值回调时。</p><p>因为Flutter的出现最本质的就是一次开发两端运行，而如果有太多这种依赖于平台层的实现，反而出现违背了，最后只是UI写了一份而已。对于平台层的实现也要尽量保持一个原则，即：</p><p>尽量让Native平台层成为服务层，让Flutter层成为消费层调用Native层的服务，即Dart调用Native的Api，这样当两端开发人员编写好一致基础的服务接口后，Flutter的开发人员即可平滑使用和开发。</p><h2 id="七、后序"><a href="#七、后序" class="headerlink" title="七、后序"></a>七、后序</h2><p>对于现有工程使用Flutter进行混合开发，坑点还是有的，比如性能、页面栈管理等方面，加上目前Flutter上一些基础库不成熟，对于项目内的重要页面以及动态化强度比较高的页面，目前还是不建议使用Flutter进行开发，如果要使用也须做好降级方案，相反可以使用稍微轻量级点的页面，且在设计时对于Flutter与Native层的通信，应该让Flutter作为消费层消费Native层提供的服务，Native端应做尽量少的改动等等。与纯原生开发或纯 Flutter 开发相比，混合开发由于需要打通原生和 Flutter 的数据和服务，需要有大量桥接实现，各个模块互相协作也需要考虑各种异常或降级的情况。</p><p>参考：<br>将 Flutter module 集成到 Android 项目 <a href="https://flutter.cn/docs/development/add-to-app/android/project-setup" target="_blank" rel="noopener">https://flutter.cn/docs/development/add-to-app/android/project-setup</a><br>将 Flutter module 集成到 iOS 项目 <a href="https://flutter.cn/docs/development/add-to-app/ios/project-setup" target="_blank" rel="noopener">https://flutter.cn/docs/development/add-to-app/ios/project-setup</a><br>在 Android 应用中添加 Flutter 页面<a href="https://flutter.cn/docs/development/add-to-app/android/add-flutter-screen" target="_blank" rel="noopener">https://flutter.cn/docs/development/add-to-app/android/add-flutter-screen</a><br>在 iOS 应用中添加 Flutter 页面 <a href="https://flutter.cn/docs/development/add-to-app/ios/add-flutter-screen" target="_blank" rel="noopener">https://flutter.cn/docs/development/add-to-app/ios/add-flutter-screen</a><br>Add-to-App Samples <a href="https://github.com/flutter/samples/blob/beface247a/add_to_app/README.md" target="_blank" rel="noopener">https://github.com/flutter/samples/blob/beface247a/add_to_app/README.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flutter的四种工程类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flutter工程Pub依赖管理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FlutterModule集成到Native&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flutter与Native通信&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flutter组件化工程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;Flutter 在目前跨平台方案中有更好的平台一致性以及更优的体验。但对于本身已有成熟的业务代码的项目来说，更多的是采用混合栈的方式，在不变更原有 App 业务的基础上，将 Flutter 能力扩展为子模块进行接入和开发。这样并不影响原有的业务和原生能力，又可以结合业务需求进行技术选择。&lt;/p&gt;
&lt;h2 id=&quot;二、Flutter-的四种工程类型&quot;&gt;&lt;a href=&quot;#二、Flutter-的四种工程类型&quot; class=&quot;headerlink&quot; title=&quot;二、Flutter 的四种工程类型&quot;&gt;&lt;/a&gt;二、Flutter 的四种工程类型&lt;/h2&gt;&lt;h3 id=&quot;2-1-Flutter-Application&quot;&gt;&lt;a href=&quot;#2-1-Flutter-Application&quot; class=&quot;headerlink&quot; title=&quot;2.1. Flutter Application&quot;&gt;&lt;/a&gt;2.1. Flutter Application&lt;/h3&gt;&lt;p&gt;标准的Flutter App工程，包含标准的Dart层与Native平台层&lt;/p&gt;
&lt;h3 id=&quot;2-2-Flutter-Module&quot;&gt;&lt;a href=&quot;#2-2-Flutter-Module&quot; class=&quot;headerlink&quot; title=&quot;2.2. Flutter Module&quot;&gt;&lt;/a&gt;2.2. Flutter Module&lt;/h3&gt;&lt;p&gt;Flutter组件工程，仅包含Dart层实现，Native平台层子工程为通过Flutter自动生成的隐藏工程&lt;/p&gt;
&lt;h3 id=&quot;2-3-Flutter-Plugin&quot;&gt;&lt;a href=&quot;#2-3-Flutter-Plugin&quot; class=&quot;headerlink&quot; title=&quot;2.3. Flutter Plugin&quot;&gt;&lt;/a&gt;2.3. Flutter Plugin&lt;/h3&gt;&lt;p&gt;Flutter平台插件工程，包含Dart层与Native平台层的实现&lt;/p&gt;
&lt;h3 id=&quot;2-4-Flutter-Package&quot;&gt;&lt;a href=&quot;#2-4-Flutter-Package&quot; class=&quot;headerlink&quot; title=&quot;2.4. Flutter Package&quot;&gt;&lt;/a&gt;2.4. Flutter Package&lt;/h3&gt;&lt;p&gt;Flutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>【新技术】又双叒叕来了系列三</title>
    <link href="http://yoursite.com/posts/477750ac.html"/>
    <id>http://yoursite.com/posts/477750ac.html</id>
    <published>2022-01-12T05:36:43.000Z</published>
    <updated>2022-01-12T06:07:59.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-在-Android-模拟器上运行-ARM-应用"><a href="#1-在-Android-模拟器上运行-ARM-应用" class="headerlink" title="1. 在 Android 模拟器上运行 ARM 应用"></a>1. 在 Android 模拟器上运行 ARM 应用</h3><p>这算是一个非常好的消息了，之前在实际应用开发中，因为模拟器缺少对 arm 的支持，基本上都使用真机进行开发与调试。<br>随着 Android 11预览版的发布<br>Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM 指令转换成 x86 指令。开发者无需搭建高负载的 ARM 环境即可执行 ARM 二进制文件并进行测试。</p><p>详情：<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652052998&idx=1&sn=9839e5a74c1dba47123d6cb5da15c10f&scene=21#wechat_redirect" target="_blank" rel="noopener">在 Android 模拟器上运行 ARM 应用</a></p><h3 id="2-大厂对外文章分享"><a href="#2-大厂对外文章分享" class="headerlink" title="2. 大厂对外文章分享"></a>2. 大厂对外文章分享</h3><p><strong>携程技术</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697269503&idx=2&sn=f5505724dcee64ebd9904ee16a2bfedb&scene=21#wechat_redirect" target="_blank" rel="noopener"> 携程Android 10适配踩坑指南</a><br>新版本适配一直是 Android 开发者的痛楚之一，但是这件事如果长期不升就会越来越困难。加上现在应用市场比较强势，所以保持一个较高的版本的适配是有必要的。<br>携程旅行分享了他们从API 26 到 29 的适配经验，大家可以参考一波。<br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697269484&idx=1&sn=1f5dcd45f90b2314050a04492e3a1cc0&scene=21#wechat_redirect" target="_blank" rel="noopener">全网最详！暗黑模式在 Trip.com App 的实践</a></p><p>暗黑模式也最近的一个非常热门的话题，甚至微信支持暗黑模式都成为热点了。如果你对这方面感兴趣，或者刚好有暗黑实践的需求，那么可以看这一篇由携程 UED 团队+研发团队撰写的文章。<br>我个人其实一直没有体验过暗黑模式，毕竟没适配的 app 太多了，所以我不认为把手机切换为暗黑模式有很好的的体验…</p><p><strong>Google 开发者</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652052998&idx=2&sn=18715a7e33b7f7a5878bd301e9f8f935&scene=21#wechat_redirect" target="_blank" rel="noopener">在 Android 开发中使用协程 | 背景介绍</a><br>可以看一下官方的文章了解下协程的一些背景知识，用来解决什么问题，如何解决，以及性能相关的一些知识。</p><p><strong>字节跳动技术团队</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485583&idx=1&sn=a572862f110948673818d745cea5aea6&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音包大小优化-资源优化</a><br>可以看下抖音团队为了减少 apk 的体积，针对资源这一方面做了哪些<strong>极致</strong>的事情。<br>另外 apk 体积优化也可以看下 jsonchao 的文章：<br><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650830257&idx=1&sn=f94eb0e05a1c40d5a99a7384b6f736ad&chksm=80b7a12fb7c028395c18bc81f544bc4d893ca9829e7b702e079d973608bee3b6eb5a7d2c49ff&scene=21#wechat_redirect" target="_blank" rel="noopener">吹爆系列：深入探索Android包体积优化</a></p><p><strong>百度 APP 技术</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247484032&idx=1&sn=da2740910b6df7d7f1ee9e2903f5ca27&scene=21#wechat_redirect" target="_blank" rel="noopener">Gradle 与 Android 构建入门</a><br>写了一篇 Gradle 构建入门的文章，其实很多同学都非常害怕 Gradle，这篇文章会给大家解释为什么需要 Gradle，以及 Gradle 相关的一些基础知识，帮你更好的了解相关知识，比较轻松，可以一看。</p><p><strong>西瓜技术团队</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODczOQ==&mid=2247483682&idx=1&sn=883435f1fe81295ec1c3ef6d576953c9&scene=21#wechat_redirect" target="_blank" rel="noopener">AwCookieManager.nativeGetCookie crash 排查</a><br>分享了西瓜的一个CookieManager.getCookie(String url) 过程中的 native crash，分析过程较为复杂，不过给出了解决方案，解决方案涉及到 hook，西瓜用了自研的方案，开源的 lancet 应该也能做到，这篇文章也会提到 lancet。</p><a id="more"></a><p>历史分享(点击可直接访问)：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580200&idx=1&sn=c663d8be4628d74efb20aee09f1cc743&scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯Bugly:对字符串匹配算法的一点理解</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247485203&idx=1&sn=26fd99ca1201e292ea5531c814eeb881&scene=21#wechat_redirect" target="_blank" rel="noopener">爱奇艺：安卓APP崩溃捕获方案——xCrash</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485042&idx=1&sn=fe32711dbcb483f7a47dfa0e304087c4&scene=21#wechat_redirect" target="_blank" rel="noopener">字节跳动：深入理解Gradle框架之一：</a><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485042&idx=1&sn=fe32711dbcb483f7a47dfa0e304087c4&scene=21#wechat_redirect" target="_blank" rel="noopener">Plugin, Extension, buildSrc</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483745&idx=1&sn=59bf0c9bc5b584d411880617cf32f795&scene=21&token=1556389437&lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">百度APP技术：Android H5首屏优化实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE2NzIzMg==&mid=2247487670&idx=1&sn=952e44c0ce8890b27b0115a1974cc431&scene=21#wechat_redirect" target="_blank" rel="noopener">京东技术：任意URL跳转漏洞修复与JDK中getHost()方法之间的坑</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483789&idx=1&sn=f3843b9ce282ab7d4e3c6225d780f9cd&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483804&idx=1&sn=026f386cc88d07044735cde5206c1de0&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483815&idx=1&sn=c3872d2e1b86d6eb48b8665fbf6f6fa4&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝 App 构建优化解析：Android 包大小极致压缩</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==&mid=2247484874&idx=1&sn=bc0f92ccb6d1b7c6be6bc535ac491cd7&scene=21#wechat_redirect" target="_blank" rel="noopener">搜狐：深入理解Flutter多线程</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697268363&idx=1&sn=3db2dce36a912936961c671dd1f71c78&scene=21#wechat_redirect" target="_blank" rel="noopener">携程：从智行 Android 项目看组件化架构实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652049096&idx=1&sn=dc9d0a408d07d78d487974354fd5dee7&scene=21#wechat_redirect" target="_blank" rel="noopener">Google: Flutter 您需要知道的知识点 | FAQ・第三期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484937&idx=1&sn=144003c8c662eebbdd71d7a9617e3439&chksm=e9d0cdebdea744fd3f413d3667590479bb5c4e52d628d44b37807a761be6415f3b4e5c40d554&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">字节跳动：二维码扫描优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247483887&idx=1&sn=d54e3f210a4f31f477dba06c3dcd352e&scene=21#wechat_redirect" target="_blank" rel="noopener">网易传媒技术团队：AOP技术在客户端的应用与实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247483939&idx=1&sn=aa170d606c7de063a0d587aa4da1fc91&scene=21#wechat_redirect" target="_blank" rel="noopener">网易大数据|互联网产品决策秘笈: AB测试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzIwMDM5Ng==&mid=2247483750&idx=1&sn=8ba37d6b8a073c3a0fbb0dcc10b00175&scene=21#wechat_redirect" target="_blank" rel="noopener">高德：Android Native 内存泄漏系统化解决方案</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTU3MTE4NQ==&mid=2247484444&idx=1&sn=2c4c8fa957df258003c4fcfe63df3a59&chksm=ea591302dd2e9a14aebb553e3af14fa12d239dd76ef01b3855bb5b9f2a3196b42e829ce8d504&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">例说 Constraint Layout（三）—— 性能测试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTU3MTE4NQ==&mid=2247484411&idx=1&sn=f8cd93a994080a31cfdb58bda9f5dc75&chksm=ea5914e5dd2e9df35cfe04b066eefc9b876faa074569f45a5320a28c5b0031d8cad282bacdf3&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">Android P之Smart Linkif</a>y</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483830&idx=1&sn=a158b07ca3fe6a4ef8ff89d4f5b682aa&scene=21#wechat_redirect" target="_blank" rel="noopener">百度App组件化之路</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483844&idx=1&sn=59e434f601cc4ae5a3970e8751662fd2&scene=21#wechat_redirect" target="_blank" rel="noopener">百度App网络深度优化系列《三》弱网优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485061&idx=1&sn=7c935aecbb9b558e4d5d9dd2c3eb7f96&scene=21#wechat_redirect" target="_blank" rel="noopener"> 头条| 深入理解gradle框架之二：依赖实现分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750945&idx=2&sn=4c0f9c59498610ea1ce9744b8b35e61a&scene=21#wechat_redirect" target="_blank" rel="noopener">美团| Probe：Android线上OOM问题定位组件</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750923&idx=1&sn=1044e16dddeda4e7a6daaadfe9637f75&scene=21#wechat_redirect" target="_blank" rel="noopener">美团|Android静态代码扫描效率优化与实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485301&idx=1&sn=eadc3d5ebfebe32c354dcd4529cd86c5&scene=21#wechat_redirect" target="_blank" rel="noopener">头条|开源 | Scene：Android 开源页面导航和组合框架</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247484258&idx=1&sn=558555cefa7ac495b66c31dd201b1c1c&scene=21#wechat_redirect" target="_blank" rel="noopener">网易新闻客户端 H5 秒开优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mzc2Nzg1MQ==&mid=2247483669&idx=1&sn=35fcd1aeefe52bdfbae9ce37fb56cee2&scene=21#wechat_redirect" target="_blank" rel="noopener">解决支付宝包体积优化的遗留问题：</a><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mzc2Nzg1MQ==&mid=2247483669&idx=1&sn=35fcd1aeefe52bdfbae9ce37fb56cee2&scene=21#wechat_redirect" target="_blank" rel="noopener">运行时获取dexpc</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247485891&idx=1&sn=f97a596399977e5ca61333ed5d359466&scene=21#wechat_redirect" target="_blank" rel="noopener">Android篇 | 爱奇艺App启动优化实践分享</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247486037&idx=2&sn=7f095d5daceb7ecc4b70983aab410d43&scene=21#wechat_redirect" target="_blank" rel="noopener">二维码扫描优化及爱奇艺App的实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580237&idx=1&sn=de8ec4404964a46995048e2b49556b7a&scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTk0ODUxOQ==&mid=2247483782&idx=1&sn=f9eae167b217c83036b3a24cd4182cd1&scene=21#wechat_redirect" target="_blank" rel="noopener">天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDIwODQ0Mw==&mid=2247483996&idx=1&sn=585369f542e084a4857145f5793e2b9f&scene=21#wechat_redirect" target="_blank" rel="noopener">花椒Android端自动化测试实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483964&idx=1&sn=fc5c4cd18e3564a237dff075bc055a3f&scene=21#wechat_redirect" target="_blank" rel="noopener">一种简单优雅的TextView行间距适配方案</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483952&idx=1&sn=da440dcb3da286969c13fc9a9f3f1223&scene=21#wechat_redirect" target="_blank" rel="noopener">Android 10分区存储介绍及百度APP适配实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247493879&idx=1&sn=653ac0a8d0e33cc3faea6659b25d0398&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485530&idx=1&sn=c6f92a614829215d13aec273cbd1022a&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%（二）</a></li></ul><h3 id="4-一个-Android-优秀博主的文章合集"><a href="#4-一个-Android-优秀博主的文章合集" class="headerlink" title="4. 一个 Android 优秀博主的文章合集"></a>4. 一个 Android 优秀博主的文章合集</h3><p><em><a href="https://github.com/yangkun19921001/Blog" target="_blank" rel="noopener">https://github.com/yangkun19921001/Blog</a></em><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220112135542.png" alt></p><p>比较适合系统性的复习，而且作者应该比较精通音视频，我知道很多同学对音视频很好奇，苦于没有什么入门的书籍等，不妨看下这位作者系列文章。</p><h3 id="5-一个Android-面试题合集"><a href="#5-一个Android-面试题合集" class="headerlink" title="5. 一个Android 面试题合集"></a>5. 一个Android 面试题合集</h3><p>这是一个国外开发者维护的仓库，所以问题以及相关问题解答的博客都是外文。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220112135726.png" alt></p><p><em><a href="https://github.com/MindorksOpenSource/android-interview-questions" target="_blank" rel="noopener">https://github.com/MindorksOpenSource/android-interview-questions</a></em><br>上述问题在我们看来不一定能作为面试题，但是有些问题还是可以用来差缺补漏的，也能帮助大家发现一些写的比较好的外文博客。</p><h3 id="6-lancet-：一个-hook-库"><a href="#6-lancet-：一个-hook-库" class="headerlink" title="6. lancet ：一个 hook 库"></a>6. lancet ：一个 hook 库</h3><p><a href="https://github.com/eleme/lancet" target="_blank" rel="noopener">https://github.com/eleme/lancet</a><br>这个库非常久了哈，饿了么对外开源的，但是好像开发者关注度并不高。<br>实际上还是非常好用的，我们传统意义 hook 的想法，都是换掉某个实现。</p><p>比如 A 类，有个 b 方法，我们需要修改 b方法返回值，我们一般会考虑 hook 一些对象，由这些对象导致 b 方法的执行返回逻辑发生改变，但是这种hook 并不是那么容易找到突破口。</p><p>而 lancet 的概念就很有意思了，它不修改 b方法，<strong>他修改所有调用 b 方法的地方</strong>，把对b 方法的调用hook 到你准备好的方法中，所以你可以随意的控制返回值，当然这种 hook 肯定是基于编译期修改字节码的，优势就是一定能换到，只要是参与编译的代码。</p><p>我说的可能大家不太容易理解，还是建议大家了解下这个库的原理，确实是 hook 的一个非常好的新思路。</p><h3 id="7-奇思妙想"><a href="#7-奇思妙想" class="headerlink" title="7. 奇思妙想"></a>7. 奇思妙想</h3><p>见到一个库是这样的:<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220112140525.png" alt></p><p><a href="https://github.com/m-zylab/SketchyComponent" target="_blank" rel="noopener">https://github.com/m-zylab/SketchyComponent</a><br>主要是手绘风，相信大家根据之前的灰白化的文章：<br><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650830283&idx=1&sn=bb0bcebfd025805ddda7bb2c36f7231e&chksm=80b7a155b7c028437cffc35a62003f7dfcc00a275b52fe98aa3c1aa9034a6fc74b16f5f18910&scene=21#wechat_redirect" target="_blank" rel="noopener">App黑白化实现探索，有一行代码实现的方案吗？</a></p><p>都知道我们可以基于换肤的方案把一些控件换成我们自己的，那么假设我们可以提供手绘风格的：TextView,Button…等，是不是有可能可以将一个 app 瞬间变成手绘风格？ </p><h3 id="8-随便播报"><a href="#8-随便播报" class="headerlink" title="8. 随便播报"></a>8. 随便播报</h3><p><strong>appcomapt 1.1.0 版本在 android 5.0,5.1的设备上可能会造成 webview 崩溃</strong><br>这是周六的时候一个朋友遇到的问题，查了下发现的。<br>这是个官方bug:<br><a href="https://issuetracker.google.com/issues/141132133" target="_blank" rel="noopener">https://issuetracker.google.com/issues/141132133</a></p><p>一些解决方案：<br><a href="https://stackoverflow.com/questions/41025200/android-view-inflateexception-error-inflating-class-android-webkit-webview/49024931#49024931" target="_blank" rel="noopener">https://stackoverflow.com/questions/41025200/android-view-inflateexception-error-inflating-class-android-webkit-webview/49024931#49024931</a><br>如果你升级1.1.0要谨慎。</p><p>好了，祝大家元气满满！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-在-Android-模拟器上运行-ARM-应用&quot;&gt;&lt;a href=&quot;#1-在-Android-模拟器上运行-ARM-应用&quot; class=&quot;headerlink&quot; title=&quot;1. 在 Android 模拟器上运行 ARM 应用&quot;&gt;&lt;/a&gt;1. 在 Android 模拟器上运行 ARM 应用&lt;/h3&gt;&lt;p&gt;这算是一个非常好的消息了，之前在实际应用开发中，因为模拟器缺少对 arm 的支持，基本上都使用真机进行开发与调试。&lt;br&gt;随着 Android 11预览版的发布&lt;br&gt;Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM 指令转换成 x86 指令。开发者无需搭建高负载的 ARM 环境即可执行 ARM 二进制文件并进行测试。&lt;/p&gt;
&lt;p&gt;详情：&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652052998&amp;idx=1&amp;sn=9839e5a74c1dba47123d6cb5da15c10f&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在 Android 模拟器上运行 ARM 应用&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-大厂对外文章分享&quot;&gt;&lt;a href=&quot;#2-大厂对外文章分享&quot; class=&quot;headerlink&quot; title=&quot;2. 大厂对外文章分享&quot;&gt;&lt;/a&gt;2. 大厂对外文章分享&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;携程技术&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;mid=2697269503&amp;idx=2&amp;sn=f5505724dcee64ebd9904ee16a2bfedb&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 携程Android 10适配踩坑指南&lt;/a&gt;&lt;br&gt;新版本适配一直是 Android 开发者的痛楚之一，但是这件事如果长期不升就会越来越困难。加上现在应用市场比较强势，所以保持一个较高的版本的适配是有必要的。&lt;br&gt;携程旅行分享了他们从API 26 到 29 的适配经验，大家可以参考一波。&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;mid=2697269484&amp;idx=1&amp;sn=1f5dcd45f90b2314050a04492e3a1cc0&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;全网最详！暗黑模式在 Trip.com App 的实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;暗黑模式也最近的一个非常热门的话题，甚至微信支持暗黑模式都成为热点了。如果你对这方面感兴趣，或者刚好有暗黑实践的需求，那么可以看这一篇由携程 UED 团队+研发团队撰写的文章。&lt;br&gt;我个人其实一直没有体验过暗黑模式，毕竟没适配的 app 太多了，所以我不认为把手机切换为暗黑模式有很好的的体验…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google 开发者&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652052998&amp;idx=2&amp;sn=18715a7e33b7f7a5878bd301e9f8f935&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在 Android 开发中使用协程 | 背景介绍&lt;/a&gt;&lt;br&gt;可以看一下官方的文章了解下协程的一些背景知识，用来解决什么问题，如何解决，以及性能相关的一些知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字节跳动技术团队&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247485583&amp;idx=1&amp;sn=a572862f110948673818d745cea5aea6&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;抖音包大小优化-资源优化&lt;/a&gt;&lt;br&gt;可以看下抖音团队为了减少 apk 的体积，针对资源这一方面做了哪些&lt;strong&gt;极致&lt;/strong&gt;的事情。&lt;br&gt;另外 apk 体积优化也可以看下 jsonchao 的文章：&lt;br&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650830257&amp;idx=1&amp;sn=f94eb0e05a1c40d5a99a7384b6f736ad&amp;chksm=80b7a12fb7c028395c18bc81f544bc4d893ca9829e7b702e079d973608bee3b6eb5a7d2c49ff&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;吹爆系列：深入探索Android包体积优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;百度 APP 技术&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&amp;mid=2247484032&amp;idx=1&amp;sn=da2740910b6df7d7f1ee9e2903f5ca27&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gradle 与 Android 构建入门&lt;/a&gt;&lt;br&gt;写了一篇 Gradle 构建入门的文章，其实很多同学都非常害怕 Gradle，这篇文章会给大家解释为什么需要 Gradle，以及 Gradle 相关的一些基础知识，帮你更好的了解相关知识，比较轻松，可以一看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;西瓜技术团队&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODczOQ==&amp;mid=2247483682&amp;idx=1&amp;sn=883435f1fe81295ec1c3ef6d576953c9&amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AwCookieManager.nativeGetCookie crash 排查&lt;/a&gt;&lt;br&gt;分享了西瓜的一个CookieManager.getCookie(String url) 过程中的 native crash，分析过程较为复杂，不过给出了解决方案，解决方案涉及到 hook，西瓜用了自研的方案，开源的 lancet 应该也能做到，这篇文章也会提到 lancet。&lt;/p&gt;
    
    </summary>
    
      <category term="新技术" scheme="http://yoursite.com/categories/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="新技术" scheme="http://yoursite.com/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大厂对外分享" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%8E%82%E5%AF%B9%E5%A4%96%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>【新技术】又双叒叕来了系列二</title>
    <link href="http://yoursite.com/posts/2e3f2830.html"/>
    <id>http://yoursite.com/posts/2e3f2830.html</id>
    <published>2022-01-11T02:09:05.000Z</published>
    <updated>2022-01-12T05:49:35.809Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Android-开发者峰会一些资源"><a href="#1-Android-开发者峰会一些资源" class="headerlink" title="1. Android 开发者峰会一些资源"></a>1. Android 开发者峰会一些资源</h3><p>大家可以在 B 站看到所有的内容：</p><p><a href="https://space.bilibili.com/64169458/channel/detail?cid=91608" target="_blank" rel="noopener">https://space.bilibili.com/64169458/channel/detail?cid=91608</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111103513.png" alt></p><p>有个值得关注的是，官方回复了一些 Android 开发的问题：<br>一些新技术都有涉及，比如 ViewPager2 正式发布，关于 Camerax,Camera2,Camera1 之间如何选择，以及Kotlin，Jetpack Compose 相关问题。</p><a id="more"></a><p>我当时比较好奇的一个问题是这个：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111103354.png" alt></p><p>挺奇怪的，难道官方 app 会考虑只用一个 Activity 么？</p><p>详细的大家直接看这里：<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652052419&idx=2&sn=1e1722c4dc0689c2e55bbbc4022d3d44&scene=21#wechat_redirect" target="_blank" rel="noopener">Android 开发者峰会 2019 常见问题解答</a></p><h3 id="2-百度对外开源文章详情页-webview-recyclerview-一些原生控件联动效果"><a href="#2-百度对外开源文章详情页-webview-recyclerview-一些原生控件联动效果" class="headerlink" title="2. 百度对外开源文章详情页 webview+recyclerview+一些原生控件联动效果"></a>2. 百度对外开源文章详情页 webview+recyclerview+一些原生控件联动效果</h3><p><em><a href="https://github.com/baiduapp-tec/ELinkageScroll" target="_blank" rel="noopener">https://github.com/baiduapp-tec/ELinkageScroll</a></em></p><p>如果大家每篇推文都看的话，<a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650830056&idx=1&sn=82a49b57cfcecbc78d6eac31173a6418&chksm=80b7a076b7c02960a897d20513e0c0d99311a93c3b7a8a58712430343106cdb331767ecb07c1&scene=21#wechat_redirect" target="_blank" rel="noopener">这个库我上次已经专门介绍过啦</a>。</p><p>这个效果使用非常广，基本所有的资讯类 app 都有，感谢百度开源。</p><p>历史类似文章：<br><a href="http://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650828127&idx=1&sn=a41f70febd47b9813fd124073028a5d1&chksm=80b7b9c1b7c030d707dbe8393bedec01e074c672014139715a36e273dcf232f71088eab4475c&scene=21#wechat_redirect" target="_blank" rel="noopener">大厂的文章详情页 WebView与 RecyclerView如何连贯滑动的？</a></p><p>另外感谢「this 蜗牛」这位朋友留言说道 QMUI也有这个效果，还后台给我发了个截图，我也给大家补充上，大家可以一起参考。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111103856.png" alt></p><p><em><a href="https://qmuiteam.com/android" target="_blank" rel="noopener">https://qmuiteam.com/android</a></em></p><p><em><a href="https://github.com/Tencent/QMUI_Android" target="_blank" rel="noopener">https://github.com/Tencent/QMUI_Android</a></em></p><p>之前的系列我也给大家推荐过 QMUI，这样的大厂出的类库还是可以关注下，尤其针对个人开发者，在快速迭代自己项目的时候还是很有用的。</p><h3 id="3-大厂对外文章分享"><a href="#3-大厂对外文章分享" class="headerlink" title="3. 大厂对外文章分享"></a>3. 大厂对外文章分享</h3><p><strong>百度 App 技术</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483964&idx=1&sn=fc5c4cd18e3564a237dff075bc055a3f&scene=21#wechat_redirect" target="_blank" rel="noopener">一种简单优雅的TextView行间距适配方案</a></p><p>以前用 TextView就怕UI 跟我们纠结行高，因为在 Android 里面没有一个非常明确的 lineHeight 概念，百度这边分享了自己的解决方案，还是学到了一些新知识的，文章中提到的LineHeightSpan我之前就不知道，还是学到了。</p><p>方案对于中文的支持还是很不错的，值得借鉴。<br><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483952&idx=1&sn=da440dcb3da286969c13fc9a9f3f1223&scene=21#wechat_redirect" target="_blank" rel="noopener">Android 10分区存储介绍及百度APP适配实践</a><br>这个就不用介绍了吧，标题很清晰。</p><p><strong>字节跳动技术团队</strong></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247493879&idx=1&sn=653ac0a8d0e33cc3faea6659b25d0398&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485530&idx=1&sn=c6f92a614829215d13aec273cbd1022a&scene=21#wechat_redirect" target="_blank" rel="noopener">抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%（二）</a></p><p>介绍了抖音团队自研的一个针对 4.x 级以下机型对于 MultiDex 的优化。<br>目前还没有开源，大家可以了解下原理，后续开源我也会周知大家的。<br>此外相关知识也可以学习下：<br>Android 一种在Dalvik虚拟机上多Dex加载优化的方案<br><a href="https://blog.csdn.net/sbsujjbcy/article/details/53381663" target="_blank" rel="noopener">https://blog.csdn.net/sbsujjbcy/article/details/53381663</a></p><p><strong>Google 开发者</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652052515&idx=1&sn=f10b5a01d889214a760b721cd195489f&scene=21#wechat_redirect" target="_blank" rel="noopener">Room 中的数据库关系</a><br>对于 Room 使用者，如果你对 1 对 1，1 对N，N 对 N 不知道如何处理的可以学习下。</p><p>历史分享(点击可直接访问)：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580200&idx=1&sn=c663d8be4628d74efb20aee09f1cc743&scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯Bugly:对字符串匹配算法的一点理解</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247485203&idx=1&sn=26fd99ca1201e292ea5531c814eeb881&scene=21#wechat_redirect" target="_blank" rel="noopener">爱奇艺：安卓APP崩溃捕获方案——xCrash</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485042&idx=1&sn=fe32711dbcb483f7a47dfa0e304087c4&scene=21#wechat_redirect" target="_blank" rel="noopener">字节跳动：深入理解Gradle框架之一：</a><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485042&idx=1&sn=fe32711dbcb483f7a47dfa0e304087c4&scene=21#wechat_redirect" target="_blank" rel="noopener">Plugin, Extension, buildSrc</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483745&idx=1&sn=59bf0c9bc5b584d411880617cf32f795&scene=21&token=1556389437&lang=zh_CN#wechat_redirect" target="_blank" rel="noopener">百度APP技术：Android H5首屏优化实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE2NzIzMg==&mid=2247487670&idx=1&sn=952e44c0ce8890b27b0115a1974cc431&scene=21#wechat_redirect" target="_blank" rel="noopener">京东技术：任意URL跳转漏洞修复与JDK中getHost()方法之间的坑</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483789&idx=1&sn=f3843b9ce282ab7d4e3c6225d780f9cd&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483804&idx=1&sn=026f386cc88d07044735cde5206c1de0&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDk2MzUzMQ==&mid=2247483815&idx=1&sn=c3872d2e1b86d6eb48b8665fbf6f6fa4&scene=21#wechat_redirect" target="_blank" rel="noopener">支付宝 App 构建优化解析：Android 包大小极致压缩</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==&mid=2247484874&idx=1&sn=bc0f92ccb6d1b7c6be6bc535ac491cd7&scene=21#wechat_redirect" target="_blank" rel="noopener">搜狐：深入理解Flutter多线程</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697268363&idx=1&sn=3db2dce36a912936961c671dd1f71c78&scene=21#wechat_redirect" target="_blank" rel="noopener">携程：从智行 Android 项目看组件化架构实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652049096&idx=1&sn=dc9d0a408d07d78d487974354fd5dee7&scene=21#wechat_redirect" target="_blank" rel="noopener">Google: Flutter 您需要知道的知识点 | FAQ・第三期</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484937&idx=1&sn=144003c8c662eebbdd71d7a9617e3439&chksm=e9d0cdebdea744fd3f413d3667590479bb5c4e52d628d44b37807a761be6415f3b4e5c40d554&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">字节跳动：二维码扫描优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247483887&idx=1&sn=d54e3f210a4f31f477dba06c3dcd352e&scene=21#wechat_redirect" target="_blank" rel="noopener">网易传媒技术团队：AOP技术在客户端的应用与实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247483939&idx=1&sn=aa170d606c7de063a0d587aa4da1fc91&scene=21#wechat_redirect" target="_blank" rel="noopener">网易大数据|互联网产品决策秘笈: AB测试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MzIwMDM5Ng==&mid=2247483750&idx=1&sn=8ba37d6b8a073c3a0fbb0dcc10b00175&scene=21#wechat_redirect" target="_blank" rel="noopener">高德：Android Native 内存泄漏系统化解决方案</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTU3MTE4NQ==&mid=2247484444&idx=1&sn=2c4c8fa957df258003c4fcfe63df3a59&chksm=ea591302dd2e9a14aebb553e3af14fa12d239dd76ef01b3855bb5b9f2a3196b42e829ce8d504&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">例说 Constraint Layout（三）—— 性能测试</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTU3MTE4NQ==&mid=2247484411&idx=1&sn=f8cd93a994080a31cfdb58bda9f5dc75&chksm=ea5914e5dd2e9df35cfe04b066eefc9b876faa074569f45a5320a28c5b0031d8cad282bacdf3&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">Android P之Smart Linkif</a>y</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483830&idx=1&sn=a158b07ca3fe6a4ef8ff89d4f5b682aa&scene=21#wechat_redirect" target="_blank" rel="noopener">百度App组件化之路</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzk2ODI1NQ==&mid=2247483844&idx=1&sn=59e434f601cc4ae5a3970e8751662fd2&scene=21#wechat_redirect" target="_blank" rel="noopener">百度App网络深度优化系列《三》弱网优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485061&idx=1&sn=7c935aecbb9b558e4d5d9dd2c3eb7f96&scene=21#wechat_redirect" target="_blank" rel="noopener">头条 | 深入理解gradle框架之二：依赖实现分析</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750945&idx=2&sn=4c0f9c59498610ea1ce9744b8b35e61a&scene=21#wechat_redirect" target="_blank" rel="noopener">美团| Probe：Android线上OOM问题定位组件</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651750923&idx=1&sn=1044e16dddeda4e7a6daaadfe9637f75&scene=21#wechat_redirect" target="_blank" rel="noopener">美团|Android静态代码扫描效率优化与实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247485301&idx=1&sn=eadc3d5ebfebe32c354dcd4529cd86c5&scene=21#wechat_redirect" target="_blank" rel="noopener">头条| 开源 | Scene：Android 开源页面导航和组合框架</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxODg0MzU2OQ==&mid=2247484258&idx=1&sn=558555cefa7ac495b66c31dd201b1c1c&scene=21#wechat_redirect" target="_blank" rel="noopener">网易新闻客户端 H5 秒开优化</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mzc2Nzg1MQ==&mid=2247483669&idx=1&sn=35fcd1aeefe52bdfbae9ce37fb56cee2&scene=21#wechat_redirect" target="_blank" rel="noopener">解决支付宝包体积优化的遗留问题：</a><a href="https://mp.weixin.qq.com/s?__biz=MzU5Mzc2Nzg1MQ==&mid=2247483669&idx=1&sn=35fcd1aeefe52bdfbae9ce37fb56cee2&scene=21#wechat_redirect" target="_blank" rel="noopener">运行时获取dexpc</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247485891&idx=1&sn=f97a596399977e5ca61333ed5d359466&scene=21#wechat_redirect" target="_blank" rel="noopener">Android篇 | 爱奇艺App启动优化实践分享</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247486037&idx=2&sn=7f095d5daceb7ecc4b70983aab410d43&scene=21#wechat_redirect" target="_blank" rel="noopener">二维码扫描优化及爱奇艺App的实践</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580237&idx=1&sn=de8ec4404964a46995048e2b49556b7a&scene=21#wechat_redirect" target="_blank" rel="noopener">腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTk0ODUxOQ==&mid=2247483782&idx=1&sn=f9eae167b217c83036b3a24cd4182cd1&scene=21#wechat_redirect" target="_blank" rel="noopener">天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDIwODQ0Mw==&mid=2247483996&idx=1&sn=585369f542e084a4857145f5793e2b9f&scene=21#wechat_redirect" target="_blank" rel="noopener">花椒Android端自动化测试实践</a></li></ul><h3 id="4-Github-找-Android-项目姿势"><a href="#4-Github-找-Android-项目姿势" class="headerlink" title="4. Github 找 Android 项目姿势"></a>4. Github 找 Android 项目姿势</h3><p>上次有同学留言问我怎么在 Github 找 Android项目，大家能想到的肯定是看 trending:<br><a href="https://github.com/trending/java" target="_blank" rel="noopener">https://github.com/trending/java</a></p><p>不过现在能上 trending 的 Android 项目太少了，毕竟和 Java 项目在一个分类。<br>其实 Github 有主题的概念，直接选择 Android 主题就可以了：<br><a href="https://github.com/topics/android" target="_blank" rel="noopener">https://github.com/topics/android</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111104421.png" alt><br>可以看到有9W+项目。</p><p>也可以按条件筛选：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111104509.png" alt></p><h3 id="5-一些Android-逆向-攻防-相关的话题"><a href="#5-一些Android-逆向-攻防-相关的话题" class="headerlink" title="5. 一些Android 逆向*攻防*相关的话题"></a>5. 一些Android 逆向*<em>攻防*</em>相关的话题</h3><p>有这么一个仓库：<br><a href="https://github.com/Hack-with-Github/Awesome-Hacking" target="_blank" rel="noopener">https://github.com/Hack-with-Github/Awesome-Hacking</a><br>看名字大家就知道介绍啥了，是一个安全相关的仓库汇总，里面包含了太多的子项目，例如有些工具不知道在哪下载，在这里面很好找：<br><a href="https://github.com/carpedm20/awesome-hacking" target="_blank" rel="noopener">https://github.com/carpedm20/awesome-hacking</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111104734.png" alt></p><h3 id="6-播报一些最近发现更新的开源库"><a href="#6-播报一些最近发现更新的开源库" class="headerlink" title="6. 播报一些最近发现更新的开源库"></a>6. 播报一些最近发现更新的开源库</h3><p><strong>LeakCanary 不再使用 haha</strong><br>我们熟悉的 LeakCanary 已经<strong>不再使用之前的 haha 做内存分析，换成了自研的 Shark</strong>。<br><a href="https://square.github.io/leakcanary/shark/" target="_blank" rel="noopener">https://square.github.io/leakcanary/shark/</a></p><p><strong>RxJava 已经更新了 3.0.0 版本</strong><br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">https://github.com/ReactiveX/RxJava</a><br>不过 Retrofit2 暂时还无法使用 RxJava3，因为相关 Adapter 库还未适配 RxJava3。</p><p>好了，祝大家元气满满！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Android-开发者峰会一些资源&quot;&gt;&lt;a href=&quot;#1-Android-开发者峰会一些资源&quot; class=&quot;headerlink&quot; title=&quot;1. Android 开发者峰会一些资源&quot;&gt;&lt;/a&gt;1. Android 开发者峰会一些资源&lt;/h3&gt;&lt;p&gt;大家可以在 B 站看到所有的内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://space.bilibili.com/64169458/channel/detail?cid=91608&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://space.bilibili.com/64169458/channel/detail?cid=91608&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220111103513.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;有个值得关注的是，官方回复了一些 Android 开发的问题：&lt;br&gt;一些新技术都有涉及，比如 ViewPager2 正式发布，关于 Camerax,Camera2,Camera1 之间如何选择，以及Kotlin，Jetpack Compose 相关问题。&lt;/p&gt;
    
    </summary>
    
      <category term="新技术" scheme="http://yoursite.com/categories/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="新技术" scheme="http://yoursite.com/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大厂对外分享" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%8E%82%E5%AF%B9%E5%A4%96%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>【新技术】又双叒叕来了系列一</title>
    <link href="http://yoursite.com/posts/3eabe808.html"/>
    <id>http://yoursite.com/posts/3eabe808.html</id>
    <published>2022-01-10T03:22:32.000Z</published>
    <updated>2022-01-10T03:45:56.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些中文独立博客分享"><a href="#一些中文独立博客分享" class="headerlink" title="一些中文独立博客分享"></a>一些中文独立博客分享</h3><p>目前随着移动端的兴起，早期的很多中文 PC 博客已经很少有人去阅读了，也很难被大家所发现。</p><p>因为我之前关注一个小伙的创业实验，比较好奇他最终会不会成功，也好奇他的灵感，他的下一个产品是一个中文博客相关的 RSS 产品。</p><p>所以他收集了一波中文博客列表，推荐给大家：</p><p><a href="https://github.com/timqian/chinese-independent-blogs" target="_blank" rel="noopener">https://github.com/timqian/chinese-independent-blogs</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220110113859.png" alt></p><p>大概有 300 多位中文博客列表，偶尔读一些这上面的文章，应该还是能激发不少灵感的。</p><p>其实如果这些独立博客数量够多，可以聚合起来，做一个阅读 app，支持订阅也是不错的。</p><a id="more"></a><h3 id="官方发布的代码检索工具"><a href="#官方发布的代码检索工具" class="headerlink" title="官方发布的代码检索工具"></a>官方发布的代码检索工具</h3><p>实际使用起来，实在太好用了，强烈推荐下。</p><p>注意：需要网络良好。</p><p><a href="https://cs.android.com/" target="_blank" rel="noopener">https://cs.android.com/</a></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220110114308.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220110114357.png" alt></p><p>其他一些在线源码阅读工具：</p><p><a href="https://www.androidos.net.cn/sourcecode" target="_blank" rel="noopener">https://www.androidos.net.cn/sourcecode</a></p><p><a href="http://aospxref.com/" target="_blank" rel="noopener">http://aospxref.com/</a></p><h3 id="字节跳动开源一系列插件"><a href="#字节跳动开源一系列插件" class="headerlink" title="字节跳动开源一系列插件"></a>字节跳动开源一系列插件</h3><p><a href="https://github.com/bytedance/ByteX" target="_blank" rel="noopener">https://github.com/bytedance/ByteX</a></p><p>基本都是编译时字节码相关的，目前应用于多款字节跳动产品上。</p><ul><li>access-inline-plugin（access方法内联）</li><li>shrink-r-plugin（R文件瘦身和无用资源检查）</li><li>closeable-check-plugin（文件流的close检查）</li><li>const-inline-plugin（常量内联）</li><li>field-assign-opt-plugin（优化多余赋值指令）</li><li>getter-setter-inline-plugin （getter和setter方法内联）</li><li>method-call-opt-plugin（干净地删除某些方法调用，如Log.d）</li><li>coverage-plugin（线上代码覆盖率）</li><li>refer-check-plugin（检查是否有调用不存在的方法和引用不存在的字段）</li><li>serialization-check-plugin（序列化检查）</li><li>SourceFileKiller（删除SourceFile和行号属性）</li></ul><p>一方面这个可以接入，做一些产品上的安全、优化。</p><p>另一方面是学习的好资料，如果都能看明白，AS 的 Transform 和字节码算是已经玩转了。</p><p>相关的开源项目就是滴滴的 booster:</p><p><a href="https://github.com/didi/booster" target="_blank" rel="noopener">https://github.com/didi/booster</a></p><h3 id="大厂对外分享"><a href="#大厂对外分享" class="headerlink" title="大厂对外分享"></a>大厂对外分享</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjczMjM2NA==&mid=2247486037&idx=2&sn=7f095d5daceb7ecc4b70983aab410d43&scene=21#wechat_redirect" target="_blank" rel="noopener">1. 二维码扫描优化及爱奇艺App的实践</a></p><p>说了一些方案，实践还是之前字节跳动给出的方案更适合：</p><p>字节跳动：<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484937&idx=1&sn=144003c8c662eebbdd71d7a9617e3439&chksm=e9d0cdebdea744fd3f413d3667590479bb5c4e52d628d44b37807a761be6415f3b4e5c40d554&mpshare=1&scene=21&srcid=#wechat_redirect" target="_blank" rel="noopener">二维码扫描优化</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653580237&idx=1&sn=de8ec4404964a46995048e2b49556b7a&scene=21#wechat_redirect" target="_blank" rel="noopener">2. 腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用</a></p><p>动态下发 so库，是减少 apk 体积非常明显的一个方案，之前在百度的时候，也搞过这样的方案，一度是瘦身黑科技，当然坑也不少，so 这玩意搞不好崩溃就比较多，如果需要可以参考目前一些插件化方案、热修方案去做。</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTk0ODUxOQ==&mid=2247483782&idx=1&sn=f9eae167b217c83036b3a24cd4182cd1&scene=21#wechat_redirect" target="_blank" rel="noopener">3. 天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析）</a></p><p>恩…技术文章还是很赞的。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NDIwODQ0Mw==&mid=2247483996&idx=1&sn=585369f542e084a4857145f5793e2b9f&scene=21#wechat_redirect" target="_blank" rel="noopener">4. 花椒Android端自动化测试实践</a></p><p>Android 测试一直被忽略，我也没有太多这方面涉猎，当然还是值得了解下。</p><p>好了，祝大家元气满满！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一些中文独立博客分享&quot;&gt;&lt;a href=&quot;#一些中文独立博客分享&quot; class=&quot;headerlink&quot; title=&quot;一些中文独立博客分享&quot;&gt;&lt;/a&gt;一些中文独立博客分享&lt;/h3&gt;&lt;p&gt;目前随着移动端的兴起，早期的很多中文 PC 博客已经很少有人去阅读了，也很难被大家所发现。&lt;/p&gt;
&lt;p&gt;因为我之前关注一个小伙的创业实验，比较好奇他最终会不会成功，也好奇他的灵感，他的下一个产品是一个中文博客相关的 RSS 产品。&lt;/p&gt;
&lt;p&gt;所以他收集了一波中文博客列表，推荐给大家：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/timqian/chinese-independent-blogs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/timqian/chinese-independent-blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220110113859.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;大概有 300 多位中文博客列表，偶尔读一些这上面的文章，应该还是能激发不少灵感的。&lt;/p&gt;
&lt;p&gt;其实如果这些独立博客数量够多，可以聚合起来，做一个阅读 app，支持订阅也是不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="新技术" scheme="http://yoursite.com/categories/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="新技术" scheme="http://yoursite.com/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大厂对外分享" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%8E%82%E5%AF%B9%E5%A4%96%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>《老大不小》观后感</title>
    <link href="http://yoursite.com/posts/e984f211.html"/>
    <id>http://yoursite.com/posts/e984f211.html</id>
    <published>2022-01-01T04:01:28.000Z</published>
    <updated>2022-01-01T04:23:59.462Z</updated>
    
    <content type="html"><![CDATA[<p>电影里对自己感触最深的一句话是爸爸在病床上对他大儿子雷子说的：‘’我走了，我对小硕一百个放心，他有个沟沟坎坎的，还有你这个哥，可是，大磊子，我走了你还有谁啊？‘’</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101120439.png" alt></p><a id="more"></a><p>再有两年就奔三了，自己一直北漂在外，爸妈身体一直是自己比较担心的，总是把最好的都给我们，他们自己的毛病只是不经常跟做儿女的说。陪伴家人的时间也是屈指可数，自己不是一个称职的儿子，只希望自己努力的脚步能超越父母慢慢变老的速度。</p><p>就像剧里的爸爸忍着胃癌晚期的疼痛不让家里的孩子知道一样，用生命在为自己的儿子铺路，存下了那两张银行卡。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121150.png" alt></p><p>真正戳到我泪点的是弟弟写给哥哥的那封说不出口的些话，再叛逆的孩子内心深处都存在着最真挚、最纯粹的感情，只是有些时候不会表达出来，比如父亲病床桌子上的一杯水；早上喂了父亲生前总喂的猫。其实生活中真的有好多情感难以用语言表达出来，但是我们彼此都真诚，都愿意付出。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121320.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121338.png" alt></p><p>关于哥哥的友情和爱情。他能有一个真正不离不弃的好哥们，在他需要的时候挺身而出，真的挺幸运的。包括兄弟说的那句话“有的人是靠脸活着，而有的人是为了脸活着。”</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121401.png" alt></p><p>成年人的世界可能就是这样吧，有生活的重担连恋爱的勇气都没有，但最后他俩在一起真的很开心。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101121435.png" alt></p><p>整体而言看完这部电影，</p><p>不是职业的电影评论。</p><p>可以说这部电影制作很成功了。</p><p>一个没有上过大学的哥哥，一个青春期叛逆的弟弟，和一个为了家努力的父亲。</p><p>成年人的世界，没有容易二字，每个人都有压力，哥哥觉得弟弟不争气，去跟已故的父亲聊聊天，收拾收拾心情还是再次回到家。</p><p>弟弟从最初的不表达爱和不接受这些爱，变成了一个懂事的孩子，每个孩子年少的时候都会经历叛逆时候。后来也会发现，当初是有多么不懂事。</p><p>弟弟打那个孩子，错了么？没错，对了么？不对。以前打架是发泄情绪，现在打架是打钱，挺好一句话，现在孩子看了可以想一想，打那个架为了什么？</p><p>整个剧可以说环环相扣，从最初哥哥每天都给那个流浪汉钱，是傻么？只是活的乐观而已。</p><p>弟弟逃学打游戏，没有光为了打游戏，打游戏得的奖品也去送给了父亲，唯一一个过错就是没有当着面叫他一声爸。</p><p>哥哥只要点点头，就能得到一份挣钱的工作，但是他没有，他活着要着一张脸，可以通过自己的努力去挣这个钱，但不想靠感情来挣这个钱。</p><p>一个简单的故事，很温暖，源于生活。</p><p>里面有句话挺好，有人是靠脸活着，有人为了脸活着。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电影里对自己感触最深的一句话是爸爸在病床上对他大儿子雷子说的：‘’我走了，我对小硕一百个放心，他有个沟沟坎坎的，还有你这个哥，可是，大磊子，我走了你还有谁啊？‘’&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20220101120439.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>十个思维方式如何改变我的人生</title>
    <link href="http://yoursite.com/posts/bdeaaf0.html"/>
    <id>http://yoursite.com/posts/bdeaaf0.html</id>
    <published>2021-12-22T09:50:39.000Z</published>
    <updated>2021-12-24T02:05:30.003Z</updated>
    
    <content type="html"><![CDATA[<p>1、你不需要是个天才，才有资格分享知识——《Show Your Work》<br>2、除了目标，还要关注实现目标的体系，享受提升自我的过程<br>3、1%定律：每天提升1%——《Atomic Habits》<br>4、多样化收入来源<br>5、你觉得很普通的事情，在别人看来可能会很了不起——《Anything You Want》<br>6、每日重点：梳理待办事项的优先级——《Make Time》<br>7、勇敢去做：不一定要遵循既定规则去过人生——《Do What You Can’t》<br>8、家庭、个人、工作的平衡——《平衡的智慧》<br>9、找个人谈谈心——《你当像鸟飞往你的山》、《也许你该找人聊聊》<br>10、成功的公式——Y2b：Ali Abdaal</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、你不需要是个天才，才有资格分享知识——《Show Your Work》&lt;br&gt;2、除了目标，还要关注实现目标的体系，享受提升自我的过程&lt;br&gt;3、1%定律：每天提升1%——《Atomic Habits》&lt;br&gt;4、多样化收入来源&lt;br&gt;5、你觉得很普通的事情，在别人看来可能会很了不起——《Anything You Want》&lt;br&gt;6、每日重点：梳理待办事项的优先级——《Make Time》&lt;br&gt;7、勇敢去做：不一定要遵循既定规则去过人生——《Do What You Can’t》&lt;br&gt;8、家庭、个人、工作的平衡——《平衡的智慧》&lt;br&gt;9、找个人谈谈心——《你当像鸟飞往你的山》、《也许你该找人聊聊》&lt;br&gt;10、成功的公式——Y2b：Ali Abdaal&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 2.8 发布 | 性能及工具链优化、Firebase 功能、WebView 3.0</title>
    <link href="http://yoursite.com/posts/7916835e.html"/>
    <id>http://yoursite.com/posts/7916835e.html</id>
    <published>2021-12-13T03:16:13.000Z</published>
    <updated>2021-12-24T02:05:30.003Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213111841.png" alt></p><blockquote><p>官方发布说明：<a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fwhats-new-in-flutter-2-8-d085b763d181" target="_blank" rel="noopener">medium.com/flutter/wha…</a></p></blockquote><p>北半球的冬意已至，黄叶与气温均随风而落，而年终的最后一个稳定版本已悄然来到你的面前。 让我们向 <strong>Flutter 2.8</strong> 打声招呼～ 本次更新包含了 <strong>207 位贡献者和 178 位审核者</strong> 的辛勤劳作， 所有人共同产出了 <strong>2424 个 PR</strong>，关闭了 <strong>2976 个 issue</strong>。 在此特别感谢本次发布中最突出的社区贡献者：来自 Very Good Ventures 的 Flutter 开发工程师 Bartosz Selwesiuk， 他专注于 Web 平台的 camera 插件并提交了 23 个 PR。</p><p>以上的所有产出让 Flutter engine 和 DevTools 都有了非常显著的性能提升， 同时带来的还有 <strong>Google 移动端广告 SDK Flutter 版本的稳定版发布、 一系列针对 Firebase 的新功能和优化、Flutter WebView 3.0、 新的 Flutter Favorite package、向桌面端 Stable 迈出的一大步， 以及支持更多 package 的新版本 DartPad</strong>。 虽然这是今年最后一个稳定版本，但它并不是最不重要的。让我们一起来看看！</p><a id="more"></a><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>Flutter 的首要目标是一如既往地保证其质量。 我们花费了大量时间以确保 Flutter 在多种多样的设备上都能流畅且稳定地运行。</p><h3 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h3><p>本次更新优化了应用启动的延迟。 我们在拥有一百万行以上的代码量的 GPay 应用上进行了测试，以确保改动在实际生产的应用上有效。 这些改动将 GPay <strong>在低端 Android 设备上启动的时间减少了约 50%，高端设备上减少了约 10%</strong>。</p><p>我们对 Flutter 调用 Dart VM 的 GC 策略也做了一些改进，以此避免在程序启动期间出现不合时宜的 GC。 例如，在 Android 设备上渲染出第一帧前，Flutter <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F90551" target="_blank" rel="noopener">仅在 <code>TRIM_LEVEL_RUNNING_CRITYCAL</code> 及高于其等级的信号出现时，通知 Dart VM 有内存压力</a> 。 在本地测试中，<strong>低端 Android 设备的初始帧出现间隔时间最多减少了约 300ms</strong>。</p><p>在先前的 Flutter 版本中， <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29145%23pullrequestreview-778935616" target="_blank" rel="noopener">出于谨慎考虑</a> ， 在创建 PlatformView 时会阻塞平台线程。 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F91711" target="_blank" rel="noopener">在经过仔细的推理和测试后</a> ， 我们删除了部分序列化的步骤，使得 GPay <strong>在低端设备上的启动时间至少减少了 100ms</strong>。</p><p>长久以来，在初始化首个 Dart isolate 前初始化默认的字体管理器会引入人为的延迟。 由于它是首要的延迟瓶颈，所以 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29291" target="_blank" rel="noopener">将默认字体管理器的初始化延迟</a> 到与首个 Dart isolate 同时运行，降低了启动的延迟，并让上述的所有启动优化的表现更加明显。</p><h3 id="应用内存"><a href="#应用内存" class="headerlink" title="应用内存"></a>应用内存</h3><p>由于 Flutter 会尽可能快地加载 Dart VM 的服务 isolate， 并将其和绑定在应用内的 AOT 代码一并加载到内存中， 这会导致 Flutter 开发人员在部分内存 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F91382" target="_blank" rel="noopener">有限制的设备上难以追踪内存指标</a> 。 在 Flutter 2.8 版本中，Android 设备上 Dart VM 的服务 isolate <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29245" target="_blank" rel="noopener">已被拆分至单独的 bundle 中</a> ， 可以单独加载，减少了在其加载前约 40MB 的内存使用。 原本 Dart VM 向操作系统发送 AOT 程序的内存用量的通知， 已转由一个无需多次读取的文件支持，后续的内存占用量进一步减少了约 10%。 因此，先前保存了文件数据拷贝的内存可以回收并用于其他用途。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>某些场景下，开发者希望能同时看到 Flutter 和 Android 的性能追踪事件， 又或者是在生产模式下查看追踪事件来更好地了解应用的性能问题。 为了这一需求，Flutter 2.8 现在可以选择在应用启动后， 将性能追踪事件发送至 Android 的事件记录器，在生产模式下也同样如此。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113455.png" alt></p><p>此外，一些开发人员想要更多的关于光栅缓存行为的性能跟踪信息， 以减少制作动画效果时的卡顿，这允许 Flutter 快速地对昂贵的、重复使用的图片进行复用而不是重新绘制。 性能跟踪中的新的 <strong>流事件</strong>让开发人员可以跟踪光栅缓存图片的生命周期。</p><h3 id="Flutter-DevTools"><a href="#Flutter-DevTools" class="headerlink" title="Flutter DevTools"></a>Flutter DevTools</h3><p>对于调试性能问题，新版的 DevTools 添加了一个新的「增强跟踪」功能， 用来帮助开发者诊断消耗较大的构建、布局和绘制操作引起的 UI 卡顿。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113531.png" alt></p><p>启用任何一个追踪功能后，时间轴中将视情况展示 Widget 的构建、RenderObject 布局和 RenderObject 绘制的事件。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113633.png" alt></p><p>此外，新版的 DevTools 增加了应用程序启动性能的分析支持。 该配置文件包含从 Dart VM 初始化到第一个 Flutter 帧渲染的 CPU 样本。 在你按下「Profile app start up」按钮并加载应用程序启动配置文件后， 你将看到为配置文件选择了「AppStartUp」用户标签。 你还可以通过在可用用户标签列表中选择此用户标签过滤器（如果存在）来加载应用程序启动配置文件。 选择此标签会显示你的应用程序启动的个人资料数据。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113719.png" alt></p><h3 id="Web-平台的平台视图-PlatformView"><a href="#Web-平台的平台视图-PlatformView" class="headerlink" title="Web 平台的平台视图 (PlatformView)"></a>Web 平台的平台视图 (PlatformView)</h3><p>不仅仅是 Android 和 iOS 平台获得了性能提升，本次发布同时包含了对 Flutter Web 平台视图的性能优化。 平台视图是从宿主平台向 Flutter 嵌入 UI 组件的媒介。 Flutter Web 使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fapi.flutter-io.cn%2Fflutter%2Fwidgets%2FHtmlElementView-class.html" target="_blank" rel="noopener"><code>HtmlElementView</code></a> widget 实现了这一功能，让你能在 Flutter Web 应用中嵌入 HTML 元素。 如果你正在使用 google_maps_flutter 插件或 video_player 插件的网络版本， 或者你正在遵循 Flutter 团队关于 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fdevelopment%2Fplatform-integration%2Fweb-images%23use-img-in-a-platform-view" target="_blank" rel="noopener">如何优化网络上显示图像</a> 的建议，那么你正在使用平台视图。</p><p>在之前版本的 Flutter 中，嵌入平台视图会创建一个新的 canvas，每嵌入一个平台视图都会新增一个 canvas。 创建额外的 canvas 是十分消耗性能的操作，因为每个 canvas 的大小都与整个窗口相等。 在 Flutter 2.8 中，将 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F28087" target="_blank" rel="noopener">复用为先前的平台视图创建的 canvas</a> ， 因此，你不会在应用程序的整个生命周期内产生每秒 60 倍的成本，而是只有一次创建的成本。 这意味着你可以在 Web 应用程序中拥有多个 <code>HtmlElementView</code> 实例而不会降低性能， 同时还可以减少使用平台视图时的滚动卡顿。</p><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><p>Flutter 不仅仅是框架、引擎和工具——pub.dev 上现有超过 2w 个与 Flutter 兼容的包和插件，而且每天都在增加。 Flutter 开发人员大量的日常操作也是庞大的生态系统的一部分， 所以让我们来看看自上一个版本以来 Flutter 生态系统中有什么改变。</p><h3 id="适用于-Flutter-广告的-Google-广告"><a href="#适用于-Flutter-广告的-Google-广告" class="headerlink" title="适用于 Flutter 广告的 Google 广告"></a>适用于 Flutter 广告的 Google 广告</h3><p>首先也是最重要的是， <a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fannouncing-general-availability-for-the-google-mobile-ads-sdk-for-flutter-574e51ea6783" target="_blank" rel="noopener">Google Mobile SDK for Flutter 已于 11 月正式发布</a> 。 此版本支持 5 种广告格式，集成了 AdMob 和 Ad Manager 支持， 并包含一个新的中转功能的测试版，可以帮助你优化广告展现的效果。 有关将 Google Ads 集成到 Flutter 应用程序以及其他货币化选项的更多信息， 请查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.dev%2Fmonetization" target="_blank" rel="noopener">flutter.dev 上的页面</a> 。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113810.png" alt></p><h3 id="WebView-3-0"><a href="#WebView-3-0" class="headerlink" title="WebView 3.0"></a>WebView 3.0</h3><p>这次 Flutter 附带的另一个新版本是 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fwebview_flutter" target="_blank" rel="noopener">webview_flutter 插件</a> 的 3.0 版本。 因为新功能的数量增加，我们提升了主要版本号，但也因为 Web 视图在 Android 上的工作方式可能发生了重大变化。 在之前的 <code>webview_flutter</code> 版本中，Hybrid composition 已经可用，但不是默认的。 而现在它修复了先前默认以虚拟显示模式运行的许多问题。 根据用户反馈和我们的问题跟踪，我们认为是时候让 Hybrid composition 成为默认设置了。 此外，<code>webview_flutter</code> 还增加了一些呼声极高的功能：</p><ul><li>支持使用 POST 和 GET 来加载内容</li><li>加载文件或字符串内容为 HTML</li><li>支持透明背景</li><li>在加载内容前设置 Cookies</li></ul><p>此外，在 3.0 版本中，<code>webview_flutter</code> 为新平台提供了初步支持：Flutter Web。 已经有很多人要求能够在 Flutter Web 应用程序中托管 Web 视图， 这允许开发者利用单个源代码库构建移动或 Web 应用程序。 在 Flutter Web 应用程序中托管 Web 视图是什么样的？ 从编写代码的角度来看，其实是一样的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/foundation.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:webview_flutter/webview_flutter.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:webview_flutter_web/webview_flutter_web.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(<span class="keyword">const</span> MaterialApp(home: HomePage()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HomePage(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;HomePage&gt; createState() =&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// required while web support is in preview</span></span><br><span class="line">    <span class="keyword">if</span> (kIsWeb) WebView.platform = WebWebViewPlatform();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">    appBar: AppBar(title: <span class="keyword">const</span> Text(<span class="string">'Flutter WebView example'</span>)),</span><br><span class="line">    body: <span class="keyword">const</span> WebView(initialUrl: <span class="string">'https://flutter.dev'</span>),</span><br><span class="line">  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Flutter Web 上运行时，它会按你的预期工作：</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213113920.png" alt></p><p>请注意，当前 <code>webview_flutter</code> 的 web 实现有许多限制，因为它是使用 iframe 构建的， iframe 仅支持简单的 URL 加载，无法控制加载的内容或与加载的内容交互。 但是，由于需求呼声太高，我们决定将 webview_flutter_web 作为未经认可的插件提供。 如果你想尝试一下，请将以下内容添加到你的 pubspec.yaml 中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  webview_flutter:</span> <span class="string">^3.0.0</span></span><br><span class="line"><span class="attr">  webview_flutter_web:</span> <span class="string">^0.1.0</span> <span class="comment"># 显式依赖未经认可的插件</span></span><br></pre></td></tr></table></figure><p>如果你对 webview_flutter v3.0 有任何反馈，无论是否是关于 Web 平台， 请<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues" target="_blank" rel="noopener">将问题记录在 Flutter 仓库中</a> 。 此外，如果你之前没有使用过 webview 或者你想复习一下， 请查看<a href="https://link.juejin.cn?target=https%3A%2F%2Fcodelabs.developers.google.com%2Fcodelabs%2Fflutter-webview" target="_blank" rel="noopener">新的 webview codelab</a> ， 它将带你逐步完成在 Flutter 应用程序中托管 web 内容的过程。</p><h3 id="Flutter-Favorites"><a href="#Flutter-Favorites" class="headerlink" title="Flutter Favorites"></a>Flutter Favorites</h3><p>Flutter 生态系统委员会再次召开会议，将以下 package 指定为 Flutter Favorite 的 package：</p><ul><li>新路由 API（又名 Navigator 2）的三个自定义路由 package： <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fbeamer" target="_blank" rel="noopener">beamer</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Froutemaster" target="_blank" rel="noopener">routemaster</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fgo_router" target="_blank" rel="noopener">go_router</a> ；</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fdrift" target="_blank" rel="noopener">drift</a> ， 对 Flutter 和 Dart 已经功能强大且流行的响应式持久性库的重命名，基于 sqlite 构建；</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Ffreezed" target="_blank" rel="noopener">freezed</a> ， 一个 Dart「语言补丁」，为定义模型、克隆对象、模式匹配等提供简单的语法；</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fdart_code_metrics" target="_blank" rel="noopener">dart_code_metrics</a> ；</li><li>以及有着漂亮界面的 package： <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fflex_color_scheme" target="_blank" rel="noopener">flex_color_scheme</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fflutter_svg" target="_blank" rel="noopener">flutter_svg</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Ffeedback" target="_blank" rel="noopener">feedback</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Ftoggle_switch" target="_blank" rel="noopener">toggle_switch</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.flutter-io.cn%2Fpackages%2Fauto_size_text" target="_blank" rel="noopener">auto_size_text</a> 。</li></ul><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114109.png" alt></p><p>祝贺这些 package 的作者，并感谢你通过你的辛勤工作支持 Flutter 社区。 如果你有兴趣提名你最喜欢的 Flutter 包加入 Flutter Favorite 嘉奖， 请按照 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fdevelopment%2Fpackages-and-plugins%2Ffavorites" target="_blank" rel="noopener">Flutter Favorite 计划页面</a> 上的指南和说明进行操作。</p><h3 id="特定平台的插件-plugin-package"><a href="#特定平台的插件-plugin-package" class="headerlink" title="特定平台的插件 (plugin package)"></a>特定平台的插件 (plugin package)</h3><p>如果你是插件作者，你必须决定你将支持哪些平台。 如果你正在使用特定于平台的原生代码构建插件， 你可以 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fdevelopment%2Fpackages-and-plugins%2Fdeveloping-packages%23plugin-platforms" target="_blank" rel="noopener">使用项目 pubspec.yaml 中的 pluginClass 属性</a> 来实现，该属性将指定提供原生功能的原生类名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  plugin:</span></span><br><span class="line"><span class="attr">    platforms:</span></span><br><span class="line"><span class="attr">      android:</span></span><br><span class="line"><span class="attr">        package:</span> <span class="string">com.example.hello</span></span><br><span class="line"><span class="attr">        pluginClass:</span> <span class="string">HelloPlugin</span></span><br><span class="line"><span class="attr">      ios:</span></span><br><span class="line"><span class="attr">        pluginClass:</span> <span class="string">HelloPlugin</span></span><br></pre></td></tr></table></figure><p>然而，随着 Dart FFI 变得更加成熟，有可能使用 100% 的 Dart 实现特定平台的功能， 就像 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fpath_provider_windows" target="_blank" rel="noopener">path_provider_windows package</a> 所做的那样。在这种情况下，你没有任何本地类可以使用， 但你仍然希望将你的包指定为仅支持某些平台。 此时你可以改用 dartPluginClass 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line"><span class="attr">  plugin:</span></span><br><span class="line"><span class="attr">    implements:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    platforms:</span></span><br><span class="line"><span class="attr">      windows:</span></span><br><span class="line"><span class="attr">        dartPluginClass:</span> <span class="string">HelloPluginWindows</span></span><br></pre></td></tr></table></figure><p>经过这样的设置后，即使你没有任何本机代码，也可以为特定平台定制插件。 你还必须提供 Dart 插件的类， 有关详细内容，你可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Fdevelopment%2Fpackages-and-plugins%2Fdeveloping-packages%23dart-only-platform-implementations" target="_blank" rel="noopener">flutter.dev 上的仅 Dart 平台实现文档</a> 中进行扩展阅读。</p><h2 id="桌面平台"><a href="#桌面平台" class="headerlink" title="桌面平台"></a>桌面平台</h2><p>Flutter 2.8 版本在 Windows、macOS 和 Linux 稳定版本的道路上又迈出了一大步。 我们的目标质量标准很高，包括国际化和本地化支持， 例如 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29620" target="_blank" rel="noopener">新的中文输入法支持</a> 、 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F24713" target="_blank" rel="noopener">韩语输入法支持</a> 以及刚刚合并的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fengine%2Fpull%2F29761" target="_blank" rel="noopener">Kanji（日文）输入法</a> 支持。 或者，就像我们在紧密构建 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fissues%2F77838" target="_blank" rel="noopener">Windows 辅助功能的支持</a> 一样。 对于 Flutter 来说，在 Stable 渠道的 desktop 上运行是不够的， 它必须在世界各地的语言和文化以及不同能力的设备上运行良好。 我们还没有达到我们想要的目标，但未来可期！</p><p>其中一个例子是我们重构了 Flutter 处理键盘事件以允许同步响应的架构。 这使 widget 能够处理按键并拦截它在整个 widget tree 中的其余部分中的传递。 我们在 Flutter 2.5 中完成了这项工作的落地，并在 Flutter 2.8 中修复了许多问题。 这是对我们如何处理特定于设备的键盘输入的方式的重新设计， 和重构 Flutter 处理文本编辑方式的持续工作的补充， 所有这些都是用键盘这样输入密集型的桌面应用程序所必需的。</p><p>此外，我们还在继续 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F89353" target="_blank" rel="noopener">向 Flutter 扩展视觉密度的定义</a> ， 暴露对话框对齐方式的设置，以便开发者可以实现更加友好的桌面 UI。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114157.png" alt></p><p>最后，Flutter 团队并不是唯一一个在为了 Flutter desktop 付出心血的团队。 举个例子，Canonical 的桌面团队正在与 Invertase 合作， 在 Linux 和 Windows 上开发最流行的 Flutter Firebase 插件。</p><p>你可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Finvertase.io%2Fblog%2Fannouncing-flutterfire-desktop" target="_blank" rel="noopener">Invertase 博客上</a> 阅读有关预览版的更多信息。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114223.png" alt></p><h2 id="DartPad"><a href="#DartPad" class="headerlink" title="DartPad"></a>DartPad</h2><p>如果没有工具的改进，那么这个 Flutter 新版本的发布是不完整的。 我们将重点介绍 DartPad 的改进，其中最大的改进是对更多软件包的支持。 事实上，目前共有 23 个 package 可供导入使用。除了几个 Firebase 服务之外，该列表还包括诸如 bloc、characters、collection、google_fonts 和 flutter_riverpod 等流行的 package。 DartPad 团队会继续添加新的 package，如果你想查看当前支持哪些软件包，可以单击右下角的信息图标。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114247.png" alt></p><p>如果你想了解随着时间的推移向 DartPad 添加新包的计划， 请查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdart-lang%2Fdart-pad%2Fwiki%2FAdding-support-for-a-new-package" target="_blank" rel="noopener">Dart wiki 上的这篇文章</a> 。 还有另一个新的 DartPad 功能也非常方便。 在此之前，DartPad 总是以运行最新的 stable 版本运行。 在新版本中，你可以使用状态栏中新的 <strong>渠道菜单</strong> 来切换最新的 Beta 渠道版本以及之前的 stable 版本（称为“旧渠道”）。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213114312.png" alt></p><p>如果你正在撰写一篇博客文章，而最新的稳定版本还不够新，这将非常有用。 （其实方便了切换不同的渠道进行调试和 BUG 验证。）</p><h2 id="移除-Dev-渠道"><a href="#移除-Dev-渠道" class="headerlink" title="移除 Dev 渠道"></a>移除 Dev 渠道</h2><p>Flutter「渠道」决定了 Flutter 框架和引擎在你的开发机器上变化的速度， stable 代表最少的变更，而 master 代表最多。 受到团队资源的限制，我们最近将停止更新 dev 渠道。 虽然我们确实收到了一些相关的问题，但我们发现只有不到 3% 的 Flutter 开发人员使用 dev 渠道。 因此，我们决定启动正式停用 dev 渠道的进程。 虽然很少有开发人员使用 dev 渠道，但 Flutter 工程师需要花费大量时间和精力来维护它。 如果你将所有时间都花在 stable 渠道上（正如超过 90% 的 Flutter 开发人员所做的那样）， 那么这项改动将不会影响你的日常开发。 通过放弃它，你可以少做一个决定，而 Flutter 团队可以将时间和精力花在其他事情上。 你可以使用 <code>flutter channel</code> 命令来决定你想要哪个渠道。 以下是 Flutter 团队对每个渠道的看法：</p><ul><li><strong>Stable 渠道</strong> 代表我们拥有的最高质量的构建。它们每季度（大致）发布一次，并针对中间的关键问题进行热修复。 这是「慢」通道：安全、成熟、长期服务。</li><li><strong>Beta 渠道</strong> 为那些习惯于更快节奏的开发者提供了一种快速调整的替代方案。 目前每月发布，发布前稳定。这是「快速」通道。如果 dev 渠道正在满足 beta 渠道无法满足的需求， 我们可能会改变我们对 beta 渠道的看法来满足这些需求 （例如，加速发布 beta 的节奏或降低我们对 beta 执行的测试和热修复级别）。</li><li><strong>Master 渠道</strong> 是我们活跃的开发渠道。我们不提供对该渠道的支持，但我们针对它运行了一套全面的单元测试。 对于对不稳定的构建感到满意的贡献者或高级开发者而言，这是适合他们的渠道。 在这个频道上，我们跑得很快，打破了一些东西（然后会很快地修复它们）。</li></ul><p>当我们在未来几个月停用 dev 渠道时，请考虑使用 beta 或 master 渠道， 这取决于你对变更的容忍度以及你对最新和最好的 SDK 的平衡点。</p><h2 id="破坏性更改"><a href="#破坏性更改" class="headerlink" title="破坏性更改"></a>破坏性更改</h2><p>与往常一样，我们努力减少每个版本中破坏性更改的数量。 在此版本中，Flutter 2.8 除了已过期并根据我们的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fwiki%2FTree-hygiene%23handling-breaking-changes" target="_blank" rel="noopener">重大变更政策</a> 被删除的已弃用 API 之外，没有重大变更。</p><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90292" target="_blank" rel="noopener">90292</a> Remove autovalidate deprecations</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90293" target="_blank" rel="noopener">90293</a> Remove FloatingHeaderSnapConfiguration.vsync  deprecation</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90294" target="_blank" rel="noopener">90294</a> Remove AndroidViewController.id deprecation</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90295" target="_blank" rel="noopener">90295</a> Remove BottomNavigationBarItem.title deprecation</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fpull%2F90296" target="_blank" rel="noopener">90296</a> Remove deprecated text input formatting classes</li></ul><p>如果你仍在使用这些 API 并想了解如何迁移代码，你可以阅读 <a href="https://link.juejin.cn?target=https%3A%2F%2Fflutter.cn%2Fdocs%2Frelease%2Fbreaking-changes%2F2-5-deprecations" target="_blank" rel="noopener">flutter.dev 上的迁移指南</a> 。 与往常一样，非常感谢社区 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fflutter%2Ftests%2Fblob%2Fmaster%2FREADME.md" target="_blank" rel="noopener">贡献了测试用例</a> ， 帮助我们识别这些重大更改。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我们结束 2021 年并展望 2022 年之际，Flutter 团队要对整个 Flutter 社区的工作和支持表示感谢。 诚然，我们正在为世界上越来越多的开发人员构建 Flutter， 但如果没有你和每位开发者的存在，我们也无法维护并构建它。 Flutter 社区与众不同，我们感谢你所做的一切。 祝你假期愉快，我们新的一年见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211213111841.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官方发布说明：&lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fflutter%2Fwhats-new-in-flutter-2-8-d085b763d181&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;medium.com/flutter/wha…&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;北半球的冬意已至，黄叶与气温均随风而落，而年终的最后一个稳定版本已悄然来到你的面前。 让我们向 &lt;strong&gt;Flutter 2.8&lt;/strong&gt; 打声招呼～ 本次更新包含了 &lt;strong&gt;207 位贡献者和 178 位审核者&lt;/strong&gt; 的辛勤劳作， 所有人共同产出了 &lt;strong&gt;2424 个 PR&lt;/strong&gt;，关闭了 &lt;strong&gt;2976 个 issue&lt;/strong&gt;。 在此特别感谢本次发布中最突出的社区贡献者：来自 Very Good Ventures 的 Flutter 开发工程师 Bartosz Selwesiuk， 他专注于 Web 平台的 camera 插件并提交了 23 个 PR。&lt;/p&gt;
&lt;p&gt;以上的所有产出让 Flutter engine 和 DevTools 都有了非常显著的性能提升， 同时带来的还有 &lt;strong&gt;Google 移动端广告 SDK Flutter 版本的稳定版发布、 一系列针对 Firebase 的新功能和优化、Flutter WebView 3.0、 新的 Flutter Favorite package、向桌面端 Stable 迈出的一大步， 以及支持更多 package 的新版本 DartPad&lt;/strong&gt;。 虽然这是今年最后一个稳定版本，但它并不是最不重要的。让我们一起来看看！&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose 入门学习</title>
    <link href="http://yoursite.com/posts/7b2baf2a.html"/>
    <id>http://yoursite.com/posts/7b2baf2a.html</id>
    <published>2021-11-15T03:40:42.000Z</published>
    <updated>2021-12-24T02:05:30.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Jetpack Compose：利用声明式编程构建Android原生界面（UI）的 工具包</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>更少的代码、代码量锐减</li><li>强大的工具/组件支持</li><li>直观的 Kotlin API</li><li>简单易用</li></ul><h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><ul><li><p><strong>声明性编程范式</strong>：声明性的函数构建一个简单的界面组件，无需修改任何 XML 布局，也不需要使用布局编辑器，只需要调用 Jetpack Compose 函数来声明想要的元素，Compose 编译器即会完成后面的所有工作。</p></li><li><p><strong>简单的组合函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">  Text(text = <span class="string">"Hello <span class="variable">$name</span>!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115115340.png" alt></p></li><li><p><strong>声明性范式转变</strong>：在 Compose 的声明性方法中，微件相对无状态，并且不提供 setter 或 getter 函数。实际上，微件不会以对象形式提供。您可以通过调用带有不同参数的同一可组合函数来更新界面。这使得向架构模式（如 ViewModel）提供状态变得很容易，如应用架构指南中所述。然后，可组合项负责在每次可观察数据更新时将当前应用状态转换为界面。</p></li><li><p><strong>动态</strong> ：组合函数是用 Kotlin 而不是 XML 编写</p></li><li><p><strong>重组</strong>：在 Compose 中，您可以使用新数据再次调用可组合函数。这样做会导致函数进行重组 – 系统会根据需要使用新数据重新绘制函数发出的微件。Compose 框架可以智能地仅重组已更改的组件。</p><ul><li>可组合函数可以按任何顺序执行</li><li>可组合函数可以并行运行</li><li>重组会跳过尽可能多的内容</li><li>重组是乐观的操作</li><li>可组合函数可能会非常频繁地运行</li></ul></li></ul><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li><p>Arctic Fox 2020-3-1 版本以上，<a href="https://developer.android.com/studio" target="_blank" rel="noopener">下载最新AndroidStudio</a><br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115145212.png" alt></p></li><li><p>ComposeApp仅支持Kotlin 最低sdk 版本为21，Android 5.0<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115145308.png" alt></p></li><li><p>Gradle Compose相关依赖</p>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">   id <span class="string">'com.android.application'</span></span><br><span class="line">   id <span class="string">'kotlin-android'</span></span><br><span class="line">&#125;</span><br><span class="line">android &#123;</span><br><span class="line">   compileSdk <span class="number">31</span></span><br><span class="line"></span><br><span class="line">   defaultConfig &#123;</span><br><span class="line">       applicationId <span class="string">"com.zm.myjetpackcompose"</span></span><br><span class="line">       minSdk <span class="number">21</span></span><br><span class="line">       targetSdk <span class="number">31</span></span><br><span class="line">       versionCode <span class="number">1</span></span><br><span class="line">       versionName <span class="string">"1.0"</span></span><br><span class="line">   </span><br><span class="line">       testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">       vectorDrawables &#123;</span><br><span class="line">           useSupportLibrary <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   buildTypes &#123;</span><br><span class="line">       release &#123;</span><br><span class="line">           minifyEnabled <span class="literal">false</span></span><br><span class="line">           proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   compileOptions &#123;</span><br><span class="line">       sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">       targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">   &#125;</span><br><span class="line">   kotlinOptions &#123;</span><br><span class="line">       jvmTarget = <span class="string">'1.8'</span></span><br><span class="line">       useIR = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   buildFeatures &#123;</span><br><span class="line">       compose <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   composeOptions &#123;</span><br><span class="line">       kotlinCompilerExtensionVersion compose_version</span><br><span class="line">       kotlinCompilerVersion <span class="string">'1.5.21'</span></span><br><span class="line">   &#125;</span><br><span class="line">   packagingOptions &#123;</span><br><span class="line">       resources &#123;</span><br><span class="line">           excludes += <span class="string">'/META-INF/&#123;AL2.0,LGPL2.1&#125;'</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">   implementation <span class="string">'androidx.core:core-ktx:1.3.2'</span></span><br><span class="line">   implementation <span class="string">'androidx.appcompat:appcompat:1.2.0'</span></span><br><span class="line">   implementation <span class="string">'com.google.android.material:material:1.3.0'</span></span><br><span class="line">   implementation <span class="string">"androidx.compose.ui:ui:$compose_version"</span></span><br><span class="line">   implementation <span class="string">"androidx.compose.material:material:$compose_version"</span></span><br><span class="line">   implementation <span class="string">"androidx.compose.ui:ui-tooling-preview:$compose_version"</span></span><br><span class="line">   implementation <span class="string">'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1'</span></span><br><span class="line">   implementation <span class="string">'androidx.activity:activity-compose:1.3.0-alpha06'</span></span><br><span class="line">   testImplementation <span class="string">'junit:junit:4.+'</span></span><br><span class="line">   androidTestImplementation <span class="string">'androidx.test.ext:junit:1.1.2'</span></span><br><span class="line">   androidTestImplementation <span class="string">'androidx.test.espresso:espresso-core:3.3.0'</span></span><br><span class="line">   androidTestImplementation <span class="string">"androidx.compose.ui:ui-test-junit4:$compose_version"</span></span><br><span class="line">   debugImplementation <span class="string">"androidx.compose.ui:ui-tooling:$compose_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要安装最新Java11， java 8 环境会报以下错误</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8.</span><br><span class="line">    You can try some of the following options:</span><br><span class="line">      - changing the IDE settings.</span><br><span class="line">      - changing the JAVA_HOME environment variable.</span><br><span class="line">      - changing `org.gradle.java.home` in `gradle.properties`.</span><br></pre></td></tr></table></figure><p>  <img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115150103.png" alt></p></li><li><p>@Preview生效，则环境正常<br>  <img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115150241.png" alt></p></li></ul><h2 id="UI布局"><a href="#UI布局" class="headerlink" title="UI布局"></a>UI布局</h2><h3 id="Compose"><a href="#Compose" class="headerlink" title="@Compose"></a>@Compose</h3><p>所有关于构建View的方法都必须添加<code>@Compose</code>注解才可以。并且<code>@Compose</code>协程的<code>Suspend</code>的使用方法比较类似,被<code>@Compose</code>注解的方法只能在同样被<code>@Comopse</code>解的方法中才能被调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Text(text = <span class="string">"Hello <span class="variable">$name</span>!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preview"><a href="#Preview" class="headerlink" title="@Preview"></a>@Preview</h3><p><code>@Preview</code>注解的方法可以在不运行App的情况下就可以确认布局的情况。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115153114.png" alt><br>常用的参数:</p><ul><li><code>name</code>: String: 为该Preview命名，该名字会在布局预览中显示。</li><li><code>showBackground</code>: Boolean: 是否显示背景，true为显示。</li><li><code>backgroundColor</code>: Long: 设置背景的颜色。</li><li><code>showDecoration</code>: Boolean: 是否显示Statusbar和Toolbar，true为显示。</li><li><code>group</code>: String: 为该Preview设置group名字，可以在UI中以group为单位显示。</li><li><code>fontScale</code>: Float: 可以在预览中对字体放大，范围是从0.01。</li><li><code>widthDp</code>: Int: 在Compose中渲染的最大宽度，单位为dp。</li><li><code>heightDp</code>: Int: 在Compose中渲染的最大高度，单位为dp。<br>上面的参数都是可选参数，还有像背景设置等的参数并不是对实际的App进行设置，只是对Preview中的背景进行设置，为了更容易看清布局。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true,name = <span class="meta-string">"Text UI"</span>,backgroundColor = 0xFF888888)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">DefaultPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyJetpackComposeTheme &#123;</span><br><span class="line">        Greeting(<span class="string">"Android"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="setContent"><a href="#setContent" class="headerlink" title="setContent"></a>setContent</h3><p>setContent的作用是和Layout/View中的setContentView是一样的。<br>setContent的方法也是有@Compose注解的方法。所以，在setContent中写入关于UI的@Compopse方法，即可在Activity中显示。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContent &#123;</span><br><span class="line">            MyJetpackComposeTheme &#123;</span><br><span class="line">                <span class="comment">// A surface container using the 'background' color from the theme</span></span><br><span class="line">                Surface(color = MaterialTheme.colors.background) &#123;</span><br><span class="line">                    Greeting(<span class="string">"Android"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><p>在创建新的Compose项目时会自动创建一个Theme.kt文件。 我们可以通过更改颜色来完成对主题颜色的设置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zm.myjetpackcompose.ui.theme</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.compose.foundation.isSystemInDarkTheme</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.MaterialTheme</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.darkColors</span><br><span class="line"><span class="keyword">import</span> androidx.compose.material.lightColors</span><br><span class="line"><span class="keyword">import</span> androidx.compose.runtime.Composable</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> DarkColorPalette = darkColors(</span><br><span class="line">    primary = Purple200,</span><br><span class="line">    primaryVariant = Purple700,</span><br><span class="line">    secondary = Teal200</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> LightColorPalette = lightColors(</span><br><span class="line">    primary = Purple500,</span><br><span class="line">    primaryVariant = Purple700,</span><br><span class="line">    secondary = Teal200</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Other default colors to override</span></span><br><span class="line"><span class="comment">    background = Color.White,</span></span><br><span class="line"><span class="comment">    surface = Color.White,</span></span><br><span class="line"><span class="comment">    onPrimary = Color.White,</span></span><br><span class="line"><span class="comment">    onSecondary = Color.Black,</span></span><br><span class="line"><span class="comment">    onBackground = Color.Black,</span></span><br><span class="line"><span class="comment">    onSurface = Color.Black,</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyJetpackComposeTheme</span><span class="params">(darkTheme: <span class="type">Boolean</span> = isSystemInDarkTheme()</span></span>, content: <span class="meta">@Composable()</span> () -&gt; <span class="built_in">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> colors = <span class="keyword">if</span> (darkTheme) &#123;</span><br><span class="line">        DarkColorPalette</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LightColorPalette</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MaterialTheme(</span><br><span class="line">        colors = colors,</span><br><span class="line">        typography = Typography,</span><br><span class="line">        shapes = Shapes,</span><br><span class="line">        content = content</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h3><p><a href="https://developer.android.com/jetpack/compose/modifiers-list" target="_blank" rel="noopener">Modifier</a>是各个Compose的UI组件一定会用到的一个类。它是被用于设置UI的摆放位置，padding等信息的类。</p><h4 id="padding-设置各个UI的padding"><a href="#padding-设置各个UI的padding" class="headerlink" title="padding 设置各个UI的padding"></a>padding 设置各个UI的padding</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Modifier.padding(<span class="number">10.</span>dp) <span class="comment">// 给上下左右设置成同一个值</span></span><br><span class="line">Modifier.padding(<span class="number">10.</span>dp, <span class="number">11.</span>dp, <span class="number">12.</span>dp, <span class="number">13.</span>dp) <span class="comment">// 分别为上下左右设值</span></span><br><span class="line">Modifier.padding(<span class="number">10.</span>dp, <span class="number">11.</span>dp) <span class="comment">// 分别为上下和左右设值</span></span><br><span class="line">Modifier.padding(InnerPadding(<span class="number">10.</span>dp, <span class="number">11.</span>dp, <span class="number">12.</span>dp, <span class="number">13.</span>dp))<span class="comment">// 分别为上下左右设值</span></span><br></pre></td></tr></table></figure><h4 id="plus-可以把其他的Modifier加入到当前的Modifier中。"><a href="#plus-可以把其他的Modifier加入到当前的Modifier中。" class="headerlink" title="plus 可以把其他的Modifier加入到当前的Modifier中。"></a>plus 可以把其他的Modifier加入到当前的Modifier中。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modifier.plus(otherModifier) <span class="comment">// 把otherModifier的信息加入到现有的modifier中</span></span><br></pre></td></tr></table></figure><h4 id="fillMaxHeight、fillMaxWidth、fillMaxSize-类似于match-parent、填充整个父layout。"><a href="#fillMaxHeight、fillMaxWidth、fillMaxSize-类似于match-parent、填充整个父layout。" class="headerlink" title="fillMaxHeight、fillMaxWidth、fillMaxSize 类似于match_parent、填充整个父layout。"></a>fillMaxHeight、fillMaxWidth、fillMaxSize 类似于match_parent、填充整个父layout。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modifier.fillMaxHeight() <span class="comment">// 填充整个高度</span></span><br></pre></td></tr></table></figure><h4 id="width、heigh、size-设置Content的宽度和高度。"><a href="#width、heigh、size-设置Content的宽度和高度。" class="headerlink" title="width、heigh、size 设置Content的宽度和高度。"></a>width、heigh、size 设置Content的宽度和高度。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modifier.width(<span class="number">2.</span>dp) <span class="comment">// 设置宽度</span></span><br><span class="line">Modifier.height(<span class="number">3.</span>dp)  <span class="comment">// 设置高度</span></span><br><span class="line">Modifier.size(<span class="number">4.</span>dp, <span class="number">5.</span>dp) <span class="comment">// 设置高度和宽度 复制代码</span></span><br></pre></td></tr></table></figure><h4 id="widthIn-heightIn-sizeIn-设置Content的宽度和高度的最大值和最小值。"><a href="#widthIn-heightIn-sizeIn-设置Content的宽度和高度的最大值和最小值。" class="headerlink" title="widthIn, heightIn, sizeIn 设置Content的宽度和高度的最大值和最小值。"></a>widthIn, heightIn, sizeIn 设置Content的宽度和高度的最大值和最小值。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modifier.widthIn(<span class="number">2.</span>dp) <span class="comment">// 设置最大宽度</span></span><br><span class="line">Modifier.heightIn(<span class="number">3.</span>dp) <span class="comment">// 设置最大高度</span></span><br><span class="line">Modifier.sizeIn(<span class="number">4.</span>dp, <span class="number">5.</span>dp, <span class="number">6.</span>dp, <span class="number">7.</span>dp) <span class="comment">// 设置最大最小的宽度和高度</span></span><br></pre></td></tr></table></figure><h4 id="gravity-在Column中元素的位置。"><a href="#gravity-在Column中元素的位置。" class="headerlink" title="gravity 在Column中元素的位置。"></a>gravity 在Column中元素的位置。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modifier.gravity(Alignment.CenterHorizontally) <span class="comment">// 横向居中</span></span><br><span class="line">Modifier.gravity(Alignment.Start) <span class="comment">// 横向居左</span></span><br><span class="line">Modifier.gravity(Alignment.End) <span class="comment">// 横向居右</span></span><br></pre></td></tr></table></figure><h4 id="rtl、ltr-开始布局UI的方向。"><a href="#rtl、ltr-开始布局UI的方向。" class="headerlink" title="rtl、ltr 开始布局UI的方向。"></a>rtl、ltr 开始布局UI的方向。</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Modifier.rtl  <span class="comment">// 从右到左</span></span><br><span class="line">Modifier.ltr  <span class="comment">// 从左到右</span></span><br><span class="line"></span><br><span class="line">Modifier的方法都返回Modifier的实例的链式调用，所以只要连续调用想要使用的方法即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"> Text(text = <span class="string">"Hello <span class="variable">$name</span>!"</span>, modifier = Modifier.padding(<span class="number">20.</span>dp).fillMaxSize())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Column，Row"><a href="#Column，Row" class="headerlink" title="Column，Row"></a>Column，Row</h3><blockquote><p>Column 线性布局 ≈ Android LinearLayout-VERTICAL<br>Row 水平布局 ≈ Android LinearLayout-HORIZONTAL</p></blockquote><p>Column和Row可以理解为在View/Layout体系中的纵向和横向的ViewGroup。</p><ul><li>Modifier 用上述的方法传入已经按需求设置好的Modifier即可。</li><li>Arrangement.Horizontal, Arrangement.Vertical 需要给Row传入Arrangement.Horizontal，为Column传入Arrangement.Vertical。 这些值决定如何布置内部UI组件。<br>可传入的值为Center, Start, End, SpaceEvenly, SpaceBetween, SpaceAround。</li><li>Alignment.Vertical, Alignment.Horizontal 需要给Row传入Alignment.Vertical，为Column传入Alignment.Horizontal。 使用方法和Modifier的gravity中传入参数的用法是一样的.</li><li>@Composable ColumnScope.() -&gt; Unit 需要传入标有@Compose的UI方法。但是这里我们会有lamda函数的写法来实现。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Column &#123;</span><br><span class="line">        Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceAround, verticalAlignment = Alignment.CenterVertically) &#123;</span><br><span class="line">            Text(text = <span class="string">"Hello <span class="variable">$name</span>!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h3><p>帧布局≈Android FrameLayout，可将一个元素放在另一个元素上，如需在 Row 中设置子项的位置，请设置 horizontalArrangement 和 verticalAlignment 参数。对于 Column，请设置 verticalArrangement 和 horizontalAlignment 参数</p><h3 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h3><p>需要引入<code>implementation &quot;androidx.constraintlayout:constraintlayout-compose:1.0.0-beta02&quot;</code></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li><p>可以滚动的布局</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们可以使用 verticalScroll() 修饰符使 Column 可滚动，但以上布局并无法实现重用，可能导致性能问题</span></span><br><span class="line">   Column(</span><br><span class="line">       modifier = Modifier.verticalScroll(rememberScrollState())</span><br><span class="line">   ) &#123;</span><br><span class="line">       messages.forEach &#123; message -&gt;</span><br><span class="line">           MessageRow(message)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>LazyColumn/LazyRow == RecylerView/listView 列表布局，解决了滚动时的性能问题，LazyColumn和LazyRow之间的区别就在于它们的列表项布局和滚动方向不同。</p><ul><li>内边距   <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LazyColumn(</span><br><span class="line">      contentPadding = PaddingValues(horizontal = <span class="number">16.</span>dp, vertical = <span class="number">8.</span>dp),</span><br><span class="line">  ) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>item间距</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LazyColumn(</span><br><span class="line">     verticalArrangement = Arrangement.spacedBy(<span class="number">4.</span>dp),</span><br><span class="line"> ) &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>浮动列表的浮动标题，使用 LazyColumn 实现粘性标题，可以使用stickyHeader()函数</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">ListWithHeader</span><span class="params">(items: <span class="type">List</span>&lt;<span class="type">Item</span>&gt;)</span></span> &#123;</span><br><span class="line">     LazyColumn &#123;</span><br><span class="line">         stickyHeader &#123;</span><br><span class="line">             Header()</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         items(items) &#123; item -&gt;</span><br><span class="line">             ItemRow(item)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>网格布局LazyVerticalGrid</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">PhotoGrid</span><span class="params">(photos: <span class="type">List</span>&lt;<span class="type">Photo</span>&gt;)</span></span> &#123;</span><br><span class="line">    LazyVerticalGrid(</span><br><span class="line">        cells = GridCells.Adaptive(minSize = <span class="number">128.</span>dp)</span><br><span class="line">    ) &#123;</span><br><span class="line">        items(photos) &#123; photo -&gt;</span><br><span class="line">            PhotoItem(photo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h3><h4 id="通过重组基础布局实现"><a href="#通过重组基础布局实现" class="headerlink" title="通过重组基础布局实现"></a>通过重组基础布局实现</h4><h4 id="Canvas绘制"><a href="#Canvas绘制" class="headerlink" title="Canvas绘制"></a>Canvas绘制</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Canvas(modifier = Modifier.fillMaxSize()) &#123;</span><br><span class="line">        <span class="keyword">val</span> canvasWidth = size.width</span><br><span class="line">        <span class="keyword">val</span> canvasHeight = size.height</span><br><span class="line">        <span class="comment">//drawCircle 画圆</span></span><br><span class="line">        <span class="comment">//drawRectangle 画矩形</span></span><br><span class="line">        <span class="comment">//drawLine //画线</span></span><br><span class="line">        drawCircle(</span><br><span class="line">            color = Color.DarkGray,</span><br><span class="line">            center = Offset(x = canvasWidth / <span class="number">2</span>, y = canvasHeight / <span class="number">2</span>),</span><br><span class="line">            radius = size.minDimension / <span class="number">4</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115161558.png" alt></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><ul><li><code>Compose</code>整体来看，布局实现上相对于xml更加简单高效，也是官方日后力推的开发方式。</li><li><code>Compose</code>写法与<code>Flutter</code>代码上有很高的相似之处，都是通过响应式的快速搭建UI布局。<br>（PS：响应式的UI开发模式在大前端的各个语言中越来越相似了）</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.android.com/jetpack/compose" target="_blank" rel="noopener">https://developer.android.com/jetpack/compose</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Jetpack Compose：利用声明式编程构建Android原生界面（UI）的 工具包&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;更少的代码、代码量锐减&lt;/li&gt;
&lt;li&gt;强大的工具/组件支持&lt;/li&gt;
&lt;li&gt;直观的 Kotlin API&lt;/li&gt;
&lt;li&gt;简单易用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;编程思想&quot;&gt;&lt;a href=&quot;#编程思想&quot; class=&quot;headerlink&quot; title=&quot;编程思想&quot;&gt;&lt;/a&gt;编程思想&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;声明性编程范式&lt;/strong&gt;：声明性的函数构建一个简单的界面组件，无需修改任何 XML 布局，也不需要使用布局编辑器，只需要调用 Jetpack Compose 函数来声明想要的元素，Compose 编译器即会完成后面的所有工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;简单的组合函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Composable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Greeting&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Text(text = &lt;span class=&quot;string&quot;&gt;&quot;Hello &lt;span class=&quot;variable&quot;&gt;$name&lt;/span&gt;!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211115115340.png&quot; alt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;声明性范式转变&lt;/strong&gt;：在 Compose 的声明性方法中，微件相对无状态，并且不提供 setter 或 getter 函数。实际上，微件不会以对象形式提供。您可以通过调用带有不同参数的同一可组合函数来更新界面。这使得向架构模式（如 ViewModel）提供状态变得很容易，如应用架构指南中所述。然后，可组合项负责在每次可观察数据更新时将当前应用状态转换为界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;动态&lt;/strong&gt; ：组合函数是用 Kotlin 而不是 XML 编写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;重组&lt;/strong&gt;：在 Compose 中，您可以使用新数据再次调用可组合函数。这样做会导致函数进行重组 – 系统会根据需要使用新数据重新绘制函数发出的微件。Compose 框架可以智能地仅重组已更改的组件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可组合函数可以按任何顺序执行&lt;/li&gt;
&lt;li&gt;可组合函数可以并行运行&lt;/li&gt;
&lt;li&gt;重组会跳过尽可能多的内容&lt;/li&gt;
&lt;li&gt;重组是乐观的操作&lt;/li&gt;
&lt;li&gt;可组合函数可能会非常频繁地运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/categories/Android/Jetpack/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Alfred进阶教程，自定义Workflows</title>
    <link href="http://yoursite.com/posts/fa126efb.html"/>
    <id>http://yoursite.com/posts/fa126efb.html</id>
    <published>2021-11-08T08:25:42.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://zhangmiao.cc/posts/d083e6c8.html" target="_blank" rel="noopener">《Mac装机必备-Alfred的基础使用教程》</a>中，已为大家介绍了Alfred的基础功能。其实除了Alfred已有的功能外，Alfred还支持用户自定义工作流。</p><p>通过设置好触发器、输入、操作、实用程序、输出，就可以自由搭建工作流。在本教程中，我将创建一个简单的热键工作流，用来一键启动我每天多次使用的一些应用程序和网页。</p><p>进入Alfred的偏好设置中的<em>workflows*标签页，点击左下角的“</em>+<em>”，然后选择</em>Templates &gt; Files and Apps &gt; Launch file group from hotkey*，创建一个用热键打开的工作流。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108163119.png" alt></p><a id="more"></a><p>然后为你的工作流编辑名称、图标等信息，便于识别。（图标可以直接拖入）</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108165131.png" alt></p><p>编辑完成后，点击右下角的Save即可创建出一个名为work的工作流。左边图标是热键，右边图标是你要创建的动作。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108165131.png" alt></p><p>双击左边图标，打开热键设置窗口，选中输入框，直接在键盘上键入你想要设置的热键，然后保存。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108165216.png" alt></p><p>双击右侧图标，打开动作设置窗口，你可以选择一次启动多个Mac软件或文件夹，比如我想要一次打开AndroidStudio、Safari、Sourcetree三个应用程序，直接将它们拖入此窗口即可。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108170007.png" alt></p><p>Alfred除了能设置打开多个Mac软件外，还可以设置打开多个网页。比如我们想同时打开马可菠萝网站，可以在窗口任意位置右键，选择Actions &gt; Open URL。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108170352.png" alt></p><p>在弹窗中将马可菠萝的网址 <a href="https://zhangmiao.cc/" target="_blank" rel="noopener">https://zhangmiao.cc/</a> 复制粘贴进去，并选好默认浏览器，保存即可。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108170432.png" alt></p><p>最后再把这个新的动作链接到热键的后面，即完成打开马可菠萝网站的设置了。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108170809.png" alt></p><p>了解Alfred的工作流程，能够帮助你轻松完成各种重复任务，让你以前所未有的方式在Mac上提高效率！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇&lt;a href=&quot;https://zhangmiao.cc/posts/d083e6c8.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Mac装机必备-Alfred的基础使用教程》&lt;/a&gt;中，已为大家介绍了Alfred的基础功能。其实除了Alfred已有的功能外，Alfred还支持用户自定义工作流。&lt;/p&gt;
&lt;p&gt;通过设置好触发器、输入、操作、实用程序、输出，就可以自由搭建工作流。在本教程中，我将创建一个简单的热键工作流，用来一键启动我每天多次使用的一些应用程序和网页。&lt;/p&gt;
&lt;p&gt;进入Alfred的偏好设置中的&lt;em&gt;workflows*标签页，点击左下角的“&lt;/em&gt;+&lt;em&gt;”，然后选择&lt;/em&gt;Templates &amp;gt; Files and Apps &amp;gt; Launch file group from hotkey*，创建一个用热键打开的工作流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108163119.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="http://yoursite.com/categories/Mac/"/>
    
      <category term="Alfred" scheme="http://yoursite.com/categories/Mac/Alfred/"/>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="Alfred" scheme="http://yoursite.com/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>Mac装机必备Alfred</title>
    <link href="http://yoursite.com/posts/d083e6c8.html"/>
    <id>http://yoursite.com/posts/d083e6c8.html</id>
    <published>2021-11-08T08:04:43.000Z</published>
    <updated>2024-08-19T08:15:42.832Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装Alfred"><a href="#安装Alfred" class="headerlink" title="安装Alfred"></a>安装<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a></h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108160814.png" alt></p><a id="more"></a><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>为了快速打开<code>Alfred</code>，我们需要为它设置一个快  捷键，打开<code>Alfred</code>偏好设置的<code>General</code>选项卡，选中<code>Alfred Hotkey</code>输入框，直接使用键盘键入你喜欢的快捷键即可。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108160920.png" alt></p><p>我使用的<code>alt+空格键</code>，当初设置时，由于这个快捷键被Mac系统的Spotlight占用了，无法设置成功。如遇到相同的情况，需要先到<code>系统偏好设置-键盘-快捷键-聚焦</code>中取消勾选<code>alt+空格键</code>打开“聚焦”搜索的设置，然后再返回到<code>Alfred</code>中设置即可。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161042.png" alt></p><h3 id="自定义外观"><a href="#自定义外观" class="headerlink" title="自定义外观"></a>自定义外观</h3><p>进入<code>Appearance</code>选项卡，Alfred为我们提供了几种外观样式，如果你都不喜欢，也可以自定义外观。点击左下角的“+”，创建你的专属样式。通过双击相应的组件，即可打开系统的调色器，可以自由的搭配自己喜欢的颜色。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161114.png" alt></p><p>进入<code>Features</code>选项卡，在左侧列表中，罗列的是<code>Alfred</code>的基础功能，包括默认<code>搜索</code>、<code>文件搜索</code>、<code>网页搜索</code>、<code>网页书签</code>、<code>计算器</code>、<code>字典</code>、<code>联系人</code>、<code>剪贴板</code>、<code>iTunes</code>、<code>系统操作</code>、<code>终端</code>等。</p><h3 id="默认搜索（Default-Results）"><a href="#默认搜索（Default-Results）" class="headerlink" title="默认搜索（Default Results）"></a>默认搜索（Default Results）</h3><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161251.png" alt></p><p>Essentials和Extras设置我们的搜索类型，可以设置搜索应用程序、联系人、偏好设置、文件夹、文本文件、压缩文件、文档、图片、脚本等。</p><p>Unintelligent建议不要勾选，会影响我们的搜索速度以及搜索结果。</p><p>Search Scope可以设置Alfred的搜索范围，点击右上角的”+”，可以添加其他的搜索范围；或者选中某项，按<code>Delete</code>键移除该搜索范围。</p><h3 id="文件搜索（File-Search）"><a href="#文件搜索（File-Search）" class="headerlink" title="文件搜索（File Search）"></a>文件搜索（File Search）</h3><p>默认搜索会搜索出所有类型的内容，包括邮件、联系人等其他内容，都是我根本不想搜索到的文件类型，这时就可以使用文件搜索，把一些不需要的类型过滤掉。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161334.png" alt></p><ul><li>空格键 + 关键字：文件搜索</li><li>find + 关键字：打开文件所在的Finder</li><li>in + 关键字：搜索文件内容中带有该关键字的文件</li></ul><h3 id="网页搜索（Web-Search）"><a href="#网页搜索（Web-Search）" class="headerlink" title="网页搜索（Web Search）"></a>网页搜索（Web Search）</h3><p>这是小编使用频率最高的功能，有了它，再也不怕记不住网址了。Alfred中已经默认设置了很多国外的网站，但大多数都是用不上的，不需要的只要取消勾选就行。点击右下角的<code>“Add Custom Search”</code>，即可添加新的网站搜索。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161453.png" alt></p><p>比如添加马可菠萝网站，只要到马可菠萝的搜索页面随便搜索一个内容，然后复制结果页面的网址，把具体的内容改成<code>{query}</code>即可，关键字填写macbl，然后保存。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161529.png" alt></p><ul><li>马可菠萝：<a href="https://www.macbl.com/search/{query}" target="_blank" rel="noopener">https://www.macbl.com/search/{query}</a></li><li>百度：<a href="https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}" target="_blank" rel="noopener">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</a></li><li>Dribbble：<a href="https://dribbble.com/search?q={query}" target="_blank" rel="noopener">https://dribbble.com/search?q={query}</a></li></ul><p>使用时，在Alfred中输入 macbl Alfred，按回车键即可打开马可菠萝搜索页面，找到Alfred啦！</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161804.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161833.png" alt></p><h3 id="剪贴板（Clipboard）"><a href="#剪贴板（Clipboard）" class="headerlink" title="剪贴板（Clipboard）"></a>剪贴板（Clipboard）</h3><p>剪贴板功能是我选择Alfred的主要原因，可以查看Alfred的所有剪贴历史记录，节省了重复操作的时间，非常强大</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108161903.png" alt></p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/1557323280715908.gif" alt></p><h3 id="系统操作（System）"><a href="#系统操作（System）" class="headerlink" title="系统操作（System）"></a>系统操作（System）</h3><p>用简单的命令，来控制系统操作，比如最常用的清空垃圾桶(enptytrash)，休眠(sleep)，强制退出应用程序(forcequit)等，快捷键都可以自由设置。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108162116.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装Alfred&quot;&gt;&lt;a href=&quot;#安装Alfred&quot; class=&quot;headerlink&quot; title=&quot;安装Alfred&quot;&gt;&lt;/a&gt;安装&lt;a href=&quot;https://www.alfredapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alfred&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211108160814.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mac" scheme="http://yoursite.com/categories/Mac/"/>
    
      <category term="Alfred" scheme="http://yoursite.com/categories/Mac/Alfred/"/>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="Alfred" scheme="http://yoursite.com/tags/Alfred/"/>
    
  </entry>
  
  <entry>
    <title>Flutter完整学习路线解读</title>
    <link href="http://yoursite.com/posts/829f290.html"/>
    <id>http://yoursite.com/posts/829f290.html</id>
    <published>2021-10-27T07:01:31.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter 作为一门新的技术，确实相关的资料书籍不太多。但就 Flutter 生态的影响力而言，已经是越来越强了。譬如，在 StackOverflow 网站上2021年度最受欢迎的技术中，Dart 语言排在了第7位。随着谷歌对 Flutter 跨平台解决方案的推进，估计会有越来越多的开发者使用 Flutter 构建他们的应用。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211027150220.png" alt></p><h2 id="学习线路思维导图"><a href="#学习线路思维导图" class="headerlink" title="学习线路思维导图"></a>学习线路思维导图</h2><p>先上一份思维导图，让大家有个整体认识。</p><p><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211027150434.png" alt></p><a id="more"></a><h2 id="Dart语言"><a href="#Dart语言" class="headerlink" title="Dart语言"></a>Dart语言</h2><p>在学习 Dart 语言前，若没有任何编程基础，建议先了解一下计算机基础知识。Dart 作为一门现代化的面向对象编程语言，具备了市面上大多数编程语言的特点，具体来说会分为下面这些内容：</p><ul><li>变量定义、赋值：这是最基础的部分，至少要知道什么是变量，如何赋值。final，var 和 const 的区别。</li><li>基本数学运算：加、减、乘、除、整除、取余等运算；</li><li>条件分支：if…else if…else 控制程序逻辑走向，或是 switch 分支；</li><li>循环：使用循环完成重复性的工作；</li><li>容器类：如List、Map 和 Set 的应用；</li><li>函数和参数：一个是使用函数编写可复用的逻辑处理代码，二是需要注意在 Dart 中函数也是对象。同时需要区分函数的命名参数、可选参数的使用；</li><li>面向对象编程：了解面向对象编程的概念和思想，能够合理地使用类来封装代码提高复用性和降低耦合；</li><li>继承、多态和抽象类：这是提高代码复用、降低代码耦合度十分重要的概念，建议是多看看一些源码和设计思想（如设计模式），然后在遇到复杂业务的时候先思考如何抽象和组织代码结构。</li><li>mixin：mixin 提供了一种更为灵活的代码复用方式，可以将功能组合到现有类中，从而避免了继承的一些缺点。</li><li>泛型：使用泛型来做工具类是再好不过的选择了，通过泛型可以一套代码处理多种数据类型。</li><li>Future：有点类似前端的 promise，通过 Future 可以让异步编程变得更加简单。</li><li>null safety：空安全现在基本上是高级语言的标配了。通过空安全可以让团队遵循同一个规范，提高了代码的健壮性。</li></ul><h2 id="Flutter组件"><a href="#Flutter组件" class="headerlink" title="Flutter组件"></a>Flutter组件</h2><p>作为一个合格的App 开发，能够将一个UI 界面还原出来是基本的要求。建议一开始需要熟悉Flutter框架提供的自带组件，然后可以通过自带的组件组合成为自己的自定义组件。这部分内容包括：</p><ul><li>运行 Hello World 程序，跑通整个应用。</li><li>了解应用程序的结构，知道如何设计你的代码目录结构。</li><li>布局类组件：如 <code>Container</code>，<code>SizedBox</code>，<code>Padding，Stack</code>，<code>ListView</code>，<code>GridView</code> 等组件。</li><li>业务类组件：如 <code>TextField</code>，按钮，文本，图片，图标等组件。</li><li>自定义组件：利用布局类组件和业务类组件组合，构成自己的可复用的组件。</li><li>自有组件库：根据产品特性和公司需要，抽取复用的组件构成自有的组件库，从而提升整个公司的开发效率。</li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>应用中，表单在界面中出现的频率很高。如何处理表单对开发效率的影响很大。建议可以一开始从简单的表单页面开始，例如登录页、注册页。然后再做一些复杂的表单页面，具体如下：</p><ul><li>简单表单页面的实现：登录页、注册页、绑定手机号这类的页面；</li><li>不同表单的实现：例如普通文本、密码、数字、日期、单选、多选等表单的实现；</li><li>表单校验：封装表单校验库，将通用的校验规则放置在校验库中，比如长度、手机号校验、密码强度校验、日期格式校验等等。通过前端的提前校验可以避免后端请求压力，也能够提升用户体验。</li><li>表单封装：封装一套通用的表单组件，供整个团队复用，提高生产效率，也能减少 bug 的产生。</li></ul><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>状态管理是 Flutter 的核心，如何处理数据实体、业务逻辑、界面之间的关系对代码的可维护性十分关键，而这都依赖于状态管理的实现。对于状态管理，建议按如下方式学习：</p><ul><li>有状态组件和无状态组件的区别，可以阅读一下<code>StatefulWidget</code> 和 <code>StatelessWidget</code>的源码，会有更深刻的理解。</li><li>理解组件的渲染机制：虽然我们开发中很少关注组件如何渲染，但是当应用状态管理插件时，我们通过渲染机制能够知道状态数据更新时如何减少刷新的范围，实现局部刷新，从而提升性能。</li><li>主流状态插件应用：对比主流状态插件，从中选择一个合适自己团队的应用。对于长期用的状态管理插件，建议深入了解具体的实现机制，以便再遇到问题时能够快速定位，快速解决。</li><li>按需刷新：相比 setState 这种简单粗暴的全局更新，状态管理插件的一大优势就是可以实现局部刷新。通过按需刷新可以极大地提高页面的流畅度。</li></ul><p>关于状态管理的内容，可以通过阅读下面两篇文章来进行了解：</p><p>🚩🚩🚩建议收藏<br><a href="https://juejin.cn/post/7016485596046557198" target="_blank" rel="noopener">Flutter状态管理插件哪家强？请看岛上码农的排行榜！</a><br><a href="https://juejin.cn/post/7016141866194173988" target="_blank" rel="noopener">Flutter 入门与实战（九十二）：状态管理系列大汇总</a></p><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>App 的业务功能开发，相当一部分工作是在与和后端对接口、联调接口。了解与后端的数据交互，封装好网络请求库非常重要。这里建议按如下的方式进行学习：</p><ul><li>JSON 数据的认识：这个其实很简单，基本上一看就明白。但更重要的是和后端约定返回数据的格式，避免每个接口的格式都不同，那样很难做统一封装。</li><li>JSON 数据转对象：曾几何时，我是直接拿 JSON 对象（实际已经转成 Map 了）的 key 去取所需的值的。结果遭受了惨痛的教训，比如后端问题变成 null 了会导致闪退。而且每次都需要敲 key的名称，编码效率极低。而将 JSON 数据转为对象，一方面是对象可以在整个工程里复用，二是可以通过对象属性访问，编码有提示。同时，可以应用 null safety 属性直接知道哪个属性是否可能为空。</li><li>RESTful接口调试：早期的接口都是 GET 和 POST 请求，但是其实语义上并不明确。建议是统一和后端约定使用 RESTful 风格接口。</li><li>Mock 数据：后端接口没出来之前，使用 Mock 数据来完成业务逻辑的模拟非常重要。建议 Mock 的数据获取接口和后端的接口保持一致（统一实现相同的接口），这样在后端接口就绪后可以直接切换接口实现类就可以了。</li><li>网络请求插件使用与封装：Flutter 目前最为流行的网络请求插件是 Dio，对应的封装版本有 Retrofit。建议不要上来一开始就有用封装好的版本。而是自己一个个调试，然后尝试自己封装，这样会更好地理解封装的过程。</li><li><code>Headers</code> 和 <code>Cookie</code>：App 和浏览器不同，浏览器会自己管理<code>Cookie</code>。而 App 需要自己管理 <code>Cookie</code>。因此有必要了解如何设置请求头<code>Headers</code>，以及如何获取后端的 <code>Cookie</code> 并回写到<code>Headers</code> 里面。</li></ul><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>当你对界面、状态管理、网络请求都掌握差不多到时候，使用 <code>Flutter</code> 开发基本的 App 就基本没问题了。这个时候需要考虑应用结构如何优化。对于<code>Dart</code> 而言，提供了 <code>Stream</code> 和 <code>StreamListener</code> 这样的工具来通过流的方式驱动关联业务或界面更新，实现响应式编程。这里面典型的是 <code>BLoC</code> 模式 （<code>BLoC</code> 也可以用于状态管理）。了解一下 <code>BLoC</code> 的理念对设计整个应用程序框架十分有帮助。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>当你掌握上述的基本技能后，你看到别人 App 的酷炫动效时肯定心痒痒，想自己偶尔也能玩一下这类高大上的东西。这个时候就需要了解动画的实现了，<code>Flutter</code> 提供了很多动画构建方式，比如：</p><ul><li>基础动画组件：例如 <code>AnimatedContainer</code>，<code>AnimatedOpacity</code> 等等，通过这些组件可以实现简单但有趣的动画。</li><li>动画复用：使用 <code>AnimatedBuilder</code> 可以构建可复用的动效。</li><li>动画曲线：<code>Flutter</code> 自带了很多动画曲线效果，如果不满足也可以实现自定义曲线。有了动画曲线，你就可以定义一些自己的动画过渡效果了。</li><li>动画插件：<a href="https://pub.dev/" target="_blank" rel="noopener">pub.dev</a>上也提供了很多动画插件，例如<code>Lottie</code> 就可以将 AE 的动画转换为 <code>Flutter</code> 动画。如何查找动画插件，这需要懂得搜索，比如搜索关键字 <code>Animation</code>，或者经常逛一些技术社区，会让你的视野开拓很多，也许，不经意间就能发现一个酷炫的插件。</li></ul><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>当你的动画都能搞定的时候，你会发现产品和设计可能已经对你刮目想看了，这个时候他们提出的交互或者界面效果会提高（千万别觉得升级自己的技能是在给自己挖坑）。比如，可能会出一个奇怪的外形，然后需要你实现，这个时候就需要用到绘图了。绘图其实需要挺高的数学知识辅助的，你可能需要提前复习一下高等数学、线性代数知识😜😜😜 —— 所以大厂筛选学校和学历其实也有一定的道理的，这些筛选出来的人的基础知识一般都不会差。</p><ul><li><code>ClipPath</code>：自定义裁剪路径对于绘制有规律的形状来说可以轻松搞定，当然有些复杂的可能需要一些贝塞尔曲线知识。</li><li><code>CustomPaint</code>和 <code>Canvas</code>：使用 <code>CustomPaint</code> 和 <code>Canvas</code> 可以随心所欲地绘图，包括你想搞个小游戏也行。但是，这个也是很烧脑的一环，说到底，数学真的很重要！</li><li>计算机图形学（CG）：这算是绘图的理论支撑，有计算机图形学知识的支撑，会让你绘制自定义图形时候得心应手。</li></ul><h2 id="本地数据存储"><a href="#本地数据存储" class="headerlink" title="本地数据存储"></a>本地数据存储</h2><p>随着网络的升级，本地数据存储可能不像之前那么重要。但是，不论是对用户体验还是减轻后端压力都是必不可少的。譬如，微信就把整个个人的聊天记录存储在了本地 —— 既节省了服务器的存储空间和加载请求量，还能够对外宣称是“保护个人隐私”。本地存储主要有三个方面：</p><ul><li>简单键值对的存储：可以存储一些配置信息、登录会话信息，避免反复从服务器读取。在 <code>Flutter</code> 通常是使用 <code>SharedPreferences</code> 实现。</li><li>文件存储：比如应用内下载的文件管理，日志文件等，可以使用文件管理实现。通常会使用到 <code>path_provider</code> 插件实现。</li><li>关系型数据库：移动端大部分都采用了 <code>SQLite</code> 数据库，<code>SQLite</code> 的数据库操作语法和 <code>MySQL</code> 这类的标准 <code>SQL</code> 基本一致，可以用于存储关系数据。在<code>Flutter</code> 中也有不少封装好的插件，比如 <code>sqflite</code>。</li></ul><h2 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h2><p>实际上页面导航在一开始就会用到，大部分情况下，自带的导航和路由管理都能够满足需求。对于路由可以按如下方式进阶：</p><ul><li>自带路由的掌握：比如匿名路由，命名路由，路由传参，路由拦截等；</li><li>路由插件的应用：了解如 <code>fluro</code>、<code>GetX</code> 的路由管理的优缺点，选择使用自带的路由管理还是使用第三方插件。</li><li>2.0路由：这个如果是在 Web端的话建议了解一下，App 端个人感觉有点重，学习成本相对较高。当然，因为刚出来没多久，估计以后也会有简单易用的插件帮助我们使用。</li></ul><h2 id="自有插件"><a href="#自有插件" class="headerlink" title="自有插件"></a>自有插件</h2><p>如果你的公司业务条线比较多，也许此时已经成为公司大神的你会被邀请做基础设施建设，或者是你自己想为开源社区做做贡献，这个时候就需要构建自有插件或开源插件了。Flutter 提供了插件构建模板工程，你可以按步骤构建自有插件，然后供整个公司的各个业务条线使用，提高各个业务条线的生产力。</p><h2 id="原生交互"><a href="#原生交互" class="headerlink" title="原生交互"></a>原生交互</h2><p>原生交互分为三个部分：</p><ul><li>Flutter为原生提供服务</li><li>Flutter 使用原生提供的接口</li><li>原生页面与 Flutter 页面之间的跳转</li></ul><p>这块对于混编的应用来说是必不可少的，此时你的知识体系需要升级了，你需要学习安卓的 kotlin 开发，iOS 的 Swift 开发（呃，本来想一站式搞定，结果又绕回来了）。当然，到这个阶段，相信这些已经难不倒你了！</p><h2 id="应用发布"><a href="#应用发布" class="headerlink" title="应用发布"></a>应用发布</h2><p>恭喜你！你的应用可以在各大应用市场上架了！记得我的第一个应用在 AppStore过审的时候别提多兴奋了（之前被拒了好几次😂😂😂）！如何进行应用打包这个搜索一下就能搞定了，但是如何应对AppStore 每年都变的审查规则也是一场斗智斗勇的过程。 而安卓，如果搞定碎片化的操作系统分布也是头疼的一件事情。建议提前在应用内做应用统计，以及异常上报，避免发布后在用户机器上出现奇怪的问题。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>技术永无止境，再往后，你可能会深入去做性能优化、应用架构设计。这些方面很大程度靠个人平时的积累，多输入新的知识，同时了解其他的应用框架和特性（不限于 Dart，比如 Java 的 Spring 框架，Web 端的 React、Vue）都会让你对当前的应用架构设计有新的认识。扩充视野和技术深度，也许你就是下一个 CTO 的人选💪🏻💪🏻💪🏻！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Flutter 作为一门新的技术，确实相关的资料书籍不太多。但就 Flutter 生态的影响力而言，已经是越来越强了。譬如，在 StackOverflow 网站上2021年度最受欢迎的技术中，Dart 语言排在了第7位。随着谷歌对 Flutter 跨平台解决方案的推进，估计会有越来越多的开发者使用 Flutter 构建他们的应用。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211027150220.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;学习线路思维导图&quot;&gt;&lt;a href=&quot;#学习线路思维导图&quot; class=&quot;headerlink&quot; title=&quot;学习线路思维导图&quot;&gt;&lt;/a&gt;学习线路思维导图&lt;/h2&gt;&lt;p&gt;先上一份思维导图，让大家有个整体认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211027150434.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter如何开发web端</title>
    <link href="http://yoursite.com/posts/b683bca5.html"/>
    <id>http://yoursite.com/posts/b683bca5.html</id>
    <published>2021-10-16T02:46:21.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<p>flutter开发移动端与开发web端有些区别，开发移动端会涉及到各自原生系统里特有的一些内容，iOS端与Android通过插件的形式引入的项目当中，但不需要考虑响应式布局。而web端开发需要考虑到窗口的大小变化，需要考虑响应式布局。</p><p>开启对web开发的支持<br>flutter开发要支持web，需要在命令行中输入以下命令打开支持的平台（以下列举了各个平台支持的命令行）：</p><blockquote><p>flutter config —enable-web-desktop<br>flutter config —enable-windows-desktop<br>flutter config —enable-macos-desktop<br>flutter config —enable-linux-desktop </p></blockquote><p>之后再次输入 <code>flutter config</code>检测开启的情况，如果检测到如下图所示则表示开启成功。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022110841.png" alt></p><p>这时候可以创建项目了，创建的时候勾选Web选项即可。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111535.png" alt></p><a id="more"></a><h2 id="web开发的注意事项"><a href="#web开发的注意事项" class="headerlink" title="web开发的注意事项"></a>web开发的注意事项</h2><h3 id="支持响应式布局的控件"><a href="#支持响应式布局的控件" class="headerlink" title="支持响应式布局的控件"></a>支持响应式布局的控件</h3><p>A. MediaQuery<br>响应式布局的本质是监听浏览器宽高的变化进而修改UI的样式，所以需要能够监听宽高的变化，此时可以使用MediaQuery控件。MediaQuery控件继承自InheritedWidget，通过<code>MediaQuery.of(context).size</code>的方式实时获取到浏览器宽高的变化，进而对全局的UI进行调整。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111054.png" alt></p><p>B.  LayoutBuilder<br>LayoutBuilder是MediaQuery的简化版本，可以实时监控父控件尺寸的变化（不是浏览器宽高的变化），进而对当前控件的UI进行调整。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111103.png" alt></p><p>C. AspectRatio<br>这是一个指定宽高比例的控件，会随着浏览器宽度变化进行等比例缩小或者放大。如果要保证某个控件的宽高保持一致，则需要使用AspectRatio。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111112.png" alt></p><p>D. Flexible 与 Expanded<br>Flexible与Expanded是用在Row或者Column中的控件，前者可以用来控制控件在Row或者Column中占用的比例，后者则用来填充Row或者Column中剩余的空间。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111121.png" alt></p><p>E. FractionallySizedBox<br>这是一个设置占位比例的控件，跟AspectRatio类似，可以设置占有父控件多大比例。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111132.png" alt></p><h3 id="响应式布局支持的开源库"><a href="#响应式布局支持的开源库" class="headerlink" title="响应式布局支持的开源库"></a>响应式布局支持的开源库</h3><p>A. responsive_framework<br>这个库支持屏幕尺寸变化时对所用控件进行缩放控制或者进行实时UI调整，支持手机、平板、电脑尺寸的设置，使用方便。支持缩放控制是其最大亮点。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111159.png" alt></p><p>B. responsive_builder<br>这个库支持屏幕尺寸的变化时对所有控件进行实时UI调整，并能检测移动端横竖屏变化。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/dd792057-6327-497f-98e1-b06144334e10.gif" alt></p><h3 id="引用开源库的注意点"><a href="#引用开源库的注意点" class="headerlink" title="引用开源库的注意点"></a>引用开源库的注意点</h3><p>如果要做到开发web的时候也需要支持移动端，在引入开源库时要注意其支持的平台种类。如下图中支持的平台就包含了安卓、iOS、Linux、MacOS、Web以及windows。最好引入的开源库支持全平台。<br><img src="https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111227.png" alt></p><p>参考资料：<br><a href="https://betterprogramming.pub/how-to-build-responsive-apps-with-flutter-widgets-review-b22c6dec6904" target="_blank" rel="noopener">https://betterprogramming.pub/how-to-build-responsive-apps-with-flutter-widgets-review-b22c6dec6904</a><br><a href="https://medium.com/flutter-community/seven-things-you-should-know-before-starting-with-flutter-web-8e48555d819e" target="_blank" rel="noopener">https://medium.com/flutter-community/seven-things-you-should-know-before-starting-with-flutter-web-8e48555d819e</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flutter开发移动端与开发web端有些区别，开发移动端会涉及到各自原生系统里特有的一些内容，iOS端与Android通过插件的形式引入的项目当中，但不需要考虑响应式布局。而web端开发需要考虑到窗口的大小变化，需要考虑响应式布局。&lt;/p&gt;
&lt;p&gt;开启对web开发的支持&lt;br&gt;flutter开发要支持web，需要在命令行中输入以下命令打开支持的平台（以下列举了各个平台支持的命令行）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;flutter config —enable-web-desktop&lt;br&gt;flutter config —enable-windows-desktop&lt;br&gt;flutter config —enable-macos-desktop&lt;br&gt;flutter config —enable-linux-desktop &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之后再次输入 &lt;code&gt;flutter config&lt;/code&gt;检测开启的情况，如果检测到如下图所示则表示开启成功。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022110841.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这时候可以创建项目了，创建的时候勾选Web选项即可。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhangmiaocc/blogImageResource/master/img/20211022111535.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter cached_network_image 图片加载流程分析</title>
    <link href="http://yoursite.com/posts/a931c363.html"/>
    <id>http://yoursite.com/posts/a931c363.html</id>
    <published>2021-09-28T09:14:46.000Z</published>
    <updated>2021-12-24T02:05:30.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>组件<a href="https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fcached_network_image" target="_blank" rel="noopener">CachedNetworkImage</a>可以支持直接使用或者通过<code>ImageProvider</code>。</p><p><strong>引入依赖</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  cached_network_image:</span> <span class="string">^3.1.0</span></span><br></pre></td></tr></table></figure><p>执行<code>flutter pub get</code>，项目中使用</p><p><strong>Import it</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:cached_network_image/cached_network_image.dart'</span>;</span><br></pre></td></tr></table></figure><p><strong>添加占位图</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CachedNetworkImage(</span><br><span class="line">        imageUrl: <span class="string">"http://via.placeholder.com/350x150"</span>,</span><br><span class="line">        placeholder: (context, url) =&gt; CircularProgressIndicator(),</span><br><span class="line">        errorWidget: (context, url, error) =&gt; Icon(Icons.error),</span><br><span class="line">     ),</span><br></pre></td></tr></table></figure><p><strong>进度条展示</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CachedNetworkImage(</span><br><span class="line">        imageUrl: <span class="string">"http://via.placeholder.com/350x150"</span>,</span><br><span class="line">        progressIndicatorBuilder: (context, url, downloadProgress) =&gt; </span><br><span class="line">                CircularProgressIndicator(value: downloadProgress.progress),</span><br><span class="line">        errorWidget: (context, url, error) =&gt; Icon(Icons.error),</span><br><span class="line">     ),</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>原生组件Image配合</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image(image: CachedNetworkImageProvider(url))</span><br></pre></td></tr></table></figure><p><strong>使用占位图并提供provider给其他组件使用</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CachedNetworkImage(</span><br><span class="line">  imageUrl: <span class="string">"http://via.placeholder.com/200x150"</span>,</span><br><span class="line">  imageBuilder: (context, imageProvider) =&gt; Container(</span><br><span class="line">    decoration: BoxDecoration(</span><br><span class="line">      image: DecorationImage(</span><br><span class="line">          image: imageProvider,</span><br><span class="line">          fit: BoxFit.cover,</span><br><span class="line">          colorFilter:</span><br><span class="line">              ColorFilter.mode(Colors.red, BlendMode.colorBurn)),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  placeholder: (context, url) =&gt; CircularProgressIndicator(),</span><br><span class="line">  errorWidget: (context, url, error) =&gt; Icon(Icons.error),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>这样就可以加载网络图片了，而且，图片加载完成时，就被缓存到本地了，首先看下图片的加载流程</p><blockquote><p>官网说了，它现在不包含缓存，缓存功能实际上是另一个库<code>flutter_cache_manager</code>中实现的</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="加载-amp-显示"><a href="#加载-amp-显示" class="headerlink" title="加载&amp;显示"></a>加载&amp;显示</h3><blockquote><p>这里我们仅梳理图片加载和缓存的主流程，对于一些其他分支流程，或无关参数不做过多分析</p></blockquote><p>首先，页面上使用的构造函数接收了一个必传参数imageUrl，用于生成ImageProvider提供图片加载</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedNetworkImage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="comment">/// image提供</span></span><br><span class="line">  <span class="keyword">final</span> CachedNetworkImageProvider _image;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 构造函数</span></span><br><span class="line">  CachedNetworkImage(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.imageUrl,</span><br><span class="line">    <span class="comment">/// 省略部分</span></span><br><span class="line">    <span class="keyword">this</span>.cacheManager,</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(imageUrl != <span class="keyword">null</span>),</span><br><span class="line">        <span class="comment">/// ...</span></span><br><span class="line">        _image = CachedNetworkImageProvider(</span><br><span class="line">          imageUrl,</span><br><span class="line">          headers: httpHeaders,</span><br><span class="line">          cacheManager: cacheManager,</span><br><span class="line">          cacheKey: cacheKey,</span><br><span class="line">          imageRenderMethodForWeb: imageRenderMethodForWeb,</span><br><span class="line">          maxWidth: maxWidthDiskCache,</span><br><span class="line">          maxHeight: maxHeightDiskCache,</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">super</span>(key: key);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> octoPlaceholderBuilder =</span><br><span class="line">        placeholder != <span class="keyword">null</span> ? _octoPlaceholderBuilder : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">var</span> octoProgressIndicatorBuilder =</span><br><span class="line">        progressIndicatorBuilder != <span class="keyword">null</span> ? _octoProgressIndicatorBuilder : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OctoImage(</span><br><span class="line">      image: _image,</span><br><span class="line">      <span class="comment">/// ...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，构造函数初始化了一个本地变量<code>_image</code> 类型是<code>CachedNetworkImageProvider</code>，它继承ImageProvider提供图片加载，看下它的构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 提供网络图片加载Provider并缓存</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedNetworkImageProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">CachedNetworkImageProvider</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// Creates an object that fetches the image at the given URL.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">factory</span> CachedNetworkImageProvider(</span><br><span class="line">    <span class="built_in">String</span> url, &#123;</span><br><span class="line">    <span class="built_in">int</span> maxHeight,</span><br><span class="line">    <span class="built_in">int</span> maxWidth,</span><br><span class="line">    <span class="built_in">String</span> cacheKey,</span><br><span class="line">    <span class="built_in">double</span> scale,</span><br><span class="line">    <span class="meta">@Deprecated</span>(<span class="string">'ErrorListener is deprecated, use listeners on the imagestream'</span>)</span><br><span class="line">        ErrorListener errorListener,</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers,</span><br><span class="line">    BaseCacheManager cacheManager,</span><br><span class="line">    ImageRenderMethodForWeb imageRenderMethodForWeb,</span><br><span class="line">  &#125;) = image_provider.CachedNetworkImageProvider;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 可选cacheManager. 默认使用 DefaultCacheManager()</span></span><br><span class="line">  <span class="comment">/// 当运行在web时,cacheManager没有使用.</span></span><br><span class="line">  BaseCacheManager <span class="keyword">get</span> cacheManager;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 请求url.</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 缓存key</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> cacheKey;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ImageStreamCompleter load(</span><br><span class="line">      CachedNetworkImageProvider key, DecoderCallback decode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的构造函数调用了<code>image_provider.CachedNetworkImageProvider</code>的实例在<code>_image_provider_io.dart</code>中是加载的具体实现类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// IO implementation of the CachedNetworkImageProvider; the ImageProvider to</span></span><br><span class="line"><span class="comment">/// load network images using a cache.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedNetworkImageProvider</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ImageProvider</span>&lt;<span class="title">image_provider</span>.<span class="title">CachedNetworkImageProvider</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">image_provider</span>.<span class="title">CachedNetworkImageProvider</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Creates an ImageProvider which loads an image from the [url], using the [scale].</span></span><br><span class="line">  <span class="comment">/// When the image fails to load [errorListener] is called.</span></span><br><span class="line">  <span class="keyword">const</span> CachedNetworkImageProvider(</span><br><span class="line">    <span class="keyword">this</span>.url, &#123;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(url != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(scale != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">final</span> BaseCacheManager cacheManager;</span><br><span class="line"><span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;CachedNetworkImageProvider&gt; obtainKey(</span><br><span class="line">      ImageConfiguration configuration) &#123;</span><br><span class="line">    <span class="keyword">return</span> SynchronousFuture&lt;CachedNetworkImageProvider&gt;(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 核心方法加载图片入口</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ImageStreamCompleter load(</span><br><span class="line">      image_provider.CachedNetworkImageProvider key, DecoderCallback decode) &#123;</span><br><span class="line">    <span class="keyword">final</span> chunkEvents = StreamController&lt;ImageChunkEvent&gt;();</span><br><span class="line">    <span class="comment">/// 多图加载</span></span><br><span class="line">    <span class="keyword">return</span> MultiImageStreamCompleter(</span><br><span class="line">      codec: _loadAsync(key, chunkEvents, decode),</span><br><span class="line">      chunkEvents: chunkEvents.stream,</span><br><span class="line">      scale: key.scale,</span><br><span class="line">      informationCollector: () <span class="keyword">sync</span>* &#123;</span><br><span class="line">        <span class="keyword">yield</span> DiagnosticsProeperty&lt;ImageProvider&gt;(</span><br><span class="line">          <span class="string">'Image provider: $this \n Image key: $key'</span>,</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          style: DiagnosticsTreeStyle.errorProperty,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的load方法即是图片加载的启动入口，它会在页面可见时被调用</p><p>它返回了一个<code>MultiImageStreamCompleter</code>传入<code>_loadAsync</code>，看下这个方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 异步加载</span></span><br><span class="line">  Stream&lt;ui.Codec&gt; _loadAsync(</span><br><span class="line">    CachedNetworkImageProvider key,</span><br><span class="line">    StreamController&lt;ImageChunkEvent&gt; chunkEvents,</span><br><span class="line">    DecoderCallback decode,</span><br><span class="line">  ) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">assert</span>(key == <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/// 默认缓存管理器</span></span><br><span class="line">      <span class="keyword">var</span> mngr = cacheManager ?? DefaultCacheManager();</span><br><span class="line">      <span class="keyword">assert</span>(</span><br><span class="line">          mngr <span class="keyword">is</span> ImageCacheManager || (maxWidth == <span class="keyword">null</span> &amp;&amp; maxHeight == <span class="keyword">null</span>),</span><br><span class="line">          <span class="string">'To resize the image with a CacheManager the '</span></span><br><span class="line">          <span class="string">'CacheManager needs to be an ImageCacheManager. maxWidth and '</span></span><br><span class="line">          <span class="string">'maxHeight will be ignored when a normal CacheManager is used.'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/// 下载逻辑放在ImageCacheManager，得到下载stream</span></span><br><span class="line">      <span class="keyword">var</span> stream = mngr <span class="keyword">is</span> ImageCacheManager</span><br><span class="line">          ? mngr.getImageFile(key.url,</span><br><span class="line">              maxHeight: maxHeight,</span><br><span class="line">              maxWidth: maxWidth,</span><br><span class="line">              withProgress: <span class="keyword">true</span>,</span><br><span class="line">              headers: headers,</span><br><span class="line">              key: key.cacheKey)</span><br><span class="line">          : mngr.getFileStream(key.url,</span><br><span class="line">              withProgress: <span class="keyword">true</span>, headers: headers, key: key.cacheKey);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> result <span class="keyword">in</span> stream) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">is</span> FileInfo) &#123;</span><br><span class="line">          <span class="keyword">var</span> file = result.file;</span><br><span class="line">          <span class="keyword">var</span> bytes = <span class="keyword">await</span> file.readAsBytes();</span><br><span class="line">          <span class="keyword">var</span> decoded = <span class="keyword">await</span> decode(bytes);</span><br><span class="line">          <span class="comment">/// 下载完成返回结果</span></span><br><span class="line">          <span class="keyword">yield</span> decoded;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">/// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> chunkEvents.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到了默认缓存管理器<code>cacheManager</code>创建的地方，为<code>DefaultCacheManager</code>，那么它如何缓存的呢，后边再分析。</p><p>下载的逻辑也是放在了<code>ImageCacheManager</code>下了，返回结果是一个<code>stream</code>完成多图下载的支持，下载完成通过yield 返回给ui解码最终显示。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">MultiImageStreamCompleter`支持多图加载继承自`ImageStreamCompleter</span><br><span class="line"><span class="comment">/// An ImageStreamCompleter with support for loading multiple images.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiImageStreamCompleter</span> <span class="keyword">extends</span> <span class="title">ImageStreamCompleter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// The constructor to create an MultiImageStreamCompleter. The [codec]</span></span><br><span class="line">  <span class="comment">/// should be a stream with the images that should be shown. The</span></span><br><span class="line">  <span class="comment">/// [chunkEvents] should indicate the [ImageChunkEvent]s of the first image</span></span><br><span class="line">  <span class="comment">/// to show.</span></span><br><span class="line">  MultiImageStreamCompleter(&#123;</span><br><span class="line">    <span class="meta">@required</span> Stream&lt;ui.Codec&gt; codec,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">double</span> scale,</span><br><span class="line">    Stream&lt;ImageChunkEvent&gt; chunkEvents,</span><br><span class="line">    InformationCollector informationCollector,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(codec != <span class="keyword">null</span>),</span><br><span class="line">        _informationCollector = informationCollector,</span><br><span class="line">        _scale = scale &#123;</span><br><span class="line">    <span class="comment">/// 显示逻辑</span></span><br><span class="line">    codec.listen((event) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        _nextImageCodec = event;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _handleCodecReady(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, onError: (<span class="keyword">dynamic</span> error, StackTrace stack) &#123;</span><br><span class="line">      reportError(</span><br><span class="line">        context: ErrorDescription(<span class="string">'resolving an image codec'</span>),</span><br><span class="line">        exception: error,</span><br><span class="line">        stack: stack,</span><br><span class="line">        informationCollector: informationCollector,</span><br><span class="line">        silent: <span class="keyword">true</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 处理解码完成</span></span><br><span class="line">  <span class="keyword">void</span> _handleCodecReady(ui.Codec codec) &#123;</span><br><span class="line">    _codec = codec;</span><br><span class="line">    <span class="keyword">assert</span>(_codec != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">      _decodeNextFrameAndSchedule();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 解码下一帧并绘制</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _decodeNextFrameAndSchedule() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _nextFrame = <span class="keyword">await</span> _codec.getNextFrame();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      reportError(</span><br><span class="line">        context: ErrorDescription(<span class="string">'resolving an image frame'</span>),</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        informationCollector: _informationCollector,</span><br><span class="line">        silent: <span class="keyword">true</span>,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_codec.frameCount == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// ImageStreamCompleter listeners removed while waiting for next frame to</span></span><br><span class="line">      <span class="comment">// be decoded.</span></span><br><span class="line">      <span class="comment">// There's no reason to emit the frame without active listeners.</span></span><br><span class="line">      <span class="keyword">if</span> (!hasListeners) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This is not an animated image, just return it and don't schedule more</span></span><br><span class="line">      <span class="comment">// frames.</span></span><br><span class="line">      _emitFrame(ImageInfo(image: _nextFrame.image, scale: _scale));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _scheduleAppFrame();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了显示逻辑，和最终转化成flutter上帧的处理，<code>_scheduleAppFrame</code>完成发送帧的处理</p><h3 id="下载-amp-缓存"><a href="#下载-amp-缓存" class="headerlink" title="下载&amp;缓存"></a>下载&amp;缓存</h3><p>上边的<code>mngr</code>调用了<code>ImageCacheManager</code>中的<code>getImageFile</code>方法现在就到了<code>flutter_cache_manager</code>这个三方库当中，它是被隐式依赖的，文件是<code>image_cache_manager.dart</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mixin ImageCacheManager on BaseCacheManager &#123;</span><br><span class="line">Stream&lt;FileResponse&gt; getImageFile(</span><br><span class="line">    <span class="built_in">String</span> url, &#123;</span><br><span class="line">    <span class="built_in">String</span> key,</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers,</span><br><span class="line">    <span class="built_in">bool</span> withProgress,</span><br><span class="line">    <span class="built_in">int</span> maxHeight,</span><br><span class="line">    <span class="built_in">int</span> maxWidth,</span><br><span class="line">  &#125;) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxHeight == <span class="keyword">null</span> &amp;&amp; maxWidth == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* getFileStream(url,</span><br><span class="line">          key: key, headers: headers, withProgress: withProgress);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileStream`方法实现在子类`cache_manager.dart`文件中的`CacheManager</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheManager</span> <span class="keyword">implements</span> <span class="title">BaseCacheManager</span> </span>&#123;</span><br><span class="line"> <span class="comment">/// 缓存管理</span></span><br><span class="line">  CacheStore _store;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the underlying store helper</span></span><br><span class="line">  CacheStore <span class="keyword">get</span> store =&gt; _store;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 下载管理</span></span><br><span class="line">  WebHelper _webHelper;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Get the underlying web helper</span></span><br><span class="line">  WebHelper <span class="keyword">get</span> webHelper =&gt; _webHelper;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 从下载或者缓存读取file返回stream</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;FileResponse&gt; getFileStream(<span class="built_in">String</span> url,</span><br><span class="line">      &#123;<span class="built_in">String</span> key, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers, <span class="built_in">bool</span> withProgress&#125;) &#123;</span><br><span class="line">    key ??= url;</span><br><span class="line">    <span class="keyword">final</span> streamController = StreamController&lt;FileResponse&gt;();</span><br><span class="line">    _pushFileToStream(</span><br><span class="line">        streamController, url, key, headers, withProgress ?? <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> streamController.stream;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _pushFileToStream(StreamController streamController, <span class="built_in">String</span> url,</span><br><span class="line">      <span class="built_in">String</span> key, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers, <span class="built_in">bool</span> withProgress) <span class="keyword">async</span> &#123;</span><br><span class="line">    key ??= url;</span><br><span class="line">    FileInfo cacheFile;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/// 缓存判断</span></span><br><span class="line">      cacheFile = <span class="keyword">await</span> getFileFromCache(key);</span><br><span class="line">      <span class="keyword">if</span> (cacheFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/// 有缓存直接返回</span></span><br><span class="line">        streamController.add(cacheFile);</span><br><span class="line">        withProgress = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">print</span>(</span><br><span class="line">          <span class="string">'CacheManager: Failed to load cached file for $url with error:\n$e'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 没有缓存或者过期下载</span></span><br><span class="line">    <span class="keyword">if</span> (cacheFile == <span class="keyword">null</span> || cacheFile.validTill.isBefore(<span class="built_in">DateTime</span>.now())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> response</span><br><span class="line">            <span class="keyword">in</span> _webHelper.downloadFile(url, key: key, authHeaders: headers)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (response <span class="keyword">is</span> DownloadProgress &amp;&amp; withProgress) &#123;</span><br><span class="line">            streamController.add(response);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (response <span class="keyword">is</span> FileInfo) &#123;</span><br><span class="line">            streamController.add(response);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(() &#123;</span><br><span class="line">          <span class="built_in">print</span>(</span><br><span class="line">              <span class="string">'CacheManager: Failed to download file from $url with error:\n$e'</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;());</span><br><span class="line">        <span class="keyword">if</span> (cacheFile == <span class="keyword">null</span> &amp;&amp; streamController.hasListener) &#123;</span><br><span class="line">          streamController.addError(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unawaited(streamController.close());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存判断逻辑在<code>CacheStore</code>提供两级缓存</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheStore</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Duration</span> cleanupRunMinInterval = <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">10</span>);</span><br><span class="line"><span class="comment">/// 未下载完成缓存</span></span><br><span class="line">  <span class="keyword">final</span> _futureCache = &lt;<span class="built_in">String</span>, Future&lt;CacheObject&gt;&gt;&#123;&#125;;</span><br><span class="line">  <span class="comment">/// 已下载完缓存</span></span><br><span class="line">  <span class="keyword">final</span> _memCache = &lt;<span class="built_in">String</span>, CacheObject&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">  Future&lt;FileInfo&gt; getFile(<span class="built_in">String</span> key, &#123;<span class="built_in">bool</span> ignoreMemCache = <span class="keyword">false</span>&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> cacheObject =</span><br><span class="line">        <span class="keyword">await</span> retrieveCacheData(key, ignoreMemCache: ignoreMemCache);</span><br><span class="line">    <span class="keyword">if</span> (cacheObject == <span class="keyword">null</span> || cacheObject.relativePath == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> file = <span class="keyword">await</span> fileSystem.createFile(cacheObject.relativePath);</span><br><span class="line">    <span class="keyword">return</span> FileInfo(</span><br><span class="line">      file,</span><br><span class="line">      FileSource.Cache,</span><br><span class="line">      cacheObject.validTill,</span><br><span class="line">      cacheObject.url,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; putFile(CacheObject cacheObject) <span class="keyword">async</span> &#123;</span><br><span class="line">    _memCache[cacheObject.key] = cacheObject;</span><br><span class="line">    <span class="keyword">await</span> _updateCacheDataInDatabase(cacheObject);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;CacheObject&gt; retrieveCacheData(<span class="built_in">String</span> key,</span><br><span class="line">      &#123;<span class="built_in">bool</span> ignoreMemCache = <span class="keyword">false</span>&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">/// 判断是否已缓存过</span></span><br><span class="line">    <span class="keyword">if</span> (!ignoreMemCache &amp;&amp; _memCache.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">await</span> _fileExists(_memCache[key])) &#123;</span><br><span class="line">        <span class="keyword">return</span> _memCache[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 未缓存的 已加入futureCache中的key直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!_futureCache.containsKey(key)) &#123;</span><br><span class="line">      <span class="keyword">final</span> completer = Completer&lt;CacheObject&gt;();</span><br><span class="line">      <span class="comment">/// 未加入的添加到futureCache</span></span><br><span class="line">      unawaited(_getCacheDataFromDatabase(key).then((cacheObject) <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheObject != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">await</span> _fileExists(cacheObject)) &#123;</span><br><span class="line">          <span class="keyword">final</span> provider = <span class="keyword">await</span> _cacheInfoRepository;</span><br><span class="line">          <span class="keyword">await</span> provider.delete(cacheObject.id);</span><br><span class="line">          cacheObject = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _memCache[key] = cacheObject;</span><br><span class="line">        completer.complete(cacheObject);</span><br><span class="line">        unawaited(_futureCache.remove(key));</span><br><span class="line">      &#125;));</span><br><span class="line">      _futureCache[key] = completer.future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _futureCache[key];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/// ...</span></span><br><span class="line">  <span class="comment">/// 更新到数据库</span></span><br><span class="line">  Future&lt;<span class="keyword">dynamic</span>&gt; _updateCacheDataInDatabase(CacheObject cacheObject) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> provider = <span class="keyword">await</span> _cacheInfoRepository;</span><br><span class="line">    <span class="keyword">return</span> provider.updateOrInsert(cacheObject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_cacheInfoRepository</code>缓存仓库是<code>CacheObjectProvider</code>使用的数据库缓存对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheObjectProvider</span> <span class="keyword">extends</span> <span class="title">CacheInfoRepository</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">CacheInfoRepositoryHelperMethods</span> </span>&#123;</span><br><span class="line">  Database db;</span><br><span class="line">  <span class="built_in">String</span> _path;</span><br><span class="line">  <span class="built_in">String</span> databaseName;</span><br><span class="line"></span><br><span class="line">  CacheObjectProvider(&#123;<span class="built_in">String</span> path, <span class="keyword">this</span>.databaseName&#125;) : _path = path;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 打开</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; open() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!shouldOpenOnNewConnection()) &#123;</span><br><span class="line">      <span class="keyword">return</span> openCompleter.future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> path = <span class="keyword">await</span> _getPath();</span><br><span class="line">    <span class="keyword">await</span> File(path).parent.create(recursive: <span class="keyword">true</span>);</span><br><span class="line">    db = <span class="keyword">await</span> openDatabase(path, version: <span class="number">3</span>,</span><br><span class="line">        onCreate: (Database db, <span class="built_in">int</span> version) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> db.execute(<span class="string">'''</span></span><br><span class="line"><span class="string">      create table $_tableCacheObject ( </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnId&#125;</span> integer primary key, </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnUrl&#125;</span> text, </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnKey&#125;</span> text, </span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnPath&#125;</span> text,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnETag&#125;</span> text,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnValidTill&#125;</span> integer,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnTouched&#125;</span> integer,</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;CacheObject.columnLength&#125;</span> integer</span></span><br><span class="line"><span class="string">        );</span></span><br><span class="line"><span class="string">        create unique index $_tableCacheObject<span class="subst">$&#123;CacheObject.columnKey&#125;</span> </span></span><br><span class="line"><span class="string">        ON $_tableCacheObject (<span class="subst">$&#123;CacheObject.columnKey&#125;</span>);</span></span><br><span class="line"><span class="string">      '''</span>);</span><br><span class="line">    &#125;, onUpgrade: (Database db, <span class="built_in">int</span> oldVersion, <span class="built_in">int</span> newVersion) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="comment">/// ...</span></span><br><span class="line">    <span class="keyword">return</span> opened();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">dynamic</span>&gt; updateOrInsert(CacheObject cacheObject) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cacheObject.id == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> insert(cacheObject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> update(cacheObject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;CacheObject&gt; insert(CacheObject cacheObject,</span><br><span class="line">      &#123;<span class="built_in">bool</span> setTouchedToNow = <span class="keyword">true</span>&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="keyword">await</span> db.insert(</span><br><span class="line">      _tableCacheObject,</span><br><span class="line">      cacheObject.toMap(setTouchedToNow: setTouchedToNow),</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> cacheObject.copyWith(id: id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;CacheObject&gt; <span class="keyword">get</span>(<span class="built_in">String</span> key) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Map</span>&gt; maps = <span class="keyword">await</span> db.query(_tableCacheObject,</span><br><span class="line">        columns: <span class="keyword">null</span>, where: <span class="string">'<span class="subst">$&#123;CacheObject.columnKey&#125;</span> = ?'</span>, whereArgs: [key]);</span><br><span class="line">    <span class="keyword">if</span> (maps.isNotEmpty) &#123;</span><br><span class="line">      <span class="keyword">return</span> CacheObject.fromMap(maps.first.cast&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="built_in">int</span>&gt; delete(<span class="built_in">int</span> id) &#123;</span><br><span class="line">    <span class="keyword">return</span> db.delete(_tableCacheObject,</span><br><span class="line">        where: <span class="string">'<span class="subst">$&#123;CacheObject.columnId&#125;</span> = ?'</span>, whereArgs: [id]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见数据库缓存的是<code>CacheObject</code>对象，保存了url、key、relativePath等信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnId = <span class="string">'_id'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnUrl = <span class="string">'url'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnKey = <span class="string">'key'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnPath = <span class="string">'relativePath'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnETag = <span class="string">'eTag'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnValidTill = <span class="string">'validTill'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnTouched = <span class="string">'touched'</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> columnLength = <span class="string">'length'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有缓存下调用了<code>_webHelper.downloadFile</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebHelper</span> </span>&#123;</span><br><span class="line">  WebHelper(<span class="keyword">this</span>._store, FileService fileFetcher)</span><br><span class="line">      : _memCache = &#123;&#125;,</span><br><span class="line">        fileFetcher = fileFetcher ?? HttpFileService();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> CacheStore _store;</span><br><span class="line">  <span class="meta">@visibleForTesting</span></span><br><span class="line">  <span class="keyword">final</span> FileService fileFetcher;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, BehaviorSubject&lt;FileResponse&gt;&gt; _memCache;</span><br><span class="line">  <span class="keyword">final</span> Queue&lt;QueueItem&gt; _queue = Queue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">///Download the file from the url</span></span><br><span class="line">  Stream&lt;FileResponse&gt; downloadFile(<span class="built_in">String</span> url,</span><br><span class="line">      &#123;<span class="built_in">String</span> key,</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; authHeaders,</span><br><span class="line">      <span class="built_in">bool</span> ignoreMemCache = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    key ??= url;</span><br><span class="line">    <span class="keyword">if</span> (!_memCache.containsKey(key) || ignoreMemCache) &#123;</span><br><span class="line">      <span class="keyword">var</span> subject = BehaviorSubject&lt;FileResponse&gt;();</span><br><span class="line">      _memCache[key] = subject;</span><br><span class="line">      <span class="comment">/// 下载或者加入队列</span></span><br><span class="line">      unawaited(_downloadOrAddToQueue(url, key, authHeaders));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _memCache[key].stream;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _downloadOrAddToQueue(</span><br><span class="line">    <span class="built_in">String</span> url,</span><br><span class="line">    <span class="built_in">String</span> key,</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; authHeaders,</span><br><span class="line">  ) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">//如果太多请求被执行，加入队列等待</span></span><br><span class="line">    <span class="keyword">if</span> (concurrentCalls &gt;= fileFetcher.concurrentFetches) &#123;</span><br><span class="line">      _queue.add(QueueItem(url, key, authHeaders));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    concurrentCalls++;</span><br><span class="line">    <span class="keyword">var</span> subject = _memCache[key];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> result</span><br><span class="line">          <span class="keyword">in</span> _updateFile(url, key, authHeaders: authHeaders)) &#123;</span><br><span class="line">        subject.add(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stackTrace) &#123;</span><br><span class="line">      subject.addError(e, stackTrace);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      concurrentCalls--;</span><br><span class="line">      <span class="keyword">await</span> subject.close();</span><br><span class="line">      _memCache.remove(key);</span><br><span class="line">      _checkQueue();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">///下载资源</span></span><br><span class="line">  Stream&lt;FileResponse&gt; _updateFile(<span class="built_in">String</span> url, <span class="built_in">String</span> key,</span><br><span class="line">      &#123;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; authHeaders&#125;) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">var</span> cacheObject = <span class="keyword">await</span> _store.retrieveCacheData(key);</span><br><span class="line">    cacheObject = cacheObject == <span class="keyword">null</span></span><br><span class="line">        ? CacheObject(url, key: key)</span><br><span class="line">        : cacheObject.copyWith(url: url);</span><br><span class="line">    <span class="comment">/// 请求得到response</span></span><br><span class="line">    <span class="keyword">final</span> response = <span class="keyword">await</span> _download(cacheObject, authHeaders);</span><br><span class="line">    <span class="keyword">yield</span>* _manageResponse(cacheObject, response);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  Stream&lt;FileResponse&gt; _manageResponse(</span><br><span class="line">      CacheObject cacheObject, FileServiceResponse response) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">    <span class="keyword">if</span> (statusCodesNewFile.contains(response.statusCode)) &#123;</span><br><span class="line">      <span class="built_in">int</span> savedBytes;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> progress <span class="keyword">in</span> _saveFile(newCacheObject, response)) &#123;</span><br><span class="line">        savedBytes = progress;</span><br><span class="line">        <span class="keyword">yield</span> DownloadProgress(</span><br><span class="line">            cacheObject.url, response.contentLength, progress);</span><br><span class="line">      &#125;</span><br><span class="line">      newCacheObject = newCacheObject.copyWith(length: savedBytes);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/// 加入缓存</span></span><br><span class="line">    unawaited(_store.putFile(newCacheObject).then((_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newCacheObject.relativePath != oldCacheObject.relativePath) &#123;</span><br><span class="line">        _removeOldFile(oldCacheObject.relativePath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> file = <span class="keyword">await</span> _store.fileSystem.createFile(</span><br><span class="line">      newCacheObject.relativePath,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">yield</span> FileInfo(</span><br><span class="line">      file,</span><br><span class="line">      FileSource.Online,</span><br><span class="line">      newCacheObject.validTill,</span><br><span class="line">      newCacheObject.url,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; _saveFile(CacheObject cacheObject, FileServiceResponse response) &#123;</span><br><span class="line">    <span class="keyword">var</span> receivedBytesResultController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    unawaited(_saveFileAndPostUpdates(</span><br><span class="line">      receivedBytesResultController,</span><br><span class="line">      cacheObject,</span><br><span class="line">      response,</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> receivedBytesResultController.stream;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Future _saveFileAndPostUpdates(</span><br><span class="line">      StreamController&lt;<span class="built_in">int</span>&gt; receivedBytesResultController,</span><br><span class="line">      CacheObject cacheObject,</span><br><span class="line">      FileServiceResponse response) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">/// 根据路径创建file</span></span><br><span class="line">    <span class="keyword">final</span> file = <span class="keyword">await</span> _store.fileSystem.createFile(cacheObject.relativePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> receivedBytes = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/// 写文件</span></span><br><span class="line">      <span class="keyword">final</span> sink = file.openWrite();</span><br><span class="line">      <span class="keyword">await</span> response.content.map((s) &#123;</span><br><span class="line">        receivedBytes += s.length;</span><br><span class="line">        receivedBytesResultController.add(receivedBytes);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">      &#125;).pipe(sink);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stacktrace) &#123;</span><br><span class="line">      receivedBytesResultController.addError(e, stacktrace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> receivedBytesResultController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>cached_network_image</code>图片加载流程依赖<code>ImageProvider</code>，缓存和下载逻辑放在另一个库<code>flutter_cache_manager</code>下载文件在<code>WebHelper</code>中提供队列管理，依赖传入<code>FileService</code>做具体获取文件方便扩展默认实现<code>HttpFileService</code>，下载完成后路径保存在<code>CacheObject</code>保存在<code>sqflite</code>数据库</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;p&gt;组件&lt;a href=&quot;https://link.juejin.cn?target=https%3A%2F%2Fpub.dev%2Fpackages%2Fcached_network_image&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CachedNetworkImage&lt;/a&gt;可以支持直接使用或者通过&lt;code&gt;ImageProvider&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引入依赖&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;dependencies:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  cached_network_image:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;^3.1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;执行&lt;code&gt;flutter pub get&lt;/code&gt;，项目中使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Import it&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;package:cached_network_image/cached_network_image.dart&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;添加占位图&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CachedNetworkImage(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        imageUrl: &lt;span class=&quot;string&quot;&gt;&quot;http://via.placeholder.com/350x150&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        placeholder: (context, url) =&amp;gt; CircularProgressIndicator(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errorWidget: (context, url, error) =&amp;gt; Icon(Icons.error),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ),&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;进度条展示&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CachedNetworkImage(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        imageUrl: &lt;span class=&quot;string&quot;&gt;&quot;http://via.placeholder.com/350x150&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        progressIndicatorBuilder: (context, url, downloadProgress) =&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                CircularProgressIndicator(value: downloadProgress.progress),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        errorWidget: (context, url, error) =&amp;gt; Icon(Icons.error),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ),&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/categories/Android/Flutter/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>北京环球影城游玩攻略</title>
    <link href="http://yoursite.com/posts/cf2918cf.html"/>
    <id>http://yoursite.com/posts/cf2918cf.html</id>
    <published>2021-09-23T02:13:35.000Z</published>
    <updated>2022-07-26T08:05:58.376Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s3.bmp.ovh/imgs/2021/09/0ebc0f368298bf55.jpeg" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s3.bmp.ovh/imgs/2021/09/0ebc0f368298bf55.jpeg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔记" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔记" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
