<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AI生成BGM音乐调研]]></title>
    <url>%2Fposts%2Ff928d1c8.html</url>
    <content type="text"><![CDATA[AI生成BGM BGM猫 • 可以通过BGM猫平台 http://bgmcat.com/home 生成AI音乐 • 使用描述 : 我走在田间的马路上,听着小歌曲,跳着走 • 提示 : 默认生成的bgm是没有商用版权的,可以通过购买专业创作者会员或单曲购买商业用途,目前感觉没必要购买 Mubert • 可以通过mubert平台 https://mubert.com/render?authBy=google ⽣成AI⾳乐 • 使⽤描述 : I was walking on the road in the field, listening to little songs, dancing (规定只能使⽤英⽂) BGM去除⼈声Spleeter • 通过 https://makenweb.com/SpleeterGUI 可以下载免费的Windows版本(2022-10-12),MAC⽆对应软件。 • 通过 https://bbs.huaweicloud.com/forum/thread-117164-1-1.html 链接教程(2021-03-30有点过时), 调⽤的是Spleeter库,调⽤的流程和Windows版软件命令⼀致,⽆须搭建使⽤了. Moises 可以通过 https://studio.moises.ai/library/ 实现⾳轨分离,下载去除⼈声后的⽂件,预期效果没问题 (缺点:免费版5次/单⽉/单账号) vocalremover • 通过 https://vocalremover.org/zh/ 可以分离人声和音乐,界面如下图 • 优点 : 使用成本低,不需要本地安装各种python库,直接在线上传/下载音频文件 免费次数无限制,没有必须开通包月包年或者单次付费的限制 uvr5 • 最新方式uvr5, github开源库 https://github.com/A/Anjok07/ultimatevocalremovergui • 如果vocalremover不可用时, 可用这种方案, 免费。 • 优点: 1 : 稳定性。不再受网页影响, 原去除人声方案vocalremover上午频繁出现与vpn冲突,短暂性无法使用,现已恢复 2 : 简捷性。使用uvr5转换,可以批量选择多个本地文件,无须在网页中大量上传原音频/下载新音频的传输过程了 3 : 高效性。使用本地软件执行转换, 依靠本地GPU, 执行效率更快 • 使用说明 : 1 为输入目录(可批量) 2为输出目录 3 为输出文件格式 4 为输出计算模型 5 为使用GPU只导出去除人声音频 6 为开始转换 7 为转换完成 结论 • 使用 bgm猫 http://bgmcat.com/home + vocalremover https://vocalremover.org/zh/ 的方式,可以得到无人声水印的AI音频,免费且无次数限制。 • 以60s时长音频左右,走完一套流程4、5分钟,即可得到无水印AI音频 • 生成AI音频的方式包括但不限于bgm猫, 去除水印方式vocalremover可以免费无限次使用。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter Web加载慢问题优化和解决方案]]></title>
    <url>%2Fposts%2Feea7bb08.html</url>
    <content type="text"><![CDATA[优化重点项将以下资源本地化，打包到项目中 canvaskit.js和canvaskit.wasm KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf css2?family=Noto_Sans+SC ps：最初canvaskit资源上传到阿里云，采用国内镜像资源加载。这次为了保险起见，也放入到本地。好处：只要服务器正常能访问，这些资源文件就能够正常加载成功，最大程度上规避页面加载异常的风险！最终项目中添加一些配置文件，如下图： index.html文件中更改canvaskit加载方式为本地 下载相关下载canvaskit.wasm和canvaskit.jshttps://unpkg.com/canvaskit-wasm@0.35.0/bin/canvaskit.jshttps://unpkg.com/canvaskit-wasm@0.35.0/bin/canvaskit.wasm下载地址方式获取：F12 -&gt;Network 下载KFOmCnqEu92Fr1Me5WZLCzYlKw.ttfhttps://fonts.gstatic.com/s/roboto/v20/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf 下载字体CSShttps://fonts.googleapis.com/css2?family=Noto+Sans+SC下载的样式保存在本地，命名为 localfonts.css更改CSS中引用的woff2字体文件，更改为本地路径 字体文件批量下载1curl -O https://fonts.gstatic.com/s/notosanssc/v26/k3kXo84MPvpLmixcA63oeALhLIiP-Q-87KaAaH7rzeAODp22mF0qmF4CSjmPC6A0Rg5g1igg1w.[1-120].woff2 下载的文件装入到woff2文件夹放在 web/canvaskit 路径下 配置相关执行flutter build web打包命令后生成build/web文件由于打包后的文件资源引用还是url链接形式，故需要修改build/web目录下的main.dart.js 替换远端路径为本地路径将https://fonts.gstatic.com/s/roboto/v20/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf替换成canvaskit/KFOmCnqEu92Fr1Me5WZLCzYlKw.ttf 将https://fonts.googleapis.com/css2?family=&quot;+A.bF(o,&quot; &quot;,&quot;+&quot;)替换成canvaskit/localfonts.css 脚本自动打包&amp;替换资源引用路径flutter_build.sh脚本自动打包以及打完包后修改build/web目录下的main.dart.js中资源引用路径替换成本地路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#!/bin/zshBLACK="\033[30m"RED="\033[31m"GREEN="\033[32m"YELLOW="\033[33m"BLUE="\033[34m"PINK="\033[35m"CYAN="\033[36m"WHITE="\033[37m"NORMAL="\033[0;39m"END="\033[0m"# 指定文件路径filepath="./build/web/main.dart.js"function chooseBuildTypeFunc &#123; echo echo "[$RED 1 $END]$CYAN 构建release包$END" echo "[$CYAN q $END] 退出" echo echo "$GREEN请输入对应的数字或q退出:$END" read param echo # 检测空格是否存在 if [[ -z $param ]]; then echo "$RED输入有误,请重新输入$END" chooseCommitTypeFunc; return fi if [ $param = "1" ]; then buildFunc; elif [ $param = "q" ]; then echo else echo "$RED输入有误,请重新输入$END" echo chooseCommitTypeFunc; fi&#125;function buildFunc &#123; # 开始打包 flutter build web --web-renderer canvaskit --dart-define=BROWSER_IMAGE_DECODING_ENABLED=false --release # 结束打包 # 定义 URL old_url="https:\/\/fonts.gstatic.com\/s\/roboto\/v20" new_url="canvaskit" # 使用 sed 命令查找并替换 URL sed -i '' "s~$old_url~$new_url~g" $filepath # 定义字符串 old_string="https:\/\/fonts.googleapis.com\/css2?family=" new_string="canvaskit\/localfonts.css" # 使用 sed 命令查找并替换字符串 # 我们使用 "|" 作为定界符，而不是常用的 "/" sed -i '' "s|$old_string|$new_string|g" $filepath # 定义所有可能的字母 LETTERS=(&#123;a..z&#125; &#123;A..Z&#125;) # 使用 for 循环遍历所有字母 for letter in "$&#123;LETTERS[@]&#125;"; do # 使用 grep 来匹配字符串 if grep -Fq "+A.b$&#123;letter&#125;(o,\" \",\"+\")" $filepath; then # 定义字符串 old_string="+A.b$letter(o,\" \",\"+\")" new_string="" # 使用 perl 的 -i 选项进行原地编辑（直接修改文件） # 使用 \Q...\E 将目标字符串视为文字而不是正则表达式 perl -i -pe 's/\Q'$old_string'\E/'$new_string'/g' $filepath break # 停止循环，因为我们已经找到了匹配的字符串 fi done echo "$CYAN============================ SUCCESS ============================$END"&#125;chooseBuildTypeFunc;]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter状态管理Provider和Get分析]]></title>
    <url>%2Fposts%2F7ff52b5f.html</url>
    <content type="text"><![CDATA[文/ Nayuta，CFUG 社区 状态管理一直是 Flutter 开发中一个火热的话题。谈到状态管理框架，社区也有诸如有以 Get、Provider 为代表的多种方案，它们有各自的优缺点。 面对这么多的选择，你可能会想：「我需要使用状态管理么？哪种框架更适合我？」 本文将从作者的实际开发经验出发，分析状态管理解决的问题以及思路，希望能帮助你做出选择。 为什么需要状态管理？首先，为什么需要状态管理？ 根据笔者的经验，这是因为 Flutter 基于 声明式 构建 UI ， 使用状态管理的目的之一就是解决「声明式」开发带来的问题。 「声明式」开发是一种区别于传原生的方式，所以我们没有在原生开发中听到过状态管理，那如何理解「声明式」开发呢？ 「声明式」VS「命令式」分析以最经典的的计数器例子分析： 如上图所示：点击右下角按钮，显示的文本数字加一。 Android 中可以这么实现：当右下角按钮点中时， 拿到 TextView 的对象，手动设置其展示的文本。 实现代码如下： 1234567891011121314// 一、定义展示的内容private int mCount =0; // 二、中间展示数字的控件 TextViewprivate TextView mTvCount; // 三、关联 TextView 与 xml 中的组件mTvCount = findViewById(R.id.tv_count) // 四、点击按钮控制组件更新private void increase( )&#123; mCount++; mTvCounter.setText(mCount.toString()); &#125; 而在 Flutter 中，我们只需要使变量增加之后调用 setState((){}) 即可。setState 会刷新整个页面，使得中间展示的值进行变更。 12345678910// 一、声明变量int _counter =0; // 二、展示变量 Text('$_counter')// 三、变量增加，更新界面setState(() &#123; _counter++; &#125;); 可以发现，Flutter 中只对 _counter 属性进行了修改，并没有对 Text 组件进行任何的操作，整个界面随着状态的改变而改变。 所以在 Flutter 中有这么一种说法: UI = f(state): 上面的例子中，状态 (state) 就是 _counter 的值，调用 setState 驱动 f build 方法生成新的 UI。 那么，声明式有哪些优势，并带来了哪些问题呢？ 优势: 让开发者摆脱组件的繁琐控制，聚焦于状态处理 习惯 Flutter 开发之后，回到原生平台开发，你会发现当多个组件之间相互关联时，对于 View 的控制非常麻烦。 而在 Flutter 中我们只需要处理好状态即可 (复杂度转移到了状态 -&gt; UI 的映射，也就是 Widget 的构建)。包括 Jetpack Compose、Swift 等技术的最新发展，也是在朝着「声明式」的方向演进。 声明式开发带来的问题 没有使用状态管理，直接「声明式」开发的时候，遇到的问题总结有三个: 逻辑和页面 UI 耦合，导致无法复用/单元测试、修改混乱等 难以跨组件 (跨页面) 访问数据 无法轻松的控制刷新范围 (页面 setState 的变化会导致全局页面的变化) 接下来，我先带领大家逐个了解这些问题，下一章向大家详细描述状态管理框架如何解决这些问题。 1) 逻辑和页面 UI 耦合，导致无法复用/单元测试、修改混乱等 一开始业务不复杂的时候，所有的代码都直接写到 widget 中，随着业务迭代， 文件越来越大，其他开发者很难直观地明白里面的业务逻辑。 并且一些通用逻辑，例如网络请求状态的处理、分页等，在不同的页面来回粘贴。 这个问题在原生上同样存在，后面也衍生了诸如 MVP 设计模式的思路去解决。 2) 难以跨组件 (跨页面) 访问数据 第二点在于跨组件交互，比如在 Widget 结构中， 一个子组件想要展示父组件中的 name 字段， 可能需要层层进行传递。 又或者是要在两个页面之间共享筛选数据， 并没有一个很优雅的机制去解决这种跨页面的数据访问。 3) 无法轻松的控制刷新范围 (页面 setState 的变化会导致全局页面的变化) 最后一个问题也是上面提到的优点，很多场景我们只是部分状态的修改，例如按钮的颜色。 但是整个页面的 setState 会使得其他不需要变化的地方也进行重建， 带来不必要的开销。 Provider、Get 状态管理框架设计分析Flutter 中状态管理框架的核心在于这三个问题的解决思路， 下面一起看看 Provider、Get 是如何解决的： 解决逻辑和页面 UI 耦合问题传统的原生开发同样存在这个问题，Activity 文件也可能随着迭代变得难以维护， 这个问题可以通过 MVP 模式进行解耦。 简单来说就是将 View 中的逻辑代码抽离到 Presenter 层， View 只负责视图的构建。 这也是 Flutter 中几乎所有状态管理框架的解决思路， 上图的 Presenter 你可以认为是 Get 中的 GetController、 Provider 中的 ChangeNotifier 或者 Bloc 中的 Bloc。 值得一提的是，具体做法上 Flutter 和原生 MVP 框架有所不同。 我们知道在经典 MVP 模式中， 一般 View 和 Presenter 以接口定义自身行为 (action)， 相互持有接口进行调用 。 但 Flutter 中不太适合这么做， 从 Presenter → View 关系上 View 在 Flutter 中对应 Widget， 但在 Flutter 中 Widget 只是用户声明 UI 的配置， 直接控制 Widget 实例并不是好的做法。 而在从 View → Presenter 的关系上， Widget 可以确实可以直接持有 Presenter， 但是这样又会带来难以数据通信的问题。 这一点不同状态管理框架的解决思路不一样，从实现上他们可以分为两大类： 通过 Flutter 树机制 解决，例如 Provider； 通过 依赖注入，例如 Get。 1) 通过 Flutter 树机制处理 V → P 的获取 1234567891011121314151617abstract class Element implements BuildContext &#123; /// 当前 Element 的父节点 Element? _parent; &#125;abstract class BuildContext &#123; /// 查找父节点中的T类型的State T findAncestorState0fType&lt;T extends State&gt;( ); /// 遍历子元素的element对象 void visitChildElements(ElementVisitor visitor); /// 查找父节点中的T类型的 InheritedWidget 例如 MediaQuery 等 T dependOnInheritedWidget0fExactType&lt;T extends InheritedWidget&gt;(&#123; Object aspect &#125;); ……&#125; Element 实现了父类 BuildContext 中操作树结构的方法 我们知道 Flutter 中存在三棵树，Widget、Element 和 RenderObject。 所谓的 Widget 树其实只是我们描述组件嵌套关系的一种说法，是一种虚拟的结构。 但 Element 和 RenderObject 在运行时实际存在， 可以看到 Element 组件中包含了 _parent 属性，存放其父节点。 而它实现了 BuildContext 接口，包含了诸多对于树结构操作的方法， 例如 findAncestorStateOfType，向上查找父节点； visitChildElements 遍历子节点。 在一开始的例子中，我们可以通过 context.findAncestorStateOfType 一层一层地向上查找到需要的 Element 对象， 获取 Widget 或者 State 后即可取出需要的变量。 provider 也是借助了这样的机制，完成了 View -&gt; Presenter 的获取。 通过 Provider.of 获取顶层 Provider 组件中的 Present 对象。 显然，所有 Provider 以下的 Widget 节点， 都可以通过自身的 context 访问到 Provider 中的 Presenter， 很好地解决了跨组件的通信问题。 2) 通过依赖注入的方式解决 V → P 树机制很不错，但依赖于 context，这一点有时很让人抓狂。 我们知道 Dart 是一种单线程的模型， 所以不存在多线程下对于对象访问的竞态问题。 基于此 Get 借助一个全局单例的 Map 存储对象。 通过依赖注入的方式，实现了对 Presenter 层的获取。 这样在任意的类中都可以获取到 Presenter。 这个 Map 对应的 key 是 runtimeType + tag， 其中 tag 是可选参数，而 value 对应 Object， 也就是说我们可以存入任何类型的对象，并且在任意位置获取。 解决难以跨组件 (跨页面) 访问数据的问题这个问题其实和上一部分的思考基本类似，所以我们可以总结一下两种方案特点： Provider 依赖树机制，必须基于 context 提供了子组件访问上层的能力 Get 全局单例，任意位置可以存取 存在类型重复，内存回收问题 解决高层级 setState 引起不必要刷新的问题最后就是我们提到的高层级 setState 引起不必要刷新的问题， Flutter 通过采用观察者模式解决，其关键在于两步： 观察者去订阅被观察的对象； 被观察的对象通知观察者。 系统也提供了 ValueNotifier 等组件的实现： 123456789101112/// 声明可能变化的数据ValueNotifier&lt;int&gt; _statusNotifier = ValueNotifier(0); ValueListenableBuilder&lt;int&gt;( // 建立与 _statusNotifier 的绑定关系 valueListenable: _statusNotifier, builder: (c, data, _) &#123; return Text('$data'); &#125;)///数据变化驱动 ValueListenableBuilder 局部刷新 _statusNotifier.value += 1; 了解到最基础的观察者模式后，看看不同框架中提供的组件： 比如 Provider 中提供了 ChangeNotifierProvider: 1234567891011121314151617181920212223class Counter extend ChangeNotifier &#123; int count = 0; /// 调用此方法更新所有观察节点 void increment() &#123; count++; notifyListeners(); &#125;&#125;void main() &#123; runApp( ChangeNotifierProvider( /// 返回一个实现 ChangeNotifier 接口的对象 create: (_) =&gt; Counter(), child: const MyApp( ), ), ); &#125;/// 子节点通过 Consumer 获取 Counter 对象 Consumer&lt;Counter&gt;( builder:(_, counter, _) =&gt; Text(counter.count.toString()) 还是之前计数器的例子，这里 Counter 继承了 ChangeNotifier 通过顶层的 Provider 进行存储。 子节点通过 Consumer 即可获取实例， 调用了 increment 方法之后，只有对应的 Text 组件进行变化。 同样的功能，在 Get 中， 只需要提前调用 Get.put 方法存储 Counter 对象， 为 GetBuilder 组件指定 Counter 作为泛型。 因为 Get 基于单例，所以 GetBuilder 可以直接通过泛型获取到存入的对象， 并在 builder 方法中暴露。这样 Counter 便与组件建立了监听关系， 之后 Counter 的变动，只会驱动以它作为泛型的 GetBuilder 组件更新。 123456789101112131415class Counter extends GetxController &#123; int count = 0; void increase() &#123; count++; update(); &#125;&#125;/// 提前进行存储final counter = Get.put(Counter( )); /// 直接通过泛型获取存储好的实例GetBuilder&lt;Counter&gt;( builder: (Counter counter) =&gt; Text('$&#123;counter.count&#125;') ); 实践中的常见问题在使用这些框架过程中，可能会遇到以下的问题： Provider 中 context 层级过高123456789101112131415class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Provider( create: (_) =&gt; const Count(), child: MaterialApp( home: Scaffold( body: Center(child: Text('$&#123;Provider.of&lt;Counter&gt;(context).count&#125;')), ), ), ); &#125;&#125; 如代码所示，当我们直接将 Provider 与组件嵌套于同一层级时， 这时代码中的 Provider.of(context) 运行时抛出 ProviderNotFoundException。 因为此处我们使用的 context 来自于 MyApp， 但 Provider 的 element 节点位于 MyApp 的下方， 所以 Provider.of(context) 无法获取到 Provider 节点。 这个问题可以有两种改法，如下方代码所示： 改法 1: 通过嵌套 Builder 组件，使用子节点的 context 访问: 12345678910111213141516171819class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Provider( create: (_) =&gt; const Count(), child: MaterialApp( home: Scaffold( body: Center( child: Builder(builder: (builderContext) &#123; return Text('$&#123;Provider.of&lt;Counter&gt;(builderContext).count&#125;'); &#125;), ), ), ), ); &#125;&#125; 改法 2: 将 Provider 提至顶层: 123456789101112131415161718192021void main() &#123; runApp( Provider( create: (_) =&gt; Counter(), child: const MyApp(), ), );&#125;class MyApp extends StatelessWidget &#123; const MyApp(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( body: Center(child: Text('$&#123;Provider.of&lt;Counter&gt;(context).count&#125;')), ), ); &#125;&#125; Get 由于全局单例带来的问题正如前面提到 Get 通过全局单例，默认以 runtimeType 为 key 进行对象的存储， 部分场景可能获取到的对象不符合预期，例如商品详情页之间跳转。 由于不同的详情页实例对应的是同一 Class，即 runtimeType 相同。 如果不添加 tag 参数，在某个页面调用 Get.find 会获取到其它页面已经存储过的对象。 同时 Get 中一定要注意考虑到对象的回收，不然很有可能引起内存泄漏。 要么手动在页面 dispose 的时候做 delete 操作， 要么完全使用 Get 中提供的组件，例如 GetBuilder， 它会在 dispose 中释放。 GetBuilder 中在 dispose 阶段进行回收: 1234567891011121314151617@overridevoid dispose() &#123; super.dispose(); widget.dispose?.call(this); if (_isCreator! || widget.assignId) &#123; if (widget.autoRemove &amp;&amp; GetInstance().isRegistered&lt;T&gt;(tag: widget.tag)) &#123; GetInstance().delete&lt;T&gt;(tag: widget.tag); &#125; &#125; _remove?.call(); controller = null; _isCreator = null; _remove = null; _filter = null;&#125; Get 与 Provider 优缺点总结通过本文，我向大家介绍了状态管理的必要性、它解决了 Flutter 开发中的哪些问题以及是如何解决的， 与此同时，我也为大家总结了在实践中常见的问题等，看到这里你可能还会有些疑惑，到底是否需要使用状态管理？ 在我看来，框架是为了解决问题而存在。所以这取决于你是否也在经历一开始提出的那些问题。 如果有，那么你可以尝试使用状态管理解决；如果没有，则没必要过度设计，为了使用而使用。 其次，如果使用状态管理，那么 Get 和 Provider 哪个更好？ 这两个框架各有优缺点，我认为如果你或者你的团队刚接触 Flutter， 使用 Provider 能帮助你们更快理解 Flutter 的核心机制。 而如果已经对 Flutter 的原理有了解，Get 丰富的功能和简洁的 API， 则能帮助你很好地提高开发效率。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlutterAPP生命周期监听]]></title>
    <url>%2Fposts%2Fb07d1684.html</url>
    <content type="text"><![CDATA[State 的生命周期，定义了 Widget 的加载到构建的全过程，可以利用其回调机制根据 Widget 的状态选择合适的时机做合适的事情。而 APP 的生命周期，则定义了 APP 从启动到退出的全过程。 如果想在对应的 APP 的生命周期事件中做相应的处理，比如 APP 从后台进入前台、从前台退到后台，或是在 UI 绘制完后做一些处理，则可以应用 WidgetsBindingObserver 类来实现。 WidgetsBindingObserver 中的回调方法 1234567891011121314151617181920212223242526// Accessibility 相关特性回调void didChangeAccessibilityFeatures() &#123; &#125;// App 生命周期改变回调void didChangeAppLifecycleState(AppLifecycleState state) &#123; &#125;// 本地化语言改变回调void didChangeLocales(List&lt;Locale&gt; locale) &#123; &#125;// 系统窗口相关改变回调void didChangeMetrics() &#123; &#125;// 系统亮度改变回调void didChangePlatformBrightness() &#123; &#125;// 文本缩放系数改变回调void didChangeTextScaleFactor() &#123; &#125;// 内存不足警告回调void didHaveMemoryPressure() &#123; &#125;// 页面 popFuture&lt;bool&gt; didPopRoute() =&gt; Future&lt;bool&gt;.value(false);// 页面 pushFuture&lt;bool&gt; didPushRoute(String route) =&gt; Future&lt;bool&gt;.value(false); 要使用以上回调方法，只需通过给 WidgetsBindingObserver 单例对象设置监听器即可监听相关回调方法 生命周期回调didChangeAppLifecycleState 回调方法中，有一个参数类型为 AppLifecycleState 的枚举类，这个枚举类是 Flutter 对 App 生命周期状态的封装，常用的状态包括 inactive、paused、resumed inactive：处在不活动状态，无法处理用户响应 paused：不可见且不能响应用户的输入，但在后台继续活动中 resumed：可见的，且能响应用户的输入 123456789101112131415161718192021222324252627class AppLifecycleReactor extends StatefulWidget &#123; const AppLifecycleReactor(&#123; Key key &#125;) : super(key: key); @override _AppLifecycleReactorState createState() =&gt; _AppLifecycleReactorState();&#125;class _AppLifecycleReactorState extends State&lt;AppLifecycleReactor&gt; with WidgetsBindingObserver &#123; @override void initState() &#123; super.initState(); WidgetsBinding.instance.addObserver(this);// 注册监听器 &#125; @override void dispose() &#123; WidgetsBinding.instance.removeObserver(this);// 移除监听器 super.dispose(); &#125; AppLifecycleState _notification; @override void didChangeAppLifecycleState(AppLifecycleState state) &#123; print("$state"); &#125;&#125; 可以试着切换下前后台，观察下控制台输出的 App 状态 从前台退到后台，控制台打印的 App 生命周期变化如下： AppLifecycleState.resumed-&gt;AppLifecycleState.inactive-&gt;AppLifecycleState.paused 从后台切换回前台，控制台打印的 App 生命周期变化如下： AppLifecycleState.paused-&gt;AppLifecycleState.inactive-&gt;AppLifecycleState.resumed 帧绘制回调有时除了需要监听 App 的生命周期回调外，还需要在组件完成渲染后做一些与显示相关的其他处理，比如切换线程等，此时可以使用 WidgetsBinding 来实现 WidgetsBinding 提供了单次 Frame 绘制回调及实时 Frame 绘制回调两种机制 单次 Frame 绘制回调：通过 addPostFrameCallback 实现。在当前 Frame 绘制完后进行回调，且只会回调一次，如果需要多次回调则需设置多次 123WidgetsBindingObserver.instance.addPostFrameCallback((_)&#123; print("addPostFrameCallback 绘制回调"); // 只回调一次&#125;); 实时 Frame 绘制回调：通过 addPersistentFrameCallback 实现。在每次绘制 Frame 结束后进行回调 123WidgetsBindingObserver.instance.addPersistentFrameCallback((_)&#123; print("addPersistentFrameCallback 绘制回调"); // 每帧都回调&#125;);]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter升级到指定版本]]></title>
    <url>%2Fposts%2F7a75b9fc.html</url>
    <content type="text"><![CDATA[一、通过命令：1234567查看版本： flutter --version检查环境：flutter doctor查看渠道：flutter channel切换渠道（stable, beta, dev, master）：flutter channel stable升级到最新版本：flutter upgrade 升级到指定版本：flutter upgrade v2.5.0回退到指定版本：flutter downgrade v2.5.0 二、通过git回退版本：1、进入flutter github找到要回退的版本 2、cd进入到存放flutter sdk目录，运行回退指令 git reset –hard [commit_id] 例如-&gt; git reset –hard 4cc385b4b84ac2f816d939a49ea1f328c4e0b48e 3、查看flutter版本 查看版本-&gt; flutter doctor 或者 flutter –version]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter3.0 重磅发布]]></title>
    <url>%2Fposts%2F216218f9.html</url>
    <content type="text"><![CDATA[颠覆开发者开发方式的Flutter Flutter的诞生是为了彻底改变应用程序开发方式：将Web的迭代开发模式与硬件加速图形渲染和像素级控制相结合，这些以前可是游戏的专利，而现在它被来进行应用开发。自从Flutter 1.0测试版发布以来，谷歌对其不断地进行优化，让Flutter的功能日趋完善，比如添加了新的框架功能和小部件、与底层平台进行更加深入的集成、提供了丰富的软件包库，并且在性能和工具上也做了许多的改进。 从1.0到3.0版本，Flutter被越来越多的开发者使用来构建应用程序。据谷歌最新用户研究报告显示： 91%的开发人员认为Flutter能缩短构建和发布应用程序所需要的时间； 85%的开发人员认为Flutter使他们的应用程序更美观； 85%的人认可Flutter能使他们在更多的平台上发布他们的应用程序。 实现“大一统”，一个Flutter，横跨iOS、Android、Web、Windows、macOS、Linux六大平台 Flutter 3.0为开发者提供了一种使用Dart编程语言为六大面向消费者的主流平台（iOS、Android、Web、Windows、macOS、Linux）目标编写应用程序的方法。基于Flutter 3，开发者能拥有从单个代码库为六个平台构建应用程序的体验，这将使其生产力大大提高。 不同于之前的版本，Flutter 3新增了对macOS和Linux应用程序的稳定支持。添加新平台的支持并不像我们想象中那么简单，其需要的不仅仅是渲染像素，还需要做很多其他的工作，比如新的输入和交互模型、编译和生成支持、可访问性和国际化以及特定于平台的集成等。Flutter不仅让用户能灵活地充分利用底层操作系统，同时能够根据需要共享尽可能多的UI。 具体来看，在macOS上，Flutter3可以通过通用二进制构建方式支持英特尔和Apple Silicon，允许应用打包在这两种架构上本机运行的可执行文件。同时，由于Dart对Apple Silicon的支持，编译速度也将更快。在Linux上，Canonical和谷歌合作提供了一个高度集成且在同类中最佳的开发选项。 另外，Flutter 3 还改进了许多基础功能，包括性能改进、Material You 支持和生产力更新。 除了上述所提到的内容，在新版本中，Flutter可以在苹果芯片上进行原生开发。虽然Flutter自发布以来，一直与搭载M1芯片的苹果设备兼容，但Flutter现在充分利用了Dart对Apple芯片的支持，可以在M1驱动的设备上实现更快的编译，并支持macOS应用程序的通用二进制文件。 另外，随着谷歌的Material Design 3在Flutter 3这个版本中基本已经完成，开发人员能够利用适应性强的跨平台设计系统，该系统提供动态配色方案和更新的视觉组件： Flutter是由Dart驱动的，Dart是一种用于多平台开发的高生产力、可移植的语言。谷歌在Dart中添加了一些新的语言功能。这些新的语言功能带来的好处颇多，比如能够减少模板、提高可读性、提供实验性的RISC-V支持，以及升级的linter和新的文档等。在专用的博客中可以获得关于Dart 2.17所有新更改的细节，可通过链接查看https://medium.com/dartlang Firebase和Flutter深度集成 当然，构建应用的不仅仅是UI框架。一套全面的工具在构建、开发和操作应用中也是必不可少的，比如身份验证、数据储存、云功能和设备测试等服务。而包括Sentry、AppWrite和AWS Amplify在内的很多服务都支持Flutter。 谷歌提供的应用服务Firebase使用率很高，在SlashData的开发者基准测试中，有62%的Flutter开发者表示会在开发应用程序时使用Firebase。因此，在以前的版本中，谷歌一直致力于将Flutter与Firebase更好地结合，以创造一流的的Flutter集成。为此，谷歌将Flutter中的Firebase插件提升到1.0（用于添加更好的文档和工具），以及提供像FlutterFire UI这样的新小部件（为开发人员提供可重用的UI用于身份验证和配置文件屏幕）。 今天，谷歌宣布将Flutter和Firebase的集成作为Firebase产品的核心，正在将源代码和文档移动到Firebase主存储库和站点中，而且谷歌有可能与Android和iOS同步发展Firebase对Flutter的支持。 此外，为了使用Crashlytics（Firebase广受欢迎的实时崩溃报告解决服务）谷歌还进行了以下重大改进。 通过更新Flutter Crashlytics插件，可以让用户实时跟踪致命的错误，从而为用户提供与其他iOS或Android开发人员相同的功能集； 升级Crashlytics分析管道，以改进Flutter崩溃的聚类分析，从而更快地对问题进行分类、优先排序和修复； 简化了插件设置过程，因此只需几个步骤即可从用户的Dart代码中启动并运行Crashlytics。 Flutter休闲游戏工具包 对于大多数开发者来说，Flutter只是一个应用程序框架。但是，在休闲游戏开发领域也有Flutter的一番天地。围绕休闲游戏开发的社区也在不断壮大，很多开发者利用Flutter提供的硬件加速图形支持和Flame等开源游戏引擎。 为了让休闲游戏开发者能够更能更容易上手，在今天的I/O大会上，谷歌宣布发布Flutter Casual Games Toolkit，它不仅提供了一个模板和最佳实践的入门工具包，还能带来广告和云服务的良好体验。 虽然Flutter并不是为高强度的3D动作游戏而生的，但是有跨度是常有的事，即使是一些游戏也转向Flutter的非游戏UI，比如像PUBG Mobile这样拥有数亿用户的流行游戏。那么谷歌能把技术发展到什么程度呢？为了得到这个问题的答案，谷歌创建了一个有趣的弹球游戏（由Firebase和Flutter的网络支持提供支持）。 I/O弹球游戏中设计了一个带有四个吉祥物（Flutter的Dash、Firebase的Sparky、Android机器人和Chrome的恐龙）的定制桌子。玩家能在游戏中与别人一教高下，谷歌通过这种方式来展示Flutter多功能性，这很有趣。 Snearh认为，游戏开发和企业开发对性能和用户体验有着共同的追求，而Flutter团队一直在努力解决界面卡顿等问题，最终让框架能够更适用于各种类型的应用程序。 「一套代码，到处运行」，从 Flutter 3 开始 作为一款开源工具，Flutter不仅仅是谷歌的框架，也是一个业界开发者都能使用的产品。无论是通过贡献新的代码或文档、创建赋予核心框架新的超能力的软件包、编写指导他人的书籍和培训课程，还是帮助组织活动和用户组等等，人人都可以参与其中。Flutter 3的发布大大地提高了开发者的效率，也终让大家都实现了「一套代码，到处运行」的梦想。 原文地址：https://medium.com/flutter/introducing-flutter-3-5eb69151622f 参考地址：https://juejin.cn/post/7096617842023333925]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter混合开发组件化架构]]></title>
    <url>%2Fposts%2F187f2070.html</url>
    <content type="text"><![CDATA[背景 Flutter的四种工程类型 Flutter工程Pub依赖管理 FlutterModule集成到Native Flutter与Native通信 Flutter组件化工程 后序 一、背景Flutter 在目前跨平台方案中有更好的平台一致性以及更优的体验。但对于本身已有成熟的业务代码的项目来说，更多的是采用混合栈的方式，在不变更原有 App 业务的基础上，将 Flutter 能力扩展为子模块进行接入和开发。这样并不影响原有的业务和原生能力，又可以结合业务需求进行技术选择。 二、Flutter 的四种工程类型2.1. Flutter Application标准的Flutter App工程，包含标准的Dart层与Native平台层 2.2. Flutter ModuleFlutter组件工程，仅包含Dart层实现，Native平台层子工程为通过Flutter自动生成的隐藏工程 2.3. Flutter PluginFlutter平台插件工程，包含Dart层与Native平台层的实现 2.4. Flutter PackageFlutter纯Dart插件工程，仅包含Dart层的实现，往往定义一些公共Widget 三、Flutter工程Pub依赖管理Flutter工程之间的依赖管理是通过Pub来管理的，依赖的产物是直接源码依赖，这种依赖方式和IOS中的Pod有点像，都可以进行依赖库版本号的区间限定与Git远程依赖等，其中具体声明依赖是在pubspec.yaml文件中，其中的依赖编写是基于YAML语法，YAML是一个专门用来编写文件配置的语言。 声明依赖后，通过运行flutter packages get命名，会从远程或本地拉取对应的依赖，同时会生成pubspec.lock文件，这个文件和IOS中的Podfile.lock极其相似，会在本地锁定当前依赖的库以及对应版本号，只有当执行flutter packages upgrade时，这时才会更新。 四、Flutter module 集成到 Native上述说的如果我们要利用Flutter来开发我们现有Native工程中的一个模块或功能，肯定得不能改变Native的工程结构以及不影响现有的开发流程，那么，以何种方式进行混合开发呢？ 4.1 Flutter混合开发模式Flutter混合开发模式一般有两种方式： Flutter App 我们可以直接忽略，因为这是一个开发全新的Flutter App工程。 对于Flutter Module，官方提供的本地依赖便是使用Flutter Module依赖到Native App的，而对于Flutter工程来说，构建Flutter工程必须得有个main.dart主入口，恰好Flutter Module中也有主入口。 4.2 Flutter Module的创建方式Flutter module创建方式一般有两种： a、通过命令来创建 flutter create -t module –org com.vhall.module vhall_flutter_module 123456789101112131415161718Creating project vhall_flutter_module... vhall_flutter_module/test/widget_test.dart (created) vhall_flutter_module/vhall_flutter_module.iml (created) vhall_flutter_module/.gitignore (created) vhall_flutter_module/.metadata (created) vhall_flutter_module/pubspec.yaml (created) vhall_flutter_module/README.md (created) vhall_flutter_module/lib/main.dart (created) vhall_flutter_module/vhall_flutter_module_android.iml (created) vhall_flutter_module/analysis_options.yaml (created) vhall_flutter_module/.idea/libraries/Dart_SDK.xml (created) vhall_flutter_module/.idea/modules.xml (created) vhall_flutter_module/.idea/workspace.xml (created)Running &quot;flutter pub get&quot; in vhall_flutter_module... 1,226msWrote 12 files.All done!Your module code is in vhall_flutter_module/lib/main.dart. b、使用 As 创建 Flutter Module 在 As 中选择 File-&gt;New-&gt;New Flutter Project，选择 Flutter Module 创建 Flutter Module 子项目 4.3 添加Flutter的两种依赖方式4.3.1 将Flutter添加到原生工程中， 有两种方式：a、以aar的方式集成到现有Android项目中 创建好 Flutter Module 之后需要将其编译成 aar 的形式，可以通过如下命令进行 aar 的编译： cd vhall_flutter_module flutter build aar 在 Android 中也可以通过 As 工具来编译 aar，选择 Build-&gt;Flutter-&gt;Build AAR 来进行 aar 的编译。 然后根据提示在主项目工程的 build.grade 文件中进行相关配置，参考如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344💪 Building with sound null safety 💪Running Gradle task &apos;assembleAarDebug&apos;... 22.2s✓ Built build/host/outputs/repo.Running Gradle task &apos;assembleAarProfile&apos;... 46.1s✓ Built build/host/outputs/repo.Running Gradle task &apos;assembleAarRelease&apos;... 37.2s✓ Built build/host/outputs/repo.Consuming the Module 1. Open &lt;host&gt;/app/build.gradle 2. Ensure you have the repositories configured, otherwise add them: String storageUrl = System.env.FLUTTER_STORAGE_BASE_URL ?: &quot;https://storage.googleapis.com&quot; repositories &#123; maven &#123; url &apos;/Users/zhangmiao/Documents/project/hybrid/vhall_flutter_module/build/host/outputs/repo&apos; &#125; maven &#123; url &quot;$storageUrl/download.flutter.io&quot; &#125; &#125; 3. Make the host app depend on the Flutter module: dependencies &#123; debugImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_debug:1.0&apos; profileImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_profile:1.0&apos; releaseImplementation &apos;com.vhall.module.vhall_flutter_module:flutter_release:1.0&apos; &#125; 4. Add the `profile` build type: android &#123; buildTypes &#123; profile &#123; initWith debug &#125; &#125; &#125;To learn more, visit https://flutter.dev/go/build-aar 优点： 依赖一个包含 Flutter 产物的 aar 包，这个的好处就是其他不开发 flutter 的同学可以不用配置 flutter 环境，它和其他模块包无异 b、以 Flutet module 的方式集成到现有 Android 项目中 在 setting.gradle 文件中配置 flutter module 如下： 12345setBinding(new Binding([gradle: this]))evaluate(new File( settingsDir, &apos;../vhall_flutter_module/.android/include_flutter.groovy&apos;)) 在 app 项目的 build.gradle 依赖 flutter module 模块 123dependencies &#123; implementation project(&apos;:flutter&apos;)&#125; 缺点： 需要 flutter 环境，并且各个开发人员环境不一致，导致集成因为版本不一致报各种错误 4.3.2本地依赖的原理Android 在Android中本地依赖方式为： 在settings.gradle中注入include_flutter.groovy脚本 在需要依赖的app中build.gradle添加project(‘:flutter’)依赖 对于Android的本地依赖，主要是由include_flutter.groovy和flutter.gradle这两个脚本负责Flutter的本地依赖和产物构建。 a、include_flutter.groovy 在settings.gradle中注入时，分别绑定了当前执行Gradle的上下文环境与执行include_flutter.groovy脚本，该脚本只做了下面三件事： include FlutterModule中的.android/Flutter工程 include FlutterModule中的.flutter-plugins文件中包含的Flutter工程路径下的android module 配置所有工程的build.gradle配置执行阶段都依赖于:flutter工程，也即它最先执行配置阶段 其中.flutter-plugins文件，是根据当前依赖自动生成的，里面包含了当前Flutter工程所依赖（直接依赖和传递依赖）的Flutter子工程与绝对路径的K-V关系，子工程可能是一个Flutter Plugin或者是一个Flutter Package。 b、flutter.gradle 该脚本位于Flutter SDK中，内容看起来很长，其实主要做了下面三件事： 选择符合对应架构的Flutter引擎（flutter.so） 解析上述.flutter-plugins文件，把对应的android module添加到Native工程的依赖中（上述的include其实为这步做准备） Hook mergeAssets/processResources Task，预先执行FlutterTask，调用flutter命令编译Dart层代码构建出flutter_assets产物，并拷贝到assets目录下 有了上述三步，则直接在Native工程中运行构建即可自动构建Flutter工程中的代码并自动拷贝产物到Native中 IOS 在IOS中本地依赖方式为： 在Podfile中通过eval binding特性注入podhelper.rb脚本，在pod install/update时会执行它 在IOS构建阶段Build Phases中注入构建时需要执行的xcode_backend.sh脚本 对于IOS的本地依赖，主要是由podhelper.rb和xcode_backend.sh这两个脚本负责Flutter的Pod本地依赖和产物构建 a、podhelper.rb 因Podfile是通过ruby语言写的，所以该脚本也是ruby脚本，该脚本在pod install/update时主要做了三件事： Pod本地依赖Flutter引擎（Flutter.framework）与Flutter插件注册表（FlutterPluginRegistrant） Pod本地源码依赖.flutter-plugins文件中包含的Flutter工程路径下的ios工程 在pod install执行完后post_install中，获取当前target工程对象，导入Generated.xcconfig配置，这些配置都为环境变量配置，主要为构建阶段xcode_backend.sh脚本执行做准备 上述事情即可保证Flutter工程以及传递依赖的都通过pod本地依赖进Native工程了，接下来就是构建了 b、xcode_backend.sh 该Shell脚本位于Flutter SDK中，该脚本主要就做了两件事： 调用flutter命令编译构建出产物（App.framework、flutter_assets） 把产物（.framework、flutter_assets）拷贝到对应XCode构建产物中，对应产物目录为：*$HOME/Library/Developer/Xcode/DerivedData/${AppName}** 上述两个静态库*.framework是拷贝到${BUILT_PRODUCTS_DIR}”/“${PRODUCT_NAME}”.app/Frameworks”目录下 flutter_assets拷贝到${BUILT_PRODUCTS_DIR}”/“${PRODUCT_NAME}”.app”目录下 在XCode工程中，对应的是在${AppName}/Products/${AppName}.app 4.4 原生接入 flutter 页面flutter 依赖提供了 FlutterActivity 来直接加载 flutter 页面，我们只需要在清单文件中配置该 Activity ： （通常我们会创建一个 Activity 继承 FlutterActivity） 123456&lt;activity android:name=&quot;io.flutter.embedding.android.FlutterActivity&quot; android:theme=&quot;@style/Theme.Vhall_app&quot; android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode&quot; android:hardwareAccelerated=&quot;true&quot; android:windowSoftInputMode=&quot;adjustResize&quot;/&gt; 三种打开flutter页面的方式： 1）普通跳转： 12345678myButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity( FlutterActivity.createDefaultIntent(currentActivity) ); &#125;&#125;); 2）设置路由的方式跳转： 1234567891011myButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity( FlutterActivity .withNewEngine() .initialRoute(&quot;/my_route&quot;) .build(currentActivity) ); &#125;&#125;); 上述代码会在内部创建自己的 FlutterEngine 实例，每个 FlutterActivity 都创建自己的 FlutterEngine，这意味着启动一个标准的 FlutterActivity 会在界面可见时出现一短暂的延迟，可以选择使用预缓存的 FlutterEngine 来减小其延迟，实际上在内部会先检查是否存在预缓存的 FlutterEngine，如果存在则使用该 FlutterEngine，否则继续使用非预缓存的 FlutterEngine。 3）缓存 Flutter 引擎方式跳转： 123456789101112131415161718192021222324252627public class MyApplication extends Application &#123; public FlutterEngine flutterEngine; @Override public void onCreate() &#123; super.onCreate(); // Instantiate a FlutterEngine. flutterEngine = new FlutterEngine(this); // Start executing Dart code to pre-warm the FlutterEngine. flutterEngine.getDartExecutor().executeDartEntrypoint(DartExecutor.DartEntrypoint.createDefault()); // Cache the FlutterEngine to be used by FlutterActivity. FlutterEngineCache.getInstance().put(&quot;my_engine_id&quot;, flutterEngine); &#125;&#125;myButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; startActivity( LoginFlutterActivity .withCachedEngine(&quot;my_engine_id&quot;) .build(MainActivity.this) ); &#125;&#125;); 五、Flutter与Native通信5.1Platform ChannelPlatform Channel为Dart和平台之间提供了相互通信的机制，将Flutter、Android、iOS连接起来。 在移动H5开发中，webview自身提供的功能往往不够用，为了解决这个问题，引入了jsbridge，即web与native之间进行数据交互的一种方法,可以方便的将native的功能扩展给webview使用，从而可以快速开发。在Flutter中，也存在和jsbridge一样的用法，那就是Platform Channel，我们可以通过Platform Channel，将Flutter和Native方便的连接在一起，架构图如下: 在Channel中 client发送信息 host接受信息并返回结果 而且消息和响应是以异步方式传递的 Flutter和Natvie可以互为client和host，信息传递是双向的 5.2 三种不同类型的Platform ChannelFlutter定义了三种不同类型的Platform Channel用于Flutter与Host App平台进行通信，它们分别 BasicMessageChannel：用于数据传递，可以双向的请求数据。 MethodChannel：用于传递方法调用，即Flutter端可以调用Platform端的方法并通过Result接口回调结果数据。 EventChannel: 用于传递事件，即Flutter端监听Platform端的实时消息，一旦Platform端产生了数据，立即回调到Flutter端。 其构造方法都需指定一个通道标识、解编码器以及 BinaryMessenger，BinaryMessenger 是一个 Flutter 与平台的通信工具，用来传递二进制数据、设置对应的消息处理器等。 解编码器有两种分别是 MethodCodec 和 MessageCodec，前者对应方法后者对应消息，BasicMessageChannel 使用的是 MessageCodec，MethodChannel 和 EventChannel 使用的是 MethodCodec。 5.3 平台数据类型对照Platform Channel 提供不同的消息解码机制，如 StandardMessageCodec 提供基本数据类型的解编码、JSONMessageCodec 支持 Json 的解编码等，在平台之间通信时都会自动转换，各平台数据类型对照如下： 六、Flutter组件化工程6.1 背景前面讲了Flutter和Native的混合开发模式，Flutter作为Native工程的一个Module存在，这样可以有效的将Flutter和Native进行物理隔离，但随着Flutter承载的业务越来越多，与Native交互的接口变的越来越多，带来了很多管理问题，因此我们迫切需要采用新的开发模式，即Flutter的组件化开发方案。 6.2 组件化的优势采用组件化开发Flutter，将会有如下的优势： 将功能模块化，相互独立，方便管理 模块之间互不影响，耦合低，一些与业务无关的模块可以开源出来，供其他APP使用，提供代码的复用。 采用组件化开发，开发时互不影响，可以提高开发效率。 方便单元测试 6.3 组件化架构组件划分，通过Flutter Module作为所有通过Flutter实现的模块或功能的聚合入口，通过它进行Flutter层到Native层的双向关联。而Flutter开发代码写在哪里呢？当然可以直接写在Flutter Module中，这没问题，而如果后续开发了多个模块、组件，我们的Dart代码总不可能全部写在Flutter Module中lib/吧，如果在lib/目录下再建立子目录进行模块区分，这不失为一种最简单的方式，不过这会带来一些问题，所有模块共用一个远程Git地址，首先在组件开发隔离上完全耦合了，其次各个模块组件没有单独的版本号或Tag，且后续模块组件的增多，带来更多的测试回归成本。 正确的组件化方式为一个组件有一个独立的远程Git地址管理，这样各个组件在发正式版时都有一个版本号和Tag，且在各个组件开发上完全隔离，后续组件的增多不影响其它组件，某个组件新增需求而不需回归其它组件，带来更低的测试成本。 前面提到Flutter Plugin可以有对应Dart层代码与平台层的实现，所以可以这样设计，一个组件对应一个Flutter Plugin，一个Flutter Plugin为一个完整的Flutter工程，有独立的Git地址，而这些组件之间不能互相依赖，保持零耦合，所以这些组件都在业务层，可以叫做业务组件，这些业务组件之间的通信和公共服务可以再划分一层基础层，可以叫做基础组件，所有业务组件依赖基础层，而Flutter Module作为聚合层依赖于所有Flutter组件，这些Flutter工程之间的依赖正是通过Pub依赖进行管理的。 所以，综合上述，整体的组件化架构可以设计为： 6.4业务组件与基础组件的定位对于上面的基础组件比如还可以进行更细粒度的划分，不过不建议划分太多，对于与Native平台层的通信，每个业务组件对应一个Channel，当然内部还可以进行更细粒度的Channel进行划分，这个Channel主要是负责Native层服务的提供，让Flutter层消费。而对于Native层调用Flutter层的Api，应该尽可能少，需要调也只有出现一些值回调时。 因为Flutter的出现最本质的就是一次开发两端运行，而如果有太多这种依赖于平台层的实现，反而出现违背了，最后只是UI写了一份而已。对于平台层的实现也要尽量保持一个原则，即： 尽量让Native平台层成为服务层，让Flutter层成为消费层调用Native层的服务，即Dart调用Native的Api，这样当两端开发人员编写好一致基础的服务接口后，Flutter的开发人员即可平滑使用和开发。 七、后序对于现有工程使用Flutter进行混合开发，坑点还是有的，比如性能、页面栈管理等方面，加上目前Flutter上一些基础库不成熟，对于项目内的重要页面以及动态化强度比较高的页面，目前还是不建议使用Flutter进行开发，如果要使用也须做好降级方案，相反可以使用稍微轻量级点的页面，且在设计时对于Flutter与Native层的通信，应该让Flutter作为消费层消费Native层提供的服务，Native端应做尽量少的改动等等。与纯原生开发或纯 Flutter 开发相比，混合开发由于需要打通原生和 Flutter 的数据和服务，需要有大量桥接实现，各个模块互相协作也需要考虑各种异常或降级的情况。 参考：将 Flutter module 集成到 Android 项目 https://flutter.cn/docs/development/add-to-app/android/project-setup将 Flutter module 集成到 iOS 项目 https://flutter.cn/docs/development/add-to-app/ios/project-setup在 Android 应用中添加 Flutter 页面https://flutter.cn/docs/development/add-to-app/android/add-flutter-screen在 iOS 应用中添加 Flutter 页面 https://flutter.cn/docs/development/add-to-app/ios/add-flutter-screenAdd-to-App Samples https://github.com/flutter/samples/blob/beface247a/add_to_app/README.md]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【新技术】又双叒叕来了系列三]]></title>
    <url>%2Fposts%2F477750ac.html</url>
    <content type="text"><![CDATA[1. 在 Android 模拟器上运行 ARM 应用这算是一个非常好的消息了，之前在实际应用开发中，因为模拟器缺少对 arm 的支持，基本上都使用真机进行开发与调试。随着 Android 11预览版的发布Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM 指令转换成 x86 指令。开发者无需搭建高负载的 ARM 环境即可执行 ARM 二进制文件并进行测试。 详情：在 Android 模拟器上运行 ARM 应用 2. 大厂对外文章分享携程技术 携程Android 10适配踩坑指南新版本适配一直是 Android 开发者的痛楚之一，但是这件事如果长期不升就会越来越困难。加上现在应用市场比较强势，所以保持一个较高的版本的适配是有必要的。携程旅行分享了他们从API 26 到 29 的适配经验，大家可以参考一波。全网最详！暗黑模式在 Trip.com App 的实践 暗黑模式也最近的一个非常热门的话题，甚至微信支持暗黑模式都成为热点了。如果你对这方面感兴趣，或者刚好有暗黑实践的需求，那么可以看这一篇由携程 UED 团队+研发团队撰写的文章。我个人其实一直没有体验过暗黑模式，毕竟没适配的 app 太多了，所以我不认为把手机切换为暗黑模式有很好的的体验… Google 开发者在 Android 开发中使用协程 | 背景介绍可以看一下官方的文章了解下协程的一些背景知识，用来解决什么问题，如何解决，以及性能相关的一些知识。 字节跳动技术团队抖音包大小优化-资源优化可以看下抖音团队为了减少 apk 的体积，针对资源这一方面做了哪些极致的事情。另外 apk 体积优化也可以看下 jsonchao 的文章：吹爆系列：深入探索Android包体积优化 百度 APP 技术Gradle 与 Android 构建入门写了一篇 Gradle 构建入门的文章，其实很多同学都非常害怕 Gradle，这篇文章会给大家解释为什么需要 Gradle，以及 Gradle 相关的一些基础知识，帮你更好的了解相关知识，比较轻松，可以一看。 西瓜技术团队AwCookieManager.nativeGetCookie crash 排查分享了西瓜的一个CookieManager.getCookie(String url) 过程中的 native crash，分析过程较为复杂，不过给出了解决方案，解决方案涉及到 hook，西瓜用了自研的方案，开源的 lancet 应该也能做到，这篇文章也会提到 lancet。 历史分享(点击可直接访问)： 腾讯Bugly:对字符串匹配算法的一点理解 爱奇艺：安卓APP崩溃捕获方案——xCrash 字节跳动：深入理解Gradle框架之一：Plugin, Extension, buildSrc 百度APP技术：Android H5首屏优化实践 京东技术：任意URL跳转漏洞修复与JDK中getHost()方法之间的坑 支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」 支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能 支付宝 App 构建优化解析：Android 包大小极致压缩 搜狐：深入理解Flutter多线程 携程：从智行 Android 项目看组件化架构实践 Google: Flutter 您需要知道的知识点 | FAQ・第三期 字节跳动：二维码扫描优化 网易传媒技术团队：AOP技术在客户端的应用与实践 网易大数据|互联网产品决策秘笈: AB测试 高德：Android Native 内存泄漏系统化解决方案 例说 Constraint Layout（三）—— 性能测试 Android P之Smart Linkify 百度App组件化之路 百度App网络深度优化系列《三》弱网优化 头条| 深入理解gradle框架之二：依赖实现分析 美团| Probe：Android线上OOM问题定位组件 美团|Android静态代码扫描效率优化与实践 头条|开源 | Scene：Android 开源页面导航和组合框架 网易新闻客户端 H5 秒开优化 解决支付宝包体积优化的遗留问题：运行时获取dexpc Android篇 | 爱奇艺App启动优化实践分享 二维码扫描优化及爱奇艺App的实践 腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用 天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析） 花椒Android端自动化测试实践 一种简单优雅的TextView行间距适配方案 Android 10分区存储介绍及百度APP适配实践 抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80% 抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%（二） 4. 一个 Android 优秀博主的文章合集https://github.com/yangkun19921001/Blog 比较适合系统性的复习，而且作者应该比较精通音视频，我知道很多同学对音视频很好奇，苦于没有什么入门的书籍等，不妨看下这位作者系列文章。 5. 一个Android 面试题合集这是一个国外开发者维护的仓库，所以问题以及相关问题解答的博客都是外文。 https://github.com/MindorksOpenSource/android-interview-questions上述问题在我们看来不一定能作为面试题，但是有些问题还是可以用来差缺补漏的，也能帮助大家发现一些写的比较好的外文博客。 6. lancet ：一个 hook 库https://github.com/eleme/lancet这个库非常久了哈，饿了么对外开源的，但是好像开发者关注度并不高。实际上还是非常好用的，我们传统意义 hook 的想法，都是换掉某个实现。 比如 A 类，有个 b 方法，我们需要修改 b方法返回值，我们一般会考虑 hook 一些对象，由这些对象导致 b 方法的执行返回逻辑发生改变，但是这种hook 并不是那么容易找到突破口。 而 lancet 的概念就很有意思了，它不修改 b方法，他修改所有调用 b 方法的地方，把对b 方法的调用hook 到你准备好的方法中，所以你可以随意的控制返回值，当然这种 hook 肯定是基于编译期修改字节码的，优势就是一定能换到，只要是参与编译的代码。 我说的可能大家不太容易理解，还是建议大家了解下这个库的原理，确实是 hook 的一个非常好的新思路。 7. 奇思妙想见到一个库是这样的: https://github.com/m-zylab/SketchyComponent主要是手绘风，相信大家根据之前的灰白化的文章：App黑白化实现探索，有一行代码实现的方案吗？ 都知道我们可以基于换肤的方案把一些控件换成我们自己的，那么假设我们可以提供手绘风格的：TextView,Button…等，是不是有可能可以将一个 app 瞬间变成手绘风格？ 8. 随便播报appcomapt 1.1.0 版本在 android 5.0,5.1的设备上可能会造成 webview 崩溃这是周六的时候一个朋友遇到的问题，查了下发现的。这是个官方bug:https://issuetracker.google.com/issues/141132133 一些解决方案：https://stackoverflow.com/questions/41025200/android-view-inflateexception-error-inflating-class-android-webkit-webview/49024931#49024931如果你升级1.1.0要谨慎。 好了，祝大家元气满满！]]></content>
      <categories>
        <category>新技术</category>
      </categories>
      <tags>
        <tag>新技术</tag>
        <tag>大厂对外分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【新技术】又双叒叕来了系列二]]></title>
    <url>%2Fposts%2F2e3f2830.html</url>
    <content type="text"><![CDATA[1. Android 开发者峰会一些资源大家可以在 B 站看到所有的内容： https://space.bilibili.com/64169458/channel/detail?cid=91608 有个值得关注的是，官方回复了一些 Android 开发的问题：一些新技术都有涉及，比如 ViewPager2 正式发布，关于 Camerax,Camera2,Camera1 之间如何选择，以及Kotlin，Jetpack Compose 相关问题。 我当时比较好奇的一个问题是这个： 挺奇怪的，难道官方 app 会考虑只用一个 Activity 么？ 详细的大家直接看这里：Android 开发者峰会 2019 常见问题解答 2. 百度对外开源文章详情页 webview+recyclerview+一些原生控件联动效果https://github.com/baiduapp-tec/ELinkageScroll 如果大家每篇推文都看的话，这个库我上次已经专门介绍过啦。 这个效果使用非常广，基本所有的资讯类 app 都有，感谢百度开源。 历史类似文章：大厂的文章详情页 WebView与 RecyclerView如何连贯滑动的？ 另外感谢「this 蜗牛」这位朋友留言说道 QMUI也有这个效果，还后台给我发了个截图，我也给大家补充上，大家可以一起参考。 https://qmuiteam.com/android https://github.com/Tencent/QMUI_Android 之前的系列我也给大家推荐过 QMUI，这样的大厂出的类库还是可以关注下，尤其针对个人开发者，在快速迭代自己项目的时候还是很有用的。 3. 大厂对外文章分享百度 App 技术一种简单优雅的TextView行间距适配方案 以前用 TextView就怕UI 跟我们纠结行高，因为在 Android 里面没有一个非常明确的 lineHeight 概念，百度这边分享了自己的解决方案，还是学到了一些新知识的，文章中提到的LineHeightSpan我之前就不知道，还是学到了。 方案对于中文的支持还是很不错的，值得借鉴。Android 10分区存储介绍及百度APP适配实践这个就不用介绍了吧，标题很清晰。 字节跳动技术团队 抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80% 抖音BoostMultiDex优化实践：Android低版本上APP首次启动时间减少80%（二） 介绍了抖音团队自研的一个针对 4.x 级以下机型对于 MultiDex 的优化。目前还没有开源，大家可以了解下原理，后续开源我也会周知大家的。此外相关知识也可以学习下：Android 一种在Dalvik虚拟机上多Dex加载优化的方案https://blog.csdn.net/sbsujjbcy/article/details/53381663 Google 开发者Room 中的数据库关系对于 Room 使用者，如果你对 1 对 1，1 对N，N 对 N 不知道如何处理的可以学习下。 历史分享(点击可直接访问)： 腾讯Bugly:对字符串匹配算法的一点理解 爱奇艺：安卓APP崩溃捕获方案——xCrash 字节跳动：深入理解Gradle框架之一：Plugin, Extension, buildSrc 百度APP技术：Android H5首屏优化实践 京东技术：任意URL跳转漏洞修复与JDK中getHost()方法之间的坑 支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」 支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能 支付宝 App 构建优化解析：Android 包大小极致压缩 搜狐：深入理解Flutter多线程 携程：从智行 Android 项目看组件化架构实践 Google: Flutter 您需要知道的知识点 | FAQ・第三期 字节跳动：二维码扫描优化 网易传媒技术团队：AOP技术在客户端的应用与实践 网易大数据|互联网产品决策秘笈: AB测试 高德：Android Native 内存泄漏系统化解决方案 例说 Constraint Layout（三）—— 性能测试 Android P之Smart Linkify 百度App组件化之路 百度App网络深度优化系列《三》弱网优化 头条 | 深入理解gradle框架之二：依赖实现分析 美团| Probe：Android线上OOM问题定位组件 美团|Android静态代码扫描效率优化与实践 头条| 开源 | Scene：Android 开源页面导航和组合框架 网易新闻客户端 H5 秒开优化 解决支付宝包体积优化的遗留问题：运行时获取dexpc Android篇 | 爱奇艺App启动优化实践分享 二维码扫描优化及爱奇艺App的实践 腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用 天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析） 花椒Android端自动化测试实践 4. Github 找 Android 项目姿势上次有同学留言问我怎么在 Github 找 Android项目，大家能想到的肯定是看 trending:https://github.com/trending/java 不过现在能上 trending 的 Android 项目太少了，毕竟和 Java 项目在一个分类。其实 Github 有主题的概念，直接选择 Android 主题就可以了：https://github.com/topics/android 可以看到有9W+项目。 也可以按条件筛选： 5. 一些Android 逆向*攻防*相关的话题有这么一个仓库：https://github.com/Hack-with-Github/Awesome-Hacking看名字大家就知道介绍啥了，是一个安全相关的仓库汇总，里面包含了太多的子项目，例如有些工具不知道在哪下载，在这里面很好找：https://github.com/carpedm20/awesome-hacking 6. 播报一些最近发现更新的开源库LeakCanary 不再使用 haha我们熟悉的 LeakCanary 已经不再使用之前的 haha 做内存分析，换成了自研的 Shark。https://square.github.io/leakcanary/shark/ RxJava 已经更新了 3.0.0 版本https://github.com/ReactiveX/RxJava不过 Retrofit2 暂时还无法使用 RxJava3，因为相关 Adapter 库还未适配 RxJava3。 好了，祝大家元气满满！]]></content>
      <categories>
        <category>新技术</category>
      </categories>
      <tags>
        <tag>新技术</tag>
        <tag>大厂对外分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【新技术】又双叒叕来了系列一]]></title>
    <url>%2Fposts%2F3eabe808.html</url>
    <content type="text"><![CDATA[一些中文独立博客分享目前随着移动端的兴起，早期的很多中文 PC 博客已经很少有人去阅读了，也很难被大家所发现。 因为我之前关注一个小伙的创业实验，比较好奇他最终会不会成功，也好奇他的灵感，他的下一个产品是一个中文博客相关的 RSS 产品。 所以他收集了一波中文博客列表，推荐给大家： https://github.com/timqian/chinese-independent-blogs 大概有 300 多位中文博客列表，偶尔读一些这上面的文章，应该还是能激发不少灵感的。 其实如果这些独立博客数量够多，可以聚合起来，做一个阅读 app，支持订阅也是不错的。 官方发布的代码检索工具实际使用起来，实在太好用了，强烈推荐下。 注意：需要网络良好。 https://cs.android.com/ 其他一些在线源码阅读工具： https://www.androidos.net.cn/sourcecode http://aospxref.com/ 字节跳动开源一系列插件https://github.com/bytedance/ByteX 基本都是编译时字节码相关的，目前应用于多款字节跳动产品上。 access-inline-plugin（access方法内联） shrink-r-plugin（R文件瘦身和无用资源检查） closeable-check-plugin（文件流的close检查） const-inline-plugin（常量内联） field-assign-opt-plugin（优化多余赋值指令） getter-setter-inline-plugin （getter和setter方法内联） method-call-opt-plugin（干净地删除某些方法调用，如Log.d） coverage-plugin（线上代码覆盖率） refer-check-plugin（检查是否有调用不存在的方法和引用不存在的字段） serialization-check-plugin（序列化检查） SourceFileKiller（删除SourceFile和行号属性） 一方面这个可以接入，做一些产品上的安全、优化。 另一方面是学习的好资料，如果都能看明白，AS 的 Transform 和字节码算是已经玩转了。 相关的开源项目就是滴滴的 booster: https://github.com/didi/booster 大厂对外分享1. 二维码扫描优化及爱奇艺App的实践 说了一些方案，实践还是之前字节跳动给出的方案更适合： 字节跳动：二维码扫描优化 2. 腾讯 Bugly：动态下发 so 库在 Android APK 安装包瘦身方面的应用 动态下发 so库，是减少 apk 体积非常明显的一个方案，之前在百度的时候，也搞过这样的方案，一度是瘦身黑科技，当然坑也不少，so 这玩意搞不好崩溃就比较多，如果需要可以参考目前一些插件化方案、热修方案去做。 3. 天猫精灵：史上最全Android渲染机制讲解（长文源码深度剖析） 恩…技术文章还是很赞的。 4. 花椒Android端自动化测试实践 Android 测试一直被忽略，我也没有太多这方面涉猎，当然还是值得了解下。 好了，祝大家元气满满！]]></content>
      <categories>
        <category>新技术</category>
      </categories>
      <tags>
        <tag>新技术</tag>
        <tag>大厂对外分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《老大不小》观后感]]></title>
    <url>%2Fposts%2Fe984f211.html</url>
    <content type="text"><![CDATA[电影里对自己感触最深的一句话是爸爸在病床上对他大儿子雷子说的：‘’我走了，我对小硕一百个放心，他有个沟沟坎坎的，还有你这个哥，可是，大磊子，我走了你还有谁啊？‘’ 再有两年就奔三了，自己一直北漂在外，爸妈身体一直是自己比较担心的，总是把最好的都给我们，他们自己的毛病只是不经常跟做儿女的说。陪伴家人的时间也是屈指可数，自己不是一个称职的儿子，只希望自己努力的脚步能超越父母慢慢变老的速度。 就像剧里的爸爸忍着胃癌晚期的疼痛不让家里的孩子知道一样，用生命在为自己的儿子铺路，存下了那两张银行卡。 真正戳到我泪点的是弟弟写给哥哥的那封说不出口的些话，再叛逆的孩子内心深处都存在着最真挚、最纯粹的感情，只是有些时候不会表达出来，比如父亲病床桌子上的一杯水；早上喂了父亲生前总喂的猫。其实生活中真的有好多情感难以用语言表达出来，但是我们彼此都真诚，都愿意付出。 关于哥哥的友情和爱情。他能有一个真正不离不弃的好哥们，在他需要的时候挺身而出，真的挺幸运的。包括兄弟说的那句话“有的人是靠脸活着，而有的人是为了脸活着。” 成年人的世界可能就是这样吧，有生活的重担连恋爱的勇气都没有，但最后他俩在一起真的很开心。 整体而言看完这部电影， 不是职业的电影评论。 可以说这部电影制作很成功了。 一个没有上过大学的哥哥，一个青春期叛逆的弟弟，和一个为了家努力的父亲。 成年人的世界，没有容易二字，每个人都有压力，哥哥觉得弟弟不争气，去跟已故的父亲聊聊天，收拾收拾心情还是再次回到家。 弟弟从最初的不表达爱和不接受这些爱，变成了一个懂事的孩子，每个孩子年少的时候都会经历叛逆时候。后来也会发现，当初是有多么不懂事。 弟弟打那个孩子，错了么？没错，对了么？不对。以前打架是发泄情绪，现在打架是打钱，挺好一句话，现在孩子看了可以想一想，打那个架为了什么？ 整个剧可以说环环相扣，从最初哥哥每天都给那个流浪汉钱，是傻么？只是活的乐观而已。 弟弟逃学打游戏，没有光为了打游戏，打游戏得的奖品也去送给了父亲，唯一一个过错就是没有当着面叫他一声爸。 哥哥只要点点头，就能得到一份挣钱的工作，但是他没有，他活着要着一张脸，可以通过自己的努力去挣这个钱，但不想靠感情来挣这个钱。 一个简单的故事，很温暖，源于生活。 里面有句话挺好，有人是靠脸活着，有人为了脸活着。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十个思维方式如何改变我的人生]]></title>
    <url>%2Fposts%2Fbdeaaf0.html</url>
    <content type="text"><![CDATA[1、你不需要是个天才，才有资格分享知识——《Show Your Work》2、除了目标，还要关注实现目标的体系，享受提升自我的过程3、1%定律：每天提升1%——《Atomic Habits》4、多样化收入来源5、你觉得很普通的事情，在别人看来可能会很了不起——《Anything You Want》6、每日重点：梳理待办事项的优先级——《Make Time》7、勇敢去做：不一定要遵循既定规则去过人生——《Do What You Can’t》8、家庭、个人、工作的平衡——《平衡的智慧》9、找个人谈谈心——《你当像鸟飞往你的山》、《也许你该找人聊聊》10、成功的公式——Y2b：Ali Abdaal]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 2.8 发布 | 性能及工具链优化、Firebase 功能、WebView 3.0]]></title>
    <url>%2Fposts%2F7916835e.html</url>
    <content type="text"><![CDATA[官方发布说明：medium.com/flutter/wha… 北半球的冬意已至，黄叶与气温均随风而落，而年终的最后一个稳定版本已悄然来到你的面前。 让我们向 Flutter 2.8 打声招呼～ 本次更新包含了 207 位贡献者和 178 位审核者 的辛勤劳作， 所有人共同产出了 2424 个 PR，关闭了 2976 个 issue。 在此特别感谢本次发布中最突出的社区贡献者：来自 Very Good Ventures 的 Flutter 开发工程师 Bartosz Selwesiuk， 他专注于 Web 平台的 camera 插件并提交了 23 个 PR。 以上的所有产出让 Flutter engine 和 DevTools 都有了非常显著的性能提升， 同时带来的还有 Google 移动端广告 SDK Flutter 版本的稳定版发布、 一系列针对 Firebase 的新功能和优化、Flutter WebView 3.0、 新的 Flutter Favorite package、向桌面端 Stable 迈出的一大步， 以及支持更多 package 的新版本 DartPad。 虽然这是今年最后一个稳定版本，但它并不是最不重要的。让我们一起来看看！ 性能Flutter 的首要目标是一如既往地保证其质量。 我们花费了大量时间以确保 Flutter 在多种多样的设备上都能流畅且稳定地运行。 应用启动本次更新优化了应用启动的延迟。 我们在拥有一百万行以上的代码量的 GPay 应用上进行了测试，以确保改动在实际生产的应用上有效。 这些改动将 GPay 在低端 Android 设备上启动的时间减少了约 50%，高端设备上减少了约 10%。 我们对 Flutter 调用 Dart VM 的 GC 策略也做了一些改进，以此避免在程序启动期间出现不合时宜的 GC。 例如，在 Android 设备上渲染出第一帧前，Flutter 仅在 TRIM_LEVEL_RUNNING_CRITYCAL 及高于其等级的信号出现时，通知 Dart VM 有内存压力 。 在本地测试中，低端 Android 设备的初始帧出现间隔时间最多减少了约 300ms。 在先前的 Flutter 版本中， 出于谨慎考虑 ， 在创建 PlatformView 时会阻塞平台线程。 在经过仔细的推理和测试后 ， 我们删除了部分序列化的步骤，使得 GPay 在低端设备上的启动时间至少减少了 100ms。 长久以来，在初始化首个 Dart isolate 前初始化默认的字体管理器会引入人为的延迟。 由于它是首要的延迟瓶颈，所以 将默认字体管理器的初始化延迟 到与首个 Dart isolate 同时运行，降低了启动的延迟，并让上述的所有启动优化的表现更加明显。 应用内存由于 Flutter 会尽可能快地加载 Dart VM 的服务 isolate， 并将其和绑定在应用内的 AOT 代码一并加载到内存中， 这会导致 Flutter 开发人员在部分内存 有限制的设备上难以追踪内存指标 。 在 Flutter 2.8 版本中，Android 设备上 Dart VM 的服务 isolate 已被拆分至单独的 bundle 中 ， 可以单独加载，减少了在其加载前约 40MB 的内存使用。 原本 Dart VM 向操作系统发送 AOT 程序的内存用量的通知， 已转由一个无需多次读取的文件支持，后续的内存占用量进一步减少了约 10%。 因此，先前保存了文件数据拷贝的内存可以回收并用于其他用途。 性能分析某些场景下，开发者希望能同时看到 Flutter 和 Android 的性能追踪事件， 又或者是在生产模式下查看追踪事件来更好地了解应用的性能问题。 为了这一需求，Flutter 2.8 现在可以选择在应用启动后， 将性能追踪事件发送至 Android 的事件记录器，在生产模式下也同样如此。 此外，一些开发人员想要更多的关于光栅缓存行为的性能跟踪信息， 以减少制作动画效果时的卡顿，这允许 Flutter 快速地对昂贵的、重复使用的图片进行复用而不是重新绘制。 性能跟踪中的新的 流事件让开发人员可以跟踪光栅缓存图片的生命周期。 Flutter DevTools对于调试性能问题，新版的 DevTools 添加了一个新的「增强跟踪」功能， 用来帮助开发者诊断消耗较大的构建、布局和绘制操作引起的 UI 卡顿。 启用任何一个追踪功能后，时间轴中将视情况展示 Widget 的构建、RenderObject 布局和 RenderObject 绘制的事件。 此外，新版的 DevTools 增加了应用程序启动性能的分析支持。 该配置文件包含从 Dart VM 初始化到第一个 Flutter 帧渲染的 CPU 样本。 在你按下「Profile app start up」按钮并加载应用程序启动配置文件后， 你将看到为配置文件选择了「AppStartUp」用户标签。 你还可以通过在可用用户标签列表中选择此用户标签过滤器（如果存在）来加载应用程序启动配置文件。 选择此标签会显示你的应用程序启动的个人资料数据。 Web 平台的平台视图 (PlatformView)不仅仅是 Android 和 iOS 平台获得了性能提升，本次发布同时包含了对 Flutter Web 平台视图的性能优化。 平台视图是从宿主平台向 Flutter 嵌入 UI 组件的媒介。 Flutter Web 使用 HtmlElementView widget 实现了这一功能，让你能在 Flutter Web 应用中嵌入 HTML 元素。 如果你正在使用 google_maps_flutter 插件或 video_player 插件的网络版本， 或者你正在遵循 Flutter 团队关于 如何优化网络上显示图像 的建议，那么你正在使用平台视图。 在之前版本的 Flutter 中，嵌入平台视图会创建一个新的 canvas，每嵌入一个平台视图都会新增一个 canvas。 创建额外的 canvas 是十分消耗性能的操作，因为每个 canvas 的大小都与整个窗口相等。 在 Flutter 2.8 中，将 复用为先前的平台视图创建的 canvas ， 因此，你不会在应用程序的整个生命周期内产生每秒 60 倍的成本，而是只有一次创建的成本。 这意味着你可以在 Web 应用程序中拥有多个 HtmlElementView 实例而不会降低性能， 同时还可以减少使用平台视图时的滚动卡顿。 生态Flutter 不仅仅是框架、引擎和工具——pub.dev 上现有超过 2w 个与 Flutter 兼容的包和插件，而且每天都在增加。 Flutter 开发人员大量的日常操作也是庞大的生态系统的一部分， 所以让我们来看看自上一个版本以来 Flutter 生态系统中有什么改变。 适用于 Flutter 广告的 Google 广告首先也是最重要的是， Google Mobile SDK for Flutter 已于 11 月正式发布 。 此版本支持 5 种广告格式，集成了 AdMob 和 Ad Manager 支持， 并包含一个新的中转功能的测试版，可以帮助你优化广告展现的效果。 有关将 Google Ads 集成到 Flutter 应用程序以及其他货币化选项的更多信息， 请查看 flutter.dev 上的页面 。 WebView 3.0这次 Flutter 附带的另一个新版本是 webview_flutter 插件 的 3.0 版本。 因为新功能的数量增加，我们提升了主要版本号，但也因为 Web 视图在 Android 上的工作方式可能发生了重大变化。 在之前的 webview_flutter 版本中，Hybrid composition 已经可用，但不是默认的。 而现在它修复了先前默认以虚拟显示模式运行的许多问题。 根据用户反馈和我们的问题跟踪，我们认为是时候让 Hybrid composition 成为默认设置了。 此外，webview_flutter 还增加了一些呼声极高的功能： 支持使用 POST 和 GET 来加载内容 加载文件或字符串内容为 HTML 支持透明背景 在加载内容前设置 Cookies 此外，在 3.0 版本中，webview_flutter 为新平台提供了初步支持：Flutter Web。 已经有很多人要求能够在 Flutter Web 应用程序中托管 Web 视图， 这允许开发者利用单个源代码库构建移动或 Web 应用程序。 在 Flutter Web 应用程序中托管 Web 视图是什么样的？ 从编写代码的角度来看，其实是一样的： 12345678910111213141516171819202122232425262728293031import 'package:flutter/foundation.dart';import 'package:flutter/material.dart';import 'package:webview_flutter/webview_flutter.dart';import 'package:webview_flutter_web/webview_flutter_web.dart';void main() &#123; runApp(const MaterialApp(home: HomePage()));&#125;class HomePage extends StatefulWidget &#123; const HomePage(&#123;Key? key&#125;) : super(key: key); @override State&lt;HomePage&gt; createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; @override void initState() &#123; super.initState(); // required while web support is in preview if (kIsWeb) WebView.platform = WebWebViewPlatform(); &#125; @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar(title: const Text('Flutter WebView example')), body: const WebView(initialUrl: 'https://flutter.dev'), ;&#125; 在 Flutter Web 上运行时，它会按你的预期工作： 请注意，当前 webview_flutter 的 web 实现有许多限制，因为它是使用 iframe 构建的， iframe 仅支持简单的 URL 加载，无法控制加载的内容或与加载的内容交互。 但是，由于需求呼声太高，我们决定将 webview_flutter_web 作为未经认可的插件提供。 如果你想尝试一下，请将以下内容添加到你的 pubspec.yaml 中： 123dependencies: webview_flutter: ^3.0.0 webview_flutter_web: ^0.1.0 # 显式依赖未经认可的插件 如果你对 webview_flutter v3.0 有任何反馈，无论是否是关于 Web 平台， 请将问题记录在 Flutter 仓库中 。 此外，如果你之前没有使用过 webview 或者你想复习一下， 请查看新的 webview codelab ， 它将带你逐步完成在 Flutter 应用程序中托管 web 内容的过程。 Flutter FavoritesFlutter 生态系统委员会再次召开会议，将以下 package 指定为 Flutter Favorite 的 package： 新路由 API（又名 Navigator 2）的三个自定义路由 package： beamer 、 routemaster 和 go_router ； drift ， 对 Flutter 和 Dart 已经功能强大且流行的响应式持久性库的重命名，基于 sqlite 构建； freezed ， 一个 Dart「语言补丁」，为定义模型、克隆对象、模式匹配等提供简单的语法； dart_code_metrics ； 以及有着漂亮界面的 package： flex_color_scheme 、 flutter_svg 、 feedback 、 toggle_switch 和 auto_size_text 。 祝贺这些 package 的作者，并感谢你通过你的辛勤工作支持 Flutter 社区。 如果你有兴趣提名你最喜欢的 Flutter 包加入 Flutter Favorite 嘉奖， 请按照 Flutter Favorite 计划页面 上的指南和说明进行操作。 特定平台的插件 (plugin package)如果你是插件作者，你必须决定你将支持哪些平台。 如果你正在使用特定于平台的原生代码构建插件， 你可以 使用项目 pubspec.yaml 中的 pluginClass 属性 来实现，该属性将指定提供原生功能的原生类名： 12345678flutter: plugin: platforms: android: package: com.example.hello pluginClass: HelloPlugin ios: pluginClass: HelloPlugin 然而，随着 Dart FFI 变得更加成熟，有可能使用 100% 的 Dart 实现特定平台的功能， 就像 path_provider_windows package 所做的那样。在这种情况下，你没有任何本地类可以使用， 但你仍然希望将你的包指定为仅支持某些平台。 此时你可以改用 dartPluginClass 属性： 123456flutter: plugin: implements: hello platforms: windows: dartPluginClass: HelloPluginWindows 经过这样的设置后，即使你没有任何本机代码，也可以为特定平台定制插件。 你还必须提供 Dart 插件的类， 有关详细内容，你可以在 flutter.dev 上的仅 Dart 平台实现文档 中进行扩展阅读。 桌面平台Flutter 2.8 版本在 Windows、macOS 和 Linux 稳定版本的道路上又迈出了一大步。 我们的目标质量标准很高，包括国际化和本地化支持， 例如 新的中文输入法支持 、 韩语输入法支持 以及刚刚合并的 Kanji（日文）输入法 支持。 或者，就像我们在紧密构建 Windows 辅助功能的支持 一样。 对于 Flutter 来说，在 Stable 渠道的 desktop 上运行是不够的， 它必须在世界各地的语言和文化以及不同能力的设备上运行良好。 我们还没有达到我们想要的目标，但未来可期！ 其中一个例子是我们重构了 Flutter 处理键盘事件以允许同步响应的架构。 这使 widget 能够处理按键并拦截它在整个 widget tree 中的其余部分中的传递。 我们在 Flutter 2.5 中完成了这项工作的落地，并在 Flutter 2.8 中修复了许多问题。 这是对我们如何处理特定于设备的键盘输入的方式的重新设计， 和重构 Flutter 处理文本编辑方式的持续工作的补充， 所有这些都是用键盘这样输入密集型的桌面应用程序所必需的。 此外，我们还在继续 向 Flutter 扩展视觉密度的定义 ， 暴露对话框对齐方式的设置，以便开发者可以实现更加友好的桌面 UI。 最后，Flutter 团队并不是唯一一个在为了 Flutter desktop 付出心血的团队。 举个例子，Canonical 的桌面团队正在与 Invertase 合作， 在 Linux 和 Windows 上开发最流行的 Flutter Firebase 插件。 你可以在 Invertase 博客上 阅读有关预览版的更多信息。 DartPad如果没有工具的改进，那么这个 Flutter 新版本的发布是不完整的。 我们将重点介绍 DartPad 的改进，其中最大的改进是对更多软件包的支持。 事实上，目前共有 23 个 package 可供导入使用。除了几个 Firebase 服务之外，该列表还包括诸如 bloc、characters、collection、google_fonts 和 flutter_riverpod 等流行的 package。 DartPad 团队会继续添加新的 package，如果你想查看当前支持哪些软件包，可以单击右下角的信息图标。 如果你想了解随着时间的推移向 DartPad 添加新包的计划， 请查看 Dart wiki 上的这篇文章 。 还有另一个新的 DartPad 功能也非常方便。 在此之前，DartPad 总是以运行最新的 stable 版本运行。 在新版本中，你可以使用状态栏中新的 渠道菜单 来切换最新的 Beta 渠道版本以及之前的 stable 版本（称为“旧渠道”）。 如果你正在撰写一篇博客文章，而最新的稳定版本还不够新，这将非常有用。 （其实方便了切换不同的渠道进行调试和 BUG 验证。） 移除 Dev 渠道Flutter「渠道」决定了 Flutter 框架和引擎在你的开发机器上变化的速度， stable 代表最少的变更，而 master 代表最多。 受到团队资源的限制，我们最近将停止更新 dev 渠道。 虽然我们确实收到了一些相关的问题，但我们发现只有不到 3% 的 Flutter 开发人员使用 dev 渠道。 因此，我们决定启动正式停用 dev 渠道的进程。 虽然很少有开发人员使用 dev 渠道，但 Flutter 工程师需要花费大量时间和精力来维护它。 如果你将所有时间都花在 stable 渠道上（正如超过 90% 的 Flutter 开发人员所做的那样）， 那么这项改动将不会影响你的日常开发。 通过放弃它，你可以少做一个决定，而 Flutter 团队可以将时间和精力花在其他事情上。 你可以使用 flutter channel 命令来决定你想要哪个渠道。 以下是 Flutter 团队对每个渠道的看法： Stable 渠道 代表我们拥有的最高质量的构建。它们每季度（大致）发布一次，并针对中间的关键问题进行热修复。 这是「慢」通道：安全、成熟、长期服务。 Beta 渠道 为那些习惯于更快节奏的开发者提供了一种快速调整的替代方案。 目前每月发布，发布前稳定。这是「快速」通道。如果 dev 渠道正在满足 beta 渠道无法满足的需求， 我们可能会改变我们对 beta 渠道的看法来满足这些需求 （例如，加速发布 beta 的节奏或降低我们对 beta 执行的测试和热修复级别）。 Master 渠道 是我们活跃的开发渠道。我们不提供对该渠道的支持，但我们针对它运行了一套全面的单元测试。 对于对不稳定的构建感到满意的贡献者或高级开发者而言，这是适合他们的渠道。 在这个频道上，我们跑得很快，打破了一些东西（然后会很快地修复它们）。 当我们在未来几个月停用 dev 渠道时，请考虑使用 beta 或 master 渠道， 这取决于你对变更的容忍度以及你对最新和最好的 SDK 的平衡点。 破坏性更改与往常一样，我们努力减少每个版本中破坏性更改的数量。 在此版本中，Flutter 2.8 除了已过期并根据我们的 重大变更政策 被删除的已弃用 API 之外，没有重大变更。 90292 Remove autovalidate deprecations 90293 Remove FloatingHeaderSnapConfiguration.vsync deprecation 90294 Remove AndroidViewController.id deprecation 90295 Remove BottomNavigationBarItem.title deprecation 90296 Remove deprecated text input formatting classes 如果你仍在使用这些 API 并想了解如何迁移代码，你可以阅读 flutter.dev 上的迁移指南 。 与往常一样，非常感谢社区 贡献了测试用例 ， 帮助我们识别这些重大更改。 总结在我们结束 2021 年并展望 2022 年之际，Flutter 团队要对整个 Flutter 社区的工作和支持表示感谢。 诚然，我们正在为世界上越来越多的开发人员构建 Flutter， 但如果没有你和每位开发者的存在，我们也无法维护并构建它。 Flutter 社区与众不同，我们感谢你所做的一切。 祝你假期愉快，我们新的一年见！]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack Compose 入门学习]]></title>
    <url>%2Fposts%2F7b2baf2a.html</url>
    <content type="text"><![CDATA[简介 Jetpack Compose：利用声明式编程构建Android原生界面（UI）的 工具包 优势 更少的代码、代码量锐减 强大的工具/组件支持 直观的 Kotlin API 简单易用 编程思想 声明性编程范式：声明性的函数构建一个简单的界面组件，无需修改任何 XML 布局，也不需要使用布局编辑器，只需要调用 Jetpack Compose 函数来声明想要的元素，Compose 编译器即会完成后面的所有工作。 简单的组合函数 1234@Composablefun Greeting(name: String) &#123; Text(text = "Hello $name!")&#125; 声明性范式转变：在 Compose 的声明性方法中，微件相对无状态，并且不提供 setter 或 getter 函数。实际上，微件不会以对象形式提供。您可以通过调用带有不同参数的同一可组合函数来更新界面。这使得向架构模式（如 ViewModel）提供状态变得很容易，如应用架构指南中所述。然后，可组合项负责在每次可观察数据更新时将当前应用状态转换为界面。 动态 ：组合函数是用 Kotlin 而不是 XML 编写 重组：在 Compose 中，您可以使用新数据再次调用可组合函数。这样做会导致函数进行重组 – 系统会根据需要使用新数据重新绘制函数发出的微件。Compose 框架可以智能地仅重组已更改的组件。 可组合函数可以按任何顺序执行 可组合函数可以并行运行 重组会跳过尽可能多的内容 重组是乐观的操作 可组合函数可能会非常频繁地运行 开发环境 Arctic Fox 2020-3-1 版本以上，下载最新AndroidStudio ComposeApp仅支持Kotlin 最低sdk 版本为21，Android 5.0 Gradle Compose相关依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162plugins &#123; id 'com.android.application' id 'kotlin-android'&#125;android &#123; compileSdk 31 defaultConfig &#123; applicationId "com.zm.myjetpackcompose" minSdk 21 targetSdk 31 versionCode 1 versionName "1.0" testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner" vectorDrawables &#123; useSupportLibrary true &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' &#125; &#125; compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; kotlinOptions &#123; jvmTarget = '1.8' useIR = true &#125; buildFeatures &#123; compose true &#125; composeOptions &#123; kotlinCompilerExtensionVersion compose_version kotlinCompilerVersion '1.5.21' &#125; packagingOptions &#123; resources &#123; excludes += '/META-INF/&#123;AL2.0,LGPL2.1&#125;' &#125; &#125;&#125;dependencies &#123; implementation 'androidx.core:core-ktx:1.3.2' implementation 'androidx.appcompat:appcompat:1.2.0' implementation 'com.google.android.material:material:1.3.0' implementation "androidx.compose.ui:ui:$compose_version" implementation "androidx.compose.material:material:$compose_version" implementation "androidx.compose.ui:ui-tooling-preview:$compose_version" implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1' implementation 'androidx.activity:activity-compose:1.3.0-alpha06' testImplementation 'junit:junit:4.+' androidTestImplementation 'androidx.test.ext:junit:1.1.2' androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0' androidTestImplementation "androidx.compose.ui:ui-test-junit4:$compose_version" debugImplementation "androidx.compose.ui:ui-tooling:$compose_version"&#125; 需要安装最新Java11， java 8 环境会报以下错误 12345Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8. You can try some of the following options: - changing the IDE settings. - changing the JAVA_HOME environment variable. - changing `org.gradle.java.home` in `gradle.properties`. @Preview生效，则环境正常 UI布局@Compose所有关于构建View的方法都必须添加@Compose注解才可以。并且@Compose协程的Suspend的使用方法比较类似,被@Compose注解的方法只能在同样被@Comopse解的方法中才能被调用。 1234@Composablefun Greeting(name: String) &#123; Text(text = "Hello $name!")&#125; @Preview@Preview注解的方法可以在不运行App的情况下就可以确认布局的情况。常用的参数: name: String: 为该Preview命名，该名字会在布局预览中显示。 showBackground: Boolean: 是否显示背景，true为显示。 backgroundColor: Long: 设置背景的颜色。 showDecoration: Boolean: 是否显示Statusbar和Toolbar，true为显示。 group: String: 为该Preview设置group名字，可以在UI中以group为单位显示。 fontScale: Float: 可以在预览中对字体放大，范围是从0.01。 widthDp: Int: 在Compose中渲染的最大宽度，单位为dp。 heightDp: Int: 在Compose中渲染的最大高度，单位为dp。上面的参数都是可选参数，还有像背景设置等的参数并不是对实际的App进行设置，只是对Preview中的背景进行设置，为了更容易看清布局。1234567@Preview(showBackground = true,name = "Text UI",backgroundColor = 0xFF888888)@Composableprivate fun DefaultPreview() &#123; MyJetpackComposeTheme &#123; Greeting("Android") &#125;&#125; setContentsetContent的作用是和Layout/View中的setContentView是一样的。setContent的方法也是有@Compose注解的方法。所以，在setContent中写入关于UI的@Compopse方法，即可在Activity中显示。 1234567891011override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContent &#123; MyJetpackComposeTheme &#123; // A surface container using the 'background' color from the theme Surface(color = MaterialTheme.colors.background) &#123; Greeting("Android") &#125; &#125; &#125; &#125; Theme在创建新的Compose项目时会自动创建一个Theme.kt文件。 我们可以通过更改颜色来完成对主题颜色的设置。 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zm.myjetpackcompose.ui.themeimport androidx.compose.foundation.isSystemInDarkThemeimport androidx.compose.material.MaterialThemeimport androidx.compose.material.darkColorsimport androidx.compose.material.lightColorsimport androidx.compose.runtime.Composableprivate val DarkColorPalette = darkColors( primary = Purple200, primaryVariant = Purple700, secondary = Teal200)private val LightColorPalette = lightColors( primary = Purple500, primaryVariant = Purple700, secondary = Teal200 /* Other default colors to override background = Color.White, surface = Color.White, onPrimary = Color.White, onSecondary = Color.Black, onBackground = Color.Black, onSurface = Color.Black, */)@Composablefun MyJetpackComposeTheme(darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable() () -&gt; Unit) &#123; val colors = if (darkTheme) &#123; DarkColorPalette &#125; else &#123; LightColorPalette &#125; MaterialTheme( colors = colors, typography = Typography, shapes = Shapes, content = content )&#125; ModifierModifier是各个Compose的UI组件一定会用到的一个类。它是被用于设置UI的摆放位置，padding等信息的类。 padding 设置各个UI的padding1234Modifier.padding(10.dp) // 给上下左右设置成同一个值Modifier.padding(10.dp, 11.dp, 12.dp, 13.dp) // 分别为上下左右设值Modifier.padding(10.dp, 11.dp) // 分别为上下和左右设值Modifier.padding(InnerPadding(10.dp, 11.dp, 12.dp, 13.dp))// 分别为上下左右设值 plus 可以把其他的Modifier加入到当前的Modifier中。1Modifier.plus(otherModifier) // 把otherModifier的信息加入到现有的modifier中 fillMaxHeight、fillMaxWidth、fillMaxSize 类似于match_parent、填充整个父layout。1Modifier.fillMaxHeight() // 填充整个高度 width、heigh、size 设置Content的宽度和高度。123Modifier.width(2.dp) // 设置宽度Modifier.height(3.dp) // 设置高度Modifier.size(4.dp, 5.dp) // 设置高度和宽度 复制代码 widthIn, heightIn, sizeIn 设置Content的宽度和高度的最大值和最小值。123Modifier.widthIn(2.dp) // 设置最大宽度Modifier.heightIn(3.dp) // 设置最大高度Modifier.sizeIn(4.dp, 5.dp, 6.dp, 7.dp) // 设置最大最小的宽度和高度 gravity 在Column中元素的位置。123Modifier.gravity(Alignment.CenterHorizontally) // 横向居中Modifier.gravity(Alignment.Start) // 横向居左Modifier.gravity(Alignment.End) // 横向居右 rtl、ltr 开始布局UI的方向。123456789Modifier.rtl // 从右到左Modifier.ltr // 从左到右Modifier的方法都返回Modifier的实例的链式调用，所以只要连续调用想要使用的方法即可。@Composablefun Greeting(name: String) &#123; Text(text = "Hello $name!", modifier = Modifier.padding(20.dp).fillMaxSize())&#125; Column，Row Column 线性布局 ≈ Android LinearLayout-VERTICALRow 水平布局 ≈ Android LinearLayout-HORIZONTAL Column和Row可以理解为在View/Layout体系中的纵向和横向的ViewGroup。 Modifier 用上述的方法传入已经按需求设置好的Modifier即可。 Arrangement.Horizontal, Arrangement.Vertical 需要给Row传入Arrangement.Horizontal，为Column传入Arrangement.Vertical。 这些值决定如何布置内部UI组件。可传入的值为Center, Start, End, SpaceEvenly, SpaceBetween, SpaceAround。 Alignment.Vertical, Alignment.Horizontal 需要给Row传入Alignment.Vertical，为Column传入Alignment.Horizontal。 使用方法和Modifier的gravity中传入参数的用法是一样的. @Composable ColumnScope.() -&gt; Unit 需要传入标有@Compose的UI方法。但是这里我们会有lamda函数的写法来实现。12345Column &#123; Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceAround, verticalAlignment = Alignment.CenterVertically) &#123; Text(text = "Hello $name!") &#125; &#125; Box帧布局≈Android FrameLayout，可将一个元素放在另一个元素上，如需在 Row 中设置子项的位置，请设置 horizontalArrangement 和 verticalAlignment 参数。对于 Column，请设置 verticalArrangement 和 horizontalAlignment 参数 ConstraintLayout需要引入implementation &quot;androidx.constraintlayout:constraintlayout-compose:1.0.0-beta02&quot; 列表 可以滚动的布局 12345678//我们可以使用 verticalScroll() 修饰符使 Column 可滚动，但以上布局并无法实现重用，可能导致性能问题 Column( modifier = Modifier.verticalScroll(rememberScrollState()) ) &#123; messages.forEach &#123; message -&gt; MessageRow(message) &#125; &#125; LazyColumn/LazyRow == RecylerView/listView 列表布局，解决了滚动时的性能问题，LazyColumn和LazyRow之间的区别就在于它们的列表项布局和滚动方向不同。 内边距 12345LazyColumn( contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp), ) &#123; // ... &#125; item间距 12345LazyColumn( verticalArrangement = Arrangement.spacedBy(4.dp), ) &#123; // ... &#125; 浮动列表的浮动标题，使用 LazyColumn 实现粘性标题，可以使用stickyHeader()函数 123456789101112@Composable fun ListWithHeader(items: List&lt;Item&gt;) &#123; LazyColumn &#123; stickyHeader &#123; Header() &#125; items(items) &#123; item -&gt; ItemRow(item) &#125; &#125; &#125; 网格布局LazyVerticalGrid 12345678910@Composablefun PhotoGrid(photos: List&lt;Photo&gt;) &#123; LazyVerticalGrid( cells = GridCells.Adaptive(minSize = 128.dp) ) &#123; items(photos) &#123; photo -&gt; PhotoItem(photo) &#125; &#125;&#125; 自定义布局通过重组基础布局实现Canvas绘制123456789101112Canvas(modifier = Modifier.fillMaxSize()) &#123; val canvasWidth = size.width val canvasHeight = size.height //drawCircle 画圆 //drawRectangle 画矩形 //drawLine //画线 drawCircle( color = Color.DarkGray, center = Offset(x = canvasWidth / 2, y = canvasHeight / 2), radius = size.minDimension / 4 ) &#125; 结束语 Compose整体来看，布局实现上相对于xml更加简单高效，也是官方日后力推的开发方式。 Compose写法与Flutter代码上有很高的相似之处，都是通过响应式的快速搭建UI布局。（PS：响应式的UI开发模式在大前端的各个语言中越来越相似了） 参考文献https://developer.android.com/jetpack/compose]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alfred进阶教程，自定义Workflows]]></title>
    <url>%2Fposts%2Ffa126efb.html</url>
    <content type="text"><![CDATA[在上一篇《Mac装机必备-Alfred的基础使用教程》中，已为大家介绍了Alfred的基础功能。其实除了Alfred已有的功能外，Alfred还支持用户自定义工作流。 通过设置好触发器、输入、操作、实用程序、输出，就可以自由搭建工作流。在本教程中，我将创建一个简单的热键工作流，用来一键启动我每天多次使用的一些应用程序和网页。 进入Alfred的偏好设置中的workflows*标签页，点击左下角的“+”，然后选择Templates &gt; Files and Apps &gt; Launch file group from hotkey*，创建一个用热键打开的工作流。 然后为你的工作流编辑名称、图标等信息，便于识别。（图标可以直接拖入） 编辑完成后，点击右下角的Save即可创建出一个名为work的工作流。左边图标是热键，右边图标是你要创建的动作。 双击左边图标，打开热键设置窗口，选中输入框，直接在键盘上键入你想要设置的热键，然后保存。 双击右侧图标，打开动作设置窗口，你可以选择一次启动多个Mac软件或文件夹，比如我想要一次打开AndroidStudio、Safari、Sourcetree三个应用程序，直接将它们拖入此窗口即可。 Alfred除了能设置打开多个Mac软件外，还可以设置打开多个网页。比如我们想同时打开马可菠萝网站，可以在窗口任意位置右键，选择Actions &gt; Open URL。 在弹窗中将马可菠萝的网址 https://zhangmiao.cc/ 复制粘贴进去，并选好默认浏览器，保存即可。 最后再把这个新的动作链接到热键的后面，即完成打开马可菠萝网站的设置了。 了解Alfred的工作流程，能够帮助你轻松完成各种重复任务，让你以前所未有的方式在Mac上提高效率！]]></content>
      <categories>
        <category>Mac</category>
        <category>Alfred</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac装机必备Alfred]]></title>
    <url>%2Fposts%2Fd083e6c8.html</url>
    <content type="text"><![CDATA[安装Alfred 快捷键设置为了快速打开Alfred，我们需要为它设置一个快捷键，打开Alfred偏好设置的General选项卡，选中Alfred Hotkey输入框，直接使用键盘键入你喜欢的快捷键即可。 我使用的alt+空格键，当初设置时，由于这个快捷键被Mac系统的Spotlight占用了，无法设置成功。如遇到相同的情况，需要先到系统偏好设置-键盘-快捷键-聚焦中取消勾选alt+空格键打开“聚焦”搜索的设置，然后再返回到Alfred中设置即可。 自定义外观进入Appearance选项卡，Alfred为我们提供了几种外观样式，如果你都不喜欢，也可以自定义外观。点击左下角的“+”，创建你的专属样式。通过双击相应的组件，即可打开系统的调色器，可以自由的搭配自己喜欢的颜色。 进入Features选项卡，在左侧列表中，罗列的是Alfred的基础功能，包括默认搜索、文件搜索、网页搜索、网页书签、计算器、字典、联系人、剪贴板、iTunes、系统操作、终端等。 默认搜索（Default Results） Essentials和Extras设置我们的搜索类型，可以设置搜索应用程序、联系人、偏好设置、文件夹、文本文件、压缩文件、文档、图片、脚本等。 Unintelligent建议不要勾选，会影响我们的搜索速度以及搜索结果。 Search Scope可以设置Alfred的搜索范围，点击右上角的”+”，可以添加其他的搜索范围；或者选中某项，按Delete键移除该搜索范围。 文件搜索（File Search）默认搜索会搜索出所有类型的内容，包括邮件、联系人等其他内容，都是我根本不想搜索到的文件类型，这时就可以使用文件搜索，把一些不需要的类型过滤掉。 空格键 + 关键字：文件搜索 find + 关键字：打开文件所在的Finder in + 关键字：搜索文件内容中带有该关键字的文件 网页搜索（Web Search）这是小编使用频率最高的功能，有了它，再也不怕记不住网址了。Alfred中已经默认设置了很多国外的网站，但大多数都是用不上的，不需要的只要取消勾选就行。点击右下角的“Add Custom Search”，即可添加新的网站搜索。 比如添加马可菠萝网站，只要到马可菠萝的搜索页面随便搜索一个内容，然后复制结果页面的网址，把具体的内容改成{query}即可，关键字填写macbl，然后保存。 马可菠萝：https://www.macbl.com/search/{query} 百度：https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query} Dribbble：https://dribbble.com/search?q={query} 使用时，在Alfred中输入 macbl Alfred，按回车键即可打开马可菠萝搜索页面，找到Alfred啦！ 剪贴板（Clipboard）剪贴板功能是我选择Alfred的主要原因，可以查看Alfred的所有剪贴历史记录，节省了重复操作的时间，非常强大 系统操作（System）用简单的命令，来控制系统操作，比如最常用的清空垃圾桶(enptytrash)，休眠(sleep)，强制退出应用程序(forcequit)等，快捷键都可以自由设置。]]></content>
      <categories>
        <category>Mac</category>
        <category>Alfred</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter完整学习路线解读]]></title>
    <url>%2Fposts%2F829f290.html</url>
    <content type="text"><![CDATA[前言Flutter 作为一门新的技术，确实相关的资料书籍不太多。但就 Flutter 生态的影响力而言，已经是越来越强了。譬如，在 StackOverflow 网站上2021年度最受欢迎的技术中，Dart 语言排在了第7位。随着谷歌对 Flutter 跨平台解决方案的推进，估计会有越来越多的开发者使用 Flutter 构建他们的应用。 学习线路思维导图先上一份思维导图，让大家有个整体认识。 Dart语言在学习 Dart 语言前，若没有任何编程基础，建议先了解一下计算机基础知识。Dart 作为一门现代化的面向对象编程语言，具备了市面上大多数编程语言的特点，具体来说会分为下面这些内容： 变量定义、赋值：这是最基础的部分，至少要知道什么是变量，如何赋值。final，var 和 const 的区别。 基本数学运算：加、减、乘、除、整除、取余等运算； 条件分支：if…else if…else 控制程序逻辑走向，或是 switch 分支； 循环：使用循环完成重复性的工作； 容器类：如List、Map 和 Set 的应用； 函数和参数：一个是使用函数编写可复用的逻辑处理代码，二是需要注意在 Dart 中函数也是对象。同时需要区分函数的命名参数、可选参数的使用； 面向对象编程：了解面向对象编程的概念和思想，能够合理地使用类来封装代码提高复用性和降低耦合； 继承、多态和抽象类：这是提高代码复用、降低代码耦合度十分重要的概念，建议是多看看一些源码和设计思想（如设计模式），然后在遇到复杂业务的时候先思考如何抽象和组织代码结构。 mixin：mixin 提供了一种更为灵活的代码复用方式，可以将功能组合到现有类中，从而避免了继承的一些缺点。 泛型：使用泛型来做工具类是再好不过的选择了，通过泛型可以一套代码处理多种数据类型。 Future：有点类似前端的 promise，通过 Future 可以让异步编程变得更加简单。 null safety：空安全现在基本上是高级语言的标配了。通过空安全可以让团队遵循同一个规范，提高了代码的健壮性。 Flutter组件作为一个合格的App 开发，能够将一个UI 界面还原出来是基本的要求。建议一开始需要熟悉Flutter框架提供的自带组件，然后可以通过自带的组件组合成为自己的自定义组件。这部分内容包括： 运行 Hello World 程序，跑通整个应用。 了解应用程序的结构，知道如何设计你的代码目录结构。 布局类组件：如 Container，SizedBox，Padding，Stack，ListView，GridView 等组件。 业务类组件：如 TextField，按钮，文本，图片，图标等组件。 自定义组件：利用布局类组件和业务类组件组合，构成自己的可复用的组件。 自有组件库：根据产品特性和公司需要，抽取复用的组件构成自有的组件库，从而提升整个公司的开发效率。 表单应用中，表单在界面中出现的频率很高。如何处理表单对开发效率的影响很大。建议可以一开始从简单的表单页面开始，例如登录页、注册页。然后再做一些复杂的表单页面，具体如下： 简单表单页面的实现：登录页、注册页、绑定手机号这类的页面； 不同表单的实现：例如普通文本、密码、数字、日期、单选、多选等表单的实现； 表单校验：封装表单校验库，将通用的校验规则放置在校验库中，比如长度、手机号校验、密码强度校验、日期格式校验等等。通过前端的提前校验可以避免后端请求压力，也能够提升用户体验。 表单封装：封装一套通用的表单组件，供整个团队复用，提高生产效率，也能减少 bug 的产生。 状态管理状态管理是 Flutter 的核心，如何处理数据实体、业务逻辑、界面之间的关系对代码的可维护性十分关键，而这都依赖于状态管理的实现。对于状态管理，建议按如下方式学习： 有状态组件和无状态组件的区别，可以阅读一下StatefulWidget 和 StatelessWidget的源码，会有更深刻的理解。 理解组件的渲染机制：虽然我们开发中很少关注组件如何渲染，但是当应用状态管理插件时，我们通过渲染机制能够知道状态数据更新时如何减少刷新的范围，实现局部刷新，从而提升性能。 主流状态插件应用：对比主流状态插件，从中选择一个合适自己团队的应用。对于长期用的状态管理插件，建议深入了解具体的实现机制，以便再遇到问题时能够快速定位，快速解决。 按需刷新：相比 setState 这种简单粗暴的全局更新，状态管理插件的一大优势就是可以实现局部刷新。通过按需刷新可以极大地提高页面的流畅度。 关于状态管理的内容，可以通过阅读下面两篇文章来进行了解： 🚩🚩🚩建议收藏Flutter状态管理插件哪家强？请看岛上码农的排行榜！Flutter 入门与实战（九十二）：状态管理系列大汇总 网络请求App 的业务功能开发，相当一部分工作是在与和后端对接口、联调接口。了解与后端的数据交互，封装好网络请求库非常重要。这里建议按如下的方式进行学习： JSON 数据的认识：这个其实很简单，基本上一看就明白。但更重要的是和后端约定返回数据的格式，避免每个接口的格式都不同，那样很难做统一封装。 JSON 数据转对象：曾几何时，我是直接拿 JSON 对象（实际已经转成 Map 了）的 key 去取所需的值的。结果遭受了惨痛的教训，比如后端问题变成 null 了会导致闪退。而且每次都需要敲 key的名称，编码效率极低。而将 JSON 数据转为对象，一方面是对象可以在整个工程里复用，二是可以通过对象属性访问，编码有提示。同时，可以应用 null safety 属性直接知道哪个属性是否可能为空。 RESTful接口调试：早期的接口都是 GET 和 POST 请求，但是其实语义上并不明确。建议是统一和后端约定使用 RESTful 风格接口。 Mock 数据：后端接口没出来之前，使用 Mock 数据来完成业务逻辑的模拟非常重要。建议 Mock 的数据获取接口和后端的接口保持一致（统一实现相同的接口），这样在后端接口就绪后可以直接切换接口实现类就可以了。 网络请求插件使用与封装：Flutter 目前最为流行的网络请求插件是 Dio，对应的封装版本有 Retrofit。建议不要上来一开始就有用封装好的版本。而是自己一个个调试，然后尝试自己封装，这样会更好地理解封装的过程。 Headers 和 Cookie：App 和浏览器不同，浏览器会自己管理Cookie。而 App 需要自己管理 Cookie。因此有必要了解如何设置请求头Headers，以及如何获取后端的 Cookie 并回写到Headers 里面。 响应式编程当你对界面、状态管理、网络请求都掌握差不多到时候，使用 Flutter 开发基本的 App 就基本没问题了。这个时候需要考虑应用结构如何优化。对于Dart 而言，提供了 Stream 和 StreamListener 这样的工具来通过流的方式驱动关联业务或界面更新，实现响应式编程。这里面典型的是 BLoC 模式 （BLoC 也可以用于状态管理）。了解一下 BLoC 的理念对设计整个应用程序框架十分有帮助。 动画当你掌握上述的基本技能后，你看到别人 App 的酷炫动效时肯定心痒痒，想自己偶尔也能玩一下这类高大上的东西。这个时候就需要了解动画的实现了，Flutter 提供了很多动画构建方式，比如： 基础动画组件：例如 AnimatedContainer，AnimatedOpacity 等等，通过这些组件可以实现简单但有趣的动画。 动画复用：使用 AnimatedBuilder 可以构建可复用的动效。 动画曲线：Flutter 自带了很多动画曲线效果，如果不满足也可以实现自定义曲线。有了动画曲线，你就可以定义一些自己的动画过渡效果了。 动画插件：pub.dev上也提供了很多动画插件，例如Lottie 就可以将 AE 的动画转换为 Flutter 动画。如何查找动画插件，这需要懂得搜索，比如搜索关键字 Animation，或者经常逛一些技术社区，会让你的视野开拓很多，也许，不经意间就能发现一个酷炫的插件。 绘图当你的动画都能搞定的时候，你会发现产品和设计可能已经对你刮目想看了，这个时候他们提出的交互或者界面效果会提高（千万别觉得升级自己的技能是在给自己挖坑）。比如，可能会出一个奇怪的外形，然后需要你实现，这个时候就需要用到绘图了。绘图其实需要挺高的数学知识辅助的，你可能需要提前复习一下高等数学、线性代数知识😜😜😜 —— 所以大厂筛选学校和学历其实也有一定的道理的，这些筛选出来的人的基础知识一般都不会差。 ClipPath：自定义裁剪路径对于绘制有规律的形状来说可以轻松搞定，当然有些复杂的可能需要一些贝塞尔曲线知识。 CustomPaint和 Canvas：使用 CustomPaint 和 Canvas 可以随心所欲地绘图，包括你想搞个小游戏也行。但是，这个也是很烧脑的一环，说到底，数学真的很重要！ 计算机图形学（CG）：这算是绘图的理论支撑，有计算机图形学知识的支撑，会让你绘制自定义图形时候得心应手。 本地数据存储随着网络的升级，本地数据存储可能不像之前那么重要。但是，不论是对用户体验还是减轻后端压力都是必不可少的。譬如，微信就把整个个人的聊天记录存储在了本地 —— 既节省了服务器的存储空间和加载请求量，还能够对外宣称是“保护个人隐私”。本地存储主要有三个方面： 简单键值对的存储：可以存储一些配置信息、登录会话信息，避免反复从服务器读取。在 Flutter 通常是使用 SharedPreferences 实现。 文件存储：比如应用内下载的文件管理，日志文件等，可以使用文件管理实现。通常会使用到 path_provider 插件实现。 关系型数据库：移动端大部分都采用了 SQLite 数据库，SQLite 的数据库操作语法和 MySQL 这类的标准 SQL 基本一致，可以用于存储关系数据。在Flutter 中也有不少封装好的插件，比如 sqflite。 页面导航实际上页面导航在一开始就会用到，大部分情况下，自带的导航和路由管理都能够满足需求。对于路由可以按如下方式进阶： 自带路由的掌握：比如匿名路由，命名路由，路由传参，路由拦截等； 路由插件的应用：了解如 fluro、GetX 的路由管理的优缺点，选择使用自带的路由管理还是使用第三方插件。 2.0路由：这个如果是在 Web端的话建议了解一下，App 端个人感觉有点重，学习成本相对较高。当然，因为刚出来没多久，估计以后也会有简单易用的插件帮助我们使用。 自有插件如果你的公司业务条线比较多，也许此时已经成为公司大神的你会被邀请做基础设施建设，或者是你自己想为开源社区做做贡献，这个时候就需要构建自有插件或开源插件了。Flutter 提供了插件构建模板工程，你可以按步骤构建自有插件，然后供整个公司的各个业务条线使用，提高各个业务条线的生产力。 原生交互原生交互分为三个部分： Flutter为原生提供服务 Flutter 使用原生提供的接口 原生页面与 Flutter 页面之间的跳转 这块对于混编的应用来说是必不可少的，此时你的知识体系需要升级了，你需要学习安卓的 kotlin 开发，iOS 的 Swift 开发（呃，本来想一站式搞定，结果又绕回来了）。当然，到这个阶段，相信这些已经难不倒你了！ 应用发布恭喜你！你的应用可以在各大应用市场上架了！记得我的第一个应用在 AppStore过审的时候别提多兴奋了（之前被拒了好几次😂😂😂）！如何进行应用打包这个搜索一下就能搞定了，但是如何应对AppStore 每年都变的审查规则也是一场斗智斗勇的过程。 而安卓，如果搞定碎片化的操作系统分布也是头疼的一件事情。建议提前在应用内做应用统计，以及异常上报，避免发布后在用户机器上出现奇怪的问题。 后续技术永无止境，再往后，你可能会深入去做性能优化、应用架构设计。这些方面很大程度靠个人平时的积累，多输入新的知识，同时了解其他的应用框架和特性（不限于 Dart，比如 Java 的 Spring 框架，Web 端的 React、Vue）都会让你对当前的应用架构设计有新的认识。扩充视野和技术深度，也许你就是下一个 CTO 的人选💪🏻💪🏻💪🏻！！！]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter如何开发web端]]></title>
    <url>%2Fposts%2Fb683bca5.html</url>
    <content type="text"><![CDATA[flutter开发移动端与开发web端有些区别，开发移动端会涉及到各自原生系统里特有的一些内容，iOS端与Android通过插件的形式引入的项目当中，但不需要考虑响应式布局。而web端开发需要考虑到窗口的大小变化，需要考虑响应式布局。 开启对web开发的支持flutter开发要支持web，需要在命令行中输入以下命令打开支持的平台（以下列举了各个平台支持的命令行）： flutter config —enable-web-desktopflutter config —enable-windows-desktopflutter config —enable-macos-desktopflutter config —enable-linux-desktop 之后再次输入 flutter config检测开启的情况，如果检测到如下图所示则表示开启成功。 这时候可以创建项目了，创建的时候勾选Web选项即可。 web开发的注意事项支持响应式布局的控件A. MediaQuery响应式布局的本质是监听浏览器宽高的变化进而修改UI的样式，所以需要能够监听宽高的变化，此时可以使用MediaQuery控件。MediaQuery控件继承自InheritedWidget，通过MediaQuery.of(context).size的方式实时获取到浏览器宽高的变化，进而对全局的UI进行调整。 B. LayoutBuilderLayoutBuilder是MediaQuery的简化版本，可以实时监控父控件尺寸的变化（不是浏览器宽高的变化），进而对当前控件的UI进行调整。 C. AspectRatio这是一个指定宽高比例的控件，会随着浏览器宽度变化进行等比例缩小或者放大。如果要保证某个控件的宽高保持一致，则需要使用AspectRatio。 D. Flexible 与 ExpandedFlexible与Expanded是用在Row或者Column中的控件，前者可以用来控制控件在Row或者Column中占用的比例，后者则用来填充Row或者Column中剩余的空间。 E. FractionallySizedBox这是一个设置占位比例的控件，跟AspectRatio类似，可以设置占有父控件多大比例。 响应式布局支持的开源库A. responsive_framework这个库支持屏幕尺寸变化时对所用控件进行缩放控制或者进行实时UI调整，支持手机、平板、电脑尺寸的设置，使用方便。支持缩放控制是其最大亮点。 B. responsive_builder这个库支持屏幕尺寸的变化时对所有控件进行实时UI调整，并能检测移动端横竖屏变化。 引用开源库的注意点如果要做到开发web的时候也需要支持移动端，在引入开源库时要注意其支持的平台种类。如下图中支持的平台就包含了安卓、iOS、Linux、MacOS、Web以及windows。最好引入的开源库支持全平台。 参考资料：https://betterprogramming.pub/how-to-build-responsive-apps-with-flutter-widgets-review-b22c6dec6904https://medium.com/flutter-community/seven-things-you-should-know-before-starting-with-flutter-web-8e48555d819e]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter cached_network_image 图片加载流程分析]]></title>
    <url>%2Fposts%2Fa931c363.html</url>
    <content type="text"><![CDATA[使用组件CachedNetworkImage可以支持直接使用或者通过ImageProvider。 引入依赖 12dependencies: cached_network_image: ^3.1.0 执行flutter pub get，项目中使用 Import it 1import 'package:cached_network_image/cached_network_image.dart'; 添加占位图 12345CachedNetworkImage( imageUrl: "http://via.placeholder.com/350x150", placeholder: (context, url) =&gt; CircularProgressIndicator(), errorWidget: (context, url, error) =&gt; Icon(Icons.error), ), 进度条展示 123456CachedNetworkImage( imageUrl: "http://via.placeholder.com/350x150", progressIndicatorBuilder: (context, url, downloadProgress) =&gt; CircularProgressIndicator(value: downloadProgress.progress), errorWidget: (context, url, error) =&gt; Icon(Icons.error), ), 原生组件Image配合 1Image(image: CachedNetworkImageProvider(url)) 使用占位图并提供provider给其他组件使用 1234567891011121314CachedNetworkImage( imageUrl: "http://via.placeholder.com/200x150", imageBuilder: (context, imageProvider) =&gt; Container( decoration: BoxDecoration( image: DecorationImage( image: imageProvider, fit: BoxFit.cover, colorFilter: ColorFilter.mode(Colors.red, BlendMode.colorBurn)), ), ), placeholder: (context, url) =&gt; CircularProgressIndicator(), errorWidget: (context, url, error) =&gt; Icon(Icons.error),), 这样就可以加载网络图片了，而且，图片加载完成时，就被缓存到本地了，首先看下图片的加载流程 官网说了，它现在不包含缓存，缓存功能实际上是另一个库flutter_cache_manager中实现的 原理加载&amp;显示 这里我们仅梳理图片加载和缓存的主流程，对于一些其他分支流程，或无关参数不做过多分析 首先，页面上使用的构造函数接收了一个必传参数imageUrl，用于生成ImageProvider提供图片加载 1234567891011121314151617181920212223242526272829303132333435363738class CachedNetworkImage extends StatelessWidget&#123; /// image提供 final CachedNetworkImageProvider _image; /// 构造函数 CachedNetworkImage(&#123; Key key, @required this.imageUrl, /// 省略部分 this.cacheManager, /// ... &#125;) : assert(imageUrl != null), /// ... _image = CachedNetworkImageProvider( imageUrl, headers: httpHeaders, cacheManager: cacheManager, cacheKey: cacheKey, imageRenderMethodForWeb: imageRenderMethodForWeb, maxWidth: maxWidthDiskCache, maxHeight: maxHeightDiskCache, ), super(key: key); @override Widget build(BuildContext context) &#123; var octoPlaceholderBuilder = placeholder != null ? _octoPlaceholderBuilder : null; var octoProgressIndicatorBuilder = progressIndicatorBuilder != null ? _octoProgressIndicatorBuilder : null; /// ... return OctoImage( image: _image, /// ... ); &#125;&#125; 这里可以看到，构造函数初始化了一个本地变量_image 类型是CachedNetworkImageProvider，它继承ImageProvider提供图片加载，看下它的构造函数 123456789101112131415161718192021222324252627282930313233/// 提供网络图片加载Provider并缓存abstract class CachedNetworkImageProvider extends ImageProvider&lt;CachedNetworkImageProvider&gt; &#123; /// Creates an object that fetches the image at the given URL. const factory CachedNetworkImageProvider( String url, &#123; int maxHeight, int maxWidth, String cacheKey, double scale, @Deprecated('ErrorListener is deprecated, use listeners on the imagestream') ErrorListener errorListener, Map&lt;String, String&gt; headers, BaseCacheManager cacheManager, ImageRenderMethodForWeb imageRenderMethodForWeb, &#125;) = image_provider.CachedNetworkImageProvider; /// 可选cacheManager. 默认使用 DefaultCacheManager() /// 当运行在web时,cacheManager没有使用. BaseCacheManager get cacheManager; /// 请求url. String get url; /// 缓存key String get cacheKey; /// ... @override ImageStreamCompleter load( CachedNetworkImageProvider key, DecoderCallback decode);&#125; 它的构造函数调用了image_provider.CachedNetworkImageProvider的实例在_image_provider_io.dart中是加载的具体实现类 123456789101112131415161718192021222324252627282930313233343536373839404142/// IO implementation of the CachedNetworkImageProvider; the ImageProvider to/// load network images using a cache.class CachedNetworkImageProvider extends ImageProvider&lt;image_provider.CachedNetworkImageProvider&gt; implements image_provider.CachedNetworkImageProvider &#123; /// Creates an ImageProvider which loads an image from the [url], using the [scale]. /// When the image fails to load [errorListener] is called. const CachedNetworkImageProvider( this.url, &#123; /// ... &#125;) : assert(url != null), assert(scale != null); @override final BaseCacheManager cacheManager; /// ... @override Future&lt;CachedNetworkImageProvider&gt; obtainKey( ImageConfiguration configuration) &#123; return SynchronousFuture&lt;CachedNetworkImageProvider&gt;(this); &#125; /// 核心方法加载图片入口 @override ImageStreamCompleter load( image_provider.CachedNetworkImageProvider key, DecoderCallback decode) &#123; final chunkEvents = StreamController&lt;ImageChunkEvent&gt;(); /// 多图加载 return MultiImageStreamCompleter( codec: _loadAsync(key, chunkEvents, decode), chunkEvents: chunkEvents.stream, scale: key.scale, informationCollector: () sync* &#123; yield DiagnosticsProeperty&lt;ImageProvider&gt;( 'Image provider: $this \n Image key: $key', this, style: DiagnosticsTreeStyle.errorProperty, ); &#125;, ); &#125; 这里的load方法即是图片加载的启动入口，它会在页面可见时被调用 它返回了一个MultiImageStreamCompleter传入_loadAsync，看下这个方法 12345678910111213141516171819202122232425262728293031323334353637383940414243 /// 异步加载 Stream&lt;ui.Codec&gt; _loadAsync( CachedNetworkImageProvider key, StreamController&lt;ImageChunkEvent&gt; chunkEvents, DecoderCallback decode, ) async* &#123; assert(key == this); try &#123; /// 默认缓存管理器 var mngr = cacheManager ?? DefaultCacheManager(); assert( mngr is ImageCacheManager || (maxWidth == null &amp;&amp; maxHeight == null), 'To resize the image with a CacheManager the ' 'CacheManager needs to be an ImageCacheManager. maxWidth and ' 'maxHeight will be ignored when a normal CacheManager is used.'); /// 下载逻辑放在ImageCacheManager，得到下载stream var stream = mngr is ImageCacheManager ? mngr.getImageFile(key.url, maxHeight: maxHeight, maxWidth: maxWidth, withProgress: true, headers: headers, key: key.cacheKey) : mngr.getFileStream(key.url, withProgress: true, headers: headers, key: key.cacheKey); await for (var result in stream) &#123; if (result is FileInfo) &#123; var file = result.file; var bytes = await file.readAsBytes(); var decoded = await decode(bytes); /// 下载完成返回结果 yield decoded; &#125; &#125; &#125; catch (e) &#123; /// ... &#125; finally &#123; await chunkEvents.close(); &#125; &#125;&#125; 这里我们看到了默认缓存管理器cacheManager创建的地方，为DefaultCacheManager，那么它如何缓存的呢，后边再分析。 下载的逻辑也是放在了ImageCacheManager下了，返回结果是一个stream完成多图下载的支持，下载完成通过yield 返回给ui解码最终显示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273MultiImageStreamCompleter`支持多图加载继承自`ImageStreamCompleter/// An ImageStreamCompleter with support for loading multiple images.class MultiImageStreamCompleter extends ImageStreamCompleter &#123; /// The constructor to create an MultiImageStreamCompleter. The [codec] /// should be a stream with the images that should be shown. The /// [chunkEvents] should indicate the [ImageChunkEvent]s of the first image /// to show. MultiImageStreamCompleter(&#123; @required Stream&lt;ui.Codec&gt; codec, @required double scale, Stream&lt;ImageChunkEvent&gt; chunkEvents, InformationCollector informationCollector, &#125;) : assert(codec != null), _informationCollector = informationCollector, _scale = scale &#123; /// 显示逻辑 codec.listen((event) &#123; if (_timer != null) &#123; _nextImageCodec = event; &#125; else &#123; _handleCodecReady(event); &#125; &#125;, onError: (dynamic error, StackTrace stack) &#123; reportError( context: ErrorDescription('resolving an image codec'), exception: error, stack: stack, informationCollector: informationCollector, silent: true, ); &#125;); /// ... &#125; &#125; /// 处理解码完成 void _handleCodecReady(ui.Codec codec) &#123; _codec = codec; assert(_codec != null); if (hasListeners) &#123; _decodeNextFrameAndSchedule(); &#125; &#125; /// 解码下一帧并绘制 Future&lt;void&gt; _decodeNextFrameAndSchedule() async &#123; try &#123; _nextFrame = await _codec.getNextFrame(); &#125; catch (exception, stack) &#123; reportError( context: ErrorDescription('resolving an image frame'), exception: exception, stack: stack, informationCollector: _informationCollector, silent: true, ); return; &#125; if (_codec.frameCount == 1) &#123; // ImageStreamCompleter listeners removed while waiting for next frame to // be decoded. // There's no reason to emit the frame without active listeners. if (!hasListeners) &#123; return; &#125; // This is not an animated image, just return it and don't schedule more // frames. _emitFrame(ImageInfo(image: _nextFrame.image, scale: _scale)); return; &#125; _scheduleAppFrame(); &#125;&#125; 这里做了显示逻辑，和最终转化成flutter上帧的处理，_scheduleAppFrame完成发送帧的处理 下载&amp;缓存上边的mngr调用了ImageCacheManager中的getImageFile方法现在就到了flutter_cache_manager这个三方库当中，它是被隐式依赖的，文件是image_cache_manager.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586mixin ImageCacheManager on BaseCacheManager &#123; Stream&lt;FileResponse&gt; getImageFile( String url, &#123; String key, Map&lt;String, String&gt; headers, bool withProgress, int maxHeight, int maxWidth, &#125;) async* &#123; if (maxHeight == null &amp;&amp; maxWidth == null) &#123; yield* getFileStream(url, key: key, headers: headers, withProgress: withProgress); return; &#125; /// ... &#125; /// ...&#125;getFileStream`方法实现在子类`cache_manager.dart`文件中的`CacheManagerclass CacheManager implements BaseCacheManager &#123; /// 缓存管理 CacheStore _store; /// Get the underlying store helper CacheStore get store =&gt; _store; /// 下载管理 WebHelper _webHelper; /// Get the underlying web helper WebHelper get webHelper =&gt; _webHelper; /// 从下载或者缓存读取file返回stream @override Stream&lt;FileResponse&gt; getFileStream(String url, &#123;String key, Map&lt;String, String&gt; headers, bool withProgress&#125;) &#123; key ??= url; final streamController = StreamController&lt;FileResponse&gt;(); _pushFileToStream( streamController, url, key, headers, withProgress ?? false); return streamController.stream; &#125; Future&lt;void&gt; _pushFileToStream(StreamController streamController, String url, String key, Map&lt;String, String&gt; headers, bool withProgress) async &#123; key ??= url; FileInfo cacheFile; try &#123; /// 缓存判断 cacheFile = await getFileFromCache(key); if (cacheFile != null) &#123; /// 有缓存直接返回 streamController.add(cacheFile); withProgress = false; &#125; &#125; catch (e) &#123; print( 'CacheManager: Failed to load cached file for $url with error:\n$e'); &#125; /// 没有缓存或者过期下载 if (cacheFile == null || cacheFile.validTill.isBefore(DateTime.now())) &#123; try &#123; await for (var response in _webHelper.downloadFile(url, key: key, authHeaders: headers)) &#123; if (response is DownloadProgress &amp;&amp; withProgress) &#123; streamController.add(response); &#125; if (response is FileInfo) &#123; streamController.add(response); &#125; &#125; &#125; catch (e) &#123; assert(() &#123; print( 'CacheManager: Failed to download file from $url with error:\n$e'); return true; &#125;()); if (cacheFile == null &amp;&amp; streamController.hasListener) &#123; streamController.addError(e); &#125; &#125; &#125; unawaited(streamController.close()); &#125;&#125; 缓存判断逻辑在CacheStore提供两级缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class CacheStore &#123; Duration cleanupRunMinInterval = const Duration(seconds: 10); /// 未下载完成缓存 final _futureCache = &lt;String, Future&lt;CacheObject&gt;&gt;&#123;&#125;; /// 已下载完缓存 final _memCache = &lt;String, CacheObject&gt;&#123;&#125;; /// ... Future&lt;FileInfo&gt; getFile(String key, &#123;bool ignoreMemCache = false&#125;) async &#123; final cacheObject = await retrieveCacheData(key, ignoreMemCache: ignoreMemCache); if (cacheObject == null || cacheObject.relativePath == null) &#123; return null; &#125; final file = await fileSystem.createFile(cacheObject.relativePath); return FileInfo( file, FileSource.Cache, cacheObject.validTill, cacheObject.url, ); &#125; Future&lt;void&gt; putFile(CacheObject cacheObject) async &#123; _memCache[cacheObject.key] = cacheObject; await _updateCacheDataInDatabase(cacheObject); &#125; Future&lt;CacheObject&gt; retrieveCacheData(String key, &#123;bool ignoreMemCache = false&#125;) async &#123; /// 判断是否已缓存过 if (!ignoreMemCache &amp;&amp; _memCache.containsKey(key)) &#123; if (await _fileExists(_memCache[key])) &#123; return _memCache[key]; &#125; &#125; /// 未缓存的 已加入futureCache中的key直接返回 if (!_futureCache.containsKey(key)) &#123; final completer = Completer&lt;CacheObject&gt;(); /// 未加入的添加到futureCache unawaited(_getCacheDataFromDatabase(key).then((cacheObject) async &#123; if (cacheObject != null &amp;&amp; !await _fileExists(cacheObject)) &#123; final provider = await _cacheInfoRepository; await provider.delete(cacheObject.id); cacheObject = null; &#125; _memCache[key] = cacheObject; completer.complete(cacheObject); unawaited(_futureCache.remove(key)); &#125;)); _futureCache[key] = completer.future; &#125; return _futureCache[key]; &#125; /// ... /// 更新到数据库 Future&lt;dynamic&gt; _updateCacheDataInDatabase(CacheObject cacheObject) async &#123; final provider = await _cacheInfoRepository; return provider.updateOrInsert(cacheObject); &#125;&#125; _cacheInfoRepository缓存仓库是CacheObjectProvider使用的数据库缓存对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class CacheObjectProvider extends CacheInfoRepository with CacheInfoRepositoryHelperMethods &#123; Database db; String _path; String databaseName; CacheObjectProvider(&#123;String path, this.databaseName&#125;) : _path = path; /// 打开 @override Future&lt;bool&gt; open() async &#123; if (!shouldOpenOnNewConnection()) &#123; return openCompleter.future; &#125; var path = await _getPath(); await File(path).parent.create(recursive: true); db = await openDatabase(path, version: 3, onCreate: (Database db, int version) async &#123; await db.execute(''' create table $_tableCacheObject ( $&#123;CacheObject.columnId&#125; integer primary key, $&#123;CacheObject.columnUrl&#125; text, $&#123;CacheObject.columnKey&#125; text, $&#123;CacheObject.columnPath&#125; text, $&#123;CacheObject.columnETag&#125; text, $&#123;CacheObject.columnValidTill&#125; integer, $&#123;CacheObject.columnTouched&#125; integer, $&#123;CacheObject.columnLength&#125; integer ); create unique index $_tableCacheObject$&#123;CacheObject.columnKey&#125; ON $_tableCacheObject ($&#123;CacheObject.columnKey&#125;); '''); &#125;, onUpgrade: (Database db, int oldVersion, int newVersion) async &#123; /// ... return opened(); &#125; @override Future&lt;dynamic&gt; updateOrInsert(CacheObject cacheObject) &#123; if (cacheObject.id == null) &#123; return insert(cacheObject); &#125; else &#123; return update(cacheObject); &#125; &#125; @override Future&lt;CacheObject&gt; insert(CacheObject cacheObject, &#123;bool setTouchedToNow = true&#125;) async &#123; var id = await db.insert( _tableCacheObject, cacheObject.toMap(setTouchedToNow: setTouchedToNow), ); return cacheObject.copyWith(id: id); &#125; @override Future&lt;CacheObject&gt; get(String key) async &#123; List&lt;Map&gt; maps = await db.query(_tableCacheObject, columns: null, where: '$&#123;CacheObject.columnKey&#125; = ?', whereArgs: [key]); if (maps.isNotEmpty) &#123; return CacheObject.fromMap(maps.first.cast&lt;String, dynamic&gt;()); &#125; return null; &#125; @override Future&lt;int&gt; delete(int id) &#123; return db.delete(_tableCacheObject, where: '$&#123;CacheObject.columnId&#125; = ?', whereArgs: [id]); &#125;&#125; 可见数据库缓存的是CacheObject对象，保存了url、key、relativePath等信息 12345678910class CacheObject &#123; static const columnId = '_id'; static const columnUrl = 'url'; static const columnKey = 'key'; static const columnPath = 'relativePath'; static const columnETag = 'eTag'; static const columnValidTill = 'validTill'; static const columnTouched = 'touched'; static const columnLength = 'length';&#125; 没有缓存下调用了_webHelper.downloadFile方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130class WebHelper &#123; WebHelper(this._store, FileService fileFetcher) : _memCache = &#123;&#125;, fileFetcher = fileFetcher ?? HttpFileService(); final CacheStore _store; @visibleForTesting final FileService fileFetcher; final Map&lt;String, BehaviorSubject&lt;FileResponse&gt;&gt; _memCache; final Queue&lt;QueueItem&gt; _queue = Queue(); ///Download the file from the url Stream&lt;FileResponse&gt; downloadFile(String url, &#123;String key, Map&lt;String, String&gt; authHeaders, bool ignoreMemCache = false&#125;) &#123; key ??= url; if (!_memCache.containsKey(key) || ignoreMemCache) &#123; var subject = BehaviorSubject&lt;FileResponse&gt;(); _memCache[key] = subject; /// 下载或者加入队列 unawaited(_downloadOrAddToQueue(url, key, authHeaders)); &#125; return _memCache[key].stream; &#125; Future&lt;void&gt; _downloadOrAddToQueue( String url, String key, Map&lt;String, String&gt; authHeaders, ) async &#123; //如果太多请求被执行，加入队列等待 if (concurrentCalls &gt;= fileFetcher.concurrentFetches) &#123; _queue.add(QueueItem(url, key, authHeaders)); return; &#125; concurrentCalls++; var subject = _memCache[key]; try &#123; await for (var result in _updateFile(url, key, authHeaders: authHeaders)) &#123; subject.add(result); &#125; &#125; catch (e, stackTrace) &#123; subject.addError(e, stackTrace); &#125; finally &#123; concurrentCalls--; await subject.close(); _memCache.remove(key); _checkQueue(); &#125; &#125; ///下载资源 Stream&lt;FileResponse&gt; _updateFile(String url, String key, &#123;Map&lt;String, String&gt; authHeaders&#125;) async* &#123; var cacheObject = await _store.retrieveCacheData(key); cacheObject = cacheObject == null ? CacheObject(url, key: key) : cacheObject.copyWith(url: url); /// 请求得到response final response = await _download(cacheObject, authHeaders); yield* _manageResponse(cacheObject, response); &#125; Stream&lt;FileResponse&gt; _manageResponse( CacheObject cacheObject, FileServiceResponse response) async* &#123; /// ... if (statusCodesNewFile.contains(response.statusCode)) &#123; int savedBytes; await for (var progress in _saveFile(newCacheObject, response)) &#123; savedBytes = progress; yield DownloadProgress( cacheObject.url, response.contentLength, progress); &#125; newCacheObject = newCacheObject.copyWith(length: savedBytes); &#125; /// 加入缓存 unawaited(_store.putFile(newCacheObject).then((_) &#123; if (newCacheObject.relativePath != oldCacheObject.relativePath) &#123; _removeOldFile(oldCacheObject.relativePath); &#125; &#125;)); final file = await _store.fileSystem.createFile( newCacheObject.relativePath, ); yield FileInfo( file, FileSource.Online, newCacheObject.validTill, newCacheObject.url, ); &#125; Stream&lt;int&gt; _saveFile(CacheObject cacheObject, FileServiceResponse response) &#123; var receivedBytesResultController = StreamController&lt;int&gt;(); unawaited(_saveFileAndPostUpdates( receivedBytesResultController, cacheObject, response, )); return receivedBytesResultController.stream; &#125; Future _saveFileAndPostUpdates( StreamController&lt;int&gt; receivedBytesResultController, CacheObject cacheObject, FileServiceResponse response) async &#123; /// 根据路径创建file final file = await _store.fileSystem.createFile(cacheObject.relativePath); try &#123; var receivedBytes = 0; /// 写文件 final sink = file.openWrite(); await response.content.map((s) &#123; receivedBytes += s.length; receivedBytesResultController.add(receivedBytes); return s; &#125;).pipe(sink); &#125; catch (e, stacktrace) &#123; receivedBytesResultController.addError(e, stacktrace); &#125; await receivedBytesResultController.close(); &#125;&#125; 总结cached_network_image图片加载流程依赖ImageProvider，缓存和下载逻辑放在另一个库flutter_cache_manager下载文件在WebHelper中提供队列管理，依赖传入FileService做具体获取文件方便扩展默认实现HttpFileService，下载完成后路径保存在CacheObject保存在sqflite数据库]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京环球影城游玩攻略]]></title>
    <url>%2Fposts%2Fcf2918cf.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《批判性思维》随笔记]]></title>
    <url>%2Fposts%2F7bd80167.html</url>
    <content type="text"><![CDATA[Why?然而在这样一个信息过载的时代里，形形色色的声音与观点鱼龙混杂。生活在信息洪流中的我们，应该如何避免随波逐流，做到真正的独立思考？ 或许可以了解一下“CriticalThinking”——「批判性思维」。 What?批判性思维是以一种合理的、反思的、心灵开放的方式进行思考，从而能够清晰准确地表达、逻辑严谨地推理、合理地论证，以及培养思辨精神。 在批判性思维的情感倾向方面，科南特(J．Kurland)于1995年提出：批判性思维与过分情感主义、智力懒惰和封闭思维相反，它关注证据、智力、诚实和开放思维。因此批判性思维强调依靠证据而非情感，全面考虑各种可能的观点和解释，警惕个人动机和偏见的影响，更关注寻求真理，不拒绝非流行的观点，意识到自己的偏见、歧视，自觉避免或减少这些偏见对判断的影响。此外，具有批判性思维并不意味着总是对任何人和任何事持否定态度和吹毛求疵，批判精神意味着敏锐的思维、好奇的探究、对推理的热情、对可靠信息的渴望。 How?当我们面对外界信息或是他人的论证时，可以在脑海里思考这些问题： 准确地说, 它的中心议题和观点是什么？ 我全部同意、部分同意还是不认同它的观点？为什么？ 它的结论实际上是建立在某种假设上吗？如果是，这假设合理吗？ 它的结论是否仅在某些条件下有效，如果是，那是什么？ 我需要限定或解释论述中的关键词语的意思吗？ 什么样的理由支持我采取这样的立场？ 对方会用什么样的理由来反驳或削弱我的立场？ 我该怎样承认或反驳他们的观点？ 当我们需要表达自己的观点、建构自己的论证时，可以遵循以下的方法： 确定问题，理清概念，有目的性思考； 针对这个问题，明确有哪些不同角度的论点和看法（这些角度有何不同？是否存在相应的理论或框架？如何利用这些不同的观点来解释问题？）； 从不同的角度、正反两方面来评估论点和论据（信息是否可靠？是否切题、相关？是否充足，是否存在偏见或不合理的隐含假设等）； 综合不同角度的思考，得出自己的结论（并反思自己的理由是否相关、充足？是否存在偏见？有何优势和劣势等）。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter 2.5 重大改版发布]]></title>
    <url>%2Fposts%2F1a5e05d8.html</url>
    <content type="text"><![CDATA[原文链接 medium.com/flutter/wha… Flutter 2.5 是 Flutter 版本历史上排名第二的大版本更新，该版本： 关闭了 4600 个 issues； 合并了 252 contributors 和 216 reviewers 的 3932 个 PR； 回顾过去一年，可以看到有 1337 位 contributors 创建了 21,072 个 PR 这样庞大的数据，其中有15,172 个被合并。 事实上该版本依然是对性能和开发工具进行了改进，同时还有增加许多新功能，包括： 对 Android 的全屏支持、更多 Material You（也称为 v3）支持； 更新文本编辑功能以支持可切换的键盘快捷键； Widget Inspector 可查阅更多详细信息； Visual Studio Code 项目中对添加依赖项增加新的支持； IntelliJ/Android Studio 中新增测试运行获取覆盖率信息； 一个全新的应用程序模板，为 Flutter 应用程序提供更好的开发基础； 性能：iOS 着色器预热、异步任务、GC 和消息传递#25644 中的第一个 PR 就是用于离线训练运行 Metal 着色器预编译，如基准测试所示，它将最坏情况的帧光栅化时间减少了 2/3 秒，将第 99 个百分位帧减少了一半。 然而着色器预热只是卡顿的来源之一，在之前的版本处理来自网络、文件系统、插件或其他 isolate 的异步事件都可能会中断动画，这是另一个卡顿的来源。 所以 #25789 改进了调度策略，在此版本 isolate 的 UI 事件循环里，帧处理现在优先于处理其他异步事件，从而在测试中消除了此类的卡顿。 另一个导致卡顿的原因是垃圾收集器 (GC) 暂停 UI 线程以回收内存。 以前某些图像的内存在响应 Dart VM 的 GC 执行时会延迟回收，作为早期版本中的解决方法，Flutter 引擎会通过 Dart VM 的 GC 回收暗示图像内存可以回收，这在理论上可以实现了更及时的内存回收。 不幸的是这也导致了太多的主要 GC，并且有时仍然无法足够快地回收内存，以避免内存受限设备上的低内存情况，而在这个版本中未使用的图像的内存被急切地回收（#26219、#82883、#84740），大大减少了 GC。 例如在一项测试用例中，播放 20 秒动画 GIF 从需要 400 多次 GC 变为只需要 4 次，更少的主要 GC 意味着涉及图像出现和消失的动画将减少卡顿，并消耗更少的 CPU 和功率。 Flutter 2.5 的另一个性能改进是在 Dart 和 Objective-C/Swift (iOS) 或 Dart 和 Java/Kotlin (Android) 之间发送消息时的延迟。 通常作为调整 消息频道的一部分，从消息编解码器中删除不必要的副本可将延迟减少高达 50% ，当然具体取决于消息大小和设备（#25988，#26331）。 你可以在此链接获取到更多关于平台通道性能的信息： medium.com/flutter/imp… Dart 2.14：格式、语言特性、发布和 linting 开箱即用此版本的 Flutter 和 Dart 2.14 一起发布。 新版本的 Dart 带有新的格式，使级联 更加清晰，新的 pub 支持忽略文件，以及新的语言功能，包括三重移位运算符的回归。 此外 Dart 2.14 创建了一组标准的 lint，在新的 Dart 和 Flutter 项目之间共享，开箱即用。 开发者不仅会在创建新的 Dart 或 Flutter 项目时获得这些 lint，而且只需几个步骤就可以将相同的分析添加到现有应用程序中。 合并迁移lint：flutter.dev/docs/releas… 有关这些 lint 的详细信息、新语言功能等，请查看 medium.com/dartlang/an… Framework：Android 全屏、Material You &amp; 文本编辑快捷方式从 #81303 开始, 我们修复了 Android 一系列与全屏模式相关的问题，此更改还添加了一种在其他模式下收听全屏更改的方法。 例如用户与应用互动时，当系统 UI 返回时，开发人员现在可以编写代码在返回全屏时执行其他操作。 新的 Android 全屏模式：普通模式（左）、边到边模式（中）、带有自定义 SystemUIOverlayStyle 的边到边（右） 在此版本中，我们对新 Material You（又名 v3）的规范增加了支持，包括对浮动操作按钮大小和主题的更新（#86441），在MaterialState.scrolledUnder 可以使用 Demo 中的示例代码查看的新状态 PR 式例 ( #79999 )。 新的 MaterialState.scrolledUnder 状态在起作用 另一个改进是添加了 scroll metrics notifications（#85221、#85499），即使用户没有滚动，它也会提供可滚动区域的通知，例如下面显示了 ListView 根据的基础大小适当地出现或消失滚动条： 在这种情况下不必编写任何代码，但如果想捕获 ScrollMetricNotification 更改，则可以通过此监听来完成。 特别感谢社区贡献者xu-baoolin，他为此付出了努力并提出了一个很好的解决方案。 另一个出色的社区贡献是为 ScaffoldMessenger ， 你可能还记得 Flutter 2.0 开始 ScaffoldMessenger 作为一个更强大的方式来显示 SnackBars ， 在屏幕的底部为用户提供通知，而在 Flutter 2.5 中，现在可以在 Scaffold 的顶部添加一个横幅，该横幅会一直保持到用户关闭它为止。 应用程序可以通过调用以下 showMaterialBanner 方法来获得此行为 ScaffoldMessenger ： 1234567891011121314151617181920212223242526272829class HomePage extends StatelessWidget &#123; const HomePage(&#123;Key? key&#125;) : super(key: key); @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar( title: const Text('The MaterialBanner is below'), ), body: Center( child: ElevatedButton( child: const Text('Show MaterialBanner'), onPressed: () =&gt; ScaffoldMessenger.of(context).showMaterialBanner( MaterialBanner( content: const Text('Hello, I am a Material Banner'), leading: const Icon(Icons.info), backgroundColor: Colors.yellow, actions: [ TextButton( child: const Text('Dismiss'), onPressed: () =&gt; ScaffoldMessenger.of(context) .hideCurrentMaterialBanner(), ), ], ), ), ), ), );&#125;复制代码 Material 指南规定 开发者的应用横幅一次只能显示一个，因此如果你调用多次 showMaterialBanner，ScaffoldMessenger 它将维护一个队列，在前一个横幅已被关闭之后，再显示一个新横幅。 感谢 Calamity210 对 Flutter 中的 Material 支持做出了如此出色的补充！ 在此版本中，我们添加了文本编辑键盘快捷键可覆盖的功能 #85381，这是在 Flutter 2.0 及其新的文本编辑功能的基础上进一步构建，例如文本选择以及能够在处理键盘事件后停止它的传播。 如果您希望 Ctrl-A 执行一些自定义操作而不是选择所有文本。 DefaultTextEditingShortcuts 类包含每个平台上受支持的键盘快捷键列表，如果开发者想覆盖任何内容，可以使用 Flutter 的现有 Shortcuts 将任何快捷方式重新映射到现有或自定义意图。 API 参考: api.flutter.dev/flutter/wid… 插件：相机、图像选择器和 plus 插件另一个具有有很多改进的插件是相机插件： #3795 [相机] android-rework 第 1 部分：支持 Android 相机功能的基类 #3796 [相机] android-rework 第 2 部分：Android 自动对焦功能 #3797 [camera] android-rework part 3：Android曝光相关功能 #3798 [相机] android-rework 第 4 部分：Android 闪光和变焦功能 #3799 [相机] android-rework 第 5 部分：Android FPS 范围、分辨率和传感器方向功能 #4039 [相机] android-rework 第 6 部分：Android 曝光和焦点功能 #4052 [camera] android-rework part 7：Android降噪功能 #4054 [相机] android-rework 第 8 部分：最终实现的支持模块 #4010 [camera] 在 iOS 上不触发设备方向 #4158 [相机] 修复坐标旋转以在 iOS 上设置焦点和曝光点 #4197 [相机] 修复相机预览并不总是在方向改变时重建 #3992 [camera] 设置不受支持的 FocusMode 时防止崩溃 #4151 [camera] 引入camera_web包 image_picker 插件 也做了很多工作，专注于端到端的相机体验： #3898 [image_picker] 图像选择器修复相机设备 #3956 [image_picker] 将相机捕获的存储位置更改为 Android 上的内部缓存，以符合新的 Google Play 存储要求 #4001 [image_picker] 删除了对相机权限的冗余请求 #4019 [image_picker] 当相机是 source 时修复旋转 这项工作改进了 Android 的相机和 image_picker 插件的功能和稳健性。 此外你会注意到 摄像头插件 的早期版本可用于网络支持 ( #4151 )。 此预览为在 Web 上查看相机预览、拍照、使用闪光灯和缩放控件提供基本支持，它目前还不是被认可的插件，因此您需要明确添加它以在才能在 web 中使用。 详细内容: pub.dev/packages/ca… 在此版本的 Flutter 中，Flutter 团队的每个相应插件现在都带有一个类似 电池 的建议： 此外，由于这些插件不再被积极维护，它们不再被标记为 Flutter 最喜欢的插件，我们建议使用以下插件的 plus 版本： Flutter DevTools：性能、Widget 检查器和 Polish首先最重要的是 DevTools 中增加利用引擎更新的支持（#26205、#26233、#26237、#26970、#27074、#26617）。 其中一组更新使 Flutter 能够更好地将跟踪事件与特定框架相关联，这有助于开发人员确定框架可能超出预算的原因。 可以在 DevTools Frames 图表中看到这一点，该图表已被重建为“实时”，可以在应用程序呈现时填充在此图表中，从此图表中选择一个帧导航到该帧的时间线事件： Flutter 引擎现在还可以识别时间线中的着色器编译事件，Flutter DevTools 使用这些事件来帮助诊断应用程序中的着色器编译卡顿。 借助这项新功能，DevTools 会检测何时因着色器编译丢失帧，以便可以解决卡顿问题。 在 flutter run 时与 --purge-persistent-cache 标志一起使用，这会清除缓存以确保重现用户在 “首次运行” 或 “重新打开” (iOS) 体验中看到的环境。 此功能仍在开发中，如果有任何问题，可以查阅：b.corp.google.com/issues/new?… 此外跟踪应用程序中的 CPU 性能问题时，可能会被来自 Dart 和 Flutter 库或引擎本机代码的分析数据淹没，如果想关闭其中任何一个以专注于您自己的代码，您可以使用新的 CPU Profiler 功能 #3236 来实现，该功能可以从这些来源中隐藏分析器信息。 对于没有过滤掉的任何类别，它们现在已经进行了颜色编码（#3310、#3324），以便可以轻松查看 CPU 帧图表来自系统的哪些部分。 彩色框架图，用于识别应用中的应用、原生、Dart 和 Flutter 代码活动 性能并不时调试的唯一因素，此版本的 DevTools 附带了对 Widget Inspector 的更新，允许将鼠标悬停在 Widget 时评估对象、视图属性、小部件状态等。 而当选择一个 Widget 时，它会自动填充在新的小部件检查器控制台中，这样就可以在其中浏览 Widget 的属性。 在断点处暂停时还可以从控制台计算表达式。 除了新功能外 Widget Inspector 还进行了翻新，为了让 DevTools 成为了解和调试 Flutter 应用程序的更有用，我们与芬兰的一家创意技术机构Codemate合作进行了一些更新。 在此屏幕截图中可以看到以下更改： 更好地传达调试切换按钮的作用——这些按钮具有新图标、面向任务的标签，以及描述它们的作用和何时使用它们的丰富工具提示，每个工具提示进一步链接到该功能的详细文档。 更容易扫描和定位感兴趣的 Widgets——Flutter 框架中常用的 Widget 现在在检查器左侧的 Widget 树视图中显示图标，它们根据类别进一步进行颜色编码，例如布局 Widget 显示为蓝色，而内容Widget 显示为绿色。此外每个文本 Widget 现在显示其内容的预览。 对齐布局资源管理器和小部件树的配色方案- 现在可以更轻松地从布局资源管理器和 Widget 树中识别相同的 Widget。例如屏幕截图中的“列” Widget 位于布局浏览器中的蓝色背景上，并且在 Widget 树视图中具有蓝色图标。 IntelliJ/Android Studio：集成测试、测试覆盖率和图标预览Flutter 的 IntelliJ/Android Studio 插件在此版本中也进行了许多改进，首先是运行集成测试的能力 ( #5459 )。 集成测试是在设备上运行的整个应用程序测试，位于 integration_test 目录中，并使用与testWidgets() 单元测试相同的功能。 要将集成测试添加到项目，请 按照 flutter.dev 上的说明进行操作，要将测试与 IntelliJ 或 Android Studio 连接，请添加启动集成测试的运行配置并连接设备以供测试使用，运行配置可以让开发者运行测试，包括设置断点、步进等。 此外，Flutter 最新的 IJ/AS 插件允许查看单元测试和集成测试运行的覆盖率信息，可以从“调试”按钮旁边的工具栏按钮访问它： 覆盖信息在编辑器的装订线中使用红色和绿色条显示，在这个例子中第 9-13 行被测试，但第 3 和 4 行没有被测试。 最新版本还包括预览来自 pub.dev 包中使用的图标的新功能，这些包是围绕 TrueType 字体文件（#5504、#5595、#5677、#5704）构建的，就像 Material 和 Cupertino 图标支持预览一样。 要启用图标预览，您需要告诉插件您正在使用哪些软件包，settings/preferences 中有一个新的文本字段： 请注意，如屏幕截图中的示例代码所示，此设置仅适用于在类中定义为静态常量的图标，它不适用于表达式，例如 LineIcons.addressBook() or LineIcons.values[&#39;code&#39;] 。 Visual Studio Code：依赖项、Fix All 和 Test RunnerFlutter 的 Visual Studio Code 插件也在此版本中得到了改进，两个新命令 “Dart: Add Dependency” and “Dart: Add Dev Dependency” (#3306, #3474)。 这些命令提供的功能类似于Jeroen Meijer 的 Pubspec Assist 插件，新命令开箱即用，并提供定期从 pub.dev 获取的包类型过滤列表。 开发者可能还对适用于 Dart 文件的“Fix All”命令（#3445、#3469）感兴趣，并且可以一步修复所有与dart fix相同的问题。 这也可以通过添加 source.fixAll 到 editor.codeActionsOnSave 的 VS Code 设置来设置为在保存时运行，或者想尝试预览功能，可以启用该 dart.previewVsCodeTestRunner 设置并查看通过新的 Visual Studio Code 测试运行程序运行的 Dart 和 Flutter 测试。 Visual Studio Code 测试运行器看起来与当前的 Dart 和 Flutter 测试运行器略有不同，它将跨会话保留结果。Visual Studio Code 测试运行器还添加了新的装订线图标，显示测试的最后状态，可以单击以运行测试（或右键单击以获取上下文菜单）。 在即将发布的版本中，现有的 Dart 和 Flutter 测试运行器将被移除，以支持新的 Visual Studio Code 测试运行器。 工具：异常、新应用模板和 Pigeon 1.0在此版本中，调试器现在可以在未处理的异常上正确中断，而这些异常以前时被 framework 捕获 ( #17007 )。 这改善了调试体验，因为调试器现在可以直接指向他们在代码中的抛出行，而不是指向框架深处的随机行。 一个相关的新功能使开发者能够决定 FutureBuilder 是否应该重新抛出或吞下错误 (#84308），这应该会为开发者提供大量额外的例外情况，以帮助追踪 Flutter 应用程序中的问题。 自 Flutter 诞生以来，就出现了 Counter 应用模板，它具有许多优点： 它展示了 Dart 语言的许多特性； 展示了几个关键的 Flutter 概念，并且它足够小； 可以放入单个文件中，即使有很多的解释性评论； 然而它没有为Flutter 应用程序提供一个特别好的起点，在此版本中，通过以下命令提供了一个新模板 ( #83530 )： 1$ flutter create -t skeleton my_app 骨架模板生成一个遵循社区最佳实践的两页列表视图，它的开发经过大量内部和外部审查，为构建生产质量应用程序提供了更好的基础，并支持以下功能： 用于 ChangeNotifier 协调多个 Widget 默认情况下使用 arb 文件生成本地化 包括示例图像并为图像资产建立 1x、2x 和 3x 文件夹 使用“功能优先”的文件夹组织 支持共享首选项 支持明暗主题 支持多页面间导航 随着时间的推移，随着 Flutter 最佳实践的发展预计这个新模板也会随之发展。 另一方面，如果你正在开发插件而不是应用程序，那么可能会对 Pigeon 的 1.0 版本感兴趣。 Pigeon 是一个代码生成工具，用于在 Flutter 及其主机平台之间生成类型安全的互操作代码，它允许定义插件 API 的描述，并为 Dart、Java 和 Objective-C（分别可用于 Kotlin 和 Swift）生成框架代码。 Flutter 团队的一些插件中已经使用了 Pigeon，在此版本中它提供了更多有用的错误消息，增加了对泛型、原始数据类型作为参数和返回类型以及多个参数的支持，预计开发者将来会更频繁地使用它。 重大更改和弃用以下是 Flutter 2.5 版本中的重大变化： 默认拖动滚动设备 在 v2.2 之后删除了弃用的 API 引入包：flutter_lints ThemeData 的 accent 属性已被弃用 GestureRecognizer Cleanup 用 collate 替换 AnimationSheetBuilder.display 使用 HTML 插槽在 Web 中呈现平台视图 将 LogicalKeySet 迁移到 SingleActivator 随着继续更新 Flutter Fix（在您的 IDE 中和通过dart fix命令可用），总共有 157 条规则来自动迁移受这些或过去的重大更改以及任何弃用影响的代码。 此外随着 Flutter 2.5 的发布，我们将弃用2020 年 9 月宣布的对 iOS 8 的支持。放弃对市场份额不到 1% 的 iOS 8 的支持，使 Flutter 团队能够专注于更广泛使用的新平台，弃用意味着这些平台可以工作，但我们不会在这些平台上测试 Flutter 的新版本或插件。 您可以在 flutter.dev 上查看当前支持的 Flutter 平台列表: flutter.dev/docs/develo…]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[能量层级（正/负）]]></title>
    <url>%2Fposts%2F4caf75c5.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GooglePlay新增付款功能一览表]]></title>
    <url>%2Fposts%2F5fd712a2.html</url>
    <content type="text"><![CDATA[随着移动行业全球化，Google Play 也陆续加入各种不同的付款方式，让用户可以选择喜好的付款方式。请注意，Google Play 帐号的国家/地区设置会影响能选择的付款方式。 如果要更改国家/地区，您需要在 Google Play 中设置一个新的国家/地区。要设置新的国家/地区，用户必须位于相应国家/地区，并且在新的国家/地区有受支持的付款方式。 请注意: 您每年只能更改一次 Play 国家/地区设置。因此，如果您更改国家/地区，则在 1 年之内无法改回之前的国家/地区。 您更改国家/地区后，将无法在新的国家/地区使用您在之前的国家/地区拥有的 Google Play 余额。 您可能会无法再享用某些图书、电影、电视节目、游戏和应用。 以下列举 Google Play 中部分采用中文语言的国家/地区常用的付款方式: 中国香港地区 信用卡及借记卡: 维萨、万事达、及美国运通卡 手机代扣，参与的运营商有: 3 CSL/1O1O Smartone 中国移动香港 SUN Mobile Telin Octopus O ! ePay AlipayHK – *new!*** Google Play 礼品卡 若想使用礼品卡或促销代码，您所居住的国家/地区与 Google Play 帐号的国家/地区设置必须与提供礼品卡或促销代码的国家/地区一致，否则会无法充值及交易。 PayPal 新加坡 信用卡及借记卡: 威萨、万事达、及美国运通卡 手机代扣，参与的运营商有: M1 SingTel StarHub PayPal 马来西亚 信用卡及借记卡: 威萨、万事达、及美国运通卡 手机代扣，参与的运营商有: Celcom Digi Maxis U Mobile webe Yes Touch ‘n Go Wallet Google Play 礼品卡 若想使用礼品卡或促销代码，您所居住的国家/地区与 Google Play 帐号的国家/地区设置必须与提供礼品卡或促销代码的国家/地区一致，否则会无法充值及交易。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android12上全新的应用启动画面]]></title>
    <url>%2Fposts%2F8c53fca7.html</url>
    <content type="text"><![CDATA[早期的Android上App的启动速度常为人诟病，如今的启动表现已不逊iOS。Google针对系统的不断优化绝对功不可没，从8.0独立出来的SplashWindow，到12上推出的全新SplashScreen。 在App的主要内容展示之前，按照需求的不同，或多或少会先展示这样几个画面。 画面 用途 Splash Screen 展示品牌Logo或Slogan Advertisement Screen 展示节日活动或日常广告 Guide Screen 演示重点功能，一般只展示一次 1 前言我们常常花费精力去打造引导画面或广告画面，而作为第一印象的启动画面却容易被忽视。回想下以前都是怎么处理这个画面的： 一般通过设置windowSplashscreenContent属性来展示UI提供的启动图，系统将为它创建专门的Window 假使忘记设置这个属性的话，默认的白色背景将导致启动过程中会有个白画面一闪而过 要去掉这个突兀的白画面可不能简单地设置Background为null，不然一闪而过的又会变成黑画面 最终发现windowDisablePreview属性可以彻底关闭这个画面，这样一来确实没有任何突兀的画面一闪而过了 但这又会带来启动”变慢”的副作用，因为用来过渡的启动画面被关闭之后，App描画前屏幕几乎没有什么变化。即便App性能没有劣化，但为了留住用户，我们还是得好好对待这个启动画面。 然而现有的windowSplashscreenContent可供定制的空间着实有限。也许官方也注意到了这点，便精心设计了Splash Screen API，并在Android 12里重磅推出。 有了这个全新特性的帮助，启动画面的定制将更加自由、方便。先来看下采用SplashScreen API 快速定制的启动效果。 下面将逐步演示全新SplashScreen可供定制的各个方面。 2 定制进入效果采用xml即可快速定制各式进入效果。 2.1 默认的启动效果默认情况下启动画面将展示白色背景和Launcher上的Adaptive Icon，也是不错的，比以前的白画面要好很多。 2.2 自定义静态Icon替换Icon为Adaptive Icon的前景图，背景色微调为米黄色。 123&lt;item name="android:windowSplashScreenBackground"&gt;@color/newSplashScreenColor&lt;/item&gt;&lt;item name="android:windowSplashScreenAnimatableIcon"&gt;@drawable/ic_kotlin_hero_new&lt;/item&gt;复制代码 2.3 自定义Icon背景Icon色调和画面背景色的对比不够明显的情况下，可以添加Icon背景色加强辨识度。 12&lt;item name=”android:windowSplashScreenIconBackground”&gt;@color/newSplashIconMaskColor&lt;/item&gt;复制代码 2.4 自定义品牌Logo添加品牌Logo可以展示企业形象或Slogan，使得启动画面更为完整和精细。 12&lt;item name=”android:windowSplashScreenBrandingImage”&gt;@drawable/ic_tm_brand_newer&lt;/item&gt;复制代码 2.5 自定义动画Icon动画形式的Icon可以增添设计和创意，使得启动流程更加流畅和有趣。 123&lt;item name="android:windowSplashScreenAnimatableIcon"&gt;@drawable/ic_kotlin_hero_new_animated_rotate&lt;/item&gt;&lt;item name="android:windowSplashScreenAnimationDuration"&gt;@integer/icon_animator_duration&lt;/item&gt;复制代码 比如让机器人图标旋转起来。 再比如让机器人在Kotlin上侧滑。 或者让几何图案拼凑出字母K之后和机器人汇合，象征着Android和Kotlin的强强联合。 注意： 动画Icon的时长上限为1000ms。 图标的进入动画可以定制，但由系统控制，不可以被监听和额外处理。 2.6 延长启动画面 The splash screen is dismissed as soon as your app draws its first frame. If you need to load a small amount of data such as in-app theme settings from a local disk asynchronously, you can use ViewTreeObserver.OnPreDrawListener to suspend the app to draw its first frame. 后台数据的加载难免耗时，启动画面结束了主要内容仍未加载好的话，体验不是太好。能够控制启动画面的持续时时长就好了。 现有的ViewTreeObserver的OnPreDrawListener回调是可以挂起描画的，如果我们在数据准备好之后再放行描画，就可以间接地延长启动画面的显示。 比如Activity初始化2s后才放行描画。 123456789101112131415161718192021222324252627282930313233class SplashActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; ... keepSplashScreenLonger() &#125; private fun keepSplashScreenLonger() &#123; // 监听Content View的描画时机 val content: View = findViewById(android.R.id.content) content.viewTreeObserver.addOnPreDrawListener( object : ViewTreeObserver.OnPreDrawListener &#123; override fun onPreDraw(): Boolean &#123; // 准备好了描画放行，反之挂起 return if (viewModel.isDataReady()) &#123; content.viewTreeObserver.removeOnPreDrawListener(this) true &#125; else &#123; false &#125; &#125; &#125; ) &#125;&#125;class MyViewModel(application: Application): AndroidViewModel(application) &#123; companion object &#123; const val WORK_DURATION = 2000L &#125; private val initTime = SystemClock.uptimeMillis() fun isDataReady() = SystemClock.uptimeMillis() - initTime &gt; WORK_DURATION&#125;复制代码 看一下效果，发现启动画面的展示时间确实变长了。 3 定制退出效果当App的第一帧开始描画，SplashScreen将会退出展示。为了丰富退出环节的体验，系统也开放了相应的入口，即画面退出的回调。在这个回调里可以开始退出效果的定制，包括整体的退出动画和图标的退出动画。 3.1 监听启动画面的退出向SplashScreen注册OnExitAnimationListener接口即可监听启动画面的退出。 1234567891011121314override fun onCreate(savedInstanceState: Bundle?) &#123; ... customizeSplashScreenExit()&#125;private fun customizeSplashScreenExit() &#123; splashScreen.setOnExitAnimationListener &#123; splashScreenView -&gt; Log.d("Splash", "SplashScreen#onSplashScreenExit view:$splashScreenView") sleep(1000) Log.d("Splash", "SplashScreen#remove after sleeping") splashScreenView.remove() &#125;&#125;复制代码 可以看到启动画面展示之后，不作定制的默认情况下就是全屏一下再消失。 日志如下： 123456Splash : Activity:com.example.splash.MainActivity@f70c0d0 Activity:com.example.splash.MainActivity@f70c0d0 onCreateSplash : Activity:com.example.splash.MainActivity@f70c0d0 onStartSplash : Activity:com.example.splash.MainActivity@f70c0d0 onResumeSplash : SplashScreen#onSplashScreenExit view:android.window.SplashScreenView&#123;18339d5 V.E...... ........ 0,0-1080,2280&#125;Splash : SplashScreen#remove after sleeping复制代码 一定记得调用remove及时移除启动画面，否则SplashScreen会长时间盖在主画面上，大概在5s左右。 另外，回调的注册需要放在Activity#onResume前，不然监听不到。 3.2 定制整体的退出动画可以给启动画面的整体设置TRANSLATE、SCALE、ROTATE、ALPHA等各种动画，使得退出更加自然。 比如给SplashScreen加上一个缩小出屏幕的动画。 1234567891011121314151617181920212223private fun customizeSplashScreenExit() &#123; splashScreen.setOnExitAnimationListener &#123; splashScreenView -&gt; showSplashExitAnimator(splashScreenView) &#125;&#125;private fun showSplashExitAnimator(splashScreenView: SplashScreenView) &#123; val path = Path() path.moveTo(1.0f, 1.0f) path.lineTo(0f, 0f) val scaleOut = ObjectAnimator.ofFloat( splashScreenView, View.SCALE_X, View.SCALE_Y, path ) ... scaleOut.doOnEnd &#123; splashScreenView.remove() &#125; scaleOut.start()&#125;复制代码 又或者从上方平移出屏幕的动画。 1234567891011private fun showSplashExitAnimator(splashScreenView: SplashScreenView) &#123; val slideUp = ObjectAnimator.ofFloat( splashScreenView, View.TRANSLATION_Y, 0f, -splashScreenView.height.toFloat() ) ... slideUp.start()&#125;复制代码 3.3 定制图标的退出动画当然也可以给图标单独加上动画，比如将Icon上滑。 123456789101112131415161718private fun customizeSplashScreenExit() &#123; splashScreen.setOnExitAnimationListener &#123; splashScreenView -&gt; showSplashIconExitAnimator(splashScreenView) &#125;&#125;private fun showSplashIconExitAnimator(splashScreenView: SplashScreenView) &#123; val iconView = splashScreenView.iconView ?: return val slideUp = ObjectAnimator.ofFloat( splashScreenView.iconView, View.TRANSLATION_Y, 0f, -iconView.height * 2.toFloat() ) ... slideUp.start()&#125;复制代码 3.4 退出动画的适当时长针对退出动画的定制官方还有一段补充说明。 By the start of this callback, the animated vector drawable on the splash screen has begun. Depending on the duration of the app launch, the drawable might be in the middle of its animation. Use SplashScreenView.getIconAnimationStart to know when the animation started. You can calculate the remaining duration of the icon animation. 简言之，退出画面回调的时候Icon动画可能进行到了一半，最好计算Icon动画的剩余时长来执行退出动画。 原因在于设备性能会影响App描画的早晚，而第一帧描画的时候上述的退出回调将被执行。也就是说，性能的优劣会影响启动画面退出的回调时机。 性能好的话，画面退出的回调较早。此时Icon动画尚在进行当中，可以将Icon动画的预设时长的剩余时间交接给退出效果来执行 性能差的话，画面退出的回调稍晚。Icon动画早已经结束，为了让用户尽早看到画面内容，就不该再执行退出效果了而是直接退出 不能为了展示效果而让用户久等，否则会弄巧成拙。 借助SplashScreenView的iconAnimationStartMillis和iconAnimationDurationMillis方法可以推算出Icon动画的剩余时长。 *模拟器上运行的缘故，大部分时候我的Demo在启动画面退出的时候Icon动画都结束了，少部分情况下动画还剩余一点时间，可能实机的情况会不一样。 12345678910111213141516171819202122private fun showSplashIconExitAnimator(splashScreenView: SplashScreenView) &#123; slideUp.duration = getRemainingDuration(splashScreenView) ...&#125;fun getRemainingDuration(splashScreenView: SplashScreenView): Long &#123; // 取得Icon动画的时长 val animationDuration = splashScreenView.iconAnimationDurationMillis // 取得Icon动画的开始时刻 val animationStart = splashScreenView.iconAnimationStartMillis // 再结合当前时间计算出Icon动画的剩余时长 // 1. 时长为负则固定为0ms即直接退出 // 2. 时长为正则采用该时长执行退出动画 return if (animationDuration != null &amp;&amp; animationStart != null) &#123; (animationDuration - SystemClock.uptimeMillis() + animationStart) .coerceAtLeast(0L) &#125; else &#123; 0L &#125;&#125;复制代码 4 SplashScreen相关API4.1 类和接口 类/接口 作用 SplashScreen 启动画面管理接口，通过Activity#getSplashScreen取得 OnExitAnimationListener 启动画面退出的回调接口，通过SplashScreen#setOnExitAnimationListener注册 SplashScreenView 启动画面包含的视图，用以定制整体或Icon的退出动画 4.2 属性 attr 作用 备注 splashScreenTheme 指定SplashScreen相关的Style 存在一点问题比如brand图片会不显示 windowSplashScreenBackground 定制启动画面的背景 默认从windowBackground里读取 windowSplashScreenBrandingImage 指定启动画面底部的品牌图标 - windowSplashScreenAnimatedIcon 指定Icon，支持静态或动画Drawable - windowSplashScreenAnimationDuration 指定动画Icon时长 上限1000ms windowSplashScreenIconBackgroundColor 补充Icon背景色 - 注意：windowSplashscreenContent是8.0版本新增的定制启动画面的属性，自12开始废弃了，使用windowSplashscreenAnimatedIcon替代 4.3 SplashScreen的构成 5 注意需要尝鲜SplashScreen的话，需要在Android 12上开发，并做如下必要配置。 compileSdkVersion和targetSdkVersion声明为S android:exported=&quot;true&quot;，明示声明启动画面的可见性，否则会安装失败 另外启动页的Icon无论是静态的还是动画效果的，都应遵循Adaptive Icon的规范，不然Icon会发生变形。 6 结语Android 12上全新的SplashScreen API非常简单清晰，整个定制过程非常流畅！ 相信在全新的API加持下，APP的启动画面可以迸发出更多特色的、好玩的创意。 快快尝试起来，给你的用户留下第一眼的好印象~ 本文DEMOgithub.com/ellisonchan… 参考资料欢迎体验 | Android 12 开发者预览版 3 SplashScreen的官方文档 SplashScreen API SplashScreen相关attr 转自TechMerger https://juejin.cn/post/6962706834889113614]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码实例展示Java和Kotlin有哪些区别]]></title>
    <url>%2Fposts%2F24470fc.html</url>
    <content type="text"><![CDATA[自从谷歌 I/O 2017宣布将支持 Kotlin 作为 Android 开发的 First-Class 语言，相信各位程序员的朋友圈都被Kotlin的消息轰炸了吧，支持Java的“守旧派”认为Java将稳坐霸主地位不动摇，支持Kotlin的“维新派”认为Kotlin很可能会把Java拉下马。其实，笔者认为新语言的出现对于程序员来说并不是一件新鲜事儿，程序员始终践行着“活到老，学到老”，真正能够对程序员产生影响的新语言的使用和性能。 易用性。 在语法糖的加持下，kotlin能够用更短的代码实现更多的功能。这是java 无法比拟的。所谓代码量越少，出bug的可能性就越低。 kotlin特有的扩展属性，不再需要java工具类，对开发更加友好。 比如我们想实现字符串判空操作，在java中需要写一个StringUtil类，这样其他开发同学想实现该功能的时候，可能并不知道已经有人实现了该功能，存在重复造轮子的可能。通过扩展属性，我们可以很方便的看出String类都存在哪些方法。 java中的bean类总是需要使用插件生成setter getter方法。kotlin中的data关键字可以解决这类问题，data类在编译期自动生成getter setter方法。 规范性。工程项目都是需要指定开发规范的。比如变量命名等。在java中，方法重载的时候会生成@Override注解，但是这并不是强制约束的。kotlin的方法采用override关键字进行了强制约束。 再比如TODO。java中的TODO是以注释的形式存在，即使没有实现TODO处的代码，也没什么运行时问题。kotlin的TODO形式如下： 123fun main(args: Array&lt;String&gt;) &#123; TODO()&#125; kotlin TODO的实现 12@kotlin.internal.InlineOnlypublic inline fun TODO(): Nothing = throw NotImplementedError() 可以看到运行时会抛出异常。 思考：这里为什么不在编译期抛出异常呢？ 安全性。java中虽然有@Nullable @NotNull等注解。但是不会在编译期起作用，而是在运行期抛出异常。kotlin在声明变量的时候，可以指定变量是否为空，调用可为空对象时，需要进行空判断。 跨平台。java在jvm的协助下虽然也是跨平台语言，但是不能像kotlin一样可以既可以编译成class字节码，又可以编译成js。 编译速度。只有全量编译下，kotlin比java慢。增量编译下，两者几乎没有差距。 其他kotlin特性。懒加载、高阶函数、协程、inline操作符、运算符重载、默认参数等。 GitHub 用户amitshekhariitbhu在GitHub上贴图分享了Java和Kotlin的语法区别，下面我们就一起来看一下吧! 打印日志123// javaSystem.out.print("Hello Word");System.out.println("Hello Word"); 123// Kotlinprint("Hello Word")println("Hello Word") 定义变量和常量123// javaString name = "Hello Word";final String name = "Hello Word"; 123// Kotlinvar name = "Hello Word"val name = "Hello Word" null声明123// javaString otherName;otherName = null; 123// kotlin var otherName : String?otherName = null 空判断1234// javaif (text != null) &#123; int length = text.length();&#125; 1234// kotlin text?.let &#123; val length = text.length&#125; 字符串拼接1234// javaString firstName = "Android";String lastName = "ZM";String message = "My name is: " + firstName + " " + lastName; 1234// kotlin val firstName = "Android"val lastName = "ZM"val message = "My name is: $firstName $lastName" 换行1234// javaString text = "First Line\n" + "Second Line\n" + "Third Line"; 123456// kotlin val text = """ |First Line |Second Line |Third Line """.trimMargin() 三元表达式12// javaString text = x &gt; 5 ? "x &gt; 5" : "x &lt;= 5"; 1234// kotlin val text = if (x &gt; 5) "x &gt; 5" else "x &lt;= 5" 操作符1234567// javafinal int andResult = a &amp; b;final int orResult = a | b;final int xorResult a ^ b;final int rightShift = a &gt;&gt; 2;final int leftShift = a &lt;&lt; 2;final int unsignedRightShift = a &gt;&gt;&gt; 2; 123456val andResult = a and b;val orResult = a or b;val xorResult a xor b;val rightShift = a shr 2;val leftShift = a shl 2;val unsignedRightShift = a ushr 2; 类型判断和转换(声明式)12// javaCar car = (Car) object; 12// kotlin var car = object as Car 类型判断和转换(隐式)1234// javaif (object instanceof Car) &#123; Car car = (Car) object;&#125; 1234// kotlin if (object is Car) &#123; var car = object // smart casting&#125; 多重条件12// javaif (score &gt;= 0 &amp;&amp; score &lt;= 300) &#123; &#125; 12// kotlin if (score in 0..300) &#123; &#125; 更灵活的case语句12345678910111213141516171819202122232425// javaint score = // some score;String grade;switch (score) &#123; case 10: case 9: grade = "Excellent"; break; case 8: case 7: case 6: grade = "Good"; break; case 5: case 4: grade = "Ok"; break; case 3: case 2: case 1: grade = "Fail"; break; default: grade = "Fail"; &#125; 123456789// kotlin var score = // some scorevar grade = when (score) &#123; 9, 10 -&gt; "Excellent" in 6..8 -&gt; "Good" 4, 5 -&gt; "Ok" in 1..3 -&gt; "Fail" else -&gt; "Fail"&#125; for循环1234567891011121314// javafor (int i = 1; i &lt;= 10 ; i++) &#123; &#125;for (int i = 1; i &lt; 10 ; i++) &#123; &#125;for (int i = 10; i &gt;= 0 ; i--) &#123; &#125;for (int i = 1; i &lt;= 10 ; i+=2) &#123; &#125;for (int i = 10; i &gt;= 0 ; i-=2) &#123; &#125;for (String item : collection) &#123; &#125;for (Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123; &#125; 1234567891011121314// kotlin for (i in 1..10) &#123; &#125;for (i in 1 until 10) &#123; &#125;for (i in 10 downTo 0) &#123; &#125;for (i in 1..10 step 2) &#123; &#125;for (i in 10 downTo 1 step 2) &#123; &#125;for (item in collection) &#123; &#125;for ((key, value) in map) &#123; &#125; 更方便的集合操作1234567891011121314// javafinal List&lt;Integer&gt; listOfNumber = Arrays.asList(1, 2, 3, 4);final Map&lt;Integer, String&gt; keyValue = new HashMap&lt;Integer, String&gt;();map.put(1, "Amit");map.put(2, "Ali");map.put(3, "Mindorks");// Java 9final List&lt;Integer&gt; listOfNumber = List.of(1, 2, 3, 4);final Map&lt;Integer, String&gt; keyValue = Map.of(1, "Amit", 2, "Ali", 3, "Mindorks"); 12345// kotlin val listOfNumber = listOf(1, 2, 3, 4)val keyValue = mapOf(1 to "Amit", 2 to "Ali", 3 to "Mindorks") 遍历123456789101112131415161718// java// Java 7 and belowfor (Car car : cars) &#123; System.out.println(car.speed);&#125;// Java 8+cars.forEach(car -&gt; System.out.println(car.speed));// Java 7 and belowfor (Car car : cars) &#123; if (car.speed &gt; 100) &#123; System.out.println(car.speed); &#125;&#125;// Java 8+cars.stream().filter(car -&gt; car.speed &gt; 100).forEach(car -&gt; System.out.println(car.speed)); 1234567// kotlincars.forEach &#123; println(it.speed)&#125;cars.filter &#123; it.speed &gt; 100 &#125; .forEach &#123; println(it.speed)&#125; 方法定义1234567// javavoid doSomething() &#123; // logic here&#125;void doSomething(int... numbers) &#123; // logic here&#125; 123456fun doSomething() &#123; // logic here&#125;fun doSomething(vararg numbers: Int) &#123; // logic here&#125; 带返回值的方法12345// javaint getScore() &#123; // logic here return score;&#125; 12345678fun getScore(): Int &#123; // logic here return score&#125;// as a single-expression functionfun getScore(): Int = score 无结束符号12345// javaint getScore(int value) &#123; // logic here return 2 * value;&#125; 12345678fun getScore(value: Int): Int &#123; // logic here return 2 * value&#125;// as a single-expression functionfun getScore(value: Int): Int = 2 * value constructor构造器123456789101112// javapublic class Utils &#123; private Utils() &#123; // This utility class is not publicly instantiable &#125; public static int getScore(int value) &#123; return 2 * value; &#125; &#125; 123456789101112131415161718192021// kotlinclass Utils private constructor() &#123; companion object &#123; fun getScore(value: Int): Int &#123; return 2 * value &#125; &#125;&#125;// other way is also thereobject Utils &#123; fun getScore(value: Int): Int &#123; return 2 * value &#125;&#125; Get Set构造器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// javapublic class Developer &#123; private String name; private int age; public Developer(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Developer developer = (Developer) o; if (age != developer.age) return false; return name != null ? name.equals(developer.name) : developer.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125; @Override public String toString() &#123; return "Developer&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 12// kotlindata class Developer(var name: String, var age: Int) 类方法1234567891011121314// javapublic class Utils &#123; private Utils() &#123; // This utility class is not publicly instantiable &#125; public static int triple(int value) &#123; return 3 * value; &#125; &#125;int result = Utils.triple(3); 123456// kotlinfun Int.triple(): Int &#123; return this * 3&#125;var result = 3.triple() 枚举1234567891011121314151617// javapublic enum Direction &#123; NORTH(1), SOUTH(2), WEST(3), EAST(4); int direction; Direction(int direction) &#123; this.direction = direction; &#125; public int getDirection() &#123; return direction; &#125; &#125; 1234567// kotlinenum class Direction(val direction: Int) &#123; NORTH(1), SOUTH(2), WEST(3), EAST(4);&#125; 定义未初始化的对象12// javaPerson person; 12// kotlininternal lateinit var person: Person 排序12345678910// javaList&lt;Profile&gt; profiles = loadProfiles(context);Collections.sort(profiles, new Comparator&lt;Profile&gt;() &#123; @Override public int compare(Profile profile1, Profile profile2) &#123; if (profile1.getAge() &gt; profile2.getAge()) return 1; if (profile1.getAge() &lt; profile2.getAge()) return -1; return 0; &#125;&#125;); 1234567// kotlinval profile = loadProfiles(context)profile.sortedWith(Comparator(&#123; profile1, profile2 -&gt; if (profile1.age &gt; profile2.age) return@Comparator 1 if (profile1.age &lt; profile2.age) return@Comparator -1 return@Comparator 0&#125;)) 匿名类1234567891011121314// java AsyncTask&lt;Void, Void, Profile&gt; task = new AsyncTask&lt;Void, Void, Profile&gt;() &#123; @Override protected Profile doInBackground(Void... voids) &#123; // fetch profile from API or DB return null; &#125; @Override protected void onPreExecute() &#123; super.onPreExecute(); // do something &#125;&#125;; 123456789101112// kotlinval task = object : AsyncTask&lt;Void, Void, Profile&gt;() &#123; override fun doInBackground(vararg voids: Void): Profile? &#123; // fetch profile from API or DB return null &#125; override fun onPreExecute() &#123; super.onPreExecute() // do something &#125;&#125; 初始化块123456// javapublic class User &#123; &#123; //Initialization block System.out.println("Init block"); &#125;&#125; 123456// kotlin class User &#123; init &#123; // Initialization block println("Init block") &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Branch deferred deep link 深度链接]]></title>
    <url>%2Fposts%2F4f2dc96b.html</url>
    <content type="text"><![CDATA[Branch 实现Android端 deferred deep link 官网sdk文档地址：https://docs.branch.io/apps/android/1. Configure Branch（配置Branch） 2. Install Branch Import the Branch SDK to your build.gradle 1234567 // required for all Android apps implementation 'io.branch.sdk.android:library:3.+' // required if your app is in the Google Play Store implementation 'com.google.android.gms:play-services-appindexing:9.+' // App indexing implementation 'com.google.android.gms:play-services-ads:9+' // GAID matching123456 3.Configure app Add Branch to your AndroidManifest.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.eneff.branch.example.android"&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;application android:allowBackup="true" android:name="com.eneff.branch.example.android.CustomApplicationClass" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;!-- Launcher Activity to handle incoming Branch intents --&gt; &lt;activity android:name=".LauncherActivity" android:launchMode="singleTask" android:label="@string/app_name" android:theme="@style/AppTheme.NoActionBar"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".intelsports.ShareShowActivity"&gt; &lt;!-- Branch App Links (optional) --&gt; &lt;intent-filter android:autoVerify="true"&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;data android:scheme="olp" android:host="sports.app.link" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- Branch init --&gt; &lt;meta-data android:name="io.branch.sdk.BranchKey" android:value="key_live_kaFuWw8WvY7yn1d9yYiP8gokwqjV0Sw" /&gt; &lt;!-- Branch install referrer tracking (optional) --&gt; &lt;receiver android:name="io.branch.referral.InstallListener" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.android.vending.INSTALL_REFERRER" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt;&lt;/manifest&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 Replace the following with values from your Branch Dashboard App settings and Link settings example.app.linkkey_live_kaFuWw8WvY7yn1d9yYiP8gokwqjV0Sw 以上是Branch的配置信息设置，接下来进行Branch的初始化工作 4.Initialize Branch Add Branch to your LauncherActivity.java 123456789101112131415161718192021222324252627282930313233public class LauncherActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_launcher); &#125; @Override public void onStart() &#123; super.onStart(); // Branch init Branch.getInstance().initSession(new Branch.BranchReferralInitListener() &#123; @Override public void onInitFinished(JSONObject referringParams, BranchError error) &#123; if (error == null) &#123; Log.i("BRANCH SDK", referringParams.toString()); // Retrieve deeplink keys from 'referringParams' and evaluate the values to determine where to route the user // Check '+clicked_branch_link' before deciding whether to use your Branch routing logic &#125; else &#123; Log.i("BRANCH SDK", error.getMessage()); &#125; &#125; &#125;, this.getIntent().getData(), this); &#125; @Override public void onNewIntent(Intent intent) &#123; this.setIntent(intent); &#125;&#125;1234567891011121314151617181920212223242526272829303132 5.Load Branch Add Branch to your CustomApplicationClass.java 12345678910111213public class CustomApplicationClass extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // Branch logging for debugging Branch.enableDebugMode(); // Branch object initialization Branch.getAutoInstance(this); &#125;&#125;123456789101112 6.Test deep link 1234567891011121314151617BranchUniversalObject buo = new BranchUniversalObject(); LinkProperties lp = new LinkProperties() .addControlParameter("custom1", "data1") //传入自定义数据 .addControlParameter("custom2", "data2");buo.generateShortUrl(this, lp, new Branch.BranchLinkCreateListener() &#123; @Override public void onLinkCreate(String url, BranchError error) &#123; if (error == null) &#123; //得到短链接，用于分享 Log.i("BRANCH SDK", "got my Branch link to share: " + url); &#125; &#125;&#125;);12345678910111213141516 使用第三方分享或系统自带分享工具，将以上短链接url分享即可。 7.Read deep link(读取depplink中携带的数据) 在要启动的ShareShowActivity或LauncherActivity onStart方法中实现。即可读取出JSONObject中相应数据 1234567891011121314151617// listener (within Main Activity's onStart)Branch.getInstance().initSession(new Branch.BranchReferralInitListener() &#123; @Override public void onInitFinished(JSONObject referringParams, BranchError error) &#123; if (error == null) &#123; Log.i("BRANCH SDK", referringParams.toString()); &#125; else &#123; Log.i("BRANCH SDK", error.getMessage()); &#125; &#125;&#125;, this.getIntent().getData(), this);// latestJSONObject sessionParams = Branch.getInstance().getLatestReferringParams();// first 若设备未安装app，用户安装app后第一次启动即可获取deep link中的数据JSONObject installParams = Branch.getInstance().getFirstReferringParams();]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack ViewModel]]></title>
    <url>%2Fposts%2F837f0209.html</url>
    <content type="text"><![CDATA[官方文档 ViewModel概览ViewModel类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续存在。 Android 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。 如果系统销毁或重新创建界面控制器，则存储在其中的任何临时性界面相关数据都会丢失。例如，应用的某个 Activity 中可能包含用户列表。因配置更改而重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。 另一个问题是，界面控制器经常需要进行异步调用，这些调用可能需要一些时间才能返回结果。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄露。此项管理需要大量的维护工作，并且在因配置更改而重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。 诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。 从界面控制器逻辑中分离出视图数据所有权的做法更易行且更高效。 实现ViewModel架构组件为界面控制器提供了 ViewModel 辅助程序类，该类负责为界面准备数据。 在配置更改期间会自动保留 ViewModel 对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。例如，如果您需要在应用中显示用户列表，请确保将获取和保留该用户列表的责任分配给 ViewModel，而不是 Activity 或 Fragment，如以下示例代码所示： 12345678910111213141516 public class MyViewModel extends ViewModel &#123; private MutableLiveData&lt;List&lt;User&gt;&gt; users; public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123; if (users == null) &#123; users = new MutableLiveData&lt;List&lt;User&gt;&gt;(); loadUsers(); &#125; return users; &#125; private void loadUsers() &#123; // Do an asynchronous operation to fetch users. &#125; &#125; 123456789101112131415 然后，您可以从 Activity 访问该列表，如下所示： 12345678910111213 public class MyActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; // Create a ViewModel the first time the system calls an activity's onCreate() method. // Re-created activities receive the same MyViewModel instance created by the first activity. MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class); model.getUsers().observe(this, users -&gt; &#123; // update UI &#125;); &#125; &#125; 123456789101112 如果重新创建了该 Activity，它接收的 MyViewModel 实例与第一个 Activity 创建的实例相同。当所有者 Activity 完成时，框架会调用 ViewModel 对象的 onCleared() 方法，以便它可以清理资源。 注意：ViewModel 绝不能引用视图、Lifecycle 或可能存储对 Activity 上下文的引用的任何类。 ViewModel 对象存在的时间比视图或 LifecycleOwners 的特定实例存在的时间更长。这还意味着，您可以更轻松地编写涵盖 ViewModel 的测试，因为它不了解视图和 Lifecycle 对象。ViewModel 对象可以包含 LifecycleObservers，如 LiveData 对象。但是，ViewModel 对象绝不能观察对生命周期感知型可观察对象（如 LiveData 对象）的更改。 如果 ViewModel 需要 Application 上下文（例如，为了查找系统服务），它可以扩展 AndroidViewModel 类并设置用于接收 Application 的构造函数，因为 Application 类会扩展 Context。 ViewModel的生命周期ViewModel 对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel 将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。 图 1 说明了 Activity 经历屏幕旋转而后结束的过程中所处的各种生命周期状态。该图还在关联的 Activity 生命周期的旁边显示了 ViewModel 的生命周期。此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。您通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel。系统可能会在 Activity 的整个生命周期内多次调用 onCreate()，如在旋转设备屏幕时。ViewModel 存在的时间范围是从您首次请求 ViewModel 直到 Activity 完成并销毁。 在 Fragment 之间共享数据Activity 中的两个或更多 Fragment 需要相互通信是一种很常见的情况。想象一下主从 Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。 可以使用 ViewModel 对象解决这一常见的难点。这两个 Fragment 可以使用其 Activity 范围共享 ViewModel 来处理此类通信，如以下示例代码所示： 12345678910111213141516171819202122232425262728293031323334 public class SharedViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;(); public void select(Item item) &#123; selected.setValue(item); &#125; public LiveData&lt;Item&gt; getSelected() &#123; return selected; &#125; &#125; public class MasterFragment extends Fragment &#123; private SharedViewModel model; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); itemSelector.setOnClickListener(item -&gt; &#123; model.select(item); &#125;); &#125; &#125; public class DetailFragment extends Fragment &#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); model.getSelected().observe(this, &#123; item -&gt; // Update the UI. &#125;); &#125; &#125; 123456789101112131415161718192021222324252627282930313233 此方法具有以下优势： Activity 不需要执行任何操作，也不需要对此通信有任何了解。 除了 SharedViewModel 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。 每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。 将加载器替换为 ViewModel诸如 CursorLoader 之类的加载器类经常用于使应用界面中的数据与数据库保持同步。您可以将 ViewModel 与一些其他类一起使用来替换加载器。使用 ViewModel 可将界面控制器与数据加载操作分离，这意味着类之间的强引用更少。 在使用加载器的一种常见方法中，应用可能会使用 CursorLoader 观察数据库的内容。当数据库中的值发生更改时，加载器会自动触发数据的重新加载并更新界面：ViewModel 与 Room 和 LiveData 一起使用可替换加载器。ViewModel 确保数据在设备配置更改后仍然存在。Room 在数据库发生更改时通知 LiveData，LiveData 进而使用修订后的数据更新界面。 示例官方示例]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Jetpack]]></title>
    <url>%2Fposts%2Ff1035a2c.html</url>
    <content type="text"><![CDATA[Jetpack是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码地工作并简化复杂任务，以便将精力集中放在所需代码上。 Jetpack包含与平台API解除捆绑地androidx.*软件包库。这意味着，它可以提供向后兼容性，且比Android平台地更新频率更高，一次确保您始终可以获取最新且最好地Jetpack组件版本。 Android Jetpack组件Android Jetpack组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用Kotlin语言功能帮助您提高工作效率，可全部使用，也可混合搭配！ 基础（Foundation）基础组件可提供横向功能，例入向后兼容性、测试和Kotlin语言支持。 Android KTX编写更简洁、惯用的kotlin代码 AppCompat在较低版本的Android系统上恰当地降级 Auto有助于开发Android Auto应用地组件 检测从Android Studio中快速检测基于Kotlin或Java的代码 多Dex处理为具有多个dex文件的应用提供支持 安全按照安全最佳做法读写加密文件和共享偏好设置 测试用于单元和运行时界面测试的Android测试框架 TV有助于开发Android TV应用的组件 Wear OS by Google谷歌有助于开发Wear应用的组件 架构（Architecture）架构组件可帮助您设计文件、可测试且易维护的应用。 数据绑定以声明方法将可观察数据绑定到界面元素 Lifecycles管理您的Activity和Fragment生命周期 LiveData在底层数据库更改时通知视图 Navigaton处理应用内导航所需的一切 Paging逐步从您的数据源按需加载信息 Room流畅地访问SQLite数据库 ViewModel以注重生命周期地方式管理界面相关的数据 WorkManager 管理您的Android后台作业 行为（Behavior）行为组件可帮助您的应用与标准Android服务（如通知、权限、分享和Google助理）相集成。 CameraX轻松地向应用中添加相机功能 下载管理器安排和管理大量下载任务 媒体和播放用于媒体播放和路由（包括Google Cast）地向后兼容API 通知提供向后兼容的通知API，支持Wear和Auto 权限用于检查和请求应用权限的兼容性API 偏好设置创建交互式设置屏幕 共享提供适合应用操作栏的共享操作 切片创建可在应用外部显示应用数据的灵活界面元素 界面（UI）界面组件可提供微件和辅助程序，让您的应用不仅简单易用，还能带来愉悦体验。了解有助于简化界面开发的Jetpack Compose。 动画和过渡移动微件和在屏幕之间过渡 表情符号在旧版平台上启用最新的表情符号字体 Fragment组件化界面的基本单位 布局使用不同的算法布置微件 调色板从调色板中提取有用的信息 -]]></content>
      <categories>
        <category>Android</category>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin入门]]></title>
    <url>%2Fposts%2F749a22ae.html</url>
    <content type="text"><![CDATA[注意： Kotlin 现作为 Android 第一开发语言，AndroidStudio 作为 Google 的亲儿子，对 Kotlin 进行了完美的支持，开发提示应有尽有，因此下面所有的演示代码都是跑在 AndroidStudio 上的 Kotlin 介绍官网对 Kotlin 的介绍：A modern programming languagethat makes developers happier. 翻译过来就是：Kotlin 是一门让开发者更开心的现代程序设计语言 。 由 JetBrains 公司开发和设计，它也是一门基于 JVM 的静态语言。 问题在学习 Kotlin 的时候我心里会有一些疑问🤔️ ？ 1、Android 操作系统是由 Google 开发出来的，为啥 JetBrains 作为一个第三方公司，却能设计出一门语言来开发 Android 应用程序？ 因为 Java 虚拟机（Android 中叫 ART，一种基于 Java 虚拟机优化的虚拟机）并不直接和你编写的这门语言的源代码打交道，而是和你编译之后的 class 字节码文件打交道。基于 JVM 的语言，如 Kotlin，Groovy等，它们都会有各自的编译器，把源文件编译成 class 字节码文件，Java 虚拟机不关心 class 字节码文件是从哪里编译而来，只要符合规格的 class 字节码文件，它都能识别，正是因为这个原因，JetBrains 才能以一个第三方公司设计出一门来开发 Android 应用程序的编程语言 2、为啥有了 Java 来开发 Android 应用程序，Google 还要推荐使用 Kotlin 来开发？ 原因有很多，列举主要的几点： 1）、Kotlin 语法更加简洁，使用 Kotlin 开发的代码量可能会比 Java 开发的减少 50% 甚至更多 2）、Kotlin 的语法更加高级，相比于 Java 老旧的语法，Kotlin 增加了很多现代高级语言的语法特性，大大提升了我们的开发效率 3）、Kotlin 和 Java 是 100% 兼容的，Kotlin 可以直接调用 Java 编写的代码，也可以无缝使用 Java 第三方开源库，这使得 Kotlin 在加入了诸多新特性的同时，还继承了 Java 的全部财富 3、为啥 Kotlin 中要显示的去声明一个非抽象类可继承，而不像 Java 那样定义的类默认可继承？ 因为一个类默认可被继承的话，它无法预知子类会如何去实现，因此存在一些未知的风险。类比 val 关键字是同样的道理，在 Java 中，除非你主动给变量声明 final 关键字，否则这个变量就是可变的，随着项目复杂度增加，多人协作开发，你永远不知道一个可变的变量会在什么时候被谁修改了，即使它原本不应该修改，也很难去排查问题。因此 Kotlin 这样的设计是为了让程序更加的健壮，也更符合高质量编码的规范 下面我们就正式进入到 Kotlin 的学习 一、变量和函数1、变量1）、使用 val（value 的简写）关键字来声明一个不可变的变量，也就是只读变量，这种变量初始赋值后就不能重新赋值了，对应 Java 中的 final 变量 2）、使用 var （variable 的简写）关键字用来声明一个可变的变量，也就是可读写变量，这种变量初始赋初值后仍然可以重新被赋值，对应 Java 中的非 final 变量 3）、Kotlin 中的每一行代码都不用加 ； 12345678910111213//在 Java 中，我们会这么定义int a = 10;boolean b = true//在 Kotlin 中，我们可以这么定义，当给变量赋值后，Kotlin 编译器会进行类型推导//定义一个不可变的变量 a val a = 10//定义一个可变的变量 bvar b = true//如果我们显示的给变量指定类型，Kotlin 就不会进行类型推导了val a: Int = 10var b: Boolean = "erdai" 如果你观察的仔细会发现，上述代码 Kotlin 定义变量给变量显示的指定类型时，使用的都是首字母大小的 Int，Boolean，而在 Java 中都是小写的 int，boolean，这表明： Kotlin 完全抛弃了 Java 中的基本数据类型，全部都是对象数据类型。 下面给出一个 Java 和 Kotlin 数据类型对照表： Java 基本数据类型 Kotlin 对象数据类型 数据类型说明 byte Byte 字节型 short Short 短整型 int Int 整型 long Long 长整型 float Float 单精度浮点数 double Double 双精度浮点数 char Char 字符型 boolean Boolean 布尔型 2、常量Kotlin 中定义一个常量需要满足三个条件 1）、使用 const val 来修饰，并初始化 2）、修饰的类型只能是字符串和基础对象类型 3）、只能修饰顶层的常量，object 修饰的成员，companion object 的成员，这些概念后面还会讲到 1234567891011121314//定义一个顶层的常量，这个常量不放在任何的类中const val CONSTANT = "This is a constant"//定义一个 object 修饰的单例类，类中定义一个常量object SingeTon &#123; const val CONSTANT = "This is a constant"&#125;class KotlinPractice &#123; //定义一个 companion object 修饰的伴生对象，里面定义一个常量 companion object&#123; const val CONSTANT = "This is a constant" &#125;&#125; 3、函数1）、函数和方法是同一个概念，在 Java 中我们习惯叫方法 (method)，但是 Kotlin 中就需要叫函数 (function) 2）、函数是运行代码的载体,像我们使用过的 main 函数就是一个函数 Kotlin 中定义语法的规则： 123456789101112fun methodName(param1: Int, param2: Int): Int &#123; return 0&#125;//下面这两个方法效果是一样的fun methodName1(params: Int,params2: Int): Unit&#123;&#125;fun methodName1(params: Int,params2: Int)&#123;&#125; 上述函数语法解释： fun ( function 的缩写 ) 是定义一个函数的关键字，无论你定义什么函数，都要用 fun 来声明 函数名称可以随便取，就像 Java 里面定义函数名一样 函数名里面的参数可以有任意多个，参数的声明格式为：”参数名”：”参数类型” 参数名后面这部分代表返回值，我们这返回的是一个 Int 类型的值，这部分是可选的，如果不定义，默认返回值为 Unit，且 Unit 可省略 实践一下： 1234567891011121314fun main() &#123; val number1 = 15 val number2 = 20 val maxNumber = largeNumber(number1,number2) println(maxNumber)&#125;fun largeNumber(number1: Int,number2: Int) : Int&#123; //调用顶层 max 函数计算两者中的最大值 return max(number1,number2)&#125;//打印结果20 Kotlin 语法糖：当一个函数体中只有一行代码的时候，我们可以不编写函数体，可以将唯一的一行代码写在函数定义的尾部，中间用 = 连接即可 那么上述 largeNumber 这个函数我们改造一下： 1234//根据上述语法糖，我们省略了函数体的 &#123;&#125; 和 return 关键字，增减的 = 连接fun largeNumber(number1: Int,number2: Int) : Int = max(number1,number2)//根据 Kotlin 类型推导机制，我们还可以把函数的返回值给省略，最终变成了这样fun largeNumber(number1: Int,number2: Int) = max(number1,number2) 二、程序的逻辑控制1、if 条件语句1）、Kotlin 中的 if 条件语句除了继承了 Java 中 if 条件语句的所有特性，且可以把每一个条件中的最后一行代码作为返回值 我们改造一下上述 largeNumber 函数的内部实现： 1234567891011//Kotlin 中把每一个条件中的最后一行代码作为返回值fun largeNumber(number1: Int,number2: Int) : Int&#123; return if(number1 &gt; number2)&#123; number1 &#125;else &#123; number2 &#125;&#125;//根据上面学习的语法糖和 Kotlin 类型推导机制，我们还可以简写 largeNumber 函数，最终变成了这样fun largeNumber(number1: Int,number2: Int) = if(number1 &gt; number2) number1 else number 2 2、when 条件语句类比 Java 中的 Switch 语句学习，Java 中的 Switch 并不怎么好用： 1）、Switch 语句只能支持一些特定的类型，如整型，短于整型，字符串，枚举类型。如果我们使用的并非这几种类型，Switch 并不可用 2）、Switch 语句的 case 条件都要在最后加上一个 break 这些问题在 Kotlin 中都得到了解决，而且 Kotlin 还加入了许多强大的新特性： 1）、when 条件语句也是有返回值的，和 if 条件语句类似，条件中的最后一行代码作为返回值 2）、when 条件语句允许传入任意类型的参数 3）、when 条件体中条件格式：匹配值 -&gt; { 执行逻辑 } 4）、when 条件语句和 if 条件语句一样，当条件体里面只有一行代码的时候，条件体的 {} 可省略 123456789101112131415//when 中有参数的情况fun getScore(name: String) = when (name) &#123; "tom" -&gt; 99 "jim" -&gt; 80 "lucy" -&gt; 70 else -&gt; 0&#125;//when 中无参数的情况，Kotin 中判断字符串或者对象是否相等，直接使用 == 操作符即可fun getScore(name: String) = when &#123; name == "tom" -&gt; 99 name == "jim" -&gt; 80 name =="lucy" -&gt; 70 else -&gt; 0&#125; 3、循环语句主要有以下两种循环： 1）、while 循环，这种循环和 Java 没有任何区别 2）、for 循环，Java 中常用的循环有：for-i，for-each，Kotlin 中主要是：for-in 区间 1）、使用 .. 表示创建两端都是闭区间的升序区间 2）、使用 until 表示创建左端是闭区间右端是开区间的升序区间 3）、使用 downTo 表示创建两端都是闭区间的降序区间 4）、在区间的后面加上 step ，表示跳过几个元素 12345678910111213141516171819202122232425262728293031323334353637383940//注意: Kotlin 中可以使用字符串内嵌表达式，也就是在字符串中可以引用变量，后续还会讲到//情况1fun main() &#123; //使用 .. 表示创建两端都是闭区间的升序区间 for (i in 0..10)&#123; print("$i ") &#125;&#125;//打印结果0 1 2 3 4 5 6 7 8 9 10//情况2fun main() &#123; //使用 until 表示创建左端是闭区间右端是开区间的升序区间 for (i in 0 until 10)&#123; print("$i ") &#125;&#125;//打印结果0 1 2 3 4 5 6 7 8 9//情况3fun main() &#123; //使用 downTo 表示创建两端都是闭区间的降序区间 for (i in 10 downTo 0)&#123; print("$i ") &#125;&#125;//打印结果10 9 8 7 6 5 4 3 2 1 0//情况4fun main() &#123; //使用 downTo 表示创建两端都是闭区间的降序区间,每次在跳过3个元素 for (i in 10 downTo 0 step 3)&#123; print("$i ") &#125;&#125;//打印结果10 7 4 1 三、面向对象编程对于面向对象编程的理解：面向对象的语言是可以创建类的，类是对事物一种的封装，例如人，汽车我们都可以把他们封装成类，类名通常是名词，类中有自己的字段和函数，字段表示该类拥有的属性，通常也是名词，就像人可以拥有姓名和年龄，汽车可以拥有品牌和价格，函数表示该类拥有那些行为，一般为动词，就像人需要吃饭睡觉，汽车可以驾驶和保养，通过这种类的封装，我们就可以在适当的地方创建这些类，然后调用他们的字段和函数来满足实际的编程需求，这就是面向对象编程最基本的思想 1、类与对象我们使用 AndroidStudio 创建一个 Person 类，在弹出的对话框中输入 Person ，选择Class，对话框默认情况下自动选中的是创建一个File，File 通常是用于编写 Kotlin 顶层函数和扩展函数等，如下图： 1）、当我们在类中创建属性的时候，Kotlin 会自动帮我们创建 get 和 set 方法 2）、Kotlin 中实例化对象和 Java 类似，但是把 new 关键字给去掉了 3）、一般在类中，我们会用 var 关键字去定义一个属性，因为属性一般是可变的，如果你确定某个属性不需要改变，则用 val 1234567891011121314151617class Person &#123; var name = "" var age = 0 fun sleep()&#123; println("$name is sleep, He is $age years old.") &#125;&#125;fun main() &#123; val person = Person() person.name = "erdai" person.age = 20 person.sleep()&#125;//打印结果erdai is sleep, He is 20 years old. 2、继承与构造函数继承1）、Kotlin 中规定，如果要声明一个非抽象类可继承，必须加上 open 关键字，否则不可继承，这点和 Java 中不同，Java 中的类默认是可被继承的，Effective Java 这本书中提到：如果一个类不是专门为继承而设计的，那么就应该主动将它加上 final 声明，禁止他可以被继承 2）、Kotlin中的继承和实现都是用 : 表示 123456789101112131415//声明 Person 类可以被继承open class Person &#123; var name = "" var age = 0 fun sleep() &#123; println("$name is sleep, He is $age years old.") &#125;&#125;//定义 Student 继承 Person 类//为啥 Person 后面会有一个括号呢？因为子类的构造函数必须调用父类中的构造函数，在 Java 中，子类的构造函数会隐式的去调用class Student : Person()&#123; &#125; 构造函数1）、主构造函数的特点是没有函数体，直接跟在类名的后面即可，如果需要在主构造函数里面做逻辑，复写 init 函数即可 2）、主构造函数中声明成 val 或者 var 的参数将自动成为该类的字段，如果不加，那么该字段的作用域仅限定在主构造函数中 3）、次构造函数是通过 constructor 关键字来定义的 4）、当一个类没有显示的定义主构造函数，但是定义了次构造函数时，那么被继承的类后面不需要加 () 123456789101112131415161718192021222324252627282930313233343536373839404142//定义 Student 类，定义主构造函数，定义属性 sno 和 grade, 继承 Person 类class Student(var sno: String, var grade: Int) : Person() &#123; //做一些初始化的逻辑 init &#123; name = "erdai" age = 20 &#125; //声明带一个参数的次构造函数 constructor(sno: String): this(sno,8)&#123; &#125; //声明一个无参的次构造函数 constructor(): this("123",7)&#123; &#125; fun printInfo()&#123; println("I am $name, $age yeas old, sno: $sno, grade: $grade") &#125;&#125;fun main() &#123; val student1 = Student() val student2 = Student("456") val student3 = Student("789",9) student1.printInfo() student2.printInfo() student3.printInfo()&#125;//打印结果I am erdai, 20 yeas old, sno: 123, grade: 7I am erdai, 20 yeas old, sno: 456, grade: 8I am erdai, 20 yeas old, sno: 789, grade: 9//一种特殊情况：当一个类没有显示的定义主构造函数，但是定义了次构造函数时，那么被继承的类后面不需要加 ()class Student : Person&#123; constructor() : super()&#123; &#125;&#125; 3、接口1）、Kotlin 和 Java 中定义接口没有任何区别 12345678910111213141516171819202122232425262728293031323334353637//定义接口中的一系列的抽象行为 Kotlin 中增加了接口中定义的函数可以有默认实现，其实 Java 在 JDK1.8 之后也开始支持这个功能interface Study&#123; fun readBooks() //如果子类没有重写这个方法,那么就会调用这个方法的默认实现 fun doHomework()&#123; println("do homework default implementation") &#125;&#125;//定义一个可被继承的 People 类，有 name 和 age 两个属性open class People(val name: String,val age: Int)&#123;&#125;//定义一个 Student 类，继承 People 类，实现 Study 接口class Student(name: String, age: Int) : People(name, age),Study&#123; override fun readBooks() &#123; println("$name is read book") &#125;&#125;//定义的一个方法 然后在main函数调用fun doStudy(study: Study)&#123; study.readBooks() study.doHomework()&#125;//main函数调用fun main()&#123; val student = Student("erdai",20) //这里student实现了Study接口,这种叫做面向接口编程,也可以称为多态 doStydy(student)&#125;//打印结果erdai is read bookdo homework default implementation 4、函数的可见性修饰符 修饰符 Java Kotlin public 所有类可见 所有类可见(默认) private 当前类可见 当前类可见 protected 当前类,子类,同一个包下的可见 当前类和子类可见 default 同一个包下的可见(默认) 无 internal 无 同一个模块中的类可见 5、数据类与单例类数据类1）、在 Java 中，数据类通常需要重写 equals( )，hashCode( )，toString( ) 这几个方法，其中 equals( ) 方法用于判断两个数据类是否相等。hashCode( ) 方法作为 equals( ) 的配套方法，也需要一起重写，否则会导致 hash 相关的系统类无法正常工作，toString( ) 方法则用于提供更清晰的输入日志，否则一个数据类默认打印出来的是一行内存地址 2）、在 Kotlin 中，我们只需要使用 data 关键字去修饰一个类，Kotlin 就会自动帮我们生成 Java 需要重写的那些方法 12345678910111213141516171819202122232425262728293031//在 Java 中，我们会这么写public class Cellphone &#123; String brand; double price; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Cellphone cellphone = (Cellphone) o; return Double.compare(cellphone.price, price) == 0 &amp;&amp; Objects.equals(brand, cellphone.brand); &#125; @Override public int hashCode() &#123; return Objects.hash(brand, price); &#125; @Override public String toString() &#123; return "Cellphone&#123;" + "brand='" + brand + '\'' + ", price=" + price + '&#125;'; &#125;&#125;//在 Kotlin 中，你会发现是如此的简洁data class Cellphone(val brand: String, val price: Double) 单例类1）、Kotlin 中，我们只需要使用 object 关键字去替换 class 关键字就可以去定义一个单例类了 2）、调用单例类中的方法也比较简单，直接使用类名 . 上方法就可以了，类似于 Java 中的静态方法调用方式 12345678910111213141516171819202122232425262728//java中单例 懒汉式public class Singleton&#123; private static Singleton instance; public synchronized static Singleton getInstace() &#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125; public void singleonTest()&#123; System.out.println("singletonTest in Java is called."); &#125;&#125;//Kotlin中的单例object Singleton&#123; fun singletonTest()&#123; println("singletonTest in Kotlin is called.") &#125;&#125;fun main() &#123; Singleton.singletonTest()&#125;//打印结果singletonTest in Kotlin is called. Lambda 编程Kotlin 从第一个版本就开始支持了 Lambda 编程，并且 Kotlin 中的 Lambda 表达式极为强大，本章我们学习 Lambda 编程的一些基础知识： 1）、简单来说，Lambda 就是一段可以作为参数传递的代码，它可以作为函数的参数，返回值，同时也可以赋值给一个变量 2）、Lambda 完整的表达式的语法结构：{ 参数名1：参数类型，参数名2：参数类型 -&gt; 函数体 } 3）、很多时候，我们会使用简化形式的语法结构，直接就是一个函数体：{函数体}，这种情况是当 Lambda 表达式的参数列表中只有一个参数的时候，我们可以把参数给省略，默认会有个 it 参数 4）、Kotlin 中规定，当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面 5）、Kotlin 中规定，当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略 1、集合的创建和遍历1）、不可变集合：在集合初始化之后，我们不能对其进行增删改操作 2）、可变集合：在集合初始化之后，我们还能对其进行增删改操作 不可变集合 可变集合 listOf mutableListOf setOf mutableSetOf mapOf mutableMapOf 1234567891011121314151617181920212223242526272829303132333435363738//List 集合 //定义一个不可变 List 集合val list1 = listOf("Apple","Banana","Orange","Pear","Grape")//定义一个可变 List 集合val list2 = mutableListOf("Apple","Banana","Orange","Pear","Grape")//添加元素list2.add("Watermelon")for (i in list2) &#123; print("$i ")&#125;//打印结果Apple Banana Orange Pear Grape Watermelon//Set 集合和 List 集合用法完全一样//定义一个不可变 Set 集合val set1 = setOf("Apple","Banana","Orange","Pear","Grape")//定义一个可变 Set 集合val set2 = mutableSetOf("Apple","Banana","Orange","Pear","Grape")//添加元素set2.add("Watermelon")for (i in set2) &#123; print("$i ")&#125;//打印结果Apple Banana Orange Pear Grape Watermelon//Map 集合//定义一个不可变 Map 集合val map1 = mapOf("Apple" to 1,"Banana" to 2,"Orange" to 3, "Pear" to 4,"Grape" to 5)//定义一个可变 Map 集合val map2 = mutableMapOf("Apple" to 1,"Banana" to 2,"Orange" to 3, "Pear" to 4,"Grape" to 5)//当前 key 存在则修改元素，不存在则添加元素map1["Watermelon"] = 6for ((key,value) in map1) &#123; print("$key: $value ")&#125;//打印结果Apple: 1 Banana: 2 Orange: 3 Pear: 4 Grape: 5 Watermelon: 6 2、集合的函数式 API12345678910111213141516171819202122232425262728293031323334353637383940414243//定义一个不可变 List 集合val list1 = listOf("Apple","Banana","Orange","Pear","Grape","Watermelon")//现在我想打印集合中英文名字最长的字符串，我们可以这么做//方式1var maxLengthFruit = ""for (fruit in list1) &#123; if(fruit.length &gt; maxLengthFruit.length)&#123; maxLengthFruit = fruit &#125;&#125;print(maxLengthFruit)//打印结果Watermelon//但是如果使用函数式 Api 将会变得更加简单, maxBy 函数会根据你的条件遍历得到符合条件的最大值//方式2val maxLengthFruit = list1.maxBy &#123; it.length&#125;print(maxLengthFruit)//打印结果Watermelon//通过 maxBy 函数结合 Lambda 表达式语法结构，我们来剖析方式2这种写法的原理, 如下所示//1val list1 = listOf("Apple","Banana","Orange","Pear","Grape","Watermelon")val lambda = &#123;fruit: String -&gt; fruit.length&#125;//maxBy 函数实际上接收的是一个函数类型的参数，后续讲高阶函数的时候会讲到，也就是我们这里可以传入一个 Lambda 表达式val maxLengthFruit = list1.maxBy(lambda)//2 替换 lambdaval maxLengthFruit = list1.maxBy(&#123;fruit: String -&gt; fruit.length&#125;)//3 Kotlin 中规定，当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面val maxLengthFruit = list1.maxBy()&#123;fruit: String -&gt; fruit.length&#125;//4 Kotlin 中规定，当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略val maxLengthFruit = list1.maxBy&#123;fruit: String -&gt; fruit.length&#125;//5 当 Lambda 表达式的参数列表中只有一个参数的时候，我们可以把参数给省略，默认会有个 it 参数val maxLengthFruit = list1.maxBy&#123; it.length &#125;//经过上面 1-&gt;2-&gt;3-&gt;4-&gt;5 这几个步骤，我们最终得到了 5 的这种写法 集合中还有很多这样的函数式 Api，下面我们通过 list 集合来实践一下其他的一些函数式 Api： 12345678910111213141516171819202122val list = listOf("Apple","Banana","Orange","Pear","Grape","Watermelon")//1//通过 map 操作，把一个元素映射成一个新的元素val newList = list.map&#123; it.toUpperCase()&#125;for (s in newList) &#123; print("$s ")&#125;//打印结果APPLE BANANA ORANGE PEAR GRAPE WATERMELON //2//通过 filter 筛选操作，筛选长度小于等于5的字符串val newList = list.filter &#123; it.length &lt;= 5&#125;for (s in newList) &#123; print("$s ")&#125;//打印结果Apple Pear Grape 3、Java 函数式 API 的使用1）、Kotlin 中调用 Java 方法也可以使用函数式 Api ,但必须满足两个条件：1、得是用 Java 编写的接口 2、接口中只有一个待实现的方法 2)、Kotlin 中写匿名内部类和 Java 有一点区别，Kotlin 中因为抛弃了 new 关键字，改用 object 关键字就可以了 1234567891011121314151617181920212223242526272829303132333435363738//java 中的匿名内部类new Thread(new Runnable() &#123; @Override public void run() &#123; &#125;&#125;).start();//Kotlin 中可以这么写Thread(object : Runnable&#123; override fun run() &#123; &#125;&#125;).start()/** * 我们接着来简化 Kotlin 中的写法 * 因为 Runnable 类中只有一个待实现方法，即使这里没有显示的重写 run() 方法， * Kotlin 也能明白后面的 Lambda 表达式就是要在 run() 方法中实现的内容 */Thread(Runnable&#123; &#125;).start()//因为是单抽象方法接口，我们可以将接口名进行省略Thread(&#123; &#125;).start()//当 Lambda 表达式作为函数的最后一个参数的时候，我们可以把 Lambda 表达式移到函数括号的外面Thread()&#123; &#125;.start()//当 Lambda 表达式是函数的唯一参数的时候，函数的括号可以省略Thread&#123; &#125;.start() 四、空指针检查Android 系统上奔溃最高的异常就是空指针异常（NullPointerException），造成这种现象的主要原因是因为空指针是一种不受编程语言检查的运行时异常，只能由程序员主动通过逻辑判断来避免，但即使在出色的程序员，也不可能将所有潜在的空指针异常都考虑到。但是这种情况在 Kotlin 上得到了很好的解决，Kotlin 把空指针异常提前到了编译期去检查，这样的做法几乎杜绝了空指针异常，但是这样子会导致代码变得比较难写，不过 Kotlin 提供了一系列的辅助工具，让我们能轻松的处理各种判空的情况，下面我们就来学习它 1、可空类型系统和判空辅助工具1）、在类型后面加上 ? ，表示可空类型，Kotlin 默认所有的参数和变量不可为空 2）、在对象调用的时候，使用 ?. 操作符，它表示如果当前对象不为空则调用，为空则什么都不做 3）、?: 操作符表示如果左边的结果不为空，返回左边的结果，否则返回右边的结果 4）、在对象后面加 !! 操作符表示告诉Kotlin我这里一定不会为空,你不用进行检测了，如果为空，则抛出空指针异常 5）、let 函数，提供函数式 Api，并把当前调用的对象当作参数传递到 Lambda 表达式中 情况1： 在类型后面加上 ? ，表示可空类型，Kotlin 默认所有的参数和变量不可为空 1234567891011interface Study&#123; fun readBooks() fun domeHomework()&#123; println("do homework default implementation") &#125;&#125;fun doStudy(study: Study)&#123; study.readBooks() study.domeHomework()&#125; 上面这段代码是不会出现空指针异常的，如果你尝试向 doStudy 这个方法传递一个 null ，编译器会报错： 因此这种情况我们就可以使用可空类型，把 Study 改成 Study？，如下图： 你会发现虽然调用 doStudy 方法不报错了，但是 doStudy 内部的调用却报错了，因为此时 doStudy 接受一个可空的类型参数，可能会造成内部的空指针， Kotlin 编译器不允许这种情况存在，那么我们进行如下改造就好了： 123456fun doStudy(study: Study?)&#123; if(study != null)&#123; study.readBooks() study.domeHomework() &#125;&#125; 情况2： 在对象调用的时候，使用 ?. 操作符，它表示如果当前对象不为空则调用，为空则什么都不做 针对上面的 doStudy 方法，我们还可以这么做： 1234fun doStudy(study: Study?)&#123; study?.readBooks() study?.domeHomework()&#125; 情况3： ?: 操作符表示如果左边的结果不为空，返回左边的结果，否则返回右边的结果 123456789//平时我们可能写这样的代码val a = if (b != null) &#123; b&#125; else &#123; c&#125;//使用 ?: 操作符可以简化成这样val a = b ?: c 情况4： 在对象后面加 !! 操作符表示告诉Kotlin我这里一定不会为空,你不用进行检测了，如果为空，则抛出空指针异常 12345678910111213141516171819202122//下面这段代码编译通不过，因为 printName 方法里的 name 并不知道你在外面做了非空判断val name: String? = "erdai"fun printName()&#123; val upperCaseName = name.toUpperCase() print(upperCaseName)&#125;fun main() &#123; if(name != null)&#123; printName() &#125;&#125;//因此在上面这种明确不会为空的情况下，我们可以使用 !! 操作符，改造一下 printName 方法//同时要提醒一下自己，是否存在更好的实现方式，因为使用这种操作符，还是会存在潜在的空指针异常fun printName()&#123; val upperCaseName = name!!.toUpperCase() print(upperCaseName)&#125;//打印结果ERDAI 情况5： let 函数，提供函数式 Api，并把当前调用的对象当作参数传递到 Lambda 表达式中 1234567891011121314151617181920212223242526272829303132333435//这是我们情况2 实现的方式，但是如果这种调用方式一多，会显得特别啰嗦，例如：fun doStudy(study: Study?)&#123; study?.readBooks() study?.domeHomework() study?.a() study?.b()&#125;//上面这种情况等同于如下代码:fun doStudy(study: Study?)&#123; if(study != null)&#123; study?.readBooks() &#125; if(study != null)&#123; study?.domeHomework() &#125; if(study != null)&#123; study?.a() &#125; if(study != null)&#123; study?.b() &#125;&#125;//这个时候我们就可以使用 let 函数来操作了fun doStudy(study: Study?)&#123; study?.let&#123; it.readBooks() it.domeHomework() it.a() it.b() &#125;&#125; 五、Kotlin中的小魔术1、字符串的内嵌表达式1）、Kotlin 中，字符串里面可以使用 ${} 引用变量值和表达式，当 {} 里面只有一个变量，非表达式时，{}也可以去掉 1234567fun main() &#123; val a = "erdai" val b = "666" print("$a $&#123;a + b&#125;")&#125;//打印结果erdai erdai666 2、函数的参数默认值1）、定义一个函数时，我们可以给函数的参数添加一个默认值，这样子我们就不需要去传那个参数 2）、在我们调用一个函数时，我们可以使用 key value 的形式来传参 12345678910111213141516171819202122232425//情况1：定义一个函数时，我们可以给函数的参数添加一个默认值，这样子我们就不需要去传那个参数fun printParams(name: String,age: Int = 20)&#123; print("I am $name, $age years old.")&#125;fun main() &#123; printParams("erdai")&#125;//打印结果I am erdai, 20 years old.//当然我们也可以选择覆盖默认参数fun main() &#123; printParams("erdai",25)&#125;//打印结果I am erdai, 25 years old.//情况2：在我们调用一个函数时，我们可以使用 key value 的形式来传参fun main() &#123; //注意 printParams 方法的一个参数是 name ,第二个才是 age, 但是通过 key value 的形式来传参就不会出现参数顺序问题 printParams(age = 19,name = "erdai666")&#125;//打印结果I am erdai666, 19 years old. 小技巧：我们可以通过函数的参数默认值来代替次构造函数，使用主构造函数就好了 六、标准函数和静态方法1、标准函数let，also，with，run 和 apply1）、let 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中的参数为当前调用者，且最后一行代码作为返回值 2）、also 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中的参数为当前调用者，无法指定返回值，这个函数返回的是当前调用对象本身 3）、with 函数，接收两个参数，第一个为任意类型参数，第二个为 Lambda 表达式参数，Lambda 表达式中拥有第一个参数的上下文 this ，且最后一行代码作为返回值 4）、run 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中拥有当前调用对象的上下文 this ，且最后一行代码作为返回值 5）、apply 函数，必须让某个对象调用，接收一个 Lambda 表达式参数，Lambda 表达式中拥有当前调用对象的上下文 this ，无法指定返回值，这个函数返回的是当前调用对象本身 注意：在Lambda 表达式中，拥有对象的上下文 this，和拥有该对象是一样的，只不过 this 可省略，而拥有该对象我们可以自定义参数名，如果不写该参数，默认会有个 it 参数 下面通过代码来感受一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 情况1：let 函数 * 1、创建一个 StringBuilder 对象调用 let 函数，Lambda 表达式中的参数为 StringBuilder 对象 * 2、当 Lambda 表达式中只有一个参数的时候可省略，默认会有个 it 的参数，返回值即为 Lambda 表达式中最后一行代码 */fun main() &#123; val name = "erdai" val age = 20 val returnValue = StringBuilder().let &#123; it.append(name).append(" ").append(age) &#125; println(returnValue)&#125;//打印结果erdai 20/** * 情况2：also 函数 * 1、创建一个 StringBuilder 对象调用 also 函数，Lambda 表达式中的参数为 StringBuilder 对象 * 2、当 Lambda 表达式中只有一个参数的时候可省略，默认会有个 it 的参数，无法指定返回值，返回调用对象本身 */fun main() &#123; val name = "erdai" val age = 20 val stringBuilder = StringBuilder().also &#123; it.append(name).append(" ").append(age) &#125; println(stringBuilder.toString())&#125;//打印结果erdai 20/** * 情况3：with 函数 * 1、接收两个参数，第一个参数为 StringBuilder 对象，第二个参数为 Lambda 表达式， * 2、Lambda 表达式中拥有 StringBuilder 对象的上下文 this, 返回值即为 Lambda 表达式中的最后一行代码 */fun main() &#123; val name = "erdai" val age = 20 val returnValue = with(StringBuilder()) &#123; append(name).append(" ").append(age) &#125; println(returnValue)&#125;//打印结果erdai 20/** * 情况4：run 函数 * 1、创建一个 StringBuilder 对象调用 also 函数，Lambda 表达式中拥有 StringBuilder 对象的上下文 this * 2、返回值即为 Lambda 表达式中的最后一行代码 */fun main() &#123; val name = "erdai" val age = 20 val returnValue = StringBuilder().run &#123; append(name).append(" ").append(age) &#125; println(returnValue)&#125;//打印结果erdai 20/** * 情况5：apply 函数 * 1、创建一个 StringBuilder 对象调用 apply 函数，Lambda 表达式中拥有 StringBuilder 对象的上下文 this * 2、无法指定返回值，返回调用对象本身 */fun main() &#123; val name = "erdai" val age = 20 val stringBuilder = StringBuilder().apply &#123; append(name).append(" ").append(age) &#125; println(stringBuilder.toString())&#125;//打印结果erdai 20 其实上面 5 个标准函数有很多相似的地方，我们需搞清楚它们差异之处，下面我们用一个图表来总结一下： 标准函数 函数参数 是否是扩展函数 返回值 T.let it 是 最后一行代码 T.also it 是 对象本身 with this 否 最后一行代码 T.run this 是 最后一行代码 T.apply this 是 对象本身 2、定义静态方法Kotlin 中没有直接提供定义为静态方法的关键字，但是提供了一些类似的语法特性来支持静态方法调用的写法 1）、使用 companion object 为一个类创建一个伴生类，然后调用这个伴生类的方法，这个方法不叫静态方法，但是可以当作静态方法调用 2）、使用 object 关键字定义一个单例类，通过单例类，去调用方法，这种方法也不叫静态方法，但是可以当作静态方法调用 3）、如果想定义真正的静态方法，Kotlin 中也提供了两种方式：1、使用 @JvmStatic 注解，且注解只能加在伴生类和单例类上的方法上面 2、定义顶层方法 4）、顶层方法就是不定义在任何类中的方法，顶层方法在任何位置都能被调用到，Kotlin 编译器会把所有的顶层方法编译成静态方法 5）、如果在 Java 中调用顶层方法，Java 默认是没有顶层方法的概念的，Kotlin 编译器会生成一个我们定义这个文件的 Java 类，例如我在 Kotlin 中的 Util.kt 文件中定义了一个顶层方法，那么就会生成一个 UtilKt 的 Java 类供在 Java 中调用 6）、在 Kotlin 中比较常用的是 单例，伴生类和顶层方法，@JvmStatic 注解用的比较少 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//在 Java 中我们可以这样定义一个静态方法public class Util &#123; public static void doAction()&#123; System.out.println("do something"); &#125;&#125;//Kotlin 中类似这样静态调用多种多样//情况1：使用 companion object 为一个类创建一个伴生类fun main() &#123; Util.doAction()&#125;class Util&#123; companion object&#123; fun doAction()&#123; println("do something") &#125; &#125;&#125;//打印结果do something//情况2：使用 object 关键字定义一个单例类fun main() &#123; Util.doAction()&#125;object Util &#123; fun doAction() &#123; println("do something") &#125;&#125;//打印结果do something//情况3：1、使用 @JvmStatic 注解 2、定义顶层方法//1//单例类object Util &#123; @JvmStatic fun doAction() &#123; println("do something") &#125;&#125;//伴生类class Util &#123; companion object&#123; fun doAction() &#123; println("do something") &#125; &#125;&#125;//2 使用 AndroidStudio 新建一个文件，在弹框中选择 File 即可，我们在这个 File 中编写一个顶层方法//顶层方法在任何位置都能调用到fun doAction()&#123; println("do something")&#125; 上述代码大家可以将 Kotlin 文件转换成 Java 文件看一下，你就会发现定义真正的静态方法和非静态方法的区别 七、延迟初始化和密封类1、对变量延迟初始化1）、使用 lateinit 关键字对一个变量延迟初始化 使用 lateinit 关键字注意事项： 1、只能作用于 var 属性，且该属性没有自定义 get 和 set 方法 2、该属性必须是非空类型，且不能是原生类型 2）、当你对一个变量使用了 lateinit 关键字，Kotlin 编译器就不会在去检查这个变量是否会为空了，此时你要确保它在被调用之前已经初始化了，否则程序运行的时候会报错，可以使用 ::object.isInitialized 这种固定的语法结构判断变量是否已经初始化 3）、使用 by lazy 对一个变量延迟初始化 使用 by lazy 注意事项： 1、只能作用于 val 属性 12345678910111213141516171819202122232425262728293031323334//情况1：使用 lateinit 关键字对一个变量延迟初始化lateinit var name: Stringfun main() &#123; name = "erdai" println(name)&#125;//打印结果erdai//情况2: 使用 ::object.isInitialized 这种固定的语法结构判断变量是否已经初始化lateinit var name: Stringfun main() &#123; if(::name.isInitialized)&#123; println(name) &#125;else&#123; println("name not been initialized") &#125;&#125;//打印结果name not been initialized//情况3: 使用 by lazy 对一个变量延迟初始化//特点：该属性调用的时候才会初始化，且 lazy 后面的 Lambda 表达式只会执行一次val name: String by lazy &#123; "erdai"&#125;fun main() &#123; println(name)&#125;//打印结果erdai 2、使用密封类优化代码密封类能使我们写出更加规范和安全的代码 1）、使用 sealed class 定义一个密封类 2）、密封类及其子类，只能定义在同一个文件的顶层位置 3）、密封类可被继承 4）、当我们使用条件语句的时候，需要实现密封类所有子类的情况，避免写出永远不会执行的代码 123456789101112131415161718192021222324252627//在使用密封类之前我们可能会写出这种代码interface Resultclass Success : Resultclass Failure : Result/** * 那么此时如果我新增一个类实现 Result 接口，编译器并不会提示我们去新增新的条件分支 * 如果我们没有新增相应的条件分支，那么就会出现执行 else 的情况 * 其实这个 else 就是一个无用分支，这仅仅是为了满足编译器的要求 */fun getResultMsg(result: Result) = when (result)&#123; is Success -&gt; "Success" is Failure -&gt; "Failure" else -&gt; throw RuntimeException()&#125;//在使用密封类之后sealed class Resultclass Success : Result()class Failure : Result()/** * 此时我们就避免了写 else 分支，这个时候如果我新增一个类实现 Result 密封类 * 编译器就会提示异常，需要 when 去新增相应的条件分支 */fun getResultMsg(result: Result) = when (result)&#123; is Success -&gt; "Success" is Failure -&gt; "Failure"&#125; 八、扩展函数和运算符1、大有用途的扩展函数扩展函数允许我们去扩展一个类的函数，这种特性是 Java 中所没有的 1）、扩展函数的语法结构如下： 123fun ClassName.methodName(params1: Int, params2: Int) : Int&#123; &#125; 相比于普通的函数，扩展函数只需要在函数前面加上一个 ClassName. 的语法结构，就表示把该函数添加到指定的类中 2）、一般我们要定义哪个类的扩展函数，我们就定义一个同名的 Kotlin 文件，便于后续查找，虽然说也可以定义在任何一个类中，但是更推荐将它定义成顶层方法，这样可以让扩展方法拥有全局的访问域 3）、扩展函数默认拥有这个类的上下文环境 例如我们现在要给 String 这个类扩展一个 printString 方法，我们就可以新建一个 String.kt 的文件，然后在这个文件下面编写扩展函数： 12345678910fun String.printString()&#123; println(this)&#125;fun main() &#123; val name = "erdai" name.printString()&#125;//打印结果erdai 2、有趣的运算符重载Kotlin 的运算符重载允许我们让任意两个对象进行相加，或者是进行其他更多的运算操作 1）运算符重载使用的是 operator 关键字，我们只需要在指定函数前面加上 operator 关键字，就可以实现运算符重载的功能了。 上面所说的指定函数有下面这些，如图： 2）例如我现在要实现两个对象相加的功能，它的语法结构如下： 12345class Obj &#123; operator fun plus(obj: Obj): Obj&#123; //do something &#125;&#125; 下面我们来实现一个金钱相加的例子： 123456789101112131415161718192021222324252627class Money(val value: Int) &#123; //实现运算符重载 Money + Money operator fun plus(money: Money): Money &#123; val sum = value + money.value return Money(sum) &#125; //实现运算符重载 Money + Int operator fun plus(money: Int): Money&#123; val sum = value + money return Money(sum) &#125;&#125;fun main() &#123; val money1 = Money(15) val money2 = Money(20) val money3 = money1 + money2 val money4 = money3 + 15 println(money3.value) print(money4.value)&#125;//打印结果3550 九、高阶函数详解高阶函数和 Lambda 表达式是密不可分的，在之前的章节，我们学习了一些 函数式 Api 的用法，你会发现，它们都会有一个共同的特点：需要传入一个 Lambda 表达式作为参数。像这种接收 Lambda 表达式的函数我们就可以称之为具有函数式编程风格的 Api，而如果你要定义自己的函数式 Api，那么就需要使用高阶函数来实现了 1、定义高阶函数1）高阶函数的定义：一个函数接收另外一个函数作为参数，或者返回值，那么就可以称之为高阶函数 Kotlin 中新增了函数类型，如果我们将这种函数类型添加到一个函数的参数声明或者返回值，那么这就是一个高阶函数 2）函数类型的语法规则如下 123(String,Int) -&gt; Unit//或者如下() -&gt; Unit -&gt; 的左边声明函数接收什么类型的参数，-&gt; 的右边声明的是函数的返回值，现在我们来声明一个高阶函数： 123fun example(func: (String,Int) -&gt; Unit) &#123; //do something&#125; 3）高阶函数的调用，我们只需要在参数名后面加上一对括号，传入对应类型的参数即可，例如以上面定义的这个高阶函数为例子： 1234fun example(func: (String,Int) -&gt; Unit) &#123; //函数类型调用 func("erdai",666)&#125; 下面我们就来实践一下： 12345678910111213141516171819202122232425262728293031323334353637383940//我们使用高阶函数来获取两个数相加的和fun numberPlus(num1: Int,num2: Int,func: (Int,Int) -&gt; Int): Int&#123; val sum = func(num1,num2) return sum&#125;fun plus(num1: Int,num2: Int): Int&#123; return num1 + num2&#125;fun minus(num1: Int,num2: Int): Int&#123; return num1 - num2&#125;//调用高阶函数的两种方式//方式1：成员引用，使用 ::plus，::minus这种写法引用一个函数fun main() &#123; val numberPlus = numberPlus(10, 20, ::plus) val numberMinus = numberPlus(10, 20, ::minus) println(numberPlus) println(numberMinus)&#125;//打印结果30-10//方式2：使用 Lambda 表达式的写法fun main() &#123; val numberPlus = numberPlus(10, 20)&#123; num1,num2 -&gt; num1 + num2 &#125; val numberMinus = numberPlus(10, 20)&#123; num1,num2 -&gt; num1 - num2 &#125; println(numberPlus) println(numberMinus)&#125;//打印结果30-10 其中使用 Lambda 表达式的写法是高阶函数中最普遍的调用方式 2、内联函数的作用1）内联函数可以消除 Lambda 表达式运行时带来的开销 Kotlin 代码最终还是会转换成 Java 字节码文件，举个🌰： 1234567891011121314151617181920212223242526272829fun numberPlus(num1: Int,num2: Int,func: (Int,Int) -&gt; Int): Int&#123; val sum = func(num1,num2) return sum&#125;fun main() &#123; val num1 = 10 val num2 = 20 val numberPlus = numberPlus(num1, num2)&#123; num1,num2 -&gt; num1 + num2 &#125;&#125;//上面这些代码最终转换成 Java 代码大概会变成这样：public static int numberPlus(int num1, int num2, Function operation)&#123; int sum = (int) operation.invoke(num1,num2); return sum;&#125;public static void main()&#123; int num1 = 10; int num2 = 20; int sum = numberPlus(num1,num2,new Function()&#123; @Override public Integer invoke(Integer num1,Integer num2)&#123; return num1 + num2; &#125; &#125;);&#125; 可以看到，转换之后，numberPlus 函数的第三个参数变成了一个 Function 接口，这是一种 Kotlin 的内置接口，里面有一个待实现的 invoke 函数，而 numberPlus 函数其实就是调用了 Function 接口的 invoke 函数，并把 num1 和 num2 传了进去。之前的 Lambda 表达式在这里变成了 Function 接口的匿名类实现，这就是 Lambda 表达式的底层转换逻辑，因此我们每调用一次 Lambda 表达式，都会创建一个新的匿名类实例，这样就会造成额外的内存和性能开销。但是我们使用内联函数，就可以很好的去解决这个问题 2）定义高阶函数时加上 inline 关键字修饰，我们就可以把这个函数称之为内联函数 12345//定义一个内联函数inline fun numberPlus(num1: Int,num2: Int,func: (Int,Int) -&gt; Int): Int&#123; val sum = func(num1,num2) return sum&#125; 那这里我就会有个疑问，为啥内联函数能消除 Lambda 表达式运行时带来的开销呢？ 这个时候我们就需要去剖析一下内联函数的工作原理了，如下： 123456789101112inline fun numberPlus(num1: Int,num2: Int,func: (Int,Int) -&gt; Int): Int&#123; val sum = func(num1,num2) return sum&#125;fun main() &#123; val num1 = 10 val num2 = 20 val numberPlus = numberPlus(num1, num2)&#123; num1,num2 -&gt; num1 + num2 &#125;&#125; 第一步替换过程：Kotlin 编译器会把 Lambda 表达式中的代码替换到函数类型参数调用的地方 ，如下图： 替换后代码变成了这样： 12345678910inline fun numberPlus(num1: Int,num2: Int,func: (Int,Int) -&gt; Int): Int&#123; val sum = num1 + num2 return sum&#125;fun main() &#123; val num1 = 10 val num2 = 20 val numberPlus = numberPlus(num1, num2);&#125; 第二步替换过程：Kotlin 编译器会把内联函数中的全部代码替换到函数调用的地方 ，如下图： 替换后代码变成了这样： 12345fun main() &#123; val num1 = 10 val num2 = 20 val numberPlus = num1 + num2&#125; 上述步骤就是内联函数的一个工作流程：Kotlin 编译器会把内联函数中的代码在编译的时候自动替换到调用它的地方 ，这样也就不存在运行时的开销了 3）使用 noinline 关键字修饰的函数类型参数，表示该函数类型参数不需要进行内联 一般使用 noinline 关键字，是在一个内联函数中存在多个函数类型的参数 1234//使用内联函数定义的高阶函数，其里面的函数类型参数都会进行内联，因此这里使用 noinline 表示我这个函数类型参数不需要内联inline fun inlineTest(block1: () -&gt; Unit, noinline block2: () -&gt; Unit)&#123; &#125; 前面我们讲到，使用内联函数能减少运行时开销，为啥现在又要出来个 noinline 关键字定义不需要内联呢？原因如下： 1、内联函数在编译的时候会进行代码替换，因此它没有真正的参数属性，它的函数类型参数只能传递给另外一个内联函数，而非内联函数的函数类型参数可以自由的传递给其他任何函数 2、内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行函数返回，非内联函数所引用的 Lambda 表达式可以使用 return@Method 语法结构来进行局部返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//情况1：非内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行局部返回//定义一个非内联的高阶函数fun printString(str: String, block: (String) -&gt; Unit)&#123; println("printString start...") block(str) println("printString end...")&#125;fun main() &#123; println("main start...") val str = "" printString(str)&#123; println("lambda start...") /** * 1，非内联函数不能直接使用 return 关键字进行局部返回 * 2，需要使用 return@printString 进行局部返回 */ if (str.isEmpty())return@printString println(it) println("lambda end...") &#125; println("main end...")&#125;//打印结果main start...printString start...lambda start...printString end...main end...//情况2：内联函数所引用的 Lambda 表达式可以使用 return 关键字来进行函数返回//定义一个非内联的高阶函数inline fun printString(str: String, block: (String) -&gt; Unit)&#123; println("printString start...") block(str) println("printString end...")&#125;fun main() &#123; println("main start...") val str = "" printString(str)&#123; println("lambda start...") if (str.isEmpty())return println(it) println("lambda end...") &#125; println("main end...")&#125;//因为内联函数会进行代码替换，因此这个 return 就相当于外层函数调用的一个返回，如下代码：fun main() &#123; println("main start...") val str = "" println("printString start...") println("lambda start...") if (str.isEmpty())return println(str) println("lambda end...") println("printString end...") println("main end...")&#125;//打印结果main start...printString start...lambda start... 4）、使用 crossinline 关键字保证内联函数的 Lambda 表达式中一定不会使用 return 关键字，但是还是可以使用 return@Method 语法结构进行局部返回，其他方面和内联函数特性一致 举个使用 crossinline 场景的🌰 ： 上面图片中的代码报错了，编译器提示我们的大致原因是：这个地方不能使用 inline ,因为它可能包含非局部的 return 返回，添加 crossinline 修饰符去修饰这个函数类型的参数。 为啥呢？我们来分析一下： 我们创建了一个 Runnable 对象，在 Runnable 中的 Lambda 表达式中调用了函数类型参数，Lambda 表达式在编译的时候会被转换成匿名内部类的方式，内联函数允许我们在 Lambda 表达式中使用 return 关键字进行函数返回，但是由于我们是在匿名类中调用的函数类型参数，此时是不可能进行外层调用函数返回的，最多是在匿名函数中进行返回，因此这里就提示了错误，知道了原因那我们使用 crossinline 关键字来修改一下 12345678910111213141516171819202122232425inline fun runRunnable(crossinline block: () -&gt; Unit) &#123; println("runRunnable start...") val runnable = Runnable &#123; block() &#125; runnable.run() println("runRunnable end...")&#125;fun main() &#123; println("main start...") runRunnable &#123; println("lambda start...") return@runRunnable println("lambda end...") &#125; println("main end...")&#125;//打印结果main start...runRunnable start...lambda start...runRunnable end...main end... 十、泛型和委托1、泛型的基本用法1）、首先我们解释下什么是泛型，泛型就是参数化类型，它允许我们在不指定具体类型的情况下进行编程。我们在定义一个类，方法，或者接口的时候，给他们加上一个类型参数，就是为这个类，方法，或者接口添加了一个泛型 1234567891011121314151617181920212223242526//1、定义一个泛型类，在类名后面使用 &lt;T&gt; 这种语法结构就是为这个类定义一个泛型class MyClass&lt;T&gt;&#123; fun method(params: T) &#123; &#125;&#125;//泛型调用val myClass = MyClass&lt;Int&gt;()myClass.method(12)//2、定义一个泛型方法，在方法名的前面加上 &lt;T&gt; 这种语法结构就是为这个方法定义一个泛型class MyClass&#123; fun &lt;T&gt; method(params: T)&#123; &#125;&#125;//泛型调用val myClass = MyClass()myClass.method&lt;Int&gt;(12)//根据 Kotlin 类型推导机制，我们可以把泛型给省略myClass.method(12)//3、定义一个泛型接口，在接口名后面加上 &lt;T&gt; 这种语法结构就是为这个接口定义一个泛型interface MyInterface&lt;T&gt;&#123; fun interfaceMethod(params: T)&#125; 上面的 T 不是固定的，可以是任意单词和字母，但是定义的泛型尽量做到见名知义 2）、为泛型指定上界，我们可以使用 &lt;T : Class&gt; 这种语法结构，如果不指定泛型的上界，默认为 Any? 类型 123456class MyClass&#123; //我们指定了泛型的上界为 Number, 那么我们就只能传入数字类型的参数了 fun &lt;T : Number&gt; method(params: T) &#123; &#125;&#125; 2、类委托和委托属性委托模式的意义：在于我们大部分方法实现可以调用辅助对象去实现，少部分方法的实现由自己来重写，甚至加入一些自己独有的方法，使我们这个类变成一个全新数据结构的类 1）、类委托核心思想就是把一个类的具体实现委托给另外一个类，使用 by 关键字进行委托 12345678910111213141516171819202122232425//定义一个 MySet 类，它里面的具体实现都委托给了 HashSet 这个类，这是是类委托class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt;&#123; override val size: Int get() = helperSet.size override fun contains(element: T) = helperSet.contains(element) override fun containsAll(elements: Collection&lt;T&gt;) = helperSet.containsAll(elements) override fun isEmpty() = helperSet.isEmpty() override fun iterator() = helperSet.iterator()&#125;/** * 如果我们使用 by 关键字，上面的代码将会变得非常整洁，同时我们可以对某个方法进行重写或者新增方法 * 那么 MySet 就变成了一个全新的数据结构类 */class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; by helperSet&#123; fun helloWord()&#123; println("Hello World") &#125; override fun isEmpty() = false&#125; 2）、属性委托的核心思想是将一个属性的具体实现委托给另一个类去完成 属性委托的语法结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940/*** 使用 by 关键字连接了左边的 p 属性和右边的 Delegate 实例* 这种写法就代表着将 p 属性的具体实现委托给了 Delegate 去完成*/class MyClass&#123; var p by Delegate()&#125;/*** 下面是一个被委托类的代码实现模版* 一、getValue 方法和setValue 方法必须使用 operator 关键字修饰* * 二、getValue 方法主要接收两个参数：* 1、第一个参数表明 Delegate 类的委托功能可以在什么类中使用* 2、第二个参数 KProperty&lt;*&gt; 是 Kotlin 中的一个属性操作类，* 可用于获取各种属性的相关值，&lt;*&gt;这种泛型的写法类似 Java 的* &lt;?&gt;，表示我不关心泛型的具体类型** 三、setValue 方法也是相似的，接收三个参数：* 1、前面两个参数和 getValue 是一样的* 2、第三个参数表示具体要赋值给委托属性的值，这个参数的类型必须和* getValue 方法返回值的类型保持一致*** 一种特殊情况：用 val 定义的变量不需要实现 setValue 方法，因为 val* 关键字声明的属性只可读，赋值之后就不能更改了*/class Delegate&#123; var propValue: Any? = null operator fun getValue(any: Any?,prop: KProperty&lt;*&gt;): Any?&#123; return propValue &#125; operator fun setValue(any: Any?,prop: KProperty&lt;*&gt;,value: Any?)&#123; propValue = value &#125;&#125; 十一、使用 infix 函数构建更可读的语法infix 函数语法结构可读性高，相比于调用一个函数，它更接近于使用英语 A to B 这样的语法结构 例如我们调用一个函数会使用： A.to(B) 这种结构，但是使用 infix 函数我们可以这么写：A to B，这种语法我们在讲 Map 的时候用过 12//定义一个不可变 Map 集合val map1 = mapOf("Apple" to 1,"Banana" to 2,"Orange" to 3, "Pear" to 4,"Grape" to 5) 1）、在函数前面加上 infix 关键字，就可以声明这是一个 infix 函数 123456789//对 String 增加一个扩展的 infix 函数，最终调用的还是 String 的 startsWith 函数infix fun String.beginWith(string: String) = startsWith(string)fun main() &#123; val name = "erdai" println(name beginWith "er")&#125;//打印结果true 我们再来实现一个初始化 Map 时里面传入 A to B 这种 infix 函数 123456789//这是 A to B 的源码实现public infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that)//我们仿照它写一个public infix fun &lt;A,B&gt; A.with(that: B): Pair&lt;A,B&gt; = Pair(this,that)fun main() &#123; val map = mapOf("Apple" with 1,"Banana" with 2,"Orange" with 3,"Pear" with 4,"Grape" with 5)&#125; 十二、使用 DSL 构建专有的语法结构1）、DSL 介绍 DSL英文全称：domain specific language，中文翻译即领域特定语言，例如：HTML，XML等 DSL 语言 特点 解决特定领域的专有问题 它与系统编程语言走的是两个极端，系统编程语言是希望解决所有的问题，比如 Java 语言希望能做 Android 开发，又希望能做后台开发，它具有横向扩展的特性。而 DSL 具有纵向深入解决特定领域专有问题的特性。 总的来说，DSL 的核心思想就是：“求专不求全，解决特定领域的问题”。 2）Kotin DSL 首先介绍一下Gradle：Gradle 是一个开源的自动化构建工具，是一种基于 Groovy 或 Kotin 的 DSL。我们的 Android 应用就是使用 Gradle 构建的，因此后续写脚本，写插件，我们可以使用 Kotlin 去编写，而且 AndroidStudio 对 Kotlin 的支持很友好，各种提示，写起来很爽。 对于我们 Android 开发，在 build.gradle 文件里面添加依赖的方式很常见： 1234dependencies &#123; implementation 'androidx.core:core-ktx:1.3.2' implementation 'androidx.appcompat:appcompat:1.2.0'&#125; 上面这种写法是一种基于 Groovy 的 DSL，下面我们就使用 Kotlin 来实现一个类似的 DSL： 12345678910111213141516171819class Dependency &#123; fun implementation(lib: String)&#123; &#125;&#125;fun dependencies(block: Dependency.() -&gt; Unit)&#123; val dependency = Dependency() dependency.block()&#125;fun main() &#123; //因为 Groovy 和 Kotlin 语法不同，因此写法会有一点区别 dependencies &#123; implementation ("androidx.core:core-ktx:1.3.2") implementation ("androidx.appcompat:appcompat:1.2.0") &#125;&#125; 十三、Java 与 Kotlin 代码之间的转换Java 代码转 Kotlin 代码方式有2： 1）、直接将 Java 代码复制到 Kotlin 文件中，AndroidStudio 会出来提示框询问你是否转换 2）、打开要转换的 Java 文件，在导航栏点击 Code -&gt; Convert Java File to Kotlin File Kotlin 代码转 Java 代码打开当前需要转换的 Kotlin 文件，在导航栏点击 Tools -&gt; Kotlin -&gt;Show Kotlin Bytecode ，会出来如下界面： 点击 Decompile 就可以把 Kotlin 字节码文件反编译成 Java 代码了 十四、总结本篇文章很长，我们介绍了 Kotlin 大部分知识点，按照文章开头的思维导图，我们就只剩下 Kotlin 泛型高级特性和 Kotlin 携程没有讲了，这两部分相对来说比较难，咋们后续在来仔细分析。相信你如果从头看到这里，收获一定很多，如果觉得我写得还不错，请给我点个赞吧🤝 转发：https://juejin.cn/post/6942251919662383134]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin5种单列模式]]></title>
    <url>%2Fposts%2F44748309.html</url>
    <content type="text"><![CDATA[最近在学习Kotlin这门语言，在项目开发中，运用到了单例模式。因为其表达方式与Java是不同的。所以对不同单例模式的实现进行了分别探讨。主要单例模式实现如下： 饿汉式 懒汉式 线程安全的懒汉式 双重校验锁式 静态内部类式 PS:该篇文章不讨论单例模式的运用场景与各种模式下的单例模式的优缺点。只讨论在Java下不同单例模式下的对应Kotlin实现。 一、饿汉式实现12345678910111213//Java实现public class SingletonDemo &#123; private static SingletonDemo instance=new SingletonDemo(); private SingletonDemo()&#123; &#125; public static SingletonDemo getInstance()&#123; return instance; &#125;&#125;//Kotlin实现object SingletonDemo 这里很多小伙伴，就吃了一惊。我靠一个object 关键字就完成相同的功能？一行代码？ Kotlin的对象声明 学习了Kotlin的小伙伴肯定知道,在Kotlin中类没有静态方法。如果你需要写一个可以无需用一个类的实例来调用，但需要访问类内部的函数（例如，工厂方法,单例等），你可以把该类声明为一个对象。 该对象与其他语言的静态成员是类似的。如果你想了解Kotlin对象声明的更多内容。请点击- - - 传送门(https://www.kotlincn.net/docs/reference/object-declarations.html#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1) 到这里，如果还是有很多小伙伴不是很相信一行代码就能解决这个功能，我们可以通过一下方式查看Kotlin的字节码。 查看Kotlin对应字节码 我们进入我们的Android Studio选择Tools工具栏，选择”Kotlin”,选择“Show Kotlin Bytecode” 选择过后就会进入到下方界面： 点击“Decompile” 根据字节码得到以下代码 12345678public final class SingletonDemo &#123; public static final SingletonDemo INSTANCE; private SingletonDemo()&#123;&#125; static &#123; SingletonDemo var0 = new SingletonDemo(); INSTANCE = var0; &#125;&#125; 通过以上代码，我们了解事实就是这个样子的，使用Kotlin”object”进行对象声明与我们的饿汉式单例的代码是相同的。 二、懒汉式123456789101112131415161718192021222324252627//Java实现public class SingletonDemo &#123; private static SingletonDemo instance; private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; if(instance==null)&#123; instance=new SingletonDemo(); &#125; return instance; &#125;&#125;//Kotlin实现class SingletonDemo private constructor() &#123; companion object &#123; private var instance: SingletonDemo? = null get() &#123; if (field == null) &#123; field = SingletonDemo() &#125; return field &#125; fun get(): SingletonDemo&#123; //细心的小伙伴肯定发现了，这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字 return instance!! &#125; &#125;&#125; 上述代码中，我们可以发现在Kotlin实现中，我们让其主构造函数私有化并自定义了其属性访问器，其余内容大同小异。 如果有小伙伴不清楚Kotlin构造函数的使用方式。请点击 - - - 构造函数(https://www.kotlincn.net/docs/reference/classes.html) 不清楚Kotlin的属性与访问器，请点击 - - -属性和字段(https://www.kotlincn.net/docs/reference/properties.html) 三、线程安全的懒汉式123456789101112131415161718192021222324252627//Java实现public class SingletonDemo &#123; private static SingletonDemo instance; private SingletonDemo()&#123;&#125; public static synchronized SingletonDemo getInstance()&#123;//使用同步锁 if(instance==null)&#123; instance=new SingletonDemo(); &#125; return instance; &#125;&#125;//Kotlin实现class SingletonDemo private constructor() &#123; companion object &#123; private var instance: SingletonDemo? = null get() &#123; if (field == null) &#123; field = SingletonDemo() &#125; return field &#125; @Synchronized fun get(): SingletonDemo&#123; return instance!! &#125; &#125;&#125; 大家都知道在使用懒汉式会出现线程安全的问题，需要使用使用同步锁，在Kotlin中，如果你需要将方法声明为同步，需要添加@Synchronized注解。 四、双重校验锁式（Double Check)12345678910111213141516171819202122//Java实现public class SingletonDemo &#123; private volatile static SingletonDemo instance; private SingletonDemo()&#123;&#125; public static SingletonDemo getInstance()&#123; if(instance==null)&#123; synchronized (SingletonDemo.class)&#123; if(instance==null)&#123; instance=new SingletonDemo(); &#125; &#125; &#125; return instance; &#125;&#125;//kotlin实现class SingletonDemo private constructor() &#123; companion object &#123; val instance: SingletonDemo by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) &#123; SingletonDemo() &#125; &#125;&#125; 哇！小伙伴们惊喜不，感不感动啊。我们居然几行代码就实现了多行的Java代码。其中我们运用到了Kotlin的延迟属性 Lazy。 Lazy是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托：第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。 这里还有有两个额外的知识点。 高阶函数，高阶函数是将函数用作参数或返回值的函数（我很纠结我到底讲不讲，哎）。大家还是看这个 —高阶函数(https://www.kotlincn.net/docs/reference/lambdas.html) 委托属性(https://www.kotlincn.net/docs/reference/delegated-properties.html) 如果你了解以上知识点，我们直接来看Lazy的内部实现。 Lazy内部实现 123456public fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; = when (mode) &#123; LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer) LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer) LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer) &#125; 观察上述代码，因为我们传入的mode = LazyThreadSafetyMode.SYNCHRONIZED，那么会直接走 SynchronizedLazyImpl，我们继续观察SynchronizedLazyImpl。 Lazy接口 SynchronizedLazyImpl实现了Lazy接口，Lazy具体接口如下：1234567public interface Lazy&lt;out T&gt; &#123; //当前实例化对象，一旦实例化后，该对象不会再改变 public val value: T //返回true表示，已经延迟实例化过了，false 表示，没有被实例化， //一旦方法返回true，该方法会一直返回true,且不会再继续实例化 public fun isInitialized(): Boolean&#125; 继续查看SynchronizedLazyImpl，具体实现如下： 123456789101112131415161718192021222324252627282930private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123; private var initializer: (() -&gt; T)? = initializer @Volatile private var _value: Any? = UNINITIALIZED_VALUE // final field is required to enable safe publication of constructed instance private val lock = lock ?: this override val value: T get() &#123; val _v1 = _value //判断是否已经初始化过，如果初始化过直接返回，不在调用高级函数内部逻辑 if (_v1 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") return _v1 as T &#125; return synchronized(lock) &#123; val _v2 = _value if (_v2 !== UNINITIALIZED_VALUE) &#123; @Suppress("UNCHECKED_CAST") (_v2 as T) &#125; else &#123; val typedValue = initializer!!()//调用高级函数获取其返回值 _value = typedValue //将返回值赋值给_value,用于下次判断时，直接返回高级函数的返回值 initializer = null typedValue &#125; &#125; &#125; //省略部分代码&#125; 通过上述代码，我们发现 SynchronizedLazyImpl 覆盖了Lazy接口的value属性，并且重新了其属性访问器。其具体逻辑与Java的双重检验是类似的。 到里这里其实大家还是肯定有疑问，我这里只是实例化了SynchronizedLazyImpl对象，并没有进行值的获取，它是怎么拿到高阶函数的返回值呢？。这里又涉及到了委托属性。 委托属性语法是：val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;。在 by 后面的表达式是该 委托， 因为属性对应的 get()（和 set()）会被委托给它的 getValue() 和 setValue() 方法。属性的委托不必实现任何的接口，但是需要提供一个 getValue() 函数（和 setValue()——对于 var 属性）。 而Lazy.kt文件中，声明了Lazy接口的getValue扩展函数。故在最终赋值的时候会调用该方法。 123@kotlin.internal.InlineOnly//返回初始化的值。public inline operator fun &lt;T&gt; Lazy&lt;T&gt;.getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T = value 五、静态内部类式12345678910111213141516171819202122//Java实现public class SingletonDemo &#123; private static class SingletonHolder&#123; private static SingletonDemo instance=new SingletonDemo(); &#125; private SingletonDemo()&#123; System.out.println("Singleton has loaded"); &#125; public static SingletonDemo getInstance()&#123; return SingletonHolder.instance; &#125;&#125;//kotlin实现class SingletonDemo private constructor() &#123; companion object &#123; val instance = SingletonHolder.holder &#125; private object SingletonHolder &#123; val holder= SingletonDemo() &#125;&#125; 静态内部类的实现方式，也没有什么好说的。Kotlin与Java实现基本雷同。 补充在该篇文章结束后，有很多小伙伴咨询，如何在Kotlin版的Double Check，给单例添加一个属性，这里我给大家提供了一个实现的方式。 12345678910class SingletonDemo private constructor(private val property: Int) &#123;//这里可以根据实际需求发生改变 companion object &#123; @Volatile private var instance: SingletonDemo? = null fun getInstance(property: Int) = instance ?: synchronized(this) &#123; instance ?: SingletonDemo(property).also &#123; instance = it &#125; &#125; &#125;&#125; 其中关于?:操作符，如果 ?: 左侧表达式非空，就返回其左侧表达式，否则返回右侧表达式。请注意，当且仅当左侧为空时，才会对右侧表达式求值。 观察代码我们可以发现大致上和我们的Java中的Double check是一样的。]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin委托]]></title>
    <url>%2Fposts%2Fa7864737.html</url>
    <content type="text"><![CDATA[委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。 Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。 类委托类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。 以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。 1234567891011121314151617// 创建接口interface Base &#123; fun print()&#125;// 实现此接口的被委托的类class BaseImpl(val x: Int) : Base &#123; override fun print() &#123; print(x) &#125;&#125;// 通过关键字 by 建立委托类class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) &#123; val b = BaseImpl(10) Derived(b).print() // 输出 10&#125; 在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。 属性委托属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。 属性委托语法格式： 1val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt; var/val：属性类型(可变/只读) 属性名：属性名称 类型：属性的数据类型 表达式：委托代理类 by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。 定义一个被委托的类该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。 1234567891011121314151617181920212223import kotlin.reflect.KProperty// 定义包含属性委托的类class Example &#123; var p: String by Delegate()&#125;// 委托的类class Delegate &#123; operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123; return "$thisRef, 这里委托了 $&#123;property.name&#125; 属性" &#125; operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123; println("$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val e = Example() println(e.p) // 访问该属性，调用 getValue() 函数 e.p = "Runoob" // 调用 setValue() 函数 println(e.p)&#125; 输出结果为： 123Example@433c675d, 这里委托了 p 属性Example@433c675d 的 p 属性赋值为 RunoobExample@433c675d, 这里委托了 p 属性 标准委托Kotlin 的标准库中已经内置了很多工厂方法来实现属性的委托。 延迟属性 Lazylazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。 123456789val lazyValue: String by lazy &#123; println("computed!") // 第一次调用输出，第二次调用不执行 "Hello"&#125;fun main(args: Array&lt;String&gt;) &#123; println(lazyValue) // 第一次执行，执行两次输出表达式 println(lazyValue) // 第二次执行，只输出返回值&#125; 执行输出结果： 123computed!HelloHello 可观察属性 Observableobservable 可以用于实现观察者模式。 Delegates.observable() 函数接受两个参数: 第一个是初始化值, 第二个是属性值变化事件的响应器(handler)。 在属性赋值后会执行事件的响应器(handler)，它有三个参数：被赋值的属性、旧值和新值： 1234567891011121314import kotlin.properties.Delegatesclass User &#123; var name: String by Delegates.observable("初始值") &#123; prop, old, new -&gt; println("旧值：$old -&gt; 新值：$new") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User() user.name = "第一次赋值" user.name = "第二次赋值"&#125; 执行输出结果： 12旧值：初始值 -&gt; 新值：第一次赋值旧值：第一次赋值 -&gt; 新值：第二次赋值 把属性储存在映射中一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他”动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。 12345678910111213141516class Site(val map: Map&lt;String, Any?&gt;) &#123; val name: String by map val url: String by map&#125;fun main(args: Array&lt;String&gt;) &#123; // 构造函数接受一个映射参数 val site = Site(mapOf( "name" to "菜鸟教程", "url" to "www.runoob.com" )) // 读取映射值 println(site.name) println(site.url)&#125; 执行输出结果： 12菜鸟教程www.runoob.com 如果使用 var 属性，需要把 Map 换成 MutableMap： 12345678910111213141516171819202122232425class Site(val map: MutableMap&lt;String, Any?&gt;) &#123; val name: String by map val url: String by map&#125;fun main(args: Array&lt;String&gt;) &#123; var map:MutableMap&lt;String, Any?&gt; = mutableMapOf( "name" to "菜鸟教程", "url" to "www.runoob.com" ) val site = Site(map) println(site.name) println(site.url) println("--------------") map.put("name", "Google") map.put("url", "www.google.com") println(site.name) println(site.url)&#125; 执行输出结果： 12345菜鸟教程www.runoob.com--------------Googlewww.google.com Not NullnotNull 适用于那些无法在初始化阶段就确定属性值的场合。 123456class Foo &#123; var notNullBar: String by Delegates.notNull&lt;String&gt;()&#125;foo.notNullBar = "bar"println(foo.notNullBar) 需要注意，如果属性在赋值前就被访问的话则会抛出异常。 局部委托属性你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化： 1234567fun example(computeFoo: () -&gt; Foo) &#123; val memoizedFoo by lazy(computeFoo) if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123; memoizedFoo.doSomething() &#125;&#125; memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。 属性委托要求对于只读属性(也就是说val属性), 它的委托必须提供一个名为getValue()的函数。该函数接受以下参数： thisRef —— 必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型 property —— 必须是类型 KProperty&lt;*&gt; 或其超类型 这个函数必须返回与属性相同的类型（或其子类型）。 对于一个值可变(mutable)属性(也就是说,var 属性),除 getValue()函数之外,它的委托还必须 另外再提供一个名为setValue()的函数, 这个函数接受以下参数: property —— 必须是类型 KProperty&lt;*&gt; 或其超类型new value —— 必须和属性同类型或者是它的超类型。 翻译规则在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，生成隐藏属性 prop$delegate，而访问器的代码只是简单地委托给这个附加属性： 1234567891011class C &#123; var prop: Type by MyDelegate()&#125;// 这段是由编译器生成的相应代码：class C &#123; private val prop$delegate = MyDelegate() var prop: Type get() = prop$delegate.getValue(this, this::prop) set(value: Type) = prop$delegate.setValue(this, this::prop, value)&#125; Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用到外部类 C 的实例而 this::prop 是 KProperty 类型的反射对象，该对象描述 prop 自身。 提供委托通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。 provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。 例如，如果要在绑定之前检查属性名称，可以这样写： 123456789101112131415161718class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123; operator fun provideDelegate( thisRef: MyUI, prop: KProperty&lt;*&gt; ): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(thisRef, prop.name) // 创建委托 &#125; private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;&#125;fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;class MyUI &#123; val image by bindResource(ResourceID.image_id) val text by bindResource(ResourceID.text_id)&#125; provideDelegate 的参数与 getValue 相同： thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型 property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。 在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。 如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便： 12345678910111213// 检查属性名称而不使用“provideDelegate”功能class MyUI &#123; val image by bindResource(ResourceID.image_id, "image") val text by bindResource(ResourceID.text_id, "text")&#125;fun &lt;T&gt; MyUI.bindResource( id: ResourceID&lt;T&gt;, propertyName: String): ReadOnlyProperty&lt;MyUI, T&gt; &#123; checkProperty(this, propertyName) // 创建委托&#125; 在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码： 123456789101112class C &#123; var prop: Type by MyDelegate()&#125;// 这段代码是当“provideDelegate”功能可用时// 由编译器生成的代码：class C &#123; // 调用“provideDelegate”来创建额外的“delegate”属性 private val prop$delegate = MyDelegate().provideDelegate(this, this::prop) val prop: Type get() = prop$delegate.getValue(this, this::prop)&#125; 请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin对象表达式和对象声明]]></title>
    <url>%2Fposts%2Fa056c2ad.html</url>
    <content type="text"><![CDATA[Kotlin 用对象表达式和对象声明来实现创建一个对某个类做了轻微改动的类的对象，且不需要去声明一个新的子类。 对象表达式通过对象表达式实现一个匿名内部类的对象用于方法的参数中： 12345678window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // ... &#125; override fun mouseEntered(e: MouseEvent) &#123; // ... &#125;&#125;) 对象可以继承于某个基类，或者实现其他接口: 123456789open class A(x: Int) &#123; public open val y: Int = x&#125;interface B &#123;……&#125;val ab: A = object : A(1), B &#123; override val y = 15&#125; 如果超类型有一个构造函数，则必须传递参数给它。多个超类型和接口可以用逗号分隔。 通过对象表达式可以越过类的定义直接得到一个对象： 12345678fun main(args: Array&lt;String&gt;) &#123; val site = object &#123; var name: String = "菜鸟教程" var url: String = "www.runoob.com" &#125; println(site.name) println(site.url)&#125; 请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的 返回类型或者用作公有属性的类型，那么该函数或属性的实际类型 会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象 中添加的成员将无法访问。 12345678910111213141516class C &#123; // 私有函数，所以其返回类型是匿名对象类型 private fun foo() = object &#123; val x: String = "x" &#125; // 公有函数，所以其返回类型是 Any fun publicFoo() = object &#123; val x: String = "x" &#125; fun bar() &#123; val x1 = foo().x // 没问题 val x2 = publicFoo().x // 错误：未能解析的引用“x” &#125;&#125; 在对象表达中可以方便的访问到作用域中的其他变量: 123456789101112131415fun countClicks(window: JComponent) &#123; var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; clickCount++ &#125; override fun mouseEntered(e: MouseEvent) &#123; enterCount++ &#125; &#125;) // ……&#125; 对象声明Kotlin 使用 object 关键字来声明一个对象。 Kotlin 中我们可以方便的通过对象声明来获得一个单例。 12345678object DataProviderManager &#123; fun registerDataProvider(provider: DataProvider) &#123; // …… &#125; val allDataProviders: Collection&lt;DataProvider&gt; get() = // ……&#125; 引用该对象，我们直接使用其名称即可： 1DataProviderManager.registerDataProvider(……) 当然你也可以定义一个变量来获取获取这个对象，当时当你定义两个不同的变量来获取这个对象时，你会发现你并不能得到两个不同的变量。也就是说通过这种方式，我们获得一个单例。 1234var data1 = DataProviderManagervar data2 = DataProviderManagerdata1.name = "test"print("data1 name = $&#123;data2.name&#125;") 实例以下实例中，两个对象都输出了同一个 url 地址： 1234567891011object Site &#123; var url:String = "" val name: String = "菜鸟教程"&#125;fun main(args: Array&lt;String&gt;) &#123; var s1 = Site var s2 = Site s1.url = "www.runoob.com" println(s1.url) println(s2.url)&#125; 输出结果为: 12www.runoob.comwww.runoob.com 对象可以有超类型： 123456789object DefaultListener : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // …… &#125; override fun mouseEntered(e: MouseEvent) &#123; // …… &#125;&#125; 与对象表达式不同，当对象声明在另一个类的内部时，这个对象并不能通过外部类的实例访问到该对象，而只能通过类名来访问，同样该对象也不能直接访问到外部类的方法和变量。 1234567891011121314class Site &#123; var name = "菜鸟教程" object DeskTop&#123; var url = "www.runoob.com" fun showName()&#123; print&#123;"desk legs $name"&#125; // 错误，不能访问到外部类的方法和变量 &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var site = Site() site.DeskTop.url // 错误，不能通过外部类的实例访问到该对象 Site.DeskTop.url // 正确&#125; 伴生对象类内部的对象声明可以用 companion 关键字标记，这样它就与外部类关联在一起，我们就可以直接通过外部类访问到对象的内部元素。 1234567class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125;val instance = MyClass.create() // 访问到对象的内部元素 我们可以省略掉该对象的对象名，然后使用 Companion 替代需要声明的对象名： 123456class MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 注意：一个类里面只能声明一个内部关联对象，即关键字 companion 只能使用一次。 请伴生对象的成员看起来像其他语言的静态成员，但在运行时他们仍然是真实对象的实例成员。例如还可以实现接口： 12345678910interface Factory&lt;T&gt; &#123; fun create(): T&#125;class MyClass &#123; companion object : Factory&lt;MyClass&gt; &#123; override fun create(): MyClass = MyClass() &#125;&#125; 对象表达式和对象声明之间的语义差异对象表达式和对象声明之间有一个重要的语义差别： 对象表达式是在使用他们的地方立即执行的 对象声明是在第一次被访问到时延迟初始化的 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin枚举类]]></title>
    <url>%2Fposts%2Fcfa629be.html</url>
    <content type="text"><![CDATA[枚举类最基本的用法是实现一个类型安全的枚举。 枚举常量用逗号分隔,每个枚举常量都是一个对象。 123enum class Color&#123; RED,BLACK,BLUE,GREEN,WHITE&#125; 枚举初始化每一个枚举都是枚举类的实例，它们可以被初始化： 12345enum class Color(val rgb: Int) &#123; RED(0xFF0000), GREEN(0x00FF00), BLUE(0x0000FF)&#125; 默认名称为枚举字符名，值从0开始。若需要指定值，则可以使用其构造函数： 1234enum class Shape(value:Int)&#123; ovel(100), rectangle(200)&#125; 枚举还支持以声明自己的匿名类及相应的方法、以及覆盖基类的方法。如： 1234567891011enum class ProtocolState &#123; WAITING &#123; override fun signal() = TALKING &#125;, TALKING &#123; override fun signal() = WAITING &#125;; abstract fun signal(): ProtocolState&#125; 如果枚举类定义任何成员，要使用分号将成员定义中的枚举常量定义分隔开 使用枚举常量Kotlin 中的枚举类具有合成方法，允许遍历定义的枚举常量，并通过其名称获取枚举常数。 12EnumClass.valueOf(value: String): EnumClass // 转换指定 name 为枚举值，若未匹配成功，会抛出IllegalArgumentExceptionEnumClass.values(): Array&lt;EnumClass&gt; // 以数组的形式，返回枚举值 获取枚举相关信息： 12val name: String //获取枚举名称val ordinal: Int //获取枚举值在所有枚举数组中定义的顺序 实例12345678910111213enum class Color&#123; RED,BLACK,BLUE,GREEN,WHITE&#125;fun main(args: Array&lt;String&gt;) &#123; var color:Color=Color.BLUE println(Color.values()) println(Color.valueOf("RED")) println(color.name) println(color.ordinal)&#125; 自 Kotlin 1.1 起，可以使用 enumValues&lt;T&gt;() 和 enumValueOf&lt;T&gt;() 函数以泛型的方式访问枚举类中的常量 ： 1234567891011enum class RGB &#123; RED, GREEN, BLUE &#125;inline fun &lt;reified T : Enum&lt;T&gt;&gt; printAllValues() &#123; print(enumValues&lt;T&gt;().joinToString &#123; it.name &#125;)&#125;fun main(args: Array&lt;String&gt;) &#123; printAllValues&lt;RGB&gt;() // 输出 RED, GREEN, BLUE&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin泛型]]></title>
    <url>%2Fposts%2F6f6a6f9c.html</url>
    <content type="text"><![CDATA[Kotlin 泛型泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。 与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。 声明一个泛型类: 123class Box&lt;T&gt;(t: T) &#123; var value = t&#125; 创建类的实例时我们需要指定类型参数: 123val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)// 或者val box = Box(1) // 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。 以下实例向泛型类 Box 传入整型数据和字符串： 1234567891011class Box&lt;T&gt;(t : T) &#123; var value = t&#125;fun main(args: Array&lt;String&gt;) &#123; var boxInt = Box&lt;Int&gt;(10) var boxString = Box&lt;String&gt;("Runoob") println(boxInt.value) println(boxString.value)&#125; 输出结果为： 1210Runoob 定义泛型类型变量，可以完整地写明类型参数，如果编译器可以自动推定类型参数，也可以省略类型参数。 Kotlin 泛型函数的声明与 Java 相同，类型参数要放在函数名的前面： 12345fun &lt;T&gt; boxIn(value: T) = Box(value)// 以下都是合法语句val box4 = boxIn&lt;Int&gt;(1)val box5 = boxIn(1) // 编译器会进行类型推断 在调用泛型函数时，如果可以推断出类型参数，可以省略泛型参数。 以下实例创建了泛型函数 doPrintln，函数根据传入的不同类型做相应处理： 123456789101112131415161718fun main(args: Array&lt;String&gt;) &#123; val age = 23 val name = "runoob" val bool = true doPrintln(age) // 整型 doPrintln(name) // 字符串 doPrintln(bool) // 布尔型&#125;fun &lt;T&gt; doPrintln(content: T) &#123; when (content) &#123; is Int -&gt; println("整型数字为 $content") is String -&gt; println("字符串转换为大写：$&#123;content.toUpperCase()&#125;") else -&gt; println("T 不是整型，也不是字符串") &#125;&#125; 输出结果为： 123整型数字为 23字符串转换为大写：RUNOOBT 不是整型，也不是字符串 泛型约束我们可以使用泛型约束来设定一个给定参数允许使用的类型。 Kotlin 中使用 : 对泛型的类型上限进行约束。 最常见的约束是上界(upper bound)： 123fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) &#123; // ……&#125; Comparable 的子类型可以替代 T。 例如: 12sort(listOf(1, 2, 3)) // OK。Int 是 Comparable&lt;Int&gt; 的子类型sort(listOf(HashMap&lt;Int, String&gt;())) // 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型 默认的上界是 Any?。 对于多个上界约束条件，可以用 where 子句： 12345fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt; where T : CharSequence, T : Comparable&lt;T&gt; &#123; return list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;&#125; 型变Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。 声明处型变声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。 使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型： 12345678910111213// 定义一个支持协变的类class Runoob&lt;out A&gt;(val a: A) &#123; fun foo(): A &#123; return a &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var strCo: Runoob&lt;String&gt; = Runoob("a") var anyCo: Runoob&lt;Any&gt; = Runoob&lt;Any&gt;("b") anyCo = strCo println(anyCo.foo()) // 输出 a&#125; in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型： 1234567891011// 定义一个支持逆变的类class Runoob&lt;in A&gt;(a: A) &#123; fun foo(a: A) &#123; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var strDCo = Runoob("a") var anyDCo = Runoob&lt;Any&gt;("b") strDCo = anyDCo&#125; 星号投射有些时候, 你可能想表示你并不知道类型参数的任何信息, 但是仍然希望能够安全地使用它. 这里所谓”安全地使用”是指, 对泛型类型定义一个类型投射, 要求这个泛型类型的所有的实体实例, 都是这个投射的子类型。 对于这个问题, Kotlin 提供了一种语法, 称为 星号投射(star-projection): 假如类型定义为 Foo , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper ,Foo&lt;&gt; 等价于 Foo . 它表示, 当 T 未知时, 你可以安全地从 Foo&lt;&gt; 中 读取TUpper 类型的值. 假如类型定义为 Foo , 其中 T 是一个反向协变的类型参数, Foo&lt;&gt; 等价于 Foo . 它表示, 当 T 未知时, 你不能安全地向 Foo&lt;&gt; 写入 任何东西. 假如类型定义为 Foo , 其中 T 是一个协变的类型参数, 上界(upper bound)为 TUpper , 对于读取值的场合, Foo&lt;*&gt; 等价于 Foo , 对于写入值的场合, 等价于 Foo . 如果一个泛型类型中存在多个类型参数, 那么每个类型参数都可以单独的投射. 比如, 如果类型定义为interface Function&lt;in T, out U&gt; , 那么可以出现以下几种星号投射: Function&lt;*, String&gt; , 代表 Function&lt;in Nothing, String&gt; ; Function&lt;Int, *&gt; , 代表 Function&lt;Int, out Any?&gt; ; Function&lt;, &gt; , 代表 Function&lt;in Nothing, out Any?&gt; . 注意: 星号投射与 Java 的原生类型(raw type)非常类似, 但可以安全使用 笔记关于星号投射，其实就是*代指了所有类型，相当于Any? 给文中补个例子方便理解： 12345678910111213141516class A&lt;T&gt;(val t: T, val t2 : T, val t3 : T)class Apple(var name : String)fun main(args: Array&lt;String&gt;) &#123; //使用类 val a1: A&lt;*&gt; = A(12, "String", Apple("苹果")) val a2: A&lt;Any?&gt; = A(12, "String", Apple("苹果")) //和a1是一样的 val apple = a1.t3 //参数类型为Any println(apple) val apple2 = apple as Apple //强转成Apple类 println(apple2.name) //使用数组 val l:ArrayList&lt;*&gt; = arrayListOf("String",1,1.2f,Apple("苹果")) for (item in l)&#123; println(item) &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin数据类与密封类]]></title>
    <url>%2Fposts%2F2fd9bfca.html</url>
    <content type="text"><![CDATA[数据类Kotlin 可以创建一个只包含数据的类，关键字为 data： 1data class User(val name: String, val age: Int) 编译器会自动的从主构造函数中根据所有声明的属性提取以下函数： equals() / hashCode() toString() 格式如 &quot;User(name=John, age=42)&quot; componentN() functions 对应于属性，按声明顺序排列 copy() 函数 如果这些函数在类中已经被明确定义了，或者从超类中继承而来，就不再会生成。 为了保证生成代码的一致性以及有意义，数据类需要满足以下条件： 主构造函数至少包含一个参数。 所有的主构造函数的参数必须标识为val 或者 var ; 数据类不可以声明为 abstract, open, sealed 或者 inner; 数据类不能继承其他类 (但是可以实现接口)。 复制复制使用 copy() 函数，我们可以使用该函数复制对象并修改部分属性, 对于上文的 User 类，其实现会类似下面这样： 1fun copy(name: String = this.name, age: Int = this.age) = User(name, age) 实例使用 copy 类复制 User 数据类，并修改 age 属性: 12345678910data class User(val name: String, val age: Int)fun main(args: Array&lt;String&gt;) &#123; val jack = User(name = "Jack", age = 1) val olderJack = jack.copy(age = 2) println(jack) println(olderJack)&#125; 输出结果为： 12User(name=Jack, age=1)User(name=Jack, age=2) 数据类以及解构声明组件函数允许数据类在解构声明中使用： 123val jane = User("Jane", 35)val (name, age) = janeprintln("$name, $age years of age") // prints "Jane, 35 years of age" 标准数据类标准库提供了 Pair 和 Triple 。在大多数情形中，命名数据类是更好的设计选择，因为这样代码可读性更强而且提供了有意义的名字和属性。 密封类密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。 声明一个密封类，使用 sealed 修饰类，密封类可以有子类，但是所有的子类都必须要内嵌在密封类中。 sealed 不能修饰 interface ,abstract class(会报 warning,但是不会出现编译错误) 12345678910sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr()fun eval(expr: Expr): Double = when (expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN&#125; 使用密封类的关键好处在于使用 when 表达式 的时候，如果能够 验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。 123456fun eval(expr: Expr): Double = when(expr) &#123; is Expr.Const -&gt; expr.number is Expr.Sum -&gt; eval(expr.e1) + eval(expr.e2) Expr.NotANumber -&gt; Double.NaN // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况&#125; 笔记我的理解密封类就是一种专门用来配合 when 语句使用的类，举个例子，假如在 Android 中我们有一个 view，我们现在想通过 when 语句设置针对 view 进行两种操作：显示和隐藏，那么就可以这样做： 12345678sealed class UiOp &#123; object Show: UiOp() object Hide: UiOp()&#125; fun execute(view: View, op: UiOp) = when (op) &#123; UiOp.Show -&gt; view.visibility = View.VISIBLE UiOp.Hide -&gt; view.visibility = View.GONE&#125; 以上功能其实完全可以用枚举实现，但是如果我们现在想加两个操作：水平平移和纵向平移，并且还要携带一些数据，比如平移了多少距离，平移过程的动画类型等数据，用枚举显然就不太好办了，这时密封类的优势就可以发挥了，例如： 123456789101112131415sealed class UiOp &#123; object Show: UiOp() object Hide: UiOp() class TranslateX(val px: Float): UiOp() class TranslateY(val px: Float): UiOp()&#125; fun execute(view: View, op: UiOp) = when (op) &#123; UiOp.Show -&gt; view.visibility = View.VISIBLE UiOp.Hide -&gt; view.visibility = View.GONE is UiOp.TranslateX -&gt; view.translationX = op.px // 这个 when 语句分支不仅告诉 view 要水平移动，还告诉 view 需要移动多少距离，这是枚举等 Java 传统思想不容易实现的 is UiOp.TranslateY -&gt; view.translationY = op.px&#125; 以上代码中，TranslateX 是一个类，它可以携带多于一个的信息，比如除了告诉 view 需要水平平移之外，还可以告诉 view 平移多少像素，甚至还可以告诉 view 平移的动画类型等信息，我想这大概就是密封类出现的意义吧。 除此之外，如果 when 语句的分支不需要携带除“显示或隐藏view之外的其它信息”时（即只需要表明 when 语句分支，不需要携带额外数据时），用 object 关键字创建单例就可以了，并且此时 when 子句不需要使用 is 关键字。只有需要携带额外信息时才定义密封类的子类，而且使用了密封类就不需要使用 else 子句，每当我们多增加一个密封类的子类或单例，编译器就会在 when 语句中给出提示，可以在编译阶段就及时发现错误，这也是以往 switch-case 语句和枚举不具备的功能。 最后，我们甚至可以把这一组操作封装成一个函数，以便日后调用，如下： 1234567891011121314151617// 先封装一个UI操作列表class Ui(val uiOps: List = emptyList()) &#123; operator fun plus(uiOp: UiOp) = Ui(uiOps + uiOp)&#125;// 定义一组操作val ui = Ui() + UiOp.Show + UiOp.TranslateX(20f) + UiOp.TranslateY(40f) + UiOp.Hide// 定义调用的函数fun run(view: View, ui: Ui) &#123; ui.uiOps.forEach &#123; execute(view, it) &#125;&#125;run(view, ui) // 最终调用]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin扩展]]></title>
    <url>%2Fposts%2F36cafa9f.html</url>
    <content type="text"><![CDATA[Kotlin 扩展Kotlin 可以对一个类的属性和方法进行扩展，且不需要继承或使用 Decorator 模式。 扩展是一种静态行为，对被扩展的类代码本身不会造成任何影响。 扩展函数扩展函数可以在已有类中添加新的方法，不会对原类做修改，扩展函数定义形式： 123fun receiverType.functionName(params)&#123; body&#125; receiverType：表示函数的接收者，也就是函数扩展的对象 functionName：扩展函数的名称 params：扩展函数的参数，可以为NULL 以下实例扩展 User 类 ： 1234567891011class User(var name:String)/**扩展函数**/fun User.Print()&#123; print("用户名 $name")&#125;fun main(arg:Array&lt;String&gt;)&#123; var user = User("Runoob") user.Print()&#125; 实例执行输出结果为： 1用户名 Runoob 下面代码为 MutableList 添加一个swap 函数： 123456789101112131415// 扩展函数 swap,调换不同位置的值fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // this 对应该列表 this[index1] = this[index2] this[index2] = tmp&#125;fun main(args: Array&lt;String&gt;) &#123; val l = mutableListOf(1, 2, 3) // 位置 0 和 2 的值做了互换 l.swap(0, 2) // 'swap()' 函数内的 'this' 将指向 'l' 的值 println(l.toString())&#125; 实例执行输出结果为： 1[3, 2, 1] this关键字指代接收者对象(receiver object)(也就是调用扩展函数时, 在点号之前指定的对象实例)。 扩展函数是静态解析的扩展函数是静态解析的，并不是接收者类型的虚拟成员，在调用扩展函数时，具体被调用的的是哪一个函数，由调用函数的的对象表达式来决定的，而不是动态的类型决定的: 123456789101112131415open class Cclass D: C()fun C.foo() = "c" // 扩展函数 foofun D.foo() = "d" // 扩展函数 foofun printFoo(c: C) &#123; println(c.foo()) // 类型是 C 类&#125;fun main(arg:Array&lt;String&gt;)&#123; printFoo(D())&#125; 实例执行输出结果为： 1c 若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。 12345678910class C &#123; fun foo() &#123; println("成员函数") &#125;&#125;fun C.foo() &#123; println("扩展函数") &#125;fun main(arg:Array&lt;String&gt;)&#123; var c = C() c.foo()&#125; 实例执行输出结果为： 1成员函数 扩展一个空对象在扩展函数内， 可以通过 this 来判断接收者是否为 NULL,这样，即使接收者为 NULL,也可以调用扩展函数。例如: 12345678910fun Any?.toString(): String &#123; if (this == null) return "null" // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数 return toString()&#125;fun main(arg:Array&lt;String&gt;)&#123; var t = null println(t.toString())&#125; 实例执行输出结果为： 1null 扩展属性 除了函数，Kotlin 也支持属性对属性进行扩展: 12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 扩展属性允许定义在类或者kotlin文件中，不允许定义在函数中。初始化属性因为属性没有后端字段（backing field），所以不允许被初始化，只能由显式提供的 getter/setter 定义。 1val Foo.bar = 1 // 错误：扩展属性不能有初始化器 扩展属性只能被声明为 val。 伴生对象的扩展如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性。 伴生对象通过”类名.”形式调用伴生对象，伴生对象声明的扩展函数，通过用类名限定符来调用： 123456789101112131415class MyClass &#123; companion object &#123; &#125; // 将被称为 "Companion"&#125;fun MyClass.Companion.foo() &#123; println("伴随对象的扩展函数")&#125;val MyClass.Companion.no: Int get() = 10fun main(args: Array&lt;String&gt;) &#123; println("no:$&#123;MyClass.no&#125;") MyClass.foo()&#125; 实例执行输出结果为： 12no:10伴随对象的扩展函数 扩展的作用域通常扩展函数或属性定义在顶级包下: 123package foo.barfun Baz.goo() &#123; …… &#125; 要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用: 123456789package com.example.usageimport foo.bar.goo // 导入所有名为 goo 的扩展 // 或者import foo.bar.* // 从 foo.bar 导入一切fun usage(baz: Baz) &#123; baz.goo()&#125; 扩展声明为成员在一个类内部你可以为另一个类声明扩展。 在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。 1234567891011121314151617181920212223class D &#123; fun bar() &#123; println("D bar") &#125;&#125;class C &#123; fun baz() &#123; println("C baz") &#125; fun D.foo() &#123; bar() // 调用 D.bar baz() // 调用 C.baz &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c: C = C() val d: D = D() c.caller(d)&#125; 实例执行输出结果为： 12D barC baz 在 C 类内，创建了 D 类的扩展。此时，C 被成为分发接受者，而 D 为扩展接受者。从上例中，可以清楚的看到，在扩展函数中，可以调用派发接收者的成员函数。 假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。 1234567891011121314151617181920212223class D &#123; fun bar() &#123; println("D bar") &#125;&#125;class C &#123; fun bar() &#123; println("C bar") &#125; // 与 D 类 的 bar 同名 fun D.foo() &#123; bar() // 调用 D.bar()，扩展接收者优先 this@C.bar() // 调用 C.bar() &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c: C = C() val d: D = D() c.caller(d)&#125; 实例执行输出结果为： 12D barC bar 以成员的形式定义的扩展函数, 可以声明为 open , 而且可以在子类中覆盖. 也就是说, 在这类扩展函数的派 发过程中, 针对分发接受者是虚拟的(virtual), 但针对扩展接受者仍然是静态的。 12345678910111213141516171819202122232425262728293031323334353637open class D &#123;&#125;class D1 : D() &#123;&#125;open class C &#123; open fun D.foo() &#123; println("D.foo in C") &#125; open fun D1.foo() &#123; println("D1.foo in C") &#125; fun caller(d: D) &#123; d.foo() // 调用扩展函数 &#125;&#125;class C1 : C() &#123; override fun D.foo() &#123; println("D.foo in C1") &#125; override fun D1.foo() &#123; println("D1.foo in C1") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; C().caller(D()) // 输出 "D.foo in C" C1().caller(D()) // 输出 "D.foo in C1" —— 分发接收者虚拟解析 C().caller(D1()) // 输出 "D.foo in C" —— 扩展接收者静态解析&#125; 实例执行输出结果为： 123D.foo in CD.foo in C1D.foo in C]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin接口]]></title>
    <url>%2Fposts%2F404317d3.html</url>
    <content type="text"><![CDATA[Kotlin 接口Kotlin 接口与 Java 8 类似，使用 interface 关键字定义接口，允许方法有默认实现： 1234567interface MyInterface &#123; fun bar() // 未实现 fun foo() &#123; //已实现 // 可选的方法体 println("foo") &#125;&#125; 实现接口一个类或者对象可以实现一个或多个接口。 12345class Child : MyInterface &#123; override fun bar() &#123; // 方法体 &#125;&#125; 实例12345678910111213141516171819interface MyInterface &#123; fun bar() fun foo() &#123; // 可选的方法体 println("foo") &#125;&#125;class Child : MyInterface &#123; override fun bar() &#123; // 方法体 println("bar") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c = Child() c.foo(); c.bar(); &#125; 输出结果为： 12foobar 接口中的属性接口中的属性只能是抽象的，不允许初始化值，接口不会保存属性值，实现接口时，必须重写属性： 1234567interface MyInterface&#123; var name:String //name 属性, 抽象的&#125; class MyImpl:MyInterface&#123; override var name: String = "runoob" //重写属性&#125; 实例12345678910111213141516171819202122interface MyInterface &#123; var name:String //name 属性, 抽象的 fun bar() fun foo() &#123; // 可选的方法体 println("foo") &#125;&#125;class Child : MyInterface &#123; override var name: String = "runoob" //重写属性 override fun bar() &#123; // 方法体 println("bar") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c = Child() c.foo(); c.bar(); println(c.name) &#125; 输出结果为： 123foobarrunoob 函数重写实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如: 实例123456789101112131415161718192021222324252627282930interface A &#123; fun foo() &#123; print("A") &#125; // 已实现 fun bar() // 未实现，没有方法体，是抽象的&#125; interface B &#123; fun foo() &#123; print("B") &#125; // 已实现 fun bar() &#123; print("bar") &#125; // 已实现&#125; class C : A &#123; override fun bar() &#123; print("bar") &#125; // 重写&#125; class D : A, B &#123; override fun foo() &#123; super&lt;A&gt;.foo() super&lt;B&gt;.foo() &#125; override fun bar() &#123; super&lt;B&gt;.bar() &#125;&#125; fun main(args: Array&lt;String&gt;) &#123; val d = D() d.foo(); d.bar();&#125; 输出结果为： 1ABbar 实例中接口 A 和 B 都定义了方法 foo() 和 bar()， 两者都实现了 foo(), B 实现了 bar()。因为 C 是一个实现了 A 的具体类，所以必须要重写 bar() 并实现这个抽象方法。 然而，如果我们从 A 和 B 派生 D，我们需要实现多个接口继承的所有方法，并指明 D 应该如何实现它们。这一规则 既适用于继承单个实现（bar()）的方法也适用于继承多个实现（foo()）的方法。]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin继承]]></title>
    <url>%2Fposts%2F8ca7e9b.html</url>
    <content type="text"><![CDATA[Kotlin 继承Kotlin 中所有类都继承该 Any 类，它是所有类的超类，对于没有超类型声明的类是默认超类： 1class Example // 从 Any 隐式继承 Any 默认提供了三个函数： 12345equals()hashCode()toString() 注意：Any 不是 java.lang.Object。 如果一个类要被继承，可以使用 open 关键字进行修饰。 123open class Base(p: Int) // 定义基类class Derived(p: Int) : Base(p) 构造函数子类有主构造函数如果子类有主构造函数， 则基类必须在主构造函数中立即初始化。 12345678910111213141516open class Person(var name : String, var age : Int)&#123;// 基类&#125;class Student(name : String, age : Int, var no : String, var score : Int) : Person(name, age) &#123;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; val s = Student("Runoob", 18, "S12346", 89) println("学生名： $&#123;s.name&#125;") println("年龄： $&#123;s.age&#125;") println("学生号： $&#123;s.no&#125;") println("成绩： $&#123;s.score&#125;")&#125; 输出结果： 1234学生名： Runoob年龄： 18学生号： S12346成绩： 89 子类没有主构造函数如果子类没有主构造函数，则必须在每一个二级构造函数中用 super 关键字初始化基类，或者在代理另一个构造函数。初始化基类时，可以调用基类的不同构造方法。 12345678class Student : Person &#123; constructor(ctx: Context) : super(ctx) &#123; &#125; constructor(ctx: Context, attrs: AttributeSet) : super(ctx,attrs) &#123; &#125;&#125; 实例12345678910111213141516171819202122232425/**用户基类**/open class Person(name:String)&#123; /**次级构造函数**/ constructor(name:String,age:Int):this(name)&#123; //初始化 println("-------基类次级构造函数---------") &#125;&#125;/**子类继承 Person 类**/class Student:Person&#123; /**次级构造函数**/ constructor(name:String,age:Int,no:String,score:Int):super(name,age)&#123; println("-------继承类次级构造函数---------") println("学生名： $&#123;name&#125;") println("年龄： $&#123;age&#125;") println("学生号： $&#123;no&#125;") println("成绩： $&#123;score&#125;") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var s = Student("Runoob", 18, "S12345", 89)&#125; 输出结果： 123456-------基类次级构造函数----------------继承类次级构造函数---------学生名： Runoob年龄： 18学生号： S12345成绩： 89 重写在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词： 1234567891011121314151617181920/**用户基类**/open class Person&#123; open fun study()&#123; // 允许子类重写 println("我毕业了") &#125;&#125;/**子类继承 Person 类**/class Student : Person() &#123; override fun study()&#123; // 重写方法 println("我在读大学") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val s = Student() s.study();&#125; 输出结果为: 1我在读大学 如果有多个相同的方法（继承或者实现自其他类，如A、B类），则必须要重写该方法，使用super范型去选择性地调用父类的实现。 12345678910111213141516171819202122open class A &#123; open fun f () &#123; print("A") &#125; fun a() &#123; print("a") &#125;&#125;interface B &#123; fun f() &#123; print("B") &#125; //接口的成员变量默认是 open 的 fun b() &#123; print("b") &#125;&#125;class C() : A() , B&#123; override fun f() &#123; super&lt;A&gt;.f()//调用 A.f() super&lt;B&gt;.f()//调用 B.f() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val c = C() c.f();&#125; C 继承自 a() 或 b(), C 不仅可以从 A 或则 B 中继承函数，而且 C 可以继承 A()、B() 中共有的函数。此时该函数在中只有一个实现，为了消除歧义，该函数必须调用A()和B()中该函数的实现，并提供自己的实现。 输出结果为: 1AB 属性重写属性重写使用 override 关键字，属性必须具有兼容类型，每一个声明的属性都可以通过初始化程序或者getter方法被重写： 1234567open class Foo &#123; open val x: Int get &#123; …… &#125;&#125;class Bar1 : Foo() &#123; override val x: Int = ……&#125; 你可以用一个var属性重写一个val属性，但是反过来不行。因为val属性本身定义了getter方法，重写为var属性会在衍生类中额外声明一个setter方法 你可以在主构造函数中使用 override 关键字作为属性声明的一部分: 123456789interface Foo &#123; val count: Int&#125;class Bar1(override val count: Int) : Fooclass Bar2 : Foo &#123; override var count: Int = 0&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin类和对象]]></title>
    <url>%2Fposts%2Fe6f2df3b.html</url>
    <content type="text"><![CDATA[类定义Kotlin 类可以包含：构造函数和初始化代码块、函数、属性、内部类、对象声明。 Kotlin 中使用关键字 class 声明类，后面紧跟类名： 123class Runoob &#123; // 类名为 Runoob // 大括号内是类体构成&#125; 我们也可以定义一个空类： 1class Empty 可以在类中定义成员函数： 123class Runoob() &#123; fun foo() &#123; print("Foo") &#125; // 成员函数&#125; 类的属性属性定义类的属性可以用关键字 var 声明为可变的，否则使用只读关键字 val 声明为不可变。 12345class Runoob &#123; var name: String = …… var url: String = …… var city: String = ……&#125; 我们可以像使用普通函数那样使用构造函数创建类实例： 1val site = Runoob() // Kotlin 中没有 new 关键字 要使用一个属性，只要用名称引用它即可 12site.name // 使用 . 号来引用site.url Koltin 中的类可以有一个 主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，位于类名称之后: 1class Person constructor(firstName: String) &#123;&#125; 如果主构造器没有任何注解，也没有任何可见度修饰符，那么constructor关键字可以省略。 12class Person(firstName: String) &#123;&#125; getter 和 setter属性声明的完整语法： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] getter 和 setter 都是可选 如果属性类型可以从初始化语句或者类的成员函数中推断出来，那就可以省去类型，val不允许设置setter函数，因为它是只读的。 1234var allByDefault: Int? // 错误: 需要一个初始化语句, 默认实现了 getter 和 setter 方法var initialized = 1 // 类型为 Int, 默认实现了 getter 和 setterval simple: Int? // 类型为 Int ，默认实现 getter ，但必须在构造函数中初始化val inferredType = 1 // 类型为 Int 类型,默认实现 getter 实例以下实例定义了一个 Person 类，包含两个可变变量 lastName 和 no，lastName 修改了 getter 方法，no 修改了 setter 方法。 1234567891011121314151617181920212223242526272829303132333435class Person &#123; var lastName: String = "zhang" get() = field.toUpperCase() // 将变量赋值后转换为大写 set var no: Int = 100 get() = field // 后端变量 set(value) &#123; if (value &lt; 10) &#123; // 如果传入的值小于 10 返回该值 field = value &#125; else &#123; field = -1 // 如果传入的值大于等于 10 返回 -1 &#125; &#125; var heiht: Float = 145.4f private set&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; var person: Person = Person() person.lastName = "wang" println("lastName:$&#123;person.lastName&#125;") person.no = 9 println("no:$&#123;person.no&#125;") person.no = 20 println("no:$&#123;person.no&#125;")&#125; 输出结果为： 123lastName:WANGno:9no:-1 Kotlin 中类不能有字段。提供了 Backing Fields(后端变量) 机制,备用字段使用field关键字声明,field 关键词只能用于属性的访问器，如以上实例： 123456789var no: Int = 100 get() = field // 后端变量 set(value) &#123; if (value &lt; 10) &#123; // 如果传入的值小于 10 返回该值 field = value &#125; else &#123; field = -1 // 如果传入的值大于等于 10 返回 -1 &#125; &#125; 非空属性必须在定义的时候初始化,kotlin提供了一种可以延迟初始化的方案,使用 lateinit 关键字描述属性： 1234567891011public class MyTest &#123; lateinit var subject: TestSubject @SetUp fun setup() &#123; subject = TestSubject() &#125; @Test fun test() &#123; subject.method() // dereference directly &#125;&#125; 主构造器主构造器中不能包含任何代码，初始化代码可以放在初始化代码段中，初始化代码段使用 init 关键字作为前缀。 12345class Person constructor(firstName: String) &#123; init &#123; println("FirstName is $firstName") &#125;&#125; 注意：主构造器的参数可以在初始化代码段中使用，也可以在类主体n定义的属性初始化代码中使用。 一种简洁语法，可以通过主构造器来定义属性并初始化属性值（可以是var或val）： 123class People(val firstName: String, val lastName: String) &#123; //...&#125; 如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。 实例创建一个 Runoob类，并通过构造函数传入网站名： 12345678910111213141516171819202122class Runoob constructor(name: String) &#123; // 类名为 Runoob // 大括号内是类体构成 var url: String = "http://www.runoob.com" var country: String = "CN" var siteName = name init &#123; println("初始化网站名: $&#123;name&#125;") &#125; fun printTest() &#123; println("我是类的函数") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val runoob = Runoob("菜鸟教程") println(runoob.siteName) println(runoob.url) println(runoob.country) runoob.printTest()&#125; 输出结果为： 12345初始化网站名: 菜鸟教程菜鸟教程http://www.runoob.comCN我是类的函数 次构造函数类也可以有二级构造函数，需要加前缀 constructor: 12345class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125; 如果类有主构造函数，每个次构造函数都要，或直接或间接通过另一个次构造函数代理主构造函数。在同一个类中代理另一个构造函数使用 this 关键字： 12345class Person(val name: String) &#123; constructor (name: String, age:Int) : this(name) &#123; // 初始化... &#125;&#125; 如果一个非抽象类没有声明构造函数(主构造函数或次构造函数)，它会产生一个没有参数的构造函数。构造函数是 public 。如果你不想你的类有公共的构造函数，你就得声明一个空的主构造函数： 12class DontCreateMe private constructor () &#123;&#125; 注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。 12&gt; class Customer(val customerName: String = "")&gt; 实例1234567891011121314151617181920212223242526class Runoob constructor(name: String) &#123; // 类名为 Runoob // 大括号内是类体构成 var url: String = "http://www.runoob.com" var country: String = "CN" var siteName = name init &#123; println("初始化网站名: $&#123;name&#125;") &#125; // 次构造函数 constructor (name: String, alexa: Int) : this(name) &#123; println("Alexa 排名 $alexa") &#125; fun printTest() &#123; println("我是类的函数") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val runoob = Runoob("菜鸟教程", 10000) println(runoob.siteName) println(runoob.url) println(runoob.country) runoob.printTest()&#125; 输出结果为： 123456初始化网站名: 菜鸟教程Alexa 排名 10000菜鸟教程http://www.runoob.comCN我是类的函数 抽象类抽象是面向对象编程的特征之一，类本身，或类中的部分成员，都可以声明为abstract的。抽象成员在类中不存在具体的实现。 注意：无需对抽象类或抽象成员标注open注解。 1234567open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125; 嵌套类我们可以把类嵌套在其他类中，看以下实例： 1234567891011class Outer &#123; // 外部类 private val bar: Int = 1 class Nested &#123; // 嵌套类 fun foo() = 2 &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val demo = Outer.Nested().foo() // 调用格式：外部类.嵌套类.嵌套类方法/属性 println(demo) // == 2&#125; 内部类内部类使用 inner 关键字来表示。 内部类会带有一个对外部类的对象的引用，所以内部类可以访问外部类成员属性和成员函数。 12345678910111213141516171819class Outer &#123; private val bar: Int = 1 var v = "成员属性" /**嵌套内部类**/ inner class Inner &#123; fun foo() = bar // 访问外部类成员 fun innerTest() &#123; var o = this@Outer //获取外部类的成员变量 println("内部类可以引用外部类的成员，例如：" + o.v) &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val demo = Outer().Inner().foo() println(demo) // 1 val demo2 = Outer().Inner().innerTest() println(demo2) // 内部类可以引用外部类的成员，例如：成员属性&#125; 为了消除歧义，要访问来自外部作用域的 this，我们使用this@label，其中 @label 是一个 代指 this 来源的标签。 匿名内部类使用对象表达式来创建匿名内部类： 123456789101112131415161718192021222324252627class Test &#123; var v = "成员属性" fun setInterFace(test: TestInterFace) &#123; test.test() &#125;&#125;/** * 定义接口 */interface TestInterFace &#123; fun test()&#125;fun main(args: Array&lt;String&gt;) &#123; var test = Test() /** * 采用对象表达式来创建接口对象，即匿名内部类的实例。 */ test.setInterFace(object : TestInterFace &#123; override fun test() &#123; println("对象表达式创建匿名内部类的实例") &#125; &#125;)&#125; 类的修饰符类的修饰符包括 classModifier 和accessModifier: classModifier: 类属性修饰符，标示类本身特性。 12345abstract // 抽象类 final // 类不可继承，默认属性enum // 枚举类open // 类可继承，类默认是final的annotation // 注解类 accessModifier: 访问权限修饰符 1234private // 仅在同一个文件中可见protected // 同一个文件中或子类可见public // 所有调用的地方都可见internal // 同一个模块中可见 实例12345678// 文件名：example.ktpackage fooprivate fun foo() &#123;&#125; // 在 example.kt 内可见public var bar: Int = 5 // 该属性随处可见internal val baz = 6 // 相同模块内可见]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin循环控制]]></title>
    <url>%2Fposts%2Fe596bfcf.html</url>
    <content type="text"><![CDATA[For 循环for 循环可以对任何提供迭代器（iterator）的对象进行遍历，语法如下: 1for (item in collection) print(item) 循环体可以是一个代码块: 123for (item: Int in ints) &#123; // ……&#125; 如上所述，for 可以循环遍历任何提供了迭代器的对象。 如果你想要通过索引遍历一个数组或者一个 list，你可以这么做： 123for (i in array.indices) &#123; print(array[i])&#125; 注意这种”在区间上遍历”会编译成优化的实现而不会创建额外对象。 或者你可以用库函数 withIndex： 123for ((index, value) in array.withIndex()) &#123; println("the element at $index is $value")&#125; 实例对集合进行迭代： 12345678910fun main(args: Array&lt;String&gt;) &#123; val items = listOf("apple", "banana", "kiwi") for (item in items) &#123; println(item) &#125; for (index in items.indices) &#123; println("item at $index is $&#123;items[index]&#125;") &#125;&#125; 输出结果： 123456applebananakiwiitem at 0 is appleitem at 1 is bananaitem at 2 is kiwi while 与 do…while 循环while是最基本的循环，它的结构为： 123while( 布尔表达式 ) &#123; //循环内容&#125; do…while 循环 对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。 do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。 123do &#123; //代码语句&#125;while(布尔表达式); 实例123456789101112fun main(args: Array&lt;String&gt;) &#123; println("----while 使用-----") var x = 5 while (x &gt; 0) &#123; println( x--) &#125; println("----do...while 使用-----") var y = 5 do &#123; println(y--) &#125; while(y&gt;0)&#125; 输出结果： 123456789101154321----do...while 使用-----54321 返回和跳转Kotlin 有三种结构化跳转表达式： return。默认从最直接包围它的函数或者匿名函数返回。 break。终止最直接包围它的循环。 continue。继续下一次最直接包围它的循环。 在循环中 Kotlin 支持传统的 break 和 continue 操作符。 1234567fun main(args: Array&lt;String&gt;) &#123; for (i in 1..10) &#123; if (i==3) continue // i 为 3 时跳过当前循环，继续下一次循环 println(i) if (i&gt;5) break // i 为 6 时 跳出循环 &#125;&#125; 输出结果： 1234512456 Break 和 Continue 标签在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签。 要为一个表达式加标签，我们只要在其前加标签即可。 123loop@ for (i in 1..100) &#123; // ……&#125; 现在，我们可以用标签限制 break 或者continue： 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。 标签处返回Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候： 123456fun foo() &#123; ints.forEach &#123; if (it == 0) return print(it) &#125;&#125; 这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。 123456fun foo() &#123; ints.forEach lit@ &#123; if (it == 0) return@lit print(it) &#125;&#125; 现在，它只会从 lambda 表达式中返回。通常情况下使用隐式标签更方便。 该标签与接受该 lambda 的函数同名。 123456fun foo() &#123; ints.forEach &#123; if (it == 0) return@forEach print(it) &#125;&#125; 或者，我们用一个匿名函数替代 lambda 表达式。 匿名函数内部的 return 语句将从该匿名函数自身返回 123456fun foo() &#123; ints.forEach(fun(value: Int) &#123; if (value == 0) return print(value) &#125;)&#125; 当要返一个回值的时候，解析器优先选用标签限制的 return，即 1return@a 1 意为”从标签 @a 返回 1”，而不是”返回一个标签标注的表达式 (@a 1)”。]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin条件控制]]></title>
    <url>%2Fposts%2F7370c7df.html</url>
    <content type="text"><![CDATA[IF 表达式一个 if 语句包含一个布尔表达式和一条或多条语句。 1234567891011121314// 传统用法var max = a if (a &lt; b) max = b// 使用 else var max: Intif (a &gt; b) &#123; max = a&#125; else &#123; max = b&#125; // 作为表达式val max = if (a &gt; b) a else b 我们也可以把 IF 表达式的结果赋值给一个变量。 1234567val max = if (a &gt; b) &#123; print("Choose a") a&#125; else &#123; print("Choose b") b&#125; 这也说明我也不需要像Java那种有一个三元操作符，因为我们可以使用它来简单实现： 1val c = if (condition) a else b 实例123456789101112131415fun main(args: Array&lt;String&gt;) &#123; var x = 0 if(x&gt;0)&#123; println("x 大于 0") &#125;else if(x==0)&#123; println("x 等于 0") &#125;else&#123; println("x 小于 0") &#125; var a = 1 var b = 2 val c = if (a&gt;=b) a else b println("c 的值为 $c")&#125; 输出结果为： 12x 等于 0c 的值为 2 使用区间使用 in 运算符来检测某个数字是否在指定区间内，区间格式为 x..y ： 实例 1234567fun main(args: Array&lt;String&gt;) &#123; val x = 5 val y = 9 if (x in 1..8) &#123; println("x 在区间内") &#125;&#125; 输出结果为： 1x 在区间内 When 表达式when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。 when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式，符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。 when 类似其他语言的 switch 操作符。其最简单的形式如下： 1234567when (x) &#123; 1 -&gt; print("x == 1") 2 -&gt; print("x == 2") else -&gt; &#123; // 注意这个块 print("x 不是 1 ，也不是 2") &#125;&#125; 在 when 中，else 同 switch 的 default。如果其他分支都不满足条件将会求值 else 分支。 如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔： 1234when (x) &#123; 0, 1 -&gt; print("x == 0 or x == 1") else -&gt; print("otherwise")&#125; 我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中： 123456when (x) &#123; in 1..10 -&gt; print("x is in the range") in validNumbers -&gt; print("x is valid") !in 10..20 -&gt; print("x is outside the range") else -&gt; print("none of the above")&#125; 另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需 任何额外的检测。 1234fun hasPrefix(x: Any) = when(x) &#123; is String -&gt; x.startsWith("prefix") else -&gt; false&#125; when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支： 12345when &#123; x.isOdd() -&gt; print("x is odd") x.isEven() -&gt; print("x is even") else -&gt; print("x is funny")&#125; 实例1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; var x = 0 when (x) &#123; 0, 1 -&gt; println("x == 0 or x == 1") else -&gt; println("otherwise") &#125; when (x) &#123; 1 -&gt; println("x == 1") 2 -&gt; println("x == 2") else -&gt; &#123; // 注意这个块 println("x 不是 1 ，也不是 2") &#125; &#125; when (x) &#123; in 0..10 -&gt; println("x 在该区间范围内") else -&gt; println("x 不在该区间范围内") &#125;&#125; 输出结果： 123x == 0 or x == 1x 不是 1 ，也不是 2x 在该区间范围内 when 中使用 in 运算符来判断集合内是否包含某实例： 1234567fun main(args: Array&lt;String&gt;) &#123; val items = setOf("apple", "banana", "kiwi") when &#123; "orange" in items -&gt; println("juicy") "apple" in items -&gt; println("apple is fine too") &#125;&#125; 输出结果： 1apple is fine too]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_Material组件使用详解]]></title>
    <url>%2Fposts%2F389c1508.html</url>
    <content type="text"><![CDATA[Android官方为开发者提供了许多丰富的UI控件，Material 组件就是包含了这些控件的一套工具，多数时候使用它可以满足我们日常开发UI的需求，提高效率。目前Android Material 组件已经更新了1.2.0稳定版，赶紧来了解一波。 导入依赖，就可以开始了。 1implementation 'com.google.android.material:material:1.2.0' MaterialButton我们平时写布局，当遇到按钮需要圆角、或者描边等，通常的方法是新建一个xml文件，在shape标签下写，然后通过android:background或setBackground(drawable)设置。 这本来没什么问题，但是UI设计师会喜欢看起来和别人不一样的效果，也许是为了审（zhuang）美（bi），例如这个页面用4dp的圆角，那个页面用10dp的圆角，要有描边，颜色还不太一样……如果我们每个界面都新建个xml写shape，那么后期项目大了，维护起来就像无底洞…… 那么有没有这样一个控件，能在xml直接配置圆角、描边属性，满足平时开发的基本UI需求？当然有，GitHub上第三方的库大把。不过Google官方在SDK28的时候也推出了一个新控件 —— MaterialButton，但是我发现很多人还不知道，今天就来安利下。 先来看一波效果图： 按压水波纹，支持设置波纹颜色。 MaterialButton继承AppCompatButton，在原来Button的基础上做了一些扩展，如圆角、描边、前置和后置icon（icon支持设置Size、Tint、Padding、Gravity等），还支持按压水波纹并且设置color，基本能满足日常的需求。 公开属性如下： 关于background在1.2版本以前，MaterialButton只能通过app:backgroundTint属性设置背景色，该属性接收color state list。不能通过android:background设置自定义drawable。 1.2版本后，官方已修复此问题。如果未设置自定义背景，则 MaterialShapeDrawable 仍将用作默认背景。 也就是说，如果按钮背景是纯色，可以通过app:backgroundTint指定；如果按钮背景是渐变色，则需要自己定义drawable，然后通过android:background设置。 注意：如果要使用android:background设置背景，则需要将backgroundTint设置为@empty，否则background不会生效。 123&lt;com.google.android.material.button.MaterialButton android:background=”@drawable/custom_background” app:backgroundTint=”@empty” /&gt; 指定@empty后，Android Studio会出现红色警告，可以正常运行，忽略就好。不过既然已经自定义drawable，就没必要使用MaterialButton，直接用普通的Button甚至用TextView就好了。 关于insetTop、insetBottom看下面的代码： 1234567&lt;com.google.android.material.button.MaterialButton android:id="@+id/btn1" android:layout_width="150dp" android:layout_height="50dp" android:textColor="@android:color/white" android:textSize="18sp"/&gt; xml预览图： 有没有感觉怪怪的？貌似button上下多了一个padding！咦！代码里面明明没有设置padding啊！ 看了源码发现，MaterialButton默认在style指定了insetTop和insetBottom为6dp，使得height看起来并没有Button实际设置值一样高，可以在xml将MaterialButton的insetTop和insetBottom都设置为0dp，这样MaterialButton的高度就和实际设置的高度一致了。 关于阴影MD组件默认都是自带阴影的，MaterialButton也不例外。但是有时候我们并不想要按钮有阴影，那么这时候可以指定style为style=”@style/Widget.MaterialComponents.Button.UnelevatedButton”，这样就能去掉阴影，让视图看起来扁平化。 关于theme在MDC1.1.0以后，使用MaterialButton可能会出现闪退的问题，原因就是使用了MD控件，但是未将them设置为MaterialComponents。解决方法可以有几种： 先在style.xml自定义MaterialComponents_Theme 1234&lt;style name="MaterialComponents_Theme" parent="Theme.MaterialComponents.Light.NoActionBar"&gt; &lt;!-- Customize your theme here. --&gt; ...&lt;/style&gt; 方法一：AndroidManifest里application节点下配置，作用域为整个应用 123&lt;application ... android:theme=&quot;@style/MaterialComponents_Theme&quot;/&gt; 方法二：只在当前activity配置，作用域为当前activity 123&lt;activity ... android:theme="@style/MaterialComponents_Theme"/&gt; 方法三：为每个在使用到MD控件的地方配置，作用域只针对当前控件 123&lt;com.google.android.material.button.MaterialButton ... android:theme="@style/Theme.MaterialComponents.Light.NoActionBar" /&gt; 关于在Android Studio中预览如下代码 12345678910111213141516&lt;com.google.android.material.button.MaterialButton android:id="@+id/btn_send" style="@style/Widget.MaterialComponents.Button.UnelevatedButton" android:layout_width="@dimen/dp_80" android:layout_height="@dimen/dp_30" android:layout_marginStart="@dimen/dp_12" android:insetTop="0dp" android:insetBottom="0dp" android:padding="0dp" android:text="@string/dispatch_room_text_upper_mic" android:textColor="@color/white" android:textSize="@dimen/font_12" app:backgroundTint="@color/c_6D56FF" app:cornerRadius="@dimen/dp_15" app:layout_constraintBottom_toBottomOf="@id/iv_head" app:layout_constraintStart_toEndOf="@id/iv_head" /&gt; xml预览 可以看到xml预览效果和代码是不匹配的，这时候可以将预览的主题指定为MaterialComponents 这样效果就和xml代码一致了 ShapeableImageView来波效果图： 以往我们实现图片圆角、描边等需求，多数时候是使用第三方或者自定义，Glide也有个扩展库，能很轻松帮我们实现。不过在MDC1.2.0中，已经有了一套官方的实现方案。那就是ShapeableImageView。 ShapeableImageView继承自ImageView，可以为image添加描边大小、颜色，以及圆角、裁切等，这得益于它新增了一个属性shapeAppearance，具体实现在ShapeAppearanceModel，可以通过style来配置，也可以通过代码实现。 style配置：1234567891011&lt;style name=&quot;StyleShapeAppearanceImage&quot; parent=&quot;&quot;&gt; &lt;item name=&quot;cornerFamily&quot;&gt;rounded&lt;/item&gt; &lt;item name=&quot;cornerSize&quot;&gt;16dp&lt;/item&gt; &lt;item name=&quot;cornerSizeTopRight&quot;&gt;10dp&lt;/item&gt; &lt;item name=&quot;cornerSizeBottomRight&quot;&gt;0dp&lt;/item&gt;&lt;/style&gt; ...&lt;com.google.android.material.imageview.ShapeableImageView app:shapeAppearance=&quot;@style/StyleShapeAppearanceImage&quot; ... /&gt; 代码设置：123456789101112imageView?.shapeAppearanceModel = ShapeAppearanceModel.builder() .setAllCorners(CornerFamily.ROUNDED,20f) .setTopLeftCorner(CornerFamily.CUT,RelativeCornerSize(0.3f)) .setTopRightCorner(CornerFamily.CUT,RelativeCornerSize(0.3f)) .setBottomRightCorner(CornerFamily.CUT,RelativeCornerSize(0.3f)) .setBottomLeftCorner(CornerFamily.CUT,RelativeCornerSize(0.3f)) .setAllCornerSizes(ShapeAppearanceModel.PILL) .setTopLeftCornerSize(20f) .setTopRightCornerSize(RelativeCornerSize(0.5f)) .setBottomLeftCornerSize(10f) .setBottomRightCornerSize(AbsoluteCornerSize(30f)) .build() 代码接收一个ShapeAppearanceModel，通过构建者模式实现，setTopLeft表示处理左上角，其他同理。 cornerSize表示设置的大小，有RelativeCornerSize和AbsoluteCornerSize，RelativeCornerSize构造方法接收一个百分比，范围0-1；AbsoluteCornerSize构造方法接收一个具体数值，这个数值就是圆角的数值。 这里还有个CornerFamily，它表示处理的方式，有ROUNDED和CUT两种，ROUNDED是圆角，CUT是直接将圆角部分裁切掉。setAllCornerSizes(ShapeAppearanceModel.PILL)可以直接实现圆形效果。 关于StrokeShapeableImageView指定strokeWidth描边的时候，其描边会被覆盖掉一半，如strokeWidth=4dp，上下左右会被覆盖，实际的效果是只有2dp被显示。如图， github有人反馈了类似问题(https://github.com/material-components/material-components-android/issues/1489)，我的处理方法是在设置了strokeWidth的同时，设置相应的pading，这样描边就不会被覆盖了。 1234&lt;com.google.android.material.imageview.ShapeableImageView ... app:strokeWidth=&quot;4dp&quot; android:padding=&quot;4dp&quot; Slider(加强版的SeekBar) Slider的父类BaseSlider，直接继承View，重新实现逻辑。此外BaseSlider还有个子类RangeSlider，用它来实现图1效果2 Slider可以实现滑块头部数字变化效果，还可以实现类似刻度尺效果，比原生的SeekBar加强了不少。 常用属性如下： 其他属性还有haloColor、haloRadius、thumbColor等，用来配置一些外观 BottomNavigationView BottomNavigationView相比之前要完善了很多，可以设置icon大小，添加红点和未读消息数，以及超过3个item，切换效果也不会出现问题，通过LabelVisibilityMode.LABEL_VISIBILITY_LABELED指定。 以上主要列举了几个常用的控件，基本可以满足一些UI开发了，更多关于MDC的内容，大家可以到github去了解 material-components-android： https://github.com/material-components/material-components-android 参考文章： https://mp.weixin.qq.com/s/PZD8RxrqP7_RAjXIo345aQ]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基本数据类型]]></title>
    <url>%2Fposts%2F83cba390.html</url>
    <content type="text"><![CDATA[Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于 Java 的是，字符不属于数值类型，是一个独立的数据类型。 类型 位宽度 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 字面常量下面是所有类型的字面常量： 十进制：123 长整型以大写的 L 结尾：123L 16 进制以 0x 开头：0x0F 2 进制以 0b 开头：0b00001011 注意：8进制不支持 Kotlin 同时也支持传统符号表示的浮点数值： Doubles 默认写法: 123.5, 123.5e10 Floats 使用 f 或者 F 后缀：123.5f 你可以使用下划线使数字常量更易读： 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 比较两个数字Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所以在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。 在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。 123456789101112fun main(args: Array&lt;String&gt;) &#123; val a: Int = 10000 println(a === a) // true，值相等，对象地址相等 //经过了装箱，创建了两个不同的对象 val boxedA: Int? = a val anotherBoxedA: Int? = a //虽然经过了装箱，但是值是相等的，都是10000 println(boxedA === anotherBoxedA) // false，值相等，对象地址不一样 println(boxedA == anotherBoxedA) // true，值相等&#125; 类型转换由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b // 错误 我们可以代用其toInt()方法。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b.toInt() // OK 每种数据类型都有下面的这些方法，可以转化为其它的类型： 1234567toByte(): BytetoShort(): ShorttoInt(): InttoLong(): LongtoFloat(): FloattoDouble(): DoubletoChar(): Char 有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的： 1val l = 1L + 3 // Long + Int =&gt; Long 位操作符对于Int和Long类型，还有一系列的位操作符可以使用，分别是： 1234567shl(bits) – 左移位 (Java’s &lt;&lt;)shr(bits) – 右移位 (Java’s &gt;&gt;)ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)and(bits) – 与or(bits) – 或xor(bits) – 异或inv() – 反向 字符和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ‘ 包含起来的。比如普通字符 ‘0’，’a’。 12345fun check(c: Char) &#123; if (c == 1) &#123; // 错误：类型不兼容 // …… &#125;&#125; 字符字面值用单引号括起来: ‘1’。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\t、 \b、\n、\r、&#39;、&quot;、\ 和 $。 编码其他字符要用 Unicode 转义序列语法：’\uFF00’。 我们可以显式把字符转换为 Int 数字： 12345fun decimalDigitValue(c: Char): Int &#123; if (c !in '0'..'9') throw IllegalArgumentException("Out of range") return c.toInt() - '0'.toInt() // 显式转换为数字&#125; 当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。 布尔布尔用 Boolean 类型表示，它有两个值：true 和 false。 若需要可空引用布尔会被装箱。 内置的布尔运算有： 123|| – 短路逻辑或&amp;&amp; – 短路逻辑与! - 逻辑非 数组数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。 数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组： 12345678910fun main(args: Array&lt;String&gt;) &#123; //[1,2,3] val a = arrayOf(1, 2, 3) //[0,2,4] val b = Array(3, &#123; i -&gt; (i * 2) &#125;) //读取数组内容 println(a[0]) // 输出结果：1 println(b[1]) // 输出结果：2&#125; 如上所述，[] 运算符代表调用成员函数 get() 和 set()。 注意: 与 Java 不同的是，Kotlin 中数组是不协变的（invariant）。 除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样： 12val x: IntArray = intArrayOf(1, 2, 3)x[0] = x[1] + x[2] 字符串和 Java 一样，String 是不可变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历： 123for (c in str) &#123; println(c)&#125; Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如： 1234567fun main(args: Array&lt;String&gt;) &#123; val text = """ 多行字符串 多行字符串 """ println(text) // 输出有一些前置空格&#125; String 可以通过 trimMargin() 方法来删除多余的空白。 123456789fun main(args: Array&lt;String&gt;) &#123; val text = """ |多行字符串 |菜鸟教程 |多行字符串 |Runoob """.trimMargin() println(text) // 前置空格删除了&#125; 默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(“&gt;”)。 字符串模板字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成: 12345fun main(args: Array&lt;String&gt;) &#123; val i = 10 val s = "i = $i" // 求值结果为 "i = 10" println(s)&#125; 或者用花括号扩起来的任意表达式: 12345fun main(args: Array&lt;String&gt;) &#123; val s = "runoob" val str = "$s.length is $&#123;s.length&#125;" // 求值结果为 "runoob.length is 6" println(str)&#125; 原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法： 123456fun main(args: Array&lt;String&gt;) &#123; val price = """ $&#123;'$'&#125;9.99 """ println(price) // 求值结果为 $9.99&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础语法]]></title>
    <url>%2Fposts%2Fa90cf00c.html</url>
    <content type="text"><![CDATA[Kotlin 文件以 .kt 为后缀。 包声明代码文件的开头一般为包的声明： 123456package com.runoob.mainimport java.util.*fun test() &#123;&#125;class Runoob &#123;&#125; kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。 以上例中 test() 的全名是 com.runoob.main.test、Runoob 的全名是 com.runoob.main.Runoob。 如果没有指定包，默认为 default 包。 默认导入有多个包会默认导入到每个 Kotlin 文件中： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 函数定义函数定义使用关键字 fun，参数格式为：参数 : 类型 123fun sum(a: Int, b: Int): Int &#123; // Int 参数，返回值 Int return a + b&#125; 表达式作为函数体，返回类型自动推断： 123fun sum(a: Int, b: Int) = a + bpublic fun sum(a: Int, b: Int): Int = a + b // public 方法则必须明确写出返回类型 无返回值的函数(类似Java中的void)： 123456789fun printSum(a: Int, b: Int): Unit &#123; print(a + b)&#125;// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：public fun printSum(a: Int, b: Int) &#123; print(a + b)&#125; 可变长参数函数函数的变长参数可以用 vararg 关键字进行标识： 12345678910fun vars(vararg v:Int)&#123; for(vt in v)&#123; print(vt) &#125;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; vars(1,2,3,4,5) // 输出12345&#125; lambda(匿名函数)lambda表达式使用实例： 12345// 测试fun main(args: Array&lt;String&gt;) &#123; val sumLambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125; println(sumLambda(1,2)) // 输出 3&#125; 定义常量与变量可变变量定义：var 关键字 1var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量) 1val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 常量与变量都可以没有初始化值,但是在引用前必须初始化 编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。 12345678val a: Int = 1val b = 1 // 系统自动推断变量类型为Intval c: Int // 如果不在声明时初始化则必须提供变量类型c = 1 // 明确赋值var x = 5 // 系统自动推断变量类型为Intx += 1 // 变量可修改 注释Kotlin 支持单行和多行注释，实例如下： 1234// 这是一个单行注释/* 这是一个多行的 块注释。 */ 与 Java 不同, Kotlin 中的块注释允许嵌套。 字符串模板$ 表示一个变量名或者变量值 $varName 表示变量值 ${varName.fun()} 表示变量的方法返回值: 1234567var a = 1// 模板中的简单名称：val s1 = "a is $a" a = 2// 模板中的任意表达式：val s2 = "$&#123;s1.replace("is", "was")&#125;, but now is $a" NULL检查机制Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理 12345678//类型后面加?表示可为空var age: String? = "23" //抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1 当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。 当 str 中的字符串内容不是一个整数时, 返回 null: 123fun parseInt(str: String): Int? &#123; // ...&#125; 以下实例演示如何使用一个返回值可为 null 的函数: 12345678910111213fun main(args: Array&lt;String&gt;) &#123; if (args.size &lt; 2) &#123; print("Two integers expected") return &#125; val x = parseInt(args[0]) val y = parseInt(args[1]) // 直接使用 `x * y` 会导致错误, 因为它们可能为 null. if (x != null &amp;&amp; y != null) &#123; // 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量 print(x * y) &#125;&#125; 类型检测及自动类型转换我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。 1234567891011121314fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 做过类型判断以后，obj会被系统自动转换为String类型 return obj.length &#125; //在这里还有一种方法，与Java中instanceof不同，使用!is // if (obj !is String)&#123; // // XXX // &#125; // 这里的obj仍然是Any类型的引用 return null&#125; 或者 123456fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // 在这个分支中, `obj` 的类型会被自动转换为 `String` return obj.length&#125; 甚至还可以 123456fun getStringLength(obj: Any): Int? &#123; // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String` if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null&#125; 区间区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例: 123456789101112131415161718for (i in 1..4) print(i) // 输出“1234”for (i in 4..1) print(i) // 什么都不输出if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;// 使用 step 指定步长for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42”// 使用 until 函数排除结束元素for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125; 实例测试1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; print("循环输出：") for (i in 1..4) print(i) // 输出“1234” println("\n----------------") print("设置步长：") for (i in 1..4 step 2) print(i) // 输出“13” println("\n----------------") print("使用 downTo：") for (i in 4 downTo 1 step 2) print(i) // 输出“42” println("\n----------------") print("使用 until：") // 使用 until 函数排除结束元素 for (i in 1 until 4) &#123; // i in [1, 4) 排除了 4 print(i) &#125; println("\n----------------")&#125; 输出结果： 12345678循环输出：1234----------------设置步长：13----------------使用 downTo：42----------------使用 until：123----------------]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin使用命令行编译]]></title>
    <url>%2Fposts%2Fc0feb7da.html</url>
    <content type="text"><![CDATA[Kotlin 使用命令行编译Kotlin 命令行编译工具下载地址：https://github.com/JetBrains/kotlin/releases/tag/v1.1.2-2，目前最新为 1.1.2-2。 你可以选择一个最新的稳定版下载。 下载完成后，解压到指定目录，然后将 bin 目录添加到系统环境变量。bin 目录包含编译和运行 Kotlin 所需的脚本。 SDKMAN!在 OS X、Linux、Cygwin、FreeBSD 和 Solaris 系统上也可以使用更简单的安装方法，命令如下： 123$ curl -s https://get.sdkman.io | bash$ sdk install kotlin Homebrew在 OS X 下，你可以使用 Homebrew 安装： 12$ brew update$ brew install kotlin MacPorts如果你是 MacPorts 用户，可以使用以下命令安装： 1$ sudo port install kotlin 创建和运行第一个程序创建一个名为 hello.kt 文件，代码如下： hello.ktfun main(args: Array) { println(“Hello, World!”) } 使用 Kotlin 编译器编译应用: 1$ kotlinc hello.kt -include-runtime -d hello.jar -d: 用来设置编译输出的名称，可以是 class 或 .jar 文件，也可以是目录。 -include-runtime : 让 .jar 文件包含 Kotlin 运行库，从而可以直接运行。 如果你想看所有的可用选项，运行: 1$ kotlinc -help 运行应用 12$ java -jar hello.jarHello, World! 编译成库若需要将生成的 jar 包供其他 Kotlin 程序使用，可无需包含 Kotlin 的运行库： 1$ kotlinc hello.kt -d hello.jar 由于这样生成的 .jar 文件不包含 Kotlin 运行库，所以你应该确保当它被使用时，运行时在你的 classpath 上。 你也可以使用 kotlin 命令来运行 Kotlin 编译器生成的 .jar 文件 1$ kotlin -classpath hello.jar HelloKt HelloKt 为编译器为 hello.kt 文件生成的默认类名。 运行 REPL（交互式解释器）我们可以运行如下命令得到一个可交互的 shell，然后输入任何有效的 Kotlin 代码，并立即看到结果 使用命令行执行脚本Kotlin 也可以作为一个脚本语言使用，文件后缀名为 .kts 。 例如我们创建一个名为 list_folders.kts，代码如下： 1234import java.io.Fileval folders = File(args[0]).listFiles &#123; file -&gt; file.isDirectory() &#125;folders?.forEach &#123; folder -&gt; println(folder) &#125; 执行时通过 -script 选项设置相应的脚本文件。 12$ kotlinc -script list_folders.kts &lt;path_to_folder&gt;$ kotlinc -script list_folders.kts]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin教程]]></title>
    <url>%2Fposts%2F17a38a8.html</url>
    <content type="text"><![CDATA[Kotlin 教程Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。 Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。 Kotlin 程序Kotlin 程序文件以 .kt 结尾，如：hello.kt 、app.kt。 最简版12345package hello // 可选的包头 fun main(args: Array&lt;String&gt;) &#123; // 包级可见的函数，接受一个字符串数组作为参数 println("Hello World!") // 分号可以省略&#125; 面向对象123456789class Greeter(val name: String) &#123; fun greet() &#123; println("Hello, $name") &#125;&#125; fun main(args: Array&lt;String&gt;) &#123; Greeter("World!").greet() // 创建一个对象不用 new 关键字&#125; 为什么选择 Kotlin？ 简洁: 大大减少样板代码的数量。 安全: 避免空指针异常等整个类的错误。 互操作性: 充分利用 JVM、Android 和浏览器的现有库。 工具友好: 可用任何 Java IDE 或者使用命令行构建。 参考链接 官方网站 官方示例 官方网站 - 中文翻译 Kotlin 官方在线工具 Kotlin 在线工具]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter插件开发指南]]></title>
    <url>%2Fposts%2Ff946bb65.html</url>
    <content type="text"><![CDATA[Flutter插件开发创建插件目录1234flutter create -i objc -a java --template=plugin demo-i, 表示指定iOS的语言, objc, swift-a, 表示指定安卓的语言, java, kotlin 通过上面命令，创建一个名为demo的plugin模板, 并生成以下目录结构 目录结构12345- android // 插件相关 Android 代码- ios // 插件相关 iOS 代码- lib // 插件相关 Dart 代码- example // 示例项目, 用于调试当前开发的插件- pubspec.yaml // 插件配置文件 example目录example目录, 是一个示例项目, 用于调试当前开发的插件 在example/lib/main.dart中, 默认生成一些示例代码. 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import 'package:flutter/material.dart';import 'dart:async';import 'package:flutter/services.dart';import 'package:demo/demo.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget &#123; @override _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; String _platformVersion = 'Unknown'; @override void initState() &#123; super.initState(); initPlatformState(); &#125; Future&lt;void&gt; initPlatformState() async &#123; String platformVersion; try &#123; platformVersion = await Demo.platformVersion; &#125; on PlatformException &#123; platformVersion = 'Failed to get platform version.'; &#125; if (!mounted) return; setState(() &#123; _platformVersion = platformVersion; &#125;); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( home: Scaffold( appBar: AppBar( title: const Text('Plugin example app'), ), body: Center( child: Text('Running on: $_platformVersion\n'), ), ), ); &#125;&#125; 示例中的代码, Demo.platformVersion, 实际上是调用了lib目录中, Demo类的get方法platformVersion, 也就是我们写的插件代码 lib目录lib目录, 主要用来存放, 开发的插件所需要的dart代码 在lib/demo.dart, 中可以找到默认生成的示例代码, 代码如下: 123456789101112import 'dart:async';import 'package:flutter/services.dart';class Demo &#123; static const MethodChannel _channel = const MethodChannel('demo') static Future&lt;String&gt; get platformVersion async &#123; final String version = await _channel.invokeMethod('getPlatformVersion'); return version; &#125;&#125; 以上代码, 创建了一个名字为demo的MethodChannel对象, 并提供一个get platformVersion方法, 在该方法中调用invokeMethod方法, 去调用原生代码中, 名字为getPlatformVersion的方法. MethodChannelflutter与原生的交互, 可以通过MethodChannel来实现, MethodChannel是双向的, 通过它可以在flutter中调用原生代码, 也可以在原生代码调用flutter代码 ios目录ios目录, 主要用来存放, 开发的插件所需要的iOS代码 在ios目录中, ios/Classes/DemoPlugin.m, 中可以找到getPlatformVersion对应的原生代码, 代码如下: 1234567891011121314151617181920#import &quot;DemoPlugin.h&quot;@implementation DemoPlugin+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123; FlutterMethodChannel* channel = [FlutterMethodChannel methodChannelWithName:@&quot;demo&quot; binaryMessenger:[registrar messenger]]; DemoPlugin* instance = [[DemoPlugin alloc] init]; [registrar addMethodCallDelegate:instance channel:channel];&#125;- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123; if ([@&quot;getPlatformVersion&quot; isEqualToString:call.method]) &#123; result([@&quot;iOS &quot; stringByAppendingString:[[UIDevice currentDevice] systemVersion]]); &#125; else &#123; result(FlutterMethodNotImplemented); &#125;&#125;@end android目录android目录, 主要用来存放, 开发的插件所需要的android代码 在android目录中, android/src/main/java/com/example/demo/DemoPlugin.java, 中可以找到getPlatformVersion对应的原生代码, 代码如下: 12345678910111213141516171819202122232425package com.example.demo;import io.flutter.plugin.common.MethodCall;import io.flutter.plugin.common.MethodChannel;import io.flutter.plugin.common.MethodChannel.MethodCallHandler;import io.flutter.plugin.common.MethodChannel.Result;import io.flutter.plugin.common.PluginRegistry.Registrar;/** DemoPlugin */public class DemoPlugin implements MethodCallHandler &#123; /** Plugin registration. */ public static void registerWith(Registrar registrar) &#123; final MethodChannel channel = new MethodChannel(registrar.messenger(), "demo"); channel.setMethodCallHandler(new DemoPlugin()); &#125; @Override public void onMethodCall(MethodCall call, Result result) &#123; if (call.method.equals("getPlatformVersion")) &#123; result.success("Android " + android.os.Build.VERSION.RELEASE); &#125; else &#123; result.notImplemented(); &#125; &#125;&#125; 原生代码原生代码中, 也都创建一个名为demo的MethodChannel对象. (与lib目中的dart代码中的MethodChannel名字一致). 通过注册, 监听该channel的回调. 在回调中通过判断call.method的值, 来区分flutter中调用的哪个方法. 如示例中判断是否等于getPlatformVersion, 并在当中执行对应的原生代码, 获取设备相关的系统版本. 其他另外, 在flutter中, 如果想使用原生的视图, 需要使用flutter的UiKitView和AndroidView.]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter - 监视页面的切换(RouteObserver & RouteAware)]]></title>
    <url>%2Fposts%2F97bcffb.html</url>
    <content type="text"><![CDATA[经常性的，我们需要监视页面的切换，用以在合适的时候对控件进行动画暂停或者资源释放。 举个栗子：相机拍照是我们需要经常用到的功能，但是当我们在切换到相机配置页面时，需要暂停当前相机预览，这种情况下我们就需要监视页面的路由变化情况，又或者用户回到应用桌面，此时也需要对相机进行暂停，返回又恢复相机。 在这里主要关系到下面两个方面的： AppStateLifeRecycle - 今天我们不说这个； RouteAware 先看看RouteAware是如何定义的？ 12345678910111213141516171819/// An interface for objects that are aware of their current [Route].////// This is used with [RouteObserver] to make a widget aware of changes to the/// [Navigator]&apos;s session history.abstract class RouteAware &#123; /// Called when the top route has been popped off, and the current route /// shows up. void didPopNext() &#123; &#125; /// Called when the current route has been pushed. void didPush() &#123; &#125; /// Called when the current route has been popped off. void didPop() &#123; &#125; /// Called when a new route has been pushed, and the current route is no /// longer visible. void didPushNext() &#123; &#125;&#125; 上面提交到4个方法，分别都有什么用呢？假如有3个页面，分别是A、B、C，跳转逻辑由A-&gt;B-&gt;C，而RouteAware使用with混淆在B中。 didPopNext：在C页面关闭后，B页面调起该方法； didPush: 当由A打开B页面时，B页面调起该方法； didPop: 当B页面关闭时，B页面调起该方法； didPushNext: 当从B页面打开C页面时，该方法被调起。 如何使用？ 使用with关键字在State类中使用，使用前在MaterialApp中定义一个RouteObserver对象。如下： 12345678910final RouteObserver&lt;PageRoute&gt; routeObserver = RouteObserver(); class MyApp extends StatelessWidget &#123; ... \\此处省略一些代码 Widget _buildMaterialApp() =&gt; MaterialApp( initialRoute: &apos;/&apos;, navigatorObservers: [routeObserver], //添加路由观察者 onGenerateRoute: _onGenerateRoute);&#125; 在B页面中混淆RouteAware, 并注册RouteObserver如下： 123456789101112131415161718192021222324252627282930313233343536373839404142class B extends StatefulWidget &#123; B(&#123;Key key&#125;) : super(key: key);&#125; class BState extends State&lt;B&gt; with RouteAware &#123; @override void didChangeDependencies() &#123; routeObserver.subscribe(this, ModalRoute.of(context)); //订阅 super.didChangeDependencies(); &#125; @override void didPush() &#123; debugPrint(&quot;------&gt; didPush&quot;); super.didPush(); &#125; @override void didPop() &#123; debugPrint(&quot;------&gt; didPop&quot;); super.didPop(); &#125; @override void didPopNext() &#123; debugPrint(&quot;------&gt; didPopNext&quot;); super.didPopNext(); &#125; @override void didPushNext() &#123; debugPrint(&quot;------&gt; didPushNext&quot;); super.didPushNext(); &#125; @override void dispose() &#123; routeObserver.unsubscribe(this); //取消订阅 super.dispose(); &#125;&#125; 总结 : 路由观察者添加订阅与取消订阅必须成对出现； 一些对象在使用后一定要记得及时释放资源。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlutterBoost混合开发实践与源码解析]]></title>
    <url>%2Fposts%2Fdd9d0434.html</url>
    <content type="text"><![CDATA[1. 简介Flutter Boost 是闲鱼团队开发的一个 Flutter 混合开发框架，项目背景可以看看闲鱼的这篇文章：码上用它开始Flutter混合开发——FlutterBoost。 文章中主要讲述了多引擎存在一些实际问题，所以闲鱼目前采用的混合方案是共享同一个引擎的方案。而 Flutter Boost 的 Feature 如下： 可复用通用型混合方案 支持更加复杂的混合模式，比如支持主页Tab这种情况 无侵入性方案：不再依赖修改Flutter的方案 支持通用页面生命周期 统一明确的设计概念 Flutter Boost 采用共享引擎的模式来实现，主要思路是由 Native 容器 Container 通过消息驱动 Flutter 页面容器 Container，从而达到 Native Container 与 Flutter Container 的同步目的。简单的理解，闲鱼想做到把 Flutter 容器做成浏览器的感觉。填写一个页面地址，然后由容器去管理页面的绘制。在 Native 侧我们只需要关心如果初始化容器，然后设置容器对应的页面标志即可。 鉴于网上没有相关的接入文档和使用教程，我这几天也恰好抽空研究了一下，遂整理成文，仅供参考。由于篇幅原因，本文只研究 Android 端的接入与源码，iOS 的部分后续有机会则补充文章来讲解。 注：本文接入的 Flutter Boost 版本为 1.12.13，对应支持的 Flutter SDK 版本为 1.12.13-hotfixes，是目前最新的版本。但 Flutter Boost 版本更新之后，接入方式和使用方式可能会有一些改变，故参考本文时请认准 1.12.13 版本。 2. 接入2.1 创建 Flutter Module在开始之前，我们需要保证工程目录如下结构所示： 1234--- flutter_hybrid --- flutter_module --- FlutterHybridAndroid --- FlutterHybridiOS 即，iOS 工程与 Android 工程与 flutter_module 目录在同一层级。如此，方便管理，同时也保证后续集成代码中路径的一致性。 接着，我们来创建 Flutter Module： 12cd flutter_hybridflutter create -t module flutter_module 需要注意的是，如果要创建支持 Android X 的 flutter module，命令上需要加上 --androidx 参数，即： 1flutter create --androidx -t module flutter_module 注：如果安装依赖过慢，可以切换为国内的依赖镜像源。 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 当然我们也可以通过新版的 Android Studio 来可视化创建一个 Flutter Module （需 3.6.1 以上版本，并给 IDE 装上 Flutter 与 Dart 插件），具体方法可以见官网介绍（https://flutter.dev/docs/development/add-to-app/android/project-setup），此处不再赘述。但个人建议使用本文介绍的更为通用的方法去创建并集成 Flutter Module。 2.2 集成 Flutter Module创建好 Flutter Module 之后，需要在 Native 工程中集成 flutter_module。具体有两种方式： 源码依赖 arr 依赖 2.2.1 源码依赖集成源码依赖的优点是开发、调试方便，也就是在 Android 工程的 settings.gradle 和 app 目录下的 build.gradle 文件中加入对 flutter_module 的依赖即可。 首先，在 settings.gradle 文件中，增加以下代码： 1234567include &apos;:app&apos; // 已存在的内容setBinding(new Binding([gradle: this])) evaluate(new File( settingsDir.parentFile, &apos;flutter_module/.android/include_flutter.groovy&apos; )) setBinding 与 evaluate 增加之后我们就可以在 app/build.gradle 中增加 :flutter 依赖： 12345...dependencies &#123; implementation project(&apos;:flutter&apos;)...&#125; 同时也需要在该文件中的 android() 配置指定一下编译时的 Java 版本为 Java 8，否则会报错 1234compileOptions &#123; sourceCompatibility 1.8 targetCompatibility 1.8&#125; 最后执行一下 gradle sync 下载依赖库。如果集成成功，会在左侧的项目目录中看到与项目同级的 flutter_module 文件夹。 2.2.2 arr 依赖集成如果需要用远程打包，而远程的机器上没有 flutter 环境，就可以把 flutter 打包成 arr 文件进行依赖。生成 aar 文件之后再在主工程里引用，flutter aar 中包含了 flutter sdk 的代码，所以这种方式是不需要flutter 环境的，也适合第三方快速接入。 12cd .android/./gradlew flutter:assembleDebug 2.3 添加 Flutter Boost 依赖首先在 Flutter Module 项目中加入 flutter-boost 依赖，即在 pubspec.yaml 文件中的 dev_dependencies 配置增加 flutter-boost 依赖： 12345dev_dependencies: flutter_boost: git: url: 'https://github.com/alibaba/flutter_boost.git' ref: '1.12.13' 以上 flutter boost 支持 AndroidX，如果想支持 support，则需要切换分支： 1234flutter_boost: git: url: 'https://github.com/alibaba/flutter_boost.git' ref: 'task/task_v1.12.13_support_hotfixes' 编辑完之后在 flutter_module 目录下执行以下命令安装依赖。 1flutter packages get 之后在 Android 工程中的 app 目录下的 build.gradle 文件中增加 :flutter_boost 依赖， 12345dependencies &#123; ... implementation project(&apos;:flutter&apos;) implementation project(&apos;:flutter_boost&apos;)&#125; 因为 Flutter Boost 是以 Flutter Plugin 的形式集成到我们的项目中来的，所以我们还需要做一些工作，首先在 app 目录下的 build.gradle 文件的头部增加以下代码： 12345678910111213141516171819202122def localProperties = new Properties()def localPropertiesFile = rootProject.file(&apos;local.properties&apos;)if (localPropertiesFile.exists()) &#123; localPropertiesFile.withReader(&apos;UTF-8&apos;) &#123; reader -&gt; localProperties.load(reader) &#125;&#125;def flutterRoot = localProperties.getProperty(&apos;flutter.sdk&apos;)if (flutterRoot == null) &#123; throw new GradleException(&quot;Flutter SDK not found. Define location with flutter.sdk in the local.properties file.&quot;)&#125;def flutterVersionCode = localProperties.getProperty(&apos;flutter.versionCode&apos;)if (flutterVersionCode == null) &#123; flutterVersionCode = &apos;1&apos;&#125;def flutterVersionName = localProperties.getProperty(&apos;flutter.versionName&apos;)if (flutterVersionName == null) &#123; flutterVersionName = &apos;1.0&apos;&#125; 这需要我们在 Android 工程下的 local.properties 文件中指定以下我们本地的 Flutter SDK 的位置（没有改文件就新建一个）： 1flutter.sdk = /Users/airing/flutter 最后再在工程目录下的 settings.gradle 中增加以下代码引入 flutter-plugin： 12345678910111213def flutterProjectRoot = rootProject.projectDir.parentFile.toPath()def plugins = new Properties()def pluginsFile = new File(flutterProjectRoot.toFile(), &apos;.flutter-plugins&apos;)if (pluginsFile.exists()) &#123; pluginsFile.withReader(&apos;UTF-8&apos;) &#123; reader -&gt; plugins.load(reader) &#125;&#125;plugins.each &#123; name, path -&gt; def pluginDirectory = flutterProjectRoot.resolve(path).resolve(&apos;android&apos;).toFile() include &quot;:$name&quot; project(&quot;:$name&quot;).projectDir = pluginDirectory&#125; 同样的，修改完 Android 工程的依赖之后，需要 gradle sync 一下。 至此，Flutter Boost 集成成功。接下来，我们使用 Flutter Boost 进行混合开发。而混合开发，主要涉及到两个场景： 在 Native 项目中加入 Flutter 页面，即 Add a single Flutter screen。 在 Native 页面中嵌入 Flutter 模块，即 Add a Flutter Fragment。 这两种方式在 Flutter 的官网上都有实践讲解，我们这里主要看看如果使用 Flutter boost 究竟要如何实现的，并顺便探究一下其实现原理。 3. 混合开发1： Flutter View 3.1 在 Flutter Module 中使用 Flutter Boost首先引入依赖 1import &apos;package:flutter_boost/flutter_boost.dart&apos;; 随后在 main 方法中运行的 rootWidget 中注册两个新的页面，以便 Native 工程可以跳转过来。 12345678910111213141516171819202122232425262728293031323334import 'package:flutter/material.dart';import 'package:flutter_boost/flutter_boost.dart';import 'simple_page_widgets.dart';void main() &#123; runApp(MyApp());&#125;class MyApp extends StatefulWidget &#123; @override _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; @override void initState() &#123; super.initState(); FlutterBoost.singleton.registerPageBuilders(&#123; 'first': (pageName, params, _) =&gt; FirstRouteWidget(), 'second': (pageName, params, _) =&gt; SecondRouteWidget(), &#125;); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Boost example', builder: FlutterBoost.init(), home: Container( color:Colors.white )); &#125;&#125; 代码很简单： 在 initState 的时候使用 FlutterBoost.singleton.registerPageBuilders 注册页面 在 bulider 中初始化 FlutterBoost。 3.2 在 Android 工程中使用 Flutter Boost在 Android 项目中增加一个 Flutter 页面，即是添加一个 Flutter Activity（iOS 即是添加一个新的 FlutterViewController，这里不再花篇幅去讲解 iOS 的实现了，有兴趣的同学可以自己去阅读 Flutter Boost 的示例代码和源码）。 这里我们在 AndroidManifest.xml 的 Application 配置中添加一个 Flutter Boost Activity： 12345678&lt;activity android:name="com.idlefish.flutterboost.containers.BoostFlutterActivity" android:theme="@style/Theme.AppCompat" android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density" android:hardwareAccelerated="true" android:windowSoftInputMode="adjustResize" &gt; &lt;meta-data android:name="io.flutter.embedding.android.SplashScreenDrawable" android:resource="@drawable/page_loading"/&gt;&lt;/activity&gt; 除此之外还需要在 AndroidManifest.xml 中添加 flutterEmbedding 版本设置： 123&lt;meta-data android:name="flutterEmbedding" android:value="2"&gt;&lt;/meta-data&gt; 接着要进行初始化 FlutterBoost 的工作，建议在 Application 的 onCreate 方法中初始化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); INativeRouter router = new INativeRouter() &#123; @Override public void openContainer(Context context, String url, Map&lt;String, Object&gt; urlParams, int requestCode, Map&lt;String, Object&gt; exts) &#123; String assembleUrl=Utils.assembleUrl(url,urlParams); PageRouter.openPageByUrl(context,assembleUrl, urlParams); &#125; &#125;; FlutterBoost.BoostLifecycleListener boostLifecycleListener= new FlutterBoost.BoostLifecycleListener()&#123; @Override public void beforeCreateEngine() &#123; &#125; @Override public void onEngineCreated() &#123; &#125; @Override public void onPluginsRegistered() &#123; &#125; @Override public void onEngineDestroy() &#123; &#125; &#125;; Platform platform = new FlutterBoost .ConfigBuilder(this,router) .isDebug(true) .whenEngineStart(FlutterBoost.ConfigBuilder.ANY_ACTIVITY_CREATED) .renderMode(FlutterView.RenderMode.texture) .lifecycleListener(boostLifecycleListener) .build(); FlutterBoost.instance().init(platform); &#125;&#125; FlutterBoost 在 Android 工程中初始化需要进行 4 步工作： 注册路由跳转方法（后续会说 PageRouter 的实现） 增加 flutter boost 的生命周期监听函数，可以在 Flutter Engine 创建之前、创建之后、销毁之后与 Flutter Plugin 注册之后回调事件。 声明 Flutter boost 配置，把路由和生命周期函数配置上。 初始化 Flutter boost。 接着要在 Android 工程中实现一个页面路由的工具类 PageRouter，这里直接摆上 Flutter Boost 示例代码中的实现了，比较全面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class PageRouter &#123; public final static Map&lt;String, String&gt; pageName = new HashMap&lt;String, String&gt;() &#123;&#123; put("first", "first"); put("second", "second"); put("tab", "tab"); put("sample://flutterPage", "flutterPage"); &#125;&#125;; public static final String NATIVE_PAGE_URL = "sample://nativePage"; public static final String FLUTTER_PAGE_URL = "sample://flutterPage"; public static final String FLUTTER_FRAGMENT_PAGE_URL = "sample://flutterFragmentPage"; public static boolean openPageByUrl(Context context, String url, Map params) &#123; return openPageByUrl(context, url, params, 0); &#125; public static boolean openPageByUrl(Context context, String url, Map params, int requestCode) &#123; String path = url.split("\\?")[0]; Log.i("openPageByUrl",path); try &#123; if (pageName.containsKey(path)) &#123; Intent intent = BoostFlutterActivity.withNewEngine().url(pageName.get(path)).params(params) .backgroundMode(BoostFlutterActivity.BackgroundMode.opaque).build(context); if(context instanceof Activity)&#123; Activity activity=(Activity)context; activity.startActivityForResult(intent,requestCode); &#125;else&#123; context.startActivity(intent); &#125; return true; &#125; else if (url.startsWith(FLUTTER_FRAGMENT_PAGE_URL)) &#123; context.startActivity(new Intent(context, FlutterFragmentPageActivity.class)); return true; &#125; else if (url.startsWith(NATIVE_PAGE_URL)) &#123; context.startActivity(new Intent(context, NativePageActivity.class)); return true; &#125; return false; &#125; catch (Throwable t) &#123; return false; &#125; &#125;&#125; 3.3 在 Native 项目中打开 Flutter 页面调用比较简单，在 Native 页面上的按钮绑定上 onClick 监听来实现点击打开我们注册的 Flutter 中的 first 页面，还可以顺便传上一个 map 参数： 12345678@Overridepublic void onClick(View v) &#123; Map params = new HashMap(); params.put("test1","v_test1"); params.put("test2","v_test2"); PageRouter.openPageByUrl(this, "first", params);&#125; 我们回顾一下我们在 3.1 中 Flutter 中注册页面的代码，发现有一个 params 参数，没错那就是 Native 打开 Flutter 时传过来的参数，我们可以打印出来或者传给 widget 做额外的处理： 12345678FlutterBoost.singleton.registerPageBuilders(&#123; 'first': (pageName, params, _) =&gt; &#123; print("flutterPage params:$params"); return FirstRouteWidget(params:params); &#125;, 'second': (pageName, params, _) =&gt; SecondRouteWidget(),&#125;); 3.4 在 Flutter 页面中打开 Native 页面同样的，我们可能还会遇到一种场景，在 Native 中打开 Flutter 页面之后，我们 Flutter 中的业务又需要再打开一个新的 Native 页面，那需要怎么做？在 Flutter 中使用 FlutterBoost.singleton.open 即可，如下： 123456// 后面的参数会在native的IPlatform.startActivity方法回调中拼接到url的query部分。// 例如：sample://nativePage?aaa=bbbonTap: () =&gt; FlutterBoost.singleton .open("sample://nativePage", urlParams: &lt;dynamic,dynamic&gt;&#123; "query": &#123;"aaa": "bbb"&#125;&#125;), 当然，这个方法不单单支持打开 Native 页面，也可以打开一个新的 Flutter 页面，只需要写好路由名就好，这里不再赘述。 注：得益于 Flutter 的 JIT 编译模式，我们可以通过 flutter attach 命令来实现 hot reload 功能，在开发 Flutter 页面时无需重新编译工程。 4. 混合开发2：Flutter Fragment 我们假设工程中存在一个 Activity，配置如下： 12345678&lt;activity android:name=".FlutterFragmentPageActivity" android:theme="@style/Theme.AppCompat" android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density" android:hardwareAccelerated="true" android:windowSoftInputMode="adjustResize"&gt; &lt;meta-data android:name="io.flutter.embedding.android.SplashScreenDrawable" android:resource="@drawable/page_loading"/&gt;&lt;/activity&gt; 而对应 layout 中我们要加入一个 FrameLayout 组件作为占位符： 12345&lt;FrameLayout android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:id="@+id/fragment_stub"/&gt; 最后，在代码中拿到对应 url 的 Flutter widget，塞到占位组件里即可： 12345678@Overridepublic void onClick(View v) &#123; FlutterFragment mFragment = new FlutterFragment.NewEngineFragmentBuilder().url("flutterFragment").build(); getSupportFragmentManager() .beginTransaction() .replace(R.id.fragment_stub, mFragment) .commit();&#125; 5. Flutter Boost 源码解析本节主要简单分析一下 Flutter Boost 的原理，只有知根知底才能用得得心应手。由于篇幅问题，不可能全部的源码都分析一遍，本节只分析具有代表性的源码，其余的原理基本一致，留给读者自行阅读。 那本节就从 Dart 端切入，关注其中两个 api，一个是注册页面的 registerPageBuilders，另一个是打开页面的 open，看看 Flutter Boost 是如何实现它们的。 5.1 注册页面我们在使用 Flutter Boost 的流程中，第一步是要在 Flutter 中注册页面，调用了 registerPageBuilders 函数，那我们来看一下这个函数是如何实现的。 在 flutter_boost.dart 文件中，我们很容易就找到了这个函数的入口： 1234///Register a map buildersvoid registerPageBuilders(Map&lt;String, PageBuilder&gt; builders) &#123; ContainerCoordinator.singleton.registerPageBuilders(builders);&#125; 它调用了 ContainerCoordinator 单例的 registerPageBuilders，那我们接着看 container_coordinator.dart 文件中这个函数的实现： 123456789final Map&lt;String, PageBuilder&gt; _pageBuilders = &lt;String, PageBuilder&gt;&#123;&#125;; PageBuilder _defaultPageBuilder;///Register page builder for a key.void registerPageBuilder(String pageName, PageBuilder builder) &#123; if (pageName != null &amp;&amp; builder != null) &#123; _pageBuilders[pageName] = builder; &#125;&#125; 其中 PageBuilder 我们可以找到定义，是一个 Widget，那么这个函数其实就将我们注册的 Widget 塞到一个 Map 里，而我们指定的路由名，就是它的 key。那我们接着要关注的是 _pageBuilders 定义好之后会怎么被使用？ 123456789101112131415161718192021222324252627BoostContainerSettings _createContainerSettings( String name, Map params, String pageId) &#123; Widget page; final BoostContainerSettings routeSettings = BoostContainerSettings( uniqueId: pageId, name: name, params: params, builder: (BuildContext ctx) &#123; //Try to build a page using keyed builder. if (_pageBuilders[name] != null) &#123; page = _pageBuilders[name](name, params, pageId); &#125; //Build a page using default builder. if (page == null &amp;&amp; _defaultPageBuilder != null) &#123; page = _defaultPageBuilder(name, params, pageId); &#125; assert(page != null); Logger.log('build widget:$page for page:$name($pageId)'); return page; &#125;); return routeSettings; &#125; 可以发现，它在 _createContainerSettings 中 build widget 之后返回一个 routeSetting，该变量在 _nativeContainerWillShow 中被 pushContainer 调用，而 _nativeContainerWillShow 会在 _onMethodCall 中被调用。 123456789101112131415161718192021222324bool _nativeContainerWillShow(String name, Map params, String pageId) &#123; if (FlutterBoost.containerManager?.containsContainer(pageId) != true) &#123; FlutterBoost.containerManager ?.pushContainer(_createContainerSettings(name, params, pageId)); &#125; return true; &#125;Future&lt;dynamic&gt; _onMethodCall(MethodCall call) &#123; Logger.log("onMetohdCall $&#123;call.method&#125;"); switch (call.method) &#123; // 省略无关代码 case "willShowPageContainer": &#123; String pageName = call.arguments["pageName"]; Map params = call.arguments["params"]; String uniqueId = call.arguments["uniqueId"]; _nativeContainerWillShow(pageName, params, uniqueId); &#125; break; &#125; // 省略无关代码&#125; 以上两段代码的作用是当 Dart 端监听到来自 Native 的通信之后，如果 Native 传递了一个要打开一个页面容器的信息（willShowPageContainer）之后，FlutterBoost 的容器管理器就会根据用户注册配置的路由页面去打开一个新的容器。而这里的 pushContainer 主要做一些路由管理和绑定监听等操作，我们就不再细看这部分的逻辑了，主要还是看看 _onMethodCall 的 Native 与 Dart 的互相通信。 5.2 通信12345678910ContainerCoordinator(BoostChannel channel) &#123; assert(_instance == null); _instance = this; channel.addEventListener("lifecycle", (String name, Map arguments) =&gt; _onChannelEvent(arguments)); channel.addMethodHandler((MethodCall call) =&gt; _onMethodCall(call)); &#125; Flutter Boost 中负责通信的是 BoostChannel，它的本质上是 MethodChannel 的一层封装，而 MethodChannel 是 Native 与 Flutter 通信的方案之一，有兴趣的同学可以自己查阅 MethodChannel 相关的资料加以了解。 可以阅读 Flutter 官网对 MethodChannel 的介绍：https://flutter.dev/docs/development/platform-integration/platform-channels 5.3 打开页面最后我们再来看一个打开页面的函数 open，它的实现在库中也容易找到： 12345678Future&lt;Map&lt;dynamic, dynamic&gt;&gt; open(String url, &#123;Map&lt;dynamic, dynamic&gt; urlParams, Map&lt;dynamic, dynamic&gt; exts&#125;) &#123; Map&lt;dynamic, dynamic&gt; properties = new Map&lt;dynamic, dynamic&gt;(); properties["url"] = url; properties["urlParams"] = urlParams; properties["exts"] = exts; return channel.invokeMethod&lt;Map&lt;dynamic, dynamic&gt;&gt;('openPage', properties); &#125; 可以发现，它的工作其实就是包装好参数后把 openPage 的消息发送给 Native。那我们再来看看 Native 侧接受到这个消息之后作何处理吧！在 Android 侧的 Flutter Boost 源码中可以找到 FlutterBoostPlugin.java 这个文件，其中有 MethodChannel 的逻辑来监听 Dart 侧的消息： 123456789101112131415161718192021222324252627282930313233class BoostMethodHandler implements MethodChannel.MethodCallHandler &#123; @Override public void onMethodCall(MethodCall methodCall, final MethodChannel.Result result) &#123; FlutterViewContainerManager mManager = (FlutterViewContainerManager) FlutterBoost.instance().containerManager(); switch (methodCall.method) &#123; // 省略无关的分支 case "openPage": &#123; try &#123; Map&lt;String, Object&gt; params = methodCall.argument("urlParams"); Map&lt;String, Object&gt; exts = methodCall.argument("exts"); String url = methodCall.argument("url"); mManager.openContainer(url, params, exts, new FlutterViewContainerManager.OnResult() &#123; @Override public void onResult(Map&lt;String, Object&gt; rlt) &#123; if (result != null) &#123; result.success(rlt); &#125; &#125; &#125;); &#125; catch (Throwable t) &#123; result.error("open page error", t.getMessage(), t); &#125; &#125; break; default: &#123; result.notImplemented(); &#125; &#125; &#125; &#125; 在收到来自 Dart 的 openPage 消息后，Android 侧的容器管理器（FlutterViewContainerMananger）会根据 Dart 侧携带来的配置数据打开一个容器，而这个 openContainer 通过阅读源码，可以发现它最后是一个抽象方法，需要我们自己在业务侧实现。回看我们在 3.2 节中在 Android 中初始化 Flutter Boost 第一步工作，做的就是实现这个 openContainer，而它最后交由我们封装的 PageRouter 工具类来实现了，即 context.startActivity()。 至此，我们在 Android 工程中集成了 Flutter Boost 来实现 Flutter 在 Android 项目中的混合开发。本文只是初步分析了下 Flutter Boost 的源码，后续有机会会补上详细的分析。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlutterUnit开源篇]]></title>
    <url>%2Fposts%2Fd75d6183.html</url>
    <content type="text"><![CDATA[FlutterUnit 下载体验: FlutterUnit.apk 下载 FlutterUnit mac版 下载 Github仓库地址 Android下载链接: http://photo.toly1994.com/release/FlutterUnit.apk Mac下载链接: http://photo.toly1994.com/release$flutter_unit_mac.zip ✨ Flutter Unit mac版支持 当前Flutter 版本 12345a1@toly ~ % flutter --versionFlutter 1.17.0 • channel stable • https://github.com/flutter/flutter.gitFramework • revision e6b34c2b5c (5 days ago) • 2020-05-02 11:39:18 -0700Engine • revision 540786dd51Tools • Dart 2.8.1 Flutter Unit 周边 🔥 Flutter Unit 更新记录 一、组件的展示页面1. 210+组件收录 Flutter源码中的可用的组件一共350个左右，纷繁复杂，也没有明确的分类标准FlutterUnit 对大大小小，常用不常用的组件能收的尽量收录。并根据个人感觉进行评星目前收录组件213个，每个都有至少一个演示展现和代码展示。 . . . 2. 组件详情页 213个组件全部都有详情页。对于重要的组件会详细展现一般都会有某个演示对应的组件和属性,尽量做到细致，如果有需要补充，欢迎联系我。最重要的是: 所有的演示展现都是Flutter的组件形成的，而非图片，这就意味着可操作性更高。 . . . 3. 组件的可操作性 对一些操作交互的组件或有可操作性的某些组件，提供操作演示 . . . 4. 相关组件的关联切换 相关组件通过link to 可以进行切换, 满足你的探索欲。如果有的关联未加入，欢迎联系我，对我来说，加个数字就行了。 . . . 5. 代码的查看和分享 激动人心的是，你可以通过右侧的图标展开/隐藏 实现下面效果的代码并且支持分享，如果你想亲自体验，so，easy ! 而且代码高亮样式可以自定义。 . . . 二、全局配置1. 颜色主题 只提供八种颜色，可在右滑菜单页的我的主题配置,可以拓展 . . . 2.字体配置 支持全局字体设置,可以拓展 . . . 3.item样式设置 支持item样式设置，可以拓展，支持征集，详见Flutter Unit 1.0 征集方案 . . . 4.代码面板风格设置 支持代码风格设置，可以拓展，支持征集，详见Flutter Unit 1.0 征集方案 . . 三、搜索与收藏功能1.搜索功能 由于Flutter中Widget比较杂乱，不太好分类，所以搜索是非常重要的另外可以根据星级进行过滤，支持多选。目前正在考虑根据功能分类，之后会有所完善。 . . . 2.搜藏功能 搜藏页做得比较简陋，后面打算做收藏夹，可以自己创建的那种。 . . . FlutterUnit 1.0目前基本就是这么多功能，可以在Github中下载打包后的apk玩玩希望能对你的Flutter学习有所帮助。 3.关于我与项目 不多说，都在图里。 . . . Flutter Unit Bug - Feature 2020-4-16 123fixed &quot; 修改样式无法点击的问题。fixed &quot; 一些已知文案的错误。fixed &quot; hero动画闪现不同步问题。 2020-4-17 123456fixed &quot; 进入收藏页，再回到首页，顶部显示不同步的问题。fixed &quot; 主页item双击黑屏问题。feature &quot; 支持详情页【相关链接的栈管理】, &quot; 即: 点击多个链接，不直接返回主页. 2020-4-18 1234feature &quot; 小彩蛋: 【长按】底部栏【最左侧按钮】,打开左边菜单栏 &quot; 【长按】底部栏【最右侧按钮】,打开右边菜单栏fixed &quot; 收藏集的AppBar背景色同主页选中色。 2020-4-19 1234optimize &quot; 添加收录【LayoutBuilder】组件optimize &quot; 添加收录【IgnorePointer】组件optimize &quot; 添加收录【AbsorbPointer】组件optimize &quot; 添加收录【BackdropFilter】组件 作者：张风捷特烈 链接：https://juejin.im/post/5e94e4d3f265da480836b943 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter ListView取消头部空白]]></title>
    <url>%2Fposts%2Fc3648888.html</url>
    <content type="text"><![CDATA[ListView头部有一段空白区域，是因为当ListView没有和AppBar一起使用时，头部会有一个padding，为了去掉padding，可以使用MediaQuery.removePadding: 1234567891011121314151617Widget _rubbishList()&#123; return MediaQuery.removePadding( removeTop: true, context: context, child: Container( margin: EdgeInsets.only(left: 20,right: 20), height: ScreenUtil().setHeight(700), child: ListView.builder( itemCount: rubbishList.length, itemBuilder: (context,index)&#123; return _cardItem(index); &#125; ) ) ); &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter常见数据类型及数据类型转换]]></title>
    <url>%2Fposts%2F87ca1d5.html</url>
    <content type="text"><![CDATA[简介既然 Dart 是一门语言，那么就和我们所知道语言一样，有基本的数据类型以及常见的流程处理语法，那么我们就来了解下。 Dart 的所有东西都是对象，包括数字，函数等。它们都继承自 Object ，默认是都是 null（包括数字），所以数字，字符串都可以调用各种方法。 常亮与变量变量使用 var 声明变量，可赋予不同类型的值；未初始化时，默认值为 null ；使用 final 声明一个只能赋值一次的变量 12345678910111213141516171819void main()&#123; // 声明一个变量 a var a; print(a); // 打印 a 的值，显示为 null a = 10; print(a); // 打印出来的结果为 10 a = "测试字符串"; print(a); // 打印出来的结果为 测试字符串 a = 30; print(a); // 打印出来的结果为 30 final b = 10; b = 20; // 这个会报错，有提示： [dart] 'b', a final variable, can only be set once. &#125; 常量在 dart 中使用 const 声明常量；使用 const 声明的必须是编译期常量。 1234void main()&#123; const a = 10; a = 20; // 这里也会报错：[dart] Constant variables can't be assigned a value.&#125; 在上面我们可以看到 dart 的一些简单的语法。其实和 js 蛮像，声明的变量的数据类型是随便去改变的，没有一个固定的数据类型（例如：java 这种语言）。其次就是 final 和 const 都可以声明变量，并且声明了变量之后都不能修改。 这里简单的说下 final 与 const 的区别： final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量，可以是常量也可以不是。而 const 要求在声明时初始化，并且赋值必需为编译时常量。 Dart中的内置类型在Dart 有几种内置的数据类型：数值型-Number、布尔型-boolean、键值对-Map、字符串-String、列表-List、其他类型-Runes、Symbols 数值型Dart 中只提供了两种类型： num1、整形int2、浮点型double 1234567891011void main()&#123; num a = 10; // 整形 a = 20.1; // 浮点型 int i = 10; i = 10.1; // 这个地方会报错，因为将 int 型的数据改为 double 型 double d = 20.1; d = 20; // 这个地方会报错，因为将 double 型的数据改为 int 型&#125; 从上面可以看到如果是使用 num 声明的变量，可以随意的转换类型，但是如果是使用了int 或者 double 明确的声明，那么就不能转换了 数值型的操作运算符： +、 - 、* 、/ 、 ~/ 、 % 常用属性： isNaN、isEven、isOdd 常用方法：abs()、round()、floorl()、ceil()、toInt()、toDouble() 123456789101112// 由于常用的方法在其他语言中都有，就不过去的赘述，下面列出一些特殊的void main()&#123; int i = 10; double d = 20.1; print(i/d); // 0.49751243781094523 print(i~/d); // 0 这个操作是取整 print( i.isOdd ); // 判断是奇数 print( i.isEven ); // 判断是偶数&#125; 一些常见的转换123456789101112131415// String -&gt; intvar one = int.parse('1');assert(one == 1); // String -&gt; doublevar onePointOne = double.parse('1.1');assert(onePointOne == 1.1); // int -&gt; StringString oneAsString = 1.toString();assert(oneAsString == '1'); // double -&gt; StringString piAsString = 3.14159.toStringAsFixed(2);assert(piAsString == '3.14'); 字符串在 dart 中居然可以使用 单引号 和 双引号声明字符串。这两种方式都可以。1234void main()&#123; String string = '单引号声明字符串'; String string1 = "双引号声明字符串";&#125; 在 String 中单、双引号互相嵌套的情况123456789101112void main()&#123; String str = '单引号中的"双引号"'; String str1 = "双引号中的'单引号'"; print(str); print(str1); String str2 = '单引号中的 \'单引号\' '; String str3 = "双引号中的 \"双引号\" "; print(str2); print(str3);&#125; 字符串拼接的方式下面列出 dart 中拼接字符串的各种骚操作（黑魔法）。12345678910111213141516171819202122232425262728void main()&#123; // 使用的是空格拼接，多个空格也可以 String str1 = '单引号空格字符串' '拼接' '~'; // 单引号字符串空格拼接~ // 使用换行符以及空格 String str2 = '单引号符串' '换行了' '再加空格' '拼接'; // 单引号符串换行了再加空格拼接 // 单双引号 空格拼接 String str3 = "单双引号空格字符串" '拼接' "~"; // 单双引号字符串空格拼接~ // 单双引号 换行符以及空格 String str4 = "单双引号符串" '换行了' '再加空格' '拼接'; // 单双引号符串换行了再加空格拼接 String str5 = ''' 使用3个单引号、 看到我使用了么 '''; String str6 = """ 使用3个双引号、 看到我使用了么 """; String str7 = "算了，还是正常一点" + "，使用 + 来拼接";&#125; 从上面可以看到 dart 中可以使用空格来做为拼接。所以我们继续研究下。123456789101112131415161718192021222324void main()&#123; // 拼接字符串， 输出：单引号空格 或者 双引号空格 String blockStr = '单引号''空格'; String blockStr1 = '单引号' '空格'; String blockStr2 = "双引号""空格"; String blockStr3 = "双引号" "空格"; // 下面这两种情况会报错 // String blockStr4 = '单引号''''空格'; // String blockStr5 = "双引号""""空格"; // 测试中间添加字符 String blockStr6 = '单引号''_''空格'; // 输出：单引号_空格 String blockStr7 = "双引号""#""空格"; // 注意不能使用 $，$会报错, 输出：单引号#空格 // 单双引号混合使用 String blockStr8 = '单""""引号'; // 输出：单""""引号 String blockStr9 = '单""_""引号'; // 输出：单""_""引号 // 单双引号混合使用 String blockStr10 = "双''''引号"; // 输出：双''''引号 String blockStr11 = "双''_''引号"; // 输出：双''_''引号&#125; ${表达式}的使用类似于JS中 ES6 上面的表达式的使用，感觉是相通的。 12345678void main()&#123; var flag = false; var str = "测试字符串"; print("我们来验证字符串：$&#123;str&#125;" "然后看看我们的 flag：$&#123;flag&#125;"); // 最后输出的结果为：我们来验证字符串：测试字符串然后看看我们的 flag：false&#125; 布尔值assert 是语言内置的断言函数，仅在检查模式下有效在开发过程中， 除非条件为真，否则会引发异常。(断言失败则程序立刻终止)。 123456789101112131415// 检查是否为空var fullName = '';assert(fullName.isEmpty); // 为0检查var hitPoints = 0;assert(hitPoints &lt;= 0); // 检查是否为 null.var unicorn;assert(unicorn == null); // 检查是否为 NaN.var iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); List列表实例化 List 的方法如下123456789101112void main()&#123; // 使用构造创建 var list = new List(); //创建一个int类型的list List intlist = [1, 2, 3]; // 创建一个常量List， 不可以改变的List List constList = const[10, 7, 23]; &#125; dart 中数组常用的方法12345678910111213141516171819202122232425262728293031323334353637383940void main()&#123; // 在数组中可以存放多个不同类型的对象 var list = [1, 2, 3, 'Flutter', true]; print(list); // 输出的结果：[1, 2, 3, Flutter, true] // 修改数组下标为2 的值 list[2] = 'Dart'; print(list); // 输出的结果：[1, 2, Dart, Flutter, true] // 获取数组的长度 print(list.length); // 输出的结果：5 // 向数组中添加元素 list.add("value"); print(list); // 输出的结果：[1, 2, Dart, Flutter, true, value] // 向数组中的指定位置添加元素 list.insert(1, 'element'); print(list); // 输出的结果：[1, element, 2, Dart, Flutter, true, value] // 移除数组中的元素 list.remove("value"); print(list); // 输出的结果：[1, element, 2, Dart, Flutter, true] // 移除数组中指定的元素 list.removeAt(1); print(list); // 输出的结果：[1, 2, Dart, Flutter, true] // 判断数组中是否有某个元素 print(list.indexOf("element")); // 输出结果：-1 // 可以使用 sort() 函数来排序, 但是由于我们使用定义的数组类型不一样，就不能使用 var intlist = [1, 2, 5, 6 ,3]; // 根据语法提示： List.sort([(int, int) → int compare]) → void intlist.sort( (a, b) =&gt; a.compareTo(b) ); print(intlist); // 输出结果：[1, 2, 3, 5, 6] &#125; map 集合创建 Map 集合1234567891011void main()&#123; // 创建Map var language = &#123;'fisrt': 'dart', 'second': 'java'&#125;; // 创建不可变的 Map var constLanguage = const &#123;'fisrt': 'dart', 'second': 'java'&#125;; // 通过构造器创建 var initLanguage = new Map();&#125; Map 中常用的方法123456789101112131415161718192021222324252627282930313233343536void main()&#123; // 创建Map var map = &#123;'fisrt': 'dart', 'second': 'java'&#125;; // 获取长度 print(map.length); // 输出结果：2 // 判断是否为空 print(map.isEmpty); // 输出结果：false print(map.isNotEmpty); // 输出结果：true // 获取到所有的 key print(map.keys); // 输出结果：(fisrt, second) // 获取到所有的 values print(map.values); // 输出结果：(dart, java) // 判断是否包含某个key print(map.containsKey("key")); // 输出结果：false // 判断是否包含某个value print(map.containsValue("key")); // 输出结果：false // 添加一个新的元素进去 map['third'] = 'key'; print(map); // 输出结果：&#123;fisrt: dart, second: java, third: key&#125; // 循环打印 代码提示：Map.forEach((String, String) → void f) → void map.forEach( (key, value) =&gt; getMap(key, value) );&#125; void getMap(key, value)&#123; print("key:$&#123;key&#125;, value:$&#123;value&#125;");&#125; dynamic 关键字这个关键字就类似定义我们在 JS 中定义变量的情况。先看下面的代码 12345678910void main()&#123; // a 的数据类型可以随意改变，这种类型就是 dynamic var a ; a = 10; a = "dart"; // 这里我们使用 dynamic 声明 dynamic d = 10; d = 'dart';&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter抓包]]></title>
    <url>%2Fposts%2F832de89a.html</url>
    <content type="text"><![CDATA[flutter抓包查看dio文档发现需要设置代理 12345678(dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (HttpClient client) &#123; client.findProxy = (uri) &#123; //proxy all request to localhost:8888 return "PROXY 192.168.8.84:8888"; &#125;; // 你也可以自己创建一个新的HttpClient实例返回。 // return new HttpClient(SecurityContext); &#125;;]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter常见第三方插件]]></title>
    <url>%2Fposts%2F9c7b53c1.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124# 网络请求框架dio: ^3.0.7# spshared_preferences: ^0.5.6# 微信sdkfluwx: ^1.2.1+1# swiper 轮播插件flutter_swiper: ^1.1.6# 个推 sdkgetuiflut: ^0.1.6# Flutter 调试工具flutter_flipperkit: ^0.0.21# flipper sqflite调试flipperkit_sqflite_driver: 0.0.2# json生成json_annotation: ^2.2.0# 下载器flutter_downloader: 1.1.7# 获取系统路径path_provider: ^1.3.0# 系统权限管理permission_handler: ^4.3.0# 通知权限管理notification_permissions: ^0.4.4# webviewflutter_webview_plugin: ^0.3.4# 唤起其他appurl_launcher: ^5.0.2# growingio 统计flutter_growingio_track:path: plugins/flutter_growingio_track-2.6.4# 设备信息device_info: ^0.4.0# 生成uuiduuid: 2.0.2# 事件传递event_bus: ^1.1.0# loading 样式组件flutter_spinkit: ^4.0.0# qq sdkflutter_qq: ^0.0.5# 代码包信息package_info: ^0.4.0+6# 状态管理provider: ^3.0.0+1# 选择器flutter_picker: ^1.0.13# 图片裁剪image_cropper: ^1.0.2# 图片选择image_picker: ^0.6.1+2# 路由框架fluro: ^1.5.1# pdf浏览器flutter_full_pdf_viewer: ^1.0.4# 避免输入框被键盘遮挡keyboard_avoider: ^0.1.2# 屏幕适配 https://github.com/OpenFlutter/flutter_screenutilflutter_screenutil: ^1.1.0# Toast插件 https://github.com/OpenFlutter/flutter_oktoastoktoast: ^2.2.0# 日期选择器flutter_cupertino_date_picker: ^1.0.12# 小红点插件 badge https://pub.dev/packages/flutter_badgeflutter_badge: ^0.0.1# 自定义上拉加载和下拉刷新效果 flutter_easyrefresh 前提：必须是一个ListViewflutter_easyrefresh: ^1.2.7# 音频播放插件: https://pub.flutter-io.cn/packages/audioplayersaudioplayers: ^0.13.2# 录音: https://pub.flutter-io.cn/packages/audio_recorderaudio_recorder:path: plugins/audio_recorder-1.0.1# 瀑布流插件 https://github.com/letsar/flutter_staggered_grid_viewflutter_staggered_grid_view: ^0.3.0# 图片浏览器: https://pub.flutter-io.cn/packages/photo_viewphoto_view: ^0.9.0# 数据加解密encrypt: 3.3.1# 网络状态插件connectivity: ^0.4.8+2connectivity: ^0.4.8+2# 腾讯imdim:path: plugins/dim# sqlsqflite: ^1.1.7+1# 富文本输入extended_text_field: 0.4.9# 富文本展示extended_text: ^0.6.6# 振动vibration: 1.2.2# 弹出气泡w_popup_menu: ^0.2.5# 高德-仅地图amap_map_fluttify:path: plugins/amap_map_fluttify-develop3# amap_map_fluttify: 0.18.2+c038d50# 高德-仅定位amap_location_fluttify: 0.8.11+481e45c# 图片缓存cached_network_image: 2.0.0-rc.1# iOS 内购flutter_inapp_purchase: ^2.1.0# 获取设备id: https://pub.flutter-io.cn/packages/unique_idsunique_ids: 1.0.10# 获取设备user_agentflutter_user_agent:path: plugins/flutter_user_agent-1.2.1# 颜色插件color: 2.1.1# 消息上下轮播(跑马灯)marquee: 1.3.1# 为SVG路径和代码生成创建一个纯Dart解析库path_parsing: 0.1.4# 异常捕获及日志打印# https://pub.flutter-io.cn/packages/sentrysentry: 3.0.1# 基于dio的网络请求日志dio_log: ^1.3.3# 支付代码测试iap_pay:git: url: https://gitee.com/Steven_Hu/iap_pay.git ref: master]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter国际化本地化]]></title>
    <url>%2Fposts%2Fd1969579.html</url>
    <content type="text"><![CDATA[源码地址 安装，配置和使用安装将此添加到包的pubspec.yaml文件中： 12dependencies: flutter_translate: &lt;latest version&gt; 从命令行（或从您的编辑器）安装软件包： 1flutter pub get 组态导入flutter_translate： 1导入 &apos;package：flutter_translate / flutter_translate.dart&apos; ; 将json本地化文件放置在项目中您选择的文件夹中。 默认情况下，flutter_translate将assets/i18n在项目根目录下的目录中搜索本地化文件。 在中声明您的资产本地化目录 pubspec.yaml 123flutter: assets: - assets/i18n 在主函数中，创建本地化委托并启动应用，然后将其与LocalizedApp包装在一起 12345678void main() async&#123; var delegate = await LocalizationDelegate.create( fallbackLocale: &apos;en_US&apos;, supportedLocales: [&apos;en_US&apos;, &apos;es&apos;, &apos;fa&apos;]); runApp(LocalizedApp(delegate, MyApp()));&#125; 如果本地化文件的资产目录与默认目录（assets/i18n）不同，则需要指定它： 1234var delegate = await LocalizationDelegate.create( ... basePath: &apos;assets/i18n/&apos; ... 示例MyApp： 123456789101112131415161718192021222324 class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var localizationDelegate = LocalizedApp.of(context).delegate; return LocalizationProvider( state: LocalizationProvider.of(context).state, child: MaterialApp( title: 'Flutter Translate Demo', localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, localizationDelegate ], supportedLocales: localizationDelegate.supportedLocales, locale: localizationDelegate.currentLocale, theme: ThemeData(primarySwatch: Colors.blue), home: MyHomePage(), ), ); &#125;&#125; 用法翻译一个字符串： 1translate(&apos;your.localization.key&apos;); 1translate(&apos;your.localization.key&apos;, args: &#123;&apos;argName1&apos;: argValue1, &apos;argName2&apos;: argValue2&#125;); 进行多元翻译： 1translatePlural(&apos;plural.demo&apos;, yourNumericValue); JSON： 1234567"plural": &#123; "demo": &#123; "0": "Please start pushing the 'plus' button.", "1": "You have pushed the button one time.", "else": "You have pushed the button &#123;&#123;value&#125;&#125; times." &#125;&#125; 更改语言： 12345678@overrideWidget build(BuildContext context) &#123;... ... changeLocale(context, 'en_US'); ......&#125; 自动保存和还原所选的语言环境Flutter Translate可以自动保存选定的语言环境，并在应用程序重新启动后将其还原。 这可以通过在委托创建期间传递ITranslatePreferences的实现来完成： 1234var delegate = await LocalizationDelegate.create( ... preferences: TranslatePreferences() ... 使用shared_preferences包的示例实现： 12345678910111213141516171819202122232425262728import &apos;dart:ui&apos;;import &apos;package:flutter_translate/flutter_translate.dart&apos;;import &apos;package:shared_preferences/shared_preferences.dart&apos;;class TranslatePreferences implements ITranslatePreferences&#123; static const String _selectedLocaleKey = &apos;selected_locale&apos;; @override Future&lt;Locale&gt; getPreferredLocale() async &#123; final preferences = await SharedPreferences.getInstance(); if(!preferences.containsKey(_selectedLocaleKey)) return null; var locale = preferences.getString(_selectedLocaleKey); return localeFromString(locale); &#125; @override Future savePreferredLocale(Locale locale) async &#123; final preferences = await SharedPreferences.getInstance(); await preferences.setString(_selectedLocaleKey, localeToString(locale)); &#125;&#125; 并且不要忘记在pubspec.yaml中引用shared_preferences包 12dependencies: shared_preferences: &lt;latest version&gt; #####]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter父子组件通信]]></title>
    <url>%2Fposts%2Fa44860d6.html</url>
    <content type="text"><![CDATA[父-&gt;子 定义父组件变量 data，在子组件Child的构造方法中把data值传进去，子组件接收data。 父-&gt;子 子组件接收callBack并调用callBack将data值传过去。 父组件定义onChanged，绑定到callBack中，接收子组件传过来的data值。 123456789101112131415161718192021222324252627282930class ParentState extends State&lt;Parent&gt; &#123; String data = "父组件传递给子组件的值"; void onChanged(val)&#123; setState(() &#123; data = val; &#125;); &#125; @override Widget build(BuildContext context) &#123; ...... //省略非关键代码 new Child(data: data,callBack: (value)=&gt;onChanged(value)), &#125;&#125;class child extends StatefulWidget &#123; childTwo(&#123;Key key, this.data, this.callBack&#125;) : super(key: key); final callBack; String data; @override void initState() &#123; data = widget.data; super.initState(); &#125; ...... //省略非关键代码 widget.callBack(data);&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter自定义轮播图Banner]]></title>
    <url>%2Fposts%2F2f3abe95.html</url>
    <content type="text"><![CDATA[widget_banner.dart123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185import 'dart:async';import 'package:ajbaby/enum/enum_indicator_style.dart';import 'package:ajbaby/route_manager.dart';import 'package:flutter/material.dart';import 'package:flutter_screenutil/flutter_screenutil.dart';/* * 自定义banner */// ignore: must_be_immutableclass CustomBanner extends StatefulWidget &#123; List&lt;String&gt; images; double height; ValueChanged&lt;int&gt; onTap; IndicatorStyle indicatorStyleStr; CustomBanner(&#123; Key key, @required this.images, @required this.indicatorStyleStr, this.height = 375, this.onTap, &#125;) : super(key: key); @override _CustomBannerState createState() =&gt; _CustomBannerState();&#125;class _CustomBannerState extends State&lt;CustomBanner&gt; &#123; PageController _pageController; int _curIndex; Timer _timer; @override void initState() &#123; super.initState(); _curIndex = widget.images.length * 5; _pageController = PageController(initialPage: _curIndex); _initTimer(); &#125; @override void dispose() &#123; // TODO: implement dispose super.dispose();// _cancelTimer(); &#125; @override Widget build(BuildContext context) &#123; return Stack( alignment: Alignment.bottomCenter, children: &lt;Widget&gt;[ _buildPageView(), _buildIndicator(), ], ); &#125; Widget _buildIndicator() &#123; var length = widget.images.length; return Positioned( bottom: 5, child: Row( children: widget.images.map((s) &#123; return Padding(padding: const EdgeInsets.symmetric(horizontal: 3.0), child: _indicatorStyle(s, length)); &#125;).toList(), ), ); &#125; Widget _indicatorStyle(s, length) &#123; switch (widget.indicatorStyleStr) &#123; case IndicatorStyle.circle: return Container( child: ClipOval( child: Container( width: ScreenUtil().setWidth(8), height: ScreenUtil().setHeight(8), color: s == widget.images[_curIndex % length] ? Color(0xFFFF5F6D) : Color(0xFFE0E0E0), ), )); break; case IndicatorStyle.line: return Container( child: ClipRRect( borderRadius: BorderRadius.circular(10.0), child: Container( width: ScreenUtil().setWidth(20), height: ScreenUtil().setHeight(3), color: s == widget.images[_curIndex % length] ? Color(0xFFFF5F6D) : Color(0xFFE0E0E0), ), )); break; &#125; return null; &#125; Widget _buildPageView() &#123; var length = widget.images.length; return Container( height: ScreenUtil().setHeight(widget.height), child: PageView.builder( controller: _pageController, onPageChanged: (index) &#123; setState(() &#123; _curIndex = index; if (index == 0) &#123; _curIndex = length; _changePage(); &#125; &#125;); &#125;, itemBuilder: (context, index) &#123; return GestureDetector( onPanDown: (details) &#123; _cancelTimer(); &#125;, onTap: () &#123; //弹出路由，跳转到其他页面 Navigator.of(context).pushNamed(RouteNames.productDetails);// Scaffold.of(context).showSnackBar(// SnackBar(// content: Text('当前 page 为 $&#123;index % length&#125;'),// duration: Duration(milliseconds: 500),// ),// ); &#125;, child: Image.network( widget.images[index % length], fit: BoxFit.cover, ), ); &#125;, ), ); &#125; /// 点击到图片的时候取消定时任务 _cancelTimer() &#123; if (_timer != null) &#123; _timer.cancel(); _timer = null; _initTimer(); &#125; &#125; /// 初始化定时任务 _initTimer() &#123; if (_timer == null) &#123; _timer = Timer.periodic(Duration(seconds: 3), (t) &#123; _curIndex++; _pageController.animateToPage( _curIndex, duration: Duration(milliseconds: 300), curve: Curves.linear, ); &#125;); &#125; &#125; /// 切换页面，并刷新小圆点 _changePage() &#123; Timer(Duration(milliseconds: 350), () &#123; _pageController.jumpToPage(_curIndex); &#125;); &#125;&#125; 引用12345child: CustomBanner( images: _imgData, indicatorStyleStr: IndicatorStyle.line, height: double.infinity,),]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter自定义TabBar]]></title>
    <url>%2Fposts%2F251aa72f.html</url>
    <content type="text"><![CDATA[custom_tabbar.dart12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import 'package:ajbaby/res/colors.dart';import 'package:flutter/material.dart';// ignore: must_be_immutableclass CustomTabBar extends StatefulWidget implements PreferredSizeWidget &#123; Color containerBgColor; Color labelColor; Color unselectedLabelColor; Color indicatorColor; TabController tabController; List&lt;Widget&gt; tabsList = new List&lt;Widget&gt;(); List&lt;Widget&gt; tabBarViewsList = new List&lt;Widget&gt;(); // @required声明必传参数 CustomTabBar(&#123; Key key, @required this.tabsList, @required this.tabBarViewsList, @required this.tabController, this.containerBgColor = YColors.color_FFFFFF, this.labelColor = YColors.color_FF5F6D, this.unselectedLabelColor = YColors.color_858585, this.indicatorColor = YColors.color_FF5F6D, &#125;) : super(key: key); @override _CustomTabBarState createState() &#123; return _CustomTabBarState(); &#125; @override // TODO: implement preferredSize Size get preferredSize =&gt; null;&#125;class _CustomTabBarState extends State&lt;CustomTabBar&gt; with AutomaticKeepAliveClientMixin &#123; @override void initState() &#123; super.initState(); &#125; @override void dispose() &#123; super.dispose();// widget.tabController.dispose(); &#125; @override Widget build(BuildContext context) &#123; super.build(context); return Scaffold( appBar: PreferredSize( child: Container( color: widget.containerBgColor, child: TabBar( isScrollable: true, controller: widget.tabController, tabs: widget.tabsList, labelColor: widget.labelColor, unselectedLabelColor: widget.unselectedLabelColor, indicatorColor: widget.indicatorColor, ), ), preferredSize: Size.fromHeight(kToolbarHeight)), body: TabBarView( controller: widget.tabController, children: widget.tabBarViewsList, ), ); &#125; @override // TODO: implement wantKeepAlive bool get wantKeepAlive =&gt; true;&#125; 引用12345body: CustomTabBar( tabsList: _tabsList, tabBarViewsList: _tabBarViewsList, tabController: _tabController,),]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter中管理路由栈的方法和应用]]></title>
    <url>%2Fposts%2Fbe45d28e.html</url>
    <content type="text"><![CDATA[本文首先讲的Flutter中的路由，然后主要讲下Flutter中栈管理的几种方法。 了解下Route和Navigator 简单的路由 命名路由 自定义路由 Flutter中使用的路由场景 Flutter中的路由栈管理 实战 了解下Route和Navigator在Flutter中，我们需要在不同屏幕或者页面之间进行切换和发送数据,这些“screens”或者“pages”被称为Route(路由),是由一个Navigator的小部件进行管理。 Navigator可以管理包含若干Route对象的堆栈，并提供了管理的方法，平常我们经常用的就是[Navigator.push]和[Navigator.pop]。 尽管我们可以自己直接创建一个navigator,但是当我们创建一个WidgetsApp或者MaterialApp,Flutter会自动默认创建一个Navigator。 所以我们一般是使用由[WidgetsApp]或者[MaterialApp]所创建的Navigator就行了，然后通过调用[Navigator.of] 来拿到当前的Navigator的状态NavigatorState,然后调用它的pop或者push方法。 简单的路由比如要导航到一个新的页面，我们可以创建一个[MaterialPageRoute]的实例，然后调用Navigator.of(context).push()方法就将新页面添加到堆栈的顶部。 返回上一个页面，则调用Navigator.pop(context)就可以从堆栈中删除这个屏幕; 12345Navigator.of(context) .push(new MaterialPageRoute(builder: (context) &#123; return new DetailPage(); &#125;)); Navigator.pop(context); 命名路由如果每次跳转到一个新的路由页面，都要跟上面一样的写法，创建MaterialPageRoute实例然后调用push方法，这样的话就太麻烦了。 所以，Flutter提供了另外一种方式来管理路由，可以使用命名路由，然后使用Navigator.pushNamed（）方法来弹出路由。 创建MaterialApp的时候需要传入一个routes参数，routes本质上是一个Map&lt;String,WidgetBuilder&gt;,key值对应自定义的路径名字，value值会映射到对应的WidgetBuilder,我们可以在WidgetBuilder中创建对应的页面。 Navigator.pushNamed()方法有两个参数（BuildContext，String),第一个是上下文，第二个是在路由中预定义的string。 特殊情况处理：当push一个不存在的路由页面的时候，需要进行提示操作。可以使用UnknownRoute的属性。比如下面的例子， 当push一个不存在的路由的时候，会跳转到NotFoundPage的页面。 12345678910111213141516171819202122232425262728293031void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( routes: &#123; //Map&lt;String, WidgetBuilder&gt; "/splash": (context) =&gt; new SplashPage(), "/login": (context) =&gt; new LoginPage(), "/home": (context) =&gt; new HomePage(), "/detail": (context) =&gt; new DetailPage(), &#125;, onUnknownRoute: (RouteSettings setting) &#123; String name = setting.name; print("onUnknownRoute:$name"); return new MaterialPageRoute(builder: (context) &#123; return new NotFoundPage(); &#125;); &#125;, title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: new SplashPage(), ); &#125;&#125;//弹出路由，跳转到其他页面 Navigator.of(context).pushNamed("/detail"); 自定义路由比如我们上面使用的是MaterialPageRoute，在页面切换的时候，会有默认的自适应平台的过渡动画。 如果想自定义页面的进场和出场动画，那么需要使用PageRouteBuilder来创建路由。 PageRouteBuilder是主要的部分，一个是“pageBuilder”，用来创建所要跳转到的页面，另一个是“transitionsBuilder”，也就是我们可以自定义的转场效果。 1234567891011PageRouteBuilder(&#123; RouteSettings settings, @required this.pageBuilder,//构造页面 this.transitionsBuilder = _defaultTransitionsBuilder,//创建转场动画 this.transitionDuration = const Duration(milliseconds: 300),//转场动画的持续时间 this.opaque = true,//是否是透明的 this.barrierDismissible = false,//举个例子，比如AlertDialog也是利用PageRouteBuilder进行创建的，barrierDismissible若为false，点击对话框周围，对话框不会关闭；若为true，点击对话框周围，对话框自动关闭。 this.barrierColor, this.barrierLabel, this.maintainState = true,&#125; 只修改单独一个页面的过渡动画，可以这样操作，例如下面的代码， 12345678910111213141516171819//自定义跳转动画Navigator.push( context, PageRouteBuilder( opaque: false, pageBuilder: (BuildContext context, _, __) &#123; return new HomePage(); &#125;, transitionsBuilder: (___, Animation&lt;double&gt; animation, ____, Widget child) &#123; return FadeTransition( opacity: animation, child: RotationTransition( turns: Tween&lt;double&gt;(begin: 0.5, end: 1.0) .animate(animation), child: child, ), ); &#125;)); Flutter中使用的路由场景在Flutter中，我们会使用到这些方法，例如[showDialog()], [showMenu()], and [showModalBottomSheet()]等，这些方法其实本质上是创建了一个路由的页面后，并调用Navigator的push方法去push到当前的屏幕上。 showDialog()其实是调用了showGeneralDialog()，所以下面贴了showGeneralDialog的源码，可以看出，也是利用了Navigator的push方法的。 这里插一下，关于对话框的使用，比如列表对话框，自定义对话框的使用和踩坑，可以看下我的另外一篇文章：Flutter之Dialog使用和踩坑 123456789101112131415161718Future&lt;T&gt; showGeneralDialog&lt;T&gt;(&#123; @required BuildContext context, @required RoutePageBuilder pageBuilder, bool barrierDismissible, String barrierLabel, Color barrierColor, Duration transitionDuration, RouteTransitionsBuilder transitionBuilder,&#125;) &#123; return Navigator.of(context, rootNavigator: true).push&lt;T&gt;(_DialogRoute&lt;T&gt;( pageBuilder: pageBuilder, barrierDismissible: barrierDismissible, barrierLabel: barrierLabel, barrierColor: barrierColor, transitionDuration: transitionDuration, transitionBuilder: transitionBuilder, ));&#125; Flutter中的路由栈管理相信大家对栈Stack都有一定的了解，push方法是将元素添加到堆栈的顶部，pop方法是删除顶部元素。 下面用图文的方式来讲解Flutter中几个管理栈的方法之间的区别。 push（）push()，就是直接将一个元素插入到堆栈的顶部。 这个方法很简单，并且我们会经常用到。比如从Screen1中利用navigator的push方法，将Screen2的路由弹到堆栈的顶部。堆栈的情况如下图： 可以利用下面的两个push方法，实现这个目的。 12Navigator.of(context).pushNamed("/111");Navigator.of(context).push(route); pop()pop(), 就是将堆栈的顶部元素进行删除，回退到上一个界面。 比如上面的例子，在Screen2中利用pop()将顶部的Screen2从堆栈中移除，之后的堆栈如下图： 1Navigator.of(context).pop(); 注意： 当利用push()跳转到一个使用Scaffold的页面的时候，Scaffold会自动在其AppBar上添加一个“ 后退 ”按钮，点击按钮会自动调用Navigator.pop()。 在Android中，按下设备后退按钮也会自动调用Navigator.pop()。 pushReplacementNamed()和popAndPushNamed()有下面的这种场景，我们进入到Screen3页面后，要跳转到Screen4页面，不过点击返回按钮，并不想回退到Screen3页面。也就是想将Screen4的元素插入栈顶的同时，将Screen3的元素夜进行移除。 这个时候，我们就要用到pushReplacementNamed()或者popAndPushNamed(),pushReplacement()都可以实现这个目的。 123Navigator.of(context).pushReplacementNamed('/screen4');Navigator.popAndPushNamed(context, '/screen4');Navigator.of(context).pushReplacement(newRoute); pushNamedAndRemoveUntil()一般会有这种场景，我们在已经登录的情况下，在设置界面会有个退出用户登录的按钮，点击后会注销用户退出登录，并且会跳转到登录界面。那么路由栈的变化应该会如下图所示： 如果只是简单的进行push一个LoginScreen的操作的话，那么按返回键的话，会回到上一个页面，这样的逻辑是不对的。 所以我们应该删除掉路由栈中的所有route，然后再弹出LoginScreen。这个时候就要用到pushNamedAndRemoveUntil()或者pushAndRemoveUntil()了。 12345678typedef RoutePredicate = bool Function(Route&lt;dynamic&gt; route);//第一个参数context是上下文的context，//第二个参数newRouteName是新的路由所命名的路径//第三个参数predicate，返回值是bool类型，按照我的理解，就是用来判断Until所结//束的时机，如果为false的话，就会一直继续执行Remove的操作，直到为true的时候，停止Remove操作，然后才执行push操作。 static Future&lt;T&gt; pushNamedAndRemoveUntil&lt;T extends Object&gt;(BuildContext context, String newRouteName, RoutePredicate predicate) &#123; return Navigator.of(context).pushNamedAndRemoveUntil&lt;T&gt;(newRouteName, predicate); &#125; 如果想在弹出新路由之前，删除路由栈中的所有路由，那可以使用下面的这种写法，(Route route) =&gt; false，这样能保证把之前所有的路由都进行删除，然后才push新的路由。 1Navigator.of(context).pushNamedAndRemoveUntil('/LoginScreen', (Route&lt;dynamic&gt; route) =&gt; false); 如果想在弹出新路由之前，删除路由栈中的部分路由。比如只弹出Screen1路由上面的Screen3和Screen2，然后再push新的Screen4，堆栈的情况如下图： 利用ModalRoute.withName(name)，来执行判断，可以看下面的源码，当所传的name跟堆栈中的路由所定义的时候，会返回true值，不匹配的话，则返回false。 12345678910Navigator.of(context).pushNamedAndRemoveUntil('/screen4',ModalRoute.withName('/screen1')); //ModalRoute.withName的源码 static RoutePredicate withName(String name) &#123; return (Route&lt;dynamic&gt; route) &#123; return !route.willHandlePopInternally &amp;&amp; route is ModalRoute &amp;&amp; route.settings.name == name; &#125;; &#125; popUntil()popUntil()方法的过程其实跟上面差不多，就是是少了push一个新页面的操作，只是单纯的进行移除路由操作。 12popUntil(RoutePredicate predicate);Navigator.of(context).popUntil(ModalRoute.withName("/XXX")); 实战这里写了一个Demo，将上面的几种管理栈的用法都运用了一下。 1234567891011121314151617181920212223242526class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( routes: &#123; //Map&lt;String, WidgetBuilder&gt; "/splash": (context) =&gt; new SplashPage(), "/login": (context) =&gt; new LoginPage(), "/home": (context) =&gt; new HomePage(), "/detail": (context) =&gt; new DetailPage(), &#125;, onUnknownRoute: (RouteSettings setting) &#123; String name = setting.name; print("onUnknownRoute:$name"); return new MaterialPageRoute(builder: (context) &#123; return new NotFoundPage(); &#125;); &#125;, title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: new SplashPage(), ); &#125;&#125; 首先是定义在MaterialApp中定义多个路由，Demo中有多个路由: SplashPage 启动页面，设置2秒后自动跳转到LoginPage LoginPage 登录页面，点击按钮，模仿登录成功的动作并跳转到HomePage HomePage 主页，显示一个列表，点击列表项跳转到DetailPage DetailPage 详细信息页面，并且有一个退出登录的按钮 NotFoundPage 当没有路由可以匹配的时候，弹出这个页面 下面简单讲一下代码： SplashPage-&gt;LoginPage,LoginPage-&gt;HomePage用的都是pushReplacementNamed()。因为跳到登录界面后，不需要返回到SplashPage，所以需要将SplashPage从路由栈中移除。LoginPage-&gt;HomePage，也是同样的道理。 12Navigator.of(context).pushReplacementNamed("/login");Navigator.of(context).pushReplacementNamed("/home"); HomePage-&gt;DetailPage使用的是简单的pushNamed()就可以了，没必要移除HomePage，因为从DetailPage点击返回后，需要返回到HomePage界面。 123456//下面的两种写法都是可以的Navigator.of(context).pushNamed("/detail");Navigator.of(context) .push(new MaterialPageRoute(builder: (context) &#123; return new DetailPage(); &#125;)); DetailPage-&gt;LoginPage利用的是从DetailPage点击退出登录按钮，会弹出路由栈中的所有路由页面，然后再将LoginPage的路由插入到栈顶。这样的话，路由栈中就只剩下LoginPage了，若是点击返回按钮的话，默认就会退出应用程序了，因为堆栈为空了。 1Navigator.of(context).pushNamedAndRemoveUntil("/login", (Route&lt;dynamic&gt; route) =&gt; false);]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter自定义导航栏AppBar]]></title>
    <url>%2Fposts%2F16d03859.html</url>
    <content type="text"><![CDATA[自定义AppBar源码中可以看到,AppBar只是实现了 PreferredSizeWidget接口 1class AppBar extends StatefulWidget implements PreferredSizeWidget 那么我们也可以从这进行入手，自定义一个实现了 PreferredSizeWidget的Widget具体代码并不多，比你想象的简单，直接上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import 'package:flutter/material.dart';import 'package:flutter_screenutil/flutter_screenutil.dart';/// 这是一个可以指定SafeArea区域背景色的AppBar/// PreferredSizeWidget提供指定高度的方法/// 如果没有约束其高度，则会使用PreferredSizeWidget指定的高度// ignore: must_be_immutableclass CustomAppbar extends StatefulWidget implements PreferredSizeWidget &#123; final double contentHeight; //从外部指定高度 Color navigationBarBackgroundColor; //设置导航栏背景的颜色 Widget leadingWidget; Widget trailingWidget; String title; CustomAppbar(&#123; @required this.leadingWidget, @required this.title, this.contentHeight = 44, this.navigationBarBackgroundColor = Colors.white, this.trailingWidget, &#125;) : super(); @override State&lt;StatefulWidget&gt; createState() &#123; return new _CustomAppbarState(); &#125; @override Size get preferredSize =&gt; new Size.fromHeight(contentHeight);&#125;/// 这里没有直接用SafeArea，而是用Container包装了一层/// 因为直接用SafeArea，会把顶部的statusBar区域留出空白/// 外层Container会填充SafeArea，指定外层Container背景色也会覆盖原来SafeArea的颜色/// var statusheight = MediaQuery.of(context).padding.top; 获取状态栏高度class _CustomAppbarState extends State&lt;CustomAppbar&gt; &#123; @override void initState() &#123; super.initState(); &#125; @override Widget build(BuildContext context) &#123; return new Container( color: widget.navigationBarBackgroundColor, child: new SafeArea( top: true, child: new Container( decoration: new UnderlineTabIndicator( borderSide: BorderSide(width: 1.0, color: Color(0xFFeeeeee)), ), height: widget.contentHeight, child: new Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ Positioned( left: 0, child: new Container( padding: const EdgeInsets.only(left: 5), child: widget.leadingWidget, ), ), new Container( child: new Text( widget.title, style: new TextStyle( fontSize: ScreenUtil().setSp(33, allowFontScalingSelf: true), color: Color(0xFF333333), fontWeight: FontWeight.w600), ), ), Positioned( right: 0, child: new Container( padding: const EdgeInsets.only(right: 5), child: widget.trailingWidget, ), ), ], )), ), ); &#125;&#125; 引用的地方:12345appBar: new CustomAppbar( title: '日历', leadingWidget: leftBarButtonItemWidget(), trailingWidget: rightBarButtonItemsWidget(), ) leftBarButtonItemWidget() rightBarButtonItemsWidget()两个方法是我自定义的导航栏按钮，实现自己需要的即可。值得说的是，可以将leadingWidget设置为非@required的，在自定义的AppBar里面做好处理即可,另外在上面的代码中并没有限制导航栏上每个Widget所占用的最大空间，如果你的导航栏子组件可能很宽，提前进行妥善处理是个好主意。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter屏幕适配方案]]></title>
    <url>%2Fposts%2F1aaabac1.html</url>
    <content type="text"><![CDATA[flutter_ScreenUtil flutter 屏幕适配方案，让你的UI在不同尺寸的屏幕上都能显示合理的布局! github: https://github.com/OpenFlutter/flutter_screenutil 使用方法:安装依赖：安装之前请查看最新版本 12345dependencies: flutter: sdk: flutter # 添加依赖 flutter_screenutil: ^1.0.2 在每个使用的地方导入包：1import &apos;package:flutter_screenutil/flutter_screenutil.dart&apos;; 属性 属性 类型 默认值 描述 width double 1080px 设计稿中设备的宽度,单位px height double 1920px 设计稿中设备的高度,单位px allowFontScaling bool false 设置字体大小是否根据系统的“字体大小”辅助选项来进行缩放 初始化并设置适配尺寸及字体大小是否根据系统的“字体大小”辅助选项来进行缩放在使用之前请设置好设计稿的宽度和高度，传入设计稿的宽度和高度(单位px)一定在MaterialApp的home中的页面设置(即入口文件，只需设置一次),以保证在每次使用之前设置好了适配尺寸: 12345678910//填入设计稿中设备的屏幕尺寸//默认 width : 1080px , height:1920px , allowFontScaling:falseScreenUtil.init(context);//假如设计稿是按iPhone6的尺寸设计的(iPhone6 750*1334) ScreenUtil.init(context, width: 750, height: 1334);//设置字体大小根据系统的“字体大小”辅助选项来进行缩放,默认为falseScreenUtil.init(context, width: 750, height: 1334, allowFontScaling: true); 使用：适配尺寸：传入设计稿的px尺寸： 根据屏幕宽度适配 width: ScreenUtil().setWidth(540), 根据屏幕高度适配 height: ScreenUtil().setHeight(200), 注意 高度也根据setWidth来做适配可以保证不变形(当你想要一个正方形的时候) setHeight方法主要是在高度上进行适配, 在你想控制UI上一屏的高度与实际中显示一样时使用. 例如: 1234567891011//UI上是长方形:Container( width: ScreenUtil().setWidth(375), height: ScreenUtil().setHeight(200), ), //如果你想显示一个正方形:Container( width: ScreenUtil().setWidth(300), height: ScreenUtil().setWidth(300), ), 适配字体:传入设计稿的px尺寸： 1234567891011121314151617181920212223//传入字体大小，默认不根据系统的“字体大小”辅助选项来进行缩放(可在初始化ScreenUtil时设置allowFontScaling)ScreenUtil().setSp(28) //传入字体大小，根据系统的“字体大小”辅助选项来进行缩放(如果某个地方不遵循全局的allowFontScaling设置) ScreenUtil().setSp(24, allowFontScalingSelf: true) //for example:Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text(&apos;我的文字大小在设计稿上是24px，不会随着系统的文字缩放比例变化&apos;, style: TextStyle( color: Colors.black, fontSize: ScreenUtil().setSp(24), )), Text(&apos;我的文字大小在设计稿上是24px，会随着系统的文字缩放比例变化&apos;, style: TextStyle( color: Colors.black, fontSize: ScreenUtil() .setSp(24, allowFontScalingSelf: true))), ], ) 其他相关api：123456789ScreenUtil.pixelRatio //设备的像素密度ScreenUtil.screenWidth //设备宽度ScreenUtil.screenHeight //设备高度ScreenUtil.bottomBarHeight //底部安全区距离，适用于全面屏下面有按键的ScreenUtil.statusBarHeight //状态栏高度 刘海屏会更高 单位pxScreenUtil.textScaleFactor //系统字体缩放比例ScreenUtil().scaleWidth // 实际宽度的dp与设计稿px的比例ScreenUtil().scaleHeight // 实际高度的dp与设计稿px的比例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155import 'package:flutter/material.dart';import 'package:flutter_screenutil/flutter_screenutil.dart';void main() =&gt; runApp( MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( debugShowCheckedModeBanner: false, title: 'Flutter_ScreenUtil', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(), ); &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; @override Widget build(BuildContext context) &#123; //设置适配尺寸 (填入设计稿中设备的屏幕尺寸) 此处假如设计稿是按iPhone6的尺寸设计的(iPhone6 750*1334) ScreenUtil.init(context, width: 750, height: 1334, allowFontScaling: false); ScreenUtil.init(context); ScreenUtil.init(context, width: 750, height: 1334, allowFontScaling: false); return ExampleWidget(title: 'FlutterScreenUtil示例'); &#125;&#125;class ExampleWidget extends StatefulWidget &#123; const ExampleWidget(&#123;Key key, this.title&#125;) : super(key: key); final String title; @override _ExampleWidgetState createState() =&gt; _ExampleWidgetState();&#125;class _ExampleWidgetState extends State&lt;ExampleWidget&gt; &#123; @override Widget build(BuildContext context) &#123; printScreenInformation(); return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: SingleChildScrollView( child: Column( crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Row( children: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(ScreenUtil().setWidth(10)), width: ScreenUtil().setWidth(375), height: ScreenUtil().setHeight(200), color: Colors.red, child: Text( '我的宽度:$&#123;ScreenUtil().setWidth(375)&#125;dp \n' '我的高度:$&#123;ScreenUtil().setHeight(200)&#125;dp', style: TextStyle( color: Colors.white, fontSize: ScreenUtil().setSp(24)), ), ), Container( padding: EdgeInsets.all(ScreenUtil().setWidth(10)), width: ScreenUtil().setWidth(375), height: ScreenUtil().setHeight(200), color: Colors.blue, child: Text( '我的宽度:$&#123;ScreenUtil().setWidth(375)&#125;dp \n' '我的高度:$&#123;ScreenUtil().setHeight(200)&#125;dp', style: TextStyle( color: Colors.white, fontSize: ScreenUtil().setSp(24))), ), ], ), Text('设备宽度:$&#123;ScreenUtil.screenWidth&#125;px'), Text('设备高度:$&#123;ScreenUtil.screenHeight&#125;px'), Text('设备宽度:$&#123;ScreenUtil.screenWidthDp&#125;dp'), Text('设备高度:$&#123;ScreenUtil.screenHeightDp&#125;dp'), Text('设备的像素密度:$&#123;ScreenUtil.pixelRatio&#125;'), Text('底部安全区距离:$&#123;ScreenUtil.bottomBarHeight&#125;dp'), Text('状态栏高度:$&#123;ScreenUtil.statusBarHeight&#125;dp'), Text( '实际宽度的dp与设计稿px的比例:$&#123;ScreenUtil().scaleWidth&#125;', textAlign: TextAlign.center, ), Text( '实际高度的dp与设计稿px的比例:$&#123;ScreenUtil().scaleHeight&#125;', textAlign: TextAlign.center, ), SizedBox( height: ScreenUtil().setHeight(100), ), Text('系统的字体缩放比例:$&#123;ScreenUtil.textScaleFactor&#125;'), Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('我的文字大小在设计稿上是24px，不会随着系统的文字缩放比例变化', style: TextStyle( color: Colors.black, fontSize: ScreenUtil().setSp(24), )), Text('我的文字大小在设计稿上是24px，会随着系统的文字缩放比例变化', style: TextStyle( color: Colors.black, fontSize: ScreenUtil() .setSp(24, allowFontScalingSelf: true))), ], ) ], ), ), floatingActionButton: FloatingActionButton( child: Icon(Icons.title), onPressed: () &#123; ScreenUtil.init(context, width: 1500, height: 1334, allowFontScaling: false); setState(() &#123;&#125;); &#125;, ), ); &#125; void printScreenInformation() &#123; print('设备宽度:$&#123;ScreenUtil.screenWidth&#125;'); //Device width print('设备高度:$&#123;ScreenUtil.screenHeight&#125;'); //Device height print('设备的像素密度:$&#123;ScreenUtil.pixelRatio&#125;'); //Device pixel density print( '底部安全区距离:$&#123;ScreenUtil.bottomBarHeight&#125;dp'); //Bottom safe zone distance，suitable for buttons with full screen print( '状态栏高度:$&#123;ScreenUtil.statusBarHeight&#125;dp'); //Status bar height , Notch will be higher Unit px print('实际宽度的dp与设计稿px的比例:$&#123;ScreenUtil().scaleWidth&#125;'); print('实际高度的dp与设计稿px的比例:$&#123;ScreenUtil().scaleHeight&#125;'); print( '宽度和字体相对于设计稿放大的比例:$&#123;ScreenUtil().scaleWidth * ScreenUtil.pixelRatio&#125;'); print('高度相对于设计稿放大的比例:$&#123;ScreenUtil().scaleHeight * ScreenUtil.pixelRatio&#125;'); print('系统的字体缩放比例:$&#123;ScreenUtil.textScaleFactor&#125;'); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter_BottomNavigationBar切换页面防止页面重绘]]></title>
    <url>%2Fposts%2F88ab6b09.html</url>
    <content type="text"><![CDATA[开始尝试用flutter开发，flutter版本1.0，写类似微信底部tab切换界面时发现界面老被重置，网上找了一圈说保持状态需要子页面mixin AutomaticKeepAliveClientMixin，然后重写 12@override bool get wantKeepAlive =&gt; true; 但发现需要配合其他组件，不是随便mixin就有用的，尝试几种写法总结BottomNavigationBar+List+AutomaticKeepAliveClientMixin是没有用的 首先尝试BottomNavigationBar+List实现的页面切换保持状态，一般刚开始学都会这么写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; MaterialApp( title: "demo", home: MainPage(), );&#125;class MainPage extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() =&gt; MainPageState();&#125;class MainPageState extends State&lt;MainPage&gt; &#123; int _currentIndex; List&lt;Widget&gt; _pages; @override void initState() &#123; super.initState(); _currentIndex = 0; _pages = List()..add(FirstPage("第一页"))..add(SecondPage("第二页"))..add(ThirdPage("第三页")); &#125; @override Widget build(BuildContext context) =&gt; Scaffold( body: _pages[_currentIndex], bottomNavigationBar: BottomNavigationBar( items: getItems(), currentIndex: _currentIndex, onTap: onTap, ), ); List&lt;BottomNavigationBarItem&gt; getItems() &#123; return [ BottomNavigationBarItem(icon: Icon(Icons.home), title: Text("Home")), BottomNavigationBarItem(icon: Icon(Icons.adb), title: Text("Adb")), BottomNavigationBarItem(icon: Icon(Icons.person), title: Text("Person")) ]; &#125; void onTap(int index) &#123; setState(() &#123; _currentIndex = index; &#125;); &#125;&#125; 子页面代码,三个界面一样： 1234567891011121314151617181920212223242526272829303132333435class FirstPage extends StatefulWidget &#123; String _title; FirstPage(this._title); @override State&lt;StatefulWidget&gt; createState() =&gt; FirstPageState();&#125;class FirstPageState extends State&lt;FirstPage&gt; with AutomaticKeepAliveClientMixin&#123; int _count = 0; @override bool get wantKeepAlive =&gt; true; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget._title), ), body: Center( child: Text(widget._title + ":点一下加1：$_count"), ), floatingActionButton: FloatingActionButton( heroTag: widget._title, child: Icon(Icons.add), onPressed: add), ); &#125; void add() &#123; setState(() &#123; _count++; &#125;); &#125;&#125; 结果无法实现保持页面 2.第二种BottomNavigationBar+PageView，与android的ViewPager类似,界面小改动一下，添加一个按钮，点击跳转到一个新的界面 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; MaterialApp( title: "demo", home: MainPage(), );&#125;class MainPage extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() =&gt; MainPageState();&#125;class MainPageState extends State&lt;MainPage&gt; &#123; int _currentIndex; List&lt;Widget&gt; _pages; PageController _controller; @override void initState() &#123; super.initState(); _currentIndex = 0; _pages = List() ..add(FirstPage("第一页")) ..add(SecondPage("第二页")) ..add(ThirdPage("第三页")); _controller = PageController(initialPage: 0); &#125; @override void dispose() &#123; super.dispose(); _controller.dispose(); &#125; @override Widget build(BuildContext context) =&gt; Scaffold( body: PageView.builder( physics: NeverScrollableScrollPhysics(),//viewPage禁止左右滑动 onPageChanged: _pageChange, controller: _controller, itemCount: _pages.length, itemBuilder: (context, index) =&gt; _pages[index]), bottomNavigationBar: BottomNavigationBar( items: getItems(), currentIndex: _currentIndex, onTap: onTap, ), ); List&lt;BottomNavigationBarItem&gt; getItems() &#123; return [ BottomNavigationBarItem(icon: Icon(Icons.home), title: Text("Home")), BottomNavigationBarItem(icon: Icon(Icons.adb), title: Text("Adb")), BottomNavigationBarItem(icon: Icon(Icons.person), title: Text("Person")) ]; &#125; void onTap(int index) &#123; _controller.jumpToPage(index); &#125; void _pageChange(int index) &#123; if (index != _currentIndex) &#123; setState(() &#123; _currentIndex = index; &#125;); &#125; &#125;&#125; 子界面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class FirstPage extends StatefulWidget &#123; String _title; FirstPage(this._title); @override State&lt;StatefulWidget&gt; createState() =&gt; FirstPageState();&#125;class FirstPageState extends State&lt;FirstPage&gt; with AutomaticKeepAliveClientMixin &#123; int _count = 0; @override bool get wantKeepAlive =&gt; true; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget._title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text(widget._title + ":点一下加1：$_count"), MaterialButton( child: Text("跳转"), color: Colors.pink, onPressed: () =&gt; Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; NewPage()))) ], ), ), floatingActionButton: FloatingActionButton( heroTag: widget._title, child: Icon(Icons.add), onPressed: add), ); &#125; void add() &#123; setState(() &#123; _count++; &#125;); &#125;&#125; 需要跳转的一个界面： 1234567891011class NewPage extends StatelessWidget &#123; @override Widget build(BuildContext context) =&gt; Scaffold( appBar: AppBar( title: Text("新的界面"), ), body: Center( child: Text("我是一个新的界面"), ), );&#125; 猛一看效果出来了，左右切换界面没有问题，结果跳转新界面时又出现新问题，当第一页跳转新的界面再返回，再切第二、三页发现重置了，再切回第一页发现页被重置了。 发生这种情况需要在重写Widget build(BuildContext context)时调用下父类build(context)方法，局部代码： 12345678910111213141516171819202122232425@override Widget build(BuildContext context) &#123; //在这边加上super.build(context); super.build(context); return Scaffold( appBar: AppBar( title: Text(widget._title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text(widget._title + ":点一下加1：$_count"), MaterialButton( child: Text("跳转"), color: Colors.pink, onPressed: () =&gt; Navigator.push(context, MaterialPageRoute(builder: (context) =&gt; NewPage()))) ], ), ), floatingActionButton: FloatingActionButton( heroTag: widget._title, child: Icon(Icons.add), onPressed: add), ); &#125; 这种布局样式网上还有一种用的比较多的是BottomNavigationBar+IndexedStack( )，这边就不贴出来了 经过长期测试BottomNavigationBar+TabBarView方案行不通，后期会遇到其他问题，目前最好用还是viewpage和IndexedStack。 最后像这种多页面使用FloatingActionButton，用它跳转新界面是一定要设置heroTag，要不然跳转会黑屏报错]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter_tabBarView切换页面防止页面重绘]]></title>
    <url>%2Fposts%2Fdffd90b2.html</url>
    <content type="text"><![CDATA[被重绘的tab页要 混入AutomaticKeepAliveClientMixin12// with 混入class DevicePageLayout extends WidgetState&lt;DevicePage&gt; with AutomaticKeepAliveClientMixin 实现wantKeepAlive方法 ，返回值改成true123@override// TODO: implement wantKeepAlivebool get wantKeepAlive =&gt; true; build中加入 super.build(context);1234@overrideWidget build(BuildContext context) &#123; super.build(context); // TODO: implement build]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3.6 正式版终于发布了]]></title>
    <url>%2Fposts%2Faaf10946.html</url>
    <content type="text"><![CDATA[如题，Android Studio 3.6 正式版终于发布了，值得兴奋呀，毕竟 3.5 大版本更新也已经差不多半年了，撒花撒花！这次更新又更新了什么呢？ 包括有设计、开发、构建、测试、优化等多方面，下面我们来看看 Release Notes 写了些什么吧！ Release Notes我们很高兴宣布 Android Studio 3.6 发布稳定版本了，该版本内有一些针对性的新特性，主要解决了在代码编辑和调试用例中的质量问题。这是我们在 Project Marble 结束之后的第一个版本，其重点是构建强大的集成开发环境（IDE）的基本功能和流。我们从 Project Marble 中学到了很多，在 Android Studio 3.6 中，我们引入了一小部分功能，完善的现有功能，并花费了很大的精力来解决错误并改善基础性能，以确保我们达到去年设定的高质量标准。 Android Studio 3.6 的一些亮点包括一种使用 XML 快速设计、开发和预览应用布局的新方法，在设计编辑器中提供了新的拆分视图。此外，您不再需要手动键入 GPS 坐标来测试应用的位置，因为我们现在将 Google 地图直接嵌入到 Android 模拟器扩展控制面板中。最后，通过针对片段和活动的自动内存泄漏检测，我们简化了应用并查找 Bug。我们希望所有这些功能可以帮助您在 Android 上开发时更快乐、更高效。 感谢在预览版中提供早期反馈的用户。您的反馈帮助我们迭代和改进 Android Studio 3.6 中的功能。如果您已准备好迎接下一个稳定版本，并且想要使用一组新的生产力功能，Android Studio 3.6 已准备好下载，以便您入门。 以下是 Android Studio 3.6 中由主要开发人员流组织的全部新功能列表。 设计在设计编辑器中拆分视图设计编辑器（如布局编辑器和导航编辑器）现在提供”拆分”视图，使您能够同时查看 UI 的”设计和代码”视图。拆分视图将替换和改进较早的”预览”窗口，并可以逐个文件进行配置，以保留上下文信息（如缩放因子和设计视图选项），因此您可以选择最适合每个用例的视图。要启用拆分视图，请单击编辑器窗口右上角的”拆分”图标。 颜色选取器资源选项卡在此版本中，我们希望更轻松地应用已定义为颜色资源的颜色。在 Android Studio 3.6 中，颜色选取器将填充应用中的颜色资源，以便快速选择和替换颜色资源值。颜色选取器可在设计工具和 XML 编辑器中访问。 开发视图绑定视图绑定是一项功能，允许您在引用代码中的视图时提供编译时安全性，从而更轻松地编写与视图交互的代码。启用后，视图绑定将为每个模块中存在的 XML 布局文件生成一个绑定类。在大多数情况下，视图绑定将替换 findViewById。您可以引用具有 ID 的所有视图，这些视图没有空指针或类强制转换异常的风险。这些差异意味着布局和代码之间的不兼容将导致生成在编译时失败，而不是在运行时。要在项目中启用视图绑定，请在每个模块的生成中包括以下内容。 123android &#123; viewBinding.enabled = true&#125; Android NDK 修改Android Studio 中的以下 Android NDK 功能以前在 Java 中支持，现在 Kotlin 也支持： 从 JNI 声明导航到 C/C++ 中的相应实现函数。通过将鼠标悬停在托管源代码文件中行号附近的 C 或C++项标记上，查看此映射。 自动为 JNI 声明创建存根实现函数。首先定义 JNI 声明，然后在要激活的 C/C++ 文件中键入”jni”或方法名称。 IntelliJ 平台更改Android Studio 3.6 包括 IntelliJ 2019.2 平台版本。此 IntelliJ 版本包括许多改进，从新的服务工具窗口到大大缩短的启动时间。 应用更改现在，您可以通过单击”应用代码更改”或”应用更改并重新启动活动”来添加类，然后将该代码更改部署到正在运行的应用。 构建Android Gradle Plugin (AGP) updatesAndroid Gradle 插件 3.6 及更高版本包括对 Maven 发布 Gradle 插件的支持，该插件允许您将构建项目发布到 Apache Maven 存储库。Android Gradle 插件为应用或库模块中的每个生成变体项目创建一个组件，您可以使用该组件将出版物自定义到 Maven 存储库。此更改将更轻松地管理各种目标的发布生命周期。 此外，Android Gradle 插件在大型项目的注释处理/KAPT 方面取得了显著的性能改进。这是由 AGP 现在直接生成 R 类字节码，而不是 .java 文件引起的。 新的打包工具Android 构建团队不断进行更改以提高生成性能，在此版本中，我们将默认打包工具更改为 zipflinger 以进行调试生成。用户应该看到生成速度的提高，但您也可以通过设置 android.useNewApkCreator_false 在您的分级中恢复使用旧的打包工具。 测试Android 模拟器 - Google 地图Android 模拟器 29.2.12 为应用开发人员提供了一种与模拟设备位置进行接口的新方式。我们在扩展控件菜单中嵌入了 Google 地图用户界面，以便更轻松地指定位置，并构建来自位置对的路由。可以保存单个点并将其重新发送到设备作为虚拟位置，而路由可以通过键入地址或单击两个点来生成。当路线上的位置发送到来宾 OS 时，可以实时重播这些路由。 多屏支持模拟器 29.1.10 包括对多个虚拟显示器的初步支持。由于有更多的设备具有多个显示器，因此在各种多显示器配置上测试应用非常重要。用户可以通过设置菜单（扩展控件和设置）配置多个显示器。 SDK 断点续传当使用 Android Studio SDK 管理器下载 Android SDK 组件和工具时，Android Studio 现在允许您恢复中断的下载（例如，由于网络问题），而不是从一开始就重新启动下载。当互联网连接不可靠时，此增强功能对于大型下载（如 Android 模拟器或系统映像）特别有用。 导入的 APK 可以自动更新Android Studio 允许您导入外部构建的 APK 来调试和分析它们。以前，当对这些 APK 进行更改时，您必须再次手动导入它们并重新附加符号和源。Android Studio 3.6 现在会自动检测对导入的 APK 文件所做的更改，并为您提供就地重新导入该文件的选项。 优化内存探查器中的泄漏检测根据反馈，我们在内存探查器中添加了检测可能泄漏的活动和片段实例的能力。要开始使用，请在内存探查器中捕获或导入堆转储文件，并选中”活动/碎片泄漏”复选框以生成结果。有关 Android Studio 如何检测泄漏的详细信息，请参阅我们的文档。 在 APK 分析器中去解类和方法字节码使用 APK 分析器检查 DEX 文件时，现在可以取消分类和方法字节码。在 DEX 文件查看器中，加载要分析的 APK 的 ProGuard 映射文件。加载后，您将能够通过选择”显示字节码”右键单击要检查的类或方法。 概括地说，Android Studio 3.6 包括这些新的增强功能和功能设计 设计编辑器中的拆分视图 颜色选取器资源选项卡已 开发 视图绑定 NDK 修改 Intelli J平台更改 Add classes with Apply Changes 构建 Android Gradle Plugin (AGP) 升级 新的打包工具 测试 Android模拟器Google Maps UI 多显示器支持 可恢复的SDK下载 导入的APK的就地更新 优化内存探查器中的泄漏检测 在APK分析器中反混淆类和方法字节码 将Kotlin来源附加到导入的APK 下载从下载页面下载 Android Studio 3.6。如果您使用的是早期版本的 Android Studio，则只需将其更新为最新版本的 Android Studio。要使用上述 Android Emulator 功能，请确保您至少运行通过 Android Studio SDK 管理器下载的 Android Emulator v29.2.12。 Google 下载地址]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter不能热加载，热重载按钮为灰色]]></title>
    <url>%2Fposts%2F628bd6da.html</url>
    <content type="text"><![CDATA[前言，Flutter的热重载(hot reload)功能可以帮助您在无需重新启动应用的情况下快速、轻松地进行测试、构建用户界面、添加功能以及修复错误。 通过将更新后的源代码文件注入正在运行的Dart虚拟机（VM）中来实现热重载。 在虚拟机使用新的的字段和函数更新类后，Flutter框架会自动重新构建widget树，以便您快速查看更改的效果。 要热重载一个Flutter应用程序: 从受支持的IntelliJ IDE 、Android Studio 或终端窗口运行应用程序。物理机或虚拟器都可以运行。 修改项目中的一个Dart文件。大多数类型的代码更改可以重新加载; 有关需要完全重新启动的更改列表，请参阅限制。 如果您使用的是IntelliJ IDE 、Android Studio ，请选择Save All (cmd-s/ctrl-s)），或者单击工具栏上的Hot Reload按钮。 一、现象：Flutter 不能热加载 热重载按钮灰色，无法点击。 二、分析原因：终端flutter doctor 显示 NO_PROXY is not set 没有设置无代理的端口 ➜ ~ flutter doctor Doctor summary (to see all details, run flutter doctor -v): [✓] Flutter(Channel stable, v1.7.8, on Mac OS X 10.14.3 18D109, locale zh-Hans-CN) [✓] Android toolchain - develop for Android devices (Android SDK version 29.0.1) [✓] Xcode - develop for iOS and macOS (Xcode 10.2.1) [✓] iOS tools - develop for iOS devices [✓] Android Studio (version 3.5) [✓] VS Code (version 1.41.1) [!] Proxy Configuration ! NO_PROXY is not set [✓] Connected device (1 available) ! Doctor found issues in 1 category. 重点在于：NO_PROXY is not set 三、解决方案：设置 NO_PROXY即可 1.启动终端 2.进入当前用户的home目录 cd ~ 或者 cd /users/YourMacUserName 3.输入touch .bash_profile 查看和编辑.bash_profile文件 1.终端输入open -e .bash_profile 2.编辑文件，新增 1export no_proxy="localhost,127.0.0.1" 3.关闭保存 最后更新配置的环境变量 输入: 1source .bash_profile 不懂这块的话，看这里设置Mac 终端走代理 操作如下： ➜ ~ cd ~ ➜ ~ touch .bash_profile ➜ ~ open -e .bash_profile ➜ ~ source .bash_profile ➜ ~ flutter doctor Doctor summary (to see all details, run flutter doctor -v): [✓] Flutter (Channel stable, v1.7.8, on Mac OS X 10.14.3 18D109, locale zh-Hans-CN) [✓] Android toolchain - develop for Android devices (Android SDK version 29.0.1) [✓] Xcode - develop for iOS and macOS (Xcode 10.2.1) [✓] iOS tools - develop for iOS devices [✓] Android Studio (version 3.5) [✓] VS Code (version 1.41.1) [✓] Proxy Configuration [✓] Connected device (1 available) • No issues found! ➜ ~ 四、验证运行时，热重载按钮变为橙色，可以点击。 快捷键保存编辑时，自动重载。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SourceTree_push_remote:Invalid_username_or_password.]]></title>
    <url>%2Fposts%2F44ceee89.html</url>
    <content type="text"><![CDATA[在网络里面移除就行了· 再推就会要你重新输入了。有点不人性化， mark 一下。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一文读懂 Android Debug 调试]]></title>
    <url>%2Fposts%2Fa9889f48.html</url>
    <content type="text"><![CDATA[一、打上断点，启动debug模式首先在我们需要打断点的代码行数上稍微偏右，点击鼠标左键，如图： 点击小爬虫按钮，启动debug模式。 运行成功后如下。可以看到红色框内，从下往上的顺序运行方法，一直阻塞在我们打断点的方法里；绿色款内，则是展示目前阻塞方法内变量和参数的数值。 二、接下来，我们一起分解debug的每个按钮操作2.1、Step Over（F8） 这个按钮的意思：程序向下一步执行，但是要注意，这个按钮不会主动进入方法体内，而是会直接运行完整个方法后直接运行下一步。例如：我当前运行的debug，如果一直点击这个按钮的话，他会在onCreate()方法内，执行完add(),再执行完sub(),然后直接结束，并不会进add和sub方法内去打印。 2.2、Step Into（F7） 这个按钮的意思：程序向下一步执行，和Step Over的区别是如果该行有方法调用且为自定义方法，则运行进入自定义方法（不会进入官方类库的方法）。 例如：我当前运行的debug，如果你想进入到add()方法里，那么点击Step Into。假如我的add()方法里，还调用了其他的自定义方法，如果此时你都想进入各个方法查看则继续用Step Into，假如你只想停留在add()方法里，其他方法只需要得到个返回值的话，这个时候应该用Step Over; 2.3、Force Step Into 从字面意思上你也能看得出来：可以进入包括官方类库在内的任何方法。一般我认为这个比较适合研究源码。 2.4、Step out 假如此时调试在add()方法里，如果我们觉得add()方法没有问题，想跳出这个方法继续debug其他断点时，那么点击Step out，跳出该方法。 2.5、Run to Cursor 从字面意思上看，他是移动到下个断点的意思。经过测试如下: 1、假如在我们当前运行的debug，如果还在onCreate()方法内，当前断点在add()方法时，点击Run to Cursor，断点确实会移动到下个断点停留在sub()方法。 2、如果此时我们已经进入到add()方法体内，点击Run to Cursor,我们会看到，他只是运行完一次for循环后，继续堵塞。如下图： 所以我总结为，Run to Cursor是在当前方法体内，运行到下一个断点。（如果有误，请大佬及时纠正）； 那么此时，如果我们已经在add()方法内，就是想直接运行到下个断点sub()上，怎么操作呢？点击Resume Program 这个按钮不会管你在不在方法内，直接回到下一步断点上。 三、Debug进阶用法。3.1、Watches如果我们在debug的时候，可能会出现很多变量，而我们就想观察那么几个变量。我们可以把他加到watches里。比如我add()方法里的变量i， 方法1：在我们观察的Variables里，找到那个变量右键，选择Add to Watches 方法2：在我们的Watches界面，点击+号，在输入框内，输入i，进行搜索，也能添加到Watches，方便我们debug调试 3.2、Set Value比如在我们的add()方法里，有一个for循环，正常调试是每次都会从i=0的时候进行调试，如果我们想直接从i=5的时候进行调试，那么我们可以在Variables界面，找到那个变量值，右键选择Set Value后，输入我们5，就能跳过前几次循环。 3.3、查看所有断点开发中你打了很多断点忘记取消的情况下，你可以点击View Breakpoints查看所有断点 打开如下界面： 3.4、停止debug调试 3.5、已经运行的程序，避免重新运行程序的情况下，怎么添加debug调试。这里多说几句，因为是在已经运行的程序上，添加debug调试，那么比如进入一个页面，onCreate()方法里的代码，都已经全部执行完了，比如我们点击一个按钮，需要运行的方法，在这个方法里我们才能添加debug调试。比如首先是一个正常运行的程序，我们给点击事件里加断点。 然后，点击Attach Debugger to Android Process 弹出如下页面，点击OK就行了，点击按钮就能进行debug调试了]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android跳转到应用商店详情页面]]></title>
    <url>%2Fposts%2F916b091e.html</url>
    <content type="text"><![CDATA[Android应用开发过程中，可能会有需求，比如：推广时跳转到应用市场下载应用，跳转到应用市场给自己的应用打分，跳转到应用市场更新自己的应用。那如何跳转到应用市场呢？ 可能跳转的方法大家都是知道的，方法如下： 123456789public static void goToMarket(Context context, String packageName) &#123; Uri uri = Uri.parse("market://details?id=" + packageName); Intent goToMarket = new Intent(Intent.ACTION_VIEW, uri); try &#123; context.startActivity(goToMarket); &#125; catch (ActivityNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 此方法支持应用宝、360手机助手、豌豆荚、小米商店等主流的应用市场，当手机上面装有多个应用市场时，则会弹出菜单让用户选择调转到哪个市场。那么，问题来了，如果这么简单就结束了，怎么还会有这篇文章呢？ 在红米Note2上测试时发现，调用此方法默认是直接调转到小米市场，那如果在小米手机上，想要跳转到应用宝或者其他的应用市场怎么办呢，方法自然是有的，如下： 12345678910public static void goToMarket(Context context, String packageName) &#123; Uri uri = Uri.parse("market://details?id=" + packageName); Intent goToMarket = new Intent(Intent.ACTION_VIEW, uri); try &#123; goToMarket.setClassName("com.tencent.android.qqdownloader", "com.tencent.pangu.link.LinkProxyActivity"); context.startActivity(goToMarket); &#125; catch (ActivityNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 看起来好像和第一个方法没什么区别，是的，只需要给多调用goToMarket.setClassName()方法，设置指定的应用去处理这个Intent事件，这样就可以在小米手机上跳转到应用宝的应用详情页面，而且，上一个方法如果在手机上装有多个应用市场时，会弹出菜单让用户选择，如果已经确定好要跳转到哪个应用市场时，也可使用此方法，直接跳转，省去中间用户选择的环节。 但是上面方法的思路似乎并不能对所有的应用市场有效，哪天产品经理提出要跳转到三星的应用市场，毕竟三星手机在国内的占有率还是排前几位的，再使用上面的方法，发现懵逼了，三星市场竟然不支持这种方式，难怪三星手机在国内市场节节败退。不过再笔者的努力下终于找到了如下方法： 1234567891011public static void goToSamsungappsMarket(Context context, String packageName) &#123; Uri uri = Uri.parse("http://www.samsungapps.com/appquery/appDetail.as?appId=" + packageName); Intent goToMarket = new Intent(); goToMarket.setClassName("com.sec.android.app.samsungapps", "com.sec.android.app.samsungapps.Main"); goToMarket.setData(uri); try &#123; context.startActivity(goToMarket); &#125; catch (ActivityNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 不过，后来发现在乐视手机上面，乐视的应用市场也是不支持goToMarket()方法的，所以又专门调研了跳转乐视应用市场的方法，方法如下： 1234567void goToLeTVStoreDetail(Context context, String packageName) &#123; Intent intent = new Intent(); intent.setClassName("com.letv.app.appstore", "com.letv.app.appstore.appmodule.details.DetailsActivity"); intent.setAction("com.letv.app.appstore.appdetailactivity"); intent.putExtra("packageName", packageName); context.startActivity(intent); &#125; 以上方法，希望能帮助到有需要的人。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 跳转到谷歌应用市场 * * @param context * @param packageName */public static void goToGoogleMarket(Context context, String packageName) &#123; try &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse("market://details?id=" + packageName)); intent.setPackage("com.android.vending");//这里对应的是谷歌商店，跳转别的商店改成对应的即可 if (intent.resolveActivity(context.getPackageManager()) != null) &#123; context.startActivity(intent); &#125; else &#123;//没有应用市场，通过浏览器跳转到Google Play Intent intent2 = new Intent(Intent.ACTION_VIEW); intent2.setData(Uri.parse("https://play.google.com/store/apps/details?id=" + packageName)); if (intent2.resolveActivity(context.getPackageManager()) != null) &#123; context.startActivity(intent2); &#125; else &#123; //没有Google Play 也没有浏览器 &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * 跳转到三星应用市场 * * @param context * @param packageName */public static void goToSamsungappsMarket(Context context, String packageName) &#123; try &#123; Uri uri = Uri.parse("http://www.samsungapps.com/appquery/appDetail.as?appId=" + packageName); Intent goToMarket = new Intent(); goToMarket.setClassName("com.sec.android.app.samsungapps", "com.sec.android.app.samsungapps.Main"); goToMarket.setData(uri); context.startActivity(goToMarket); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextView字体大小自适应]]></title>
    <url>%2Fposts%2F14fca390.html</url>
    <content type="text"><![CDATA[描述在进行android 开发过程中，会遇到TextView 中文本显示不全的情况，这个时候想根据文本的长度自动改变字体大小，首先想到的时候自定义View ，但是呢在Android O 中已经提供了实现方式，并且拥有兼容库，最低支持到API 14,这瞬间就爽到我了，不多BB 了，直接看实现。 重点注意：如果代码中设置了以下的代码，不生效。 1android:singleLine="true" 必须设置的属性是： 1android:maxLines="1" 效果图没有效果图，如果你用过今日头条添加频道的话，这里就不会骂我了。 通过代码方式在代码中调用函数 setAutoSizeTextTypeWithDefaults(@AutoSizeTextType int autoSizeTextType) 并指定参数为 AUTO_SIZE_TEXT_TYPE_UNIFORM来设置默认值。如果你不想启用自动调整字体大小的功能，则可以设置参数为 AUTO_SIZE_TEXT_TYPE_NONE. 1textView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM); 或者设置粒度（设置最大只和最小值，并且指定每次调整的增量值）： 12//autoSizeMinTextSize 最小值；autoSizeMaxTextSize：最大值；autoSizeStepGranularity：增量；unit：类型，此处指定的是sptextView.setAutoSizeTextTypeUniformWithConfiguration(10,17,1,TypedValue.COMPLEX_UNIT_SP); 通过xml 方式(推荐的方式)1234567891011&lt;TextView android:id="@+id/title" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:layout_gravity="center" app:autoSizeTextType="uniform" app:autoSizeMinTextSize="3sp" app:autoSizeMaxTextSize="15sp" app:autoSizeStepGranularity="1sp" android:maxLines="1"/&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中常用的加密方式]]></title>
    <url>%2Fposts%2Fcaa299cc.html</url>
    <content type="text"><![CDATA[一、Rsa加密1、RSA是第一种既可以用于数据加密，也可以用于数字签名的算法；2、算法原理：1）、随机产生两个大的质数m、n且m！=n，计算K1=mn； 2)、选择一个大于1小于k1的自然数k2，k2必须与(m-1)(n-1)互为素数； 3)、计算得到d—&gt;d x k2=1(mod(m-1)(n-1)); 4)、销毁mn； 最终产生的k1和k2为“公钥”，d为“私钥”，发送方使用k1进行加密，接收方使用d进行解密。 3、注意：1、RSA的安全性依赖于大数分解，小于1024位的k1被认为是不安全的； 2、RSA的计算速度慢。 4、使用1、生成密钥对 1234567891011121314151617/** * 随机生成RSA密钥对 * * @param keyLength 密钥长度，范围：512～2048 * 一般1024 * @return */public static KeyPair generateRSAKeyPair(int keyLength) &#123; try &#123; KeyPairGenerator kpg = KeyPairGenerator.getInstance(RSA); kpg.initialize(keyLength); return kpg.genKeyPair(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return null; &#125;&#125; 2、公钥加密 123456789101112131415/** * 用公钥对字符串进行加密 * * @param data 原文 */ public static byte[] encryptByPublicKey(byte[] data, byte[] publicKey) throws Exception &#123; // 得到公钥 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKey); KeyFactory kf = KeyFactory.getInstance(RSA); PublicKey keyPublic = kf.generatePublic(keySpec); // 加密数据 Cipher cp = Cipher.getInstance(ECB_PKCS1_PADDING); cp.init(Cipher.ENCRYPT_MODE, keyPublic); return cp.doFinal(data); &#125; 3、私钥加密 1234567891011121314151617/** * 私钥加密 * * @param data 待加密数据 * @param privateKey 密钥 * @return byte[] 加密数据 */ public static byte[] encryptByPrivateKey(byte[] data, byte[] privateKey) throws Exception &#123; // 得到私钥 PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey); KeyFactory kf = KeyFactory.getInstance(RSA); PrivateKey keyPrivate = kf.generatePrivate(keySpec); // 数据加密 Cipher cipher = Cipher.getInstance(ECB_PKCS1_PADDING); cipher.init(Cipher.ENCRYPT_MODE, keyPrivate); return cipher.doFinal(data); &#125; 有加密自然也得有解密 1、公钥解密 1234567891011121314151617/** * 公钥解密 * * @param data 待解密数据 * @param publicKey 密钥 * @return byte[] 解密数据 */ public static byte[] decryptByPublicKey(byte[] data, byte[] publicKey) throws Exception &#123; // 得到公钥 X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKey); KeyFactory kf = KeyFactory.getInstance(RSA); PublicKey keyPublic = kf.generatePublic(keySpec); // 数据解密 Cipher cipher = Cipher.getInstance(ECB_PKCS1_PADDING); cipher.init(Cipher.DECRYPT_MODE, keyPublic); return cipher.doFinal(data); &#125; 2、私钥解密 123456789101112131415/** * 使用私钥进行解密 */ public static byte[] decryptByPrivateKey(byte[] encrypted, byte[] privateKey) throws Exception &#123; // 得到私钥 PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey); KeyFactory kf = KeyFactory.getInstance(RSA); PrivateKey keyPrivate = kf.generatePrivate(keySpec); // 解密数据 Cipher cp = Cipher.getInstance(ECB_PKCS1_PADDING); cp.init(Cipher.DECRYPT_MODE, keyPrivate); byte[] arr = cp.doFinal(encrypted); return arr; &#125; 用到的全局变量 12345678910// 非对称加密密钥算法 public static final String RSA = "RSA"; //加密填充方式 public static final String ECB_PKCS1_PADDING = "RSA/ECB/PKCS1Padding"; //秘钥默认长度 public static final int DEFAULT_KEY_SIZE = 2048; // 当要加密的内容超过bufferSize，则采用partSplit进行分块加密 public static final byte[] DEFAULT_SPLIT = "#PART#".getBytes(); // 当前秘钥支持加密的最大字节数 public static final int DEFAULT_BUFFERSIZE = (DEFAULT_KEY_SIZE / 8) - 11; 关于加密填充方式：之前以为上面这些操作就能实现rsa加解密，以为万事大吉了，呵呵，这事还没完，悲剧还是发生了，Android这边加密过的数据，服务器端死活解密不了，原来android系统的RSA实现是&quot;RSA/None/NoPadding&quot;，而标准JDK实现是&quot;RSA/None/PKCS1Padding&quot;，这造成了在android机上加密后无法在服务器上解密的原因，所以在实现的时候这个一定要注意。 二、DES加密1、简单介绍DES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法。DES加密算法出自IBM的研究，后来被美国政府正式采用，之后开始广泛流传，但是近些年使用越来越少，因为DES使用56位密钥，以现代计算能力，24小时内即可被破解。 划重点 ：DES不太安全。2、静态秘钥DES加密方式使用1）、DES加密代码 123456789101112131415161718/** *DES 加密 * * @param message 原文 * @param key 密钥,长度不能够小于8位 * @return * @throws Exception */ public static String desEncrypt(String message, String key) throws Exception &#123; Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding"); DESKeySpec desKeySpec = new DESKeySpec(key.getBytes("UTF-8")); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); SecretKey secretKey = keyFactory.generateSecret(desKeySpec); IvParameterSpec iv = new IvParameterSpec(key.getBytes("UTF-8")); cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv); byte[] encryptbyte = cipher.doFinal(message.getBytes()); return new String(Base64.encode(encryptbyte, Base64.DEFAULT)).trim(); &#125; 2、DES解密代码 1234567891011121314151617181920/** * DES解密 * * @param message 密文 * @param key 密钥,长度不能够小于8位 * @return * @throws Exception */ public static String desDecrypt(String message, String key) throws Exception &#123; byte[] bytesrc = Base64.decode(message.getBytes(), Base64.DEFAULT); Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding"); DESKeySpec desKeySpec = new DESKeySpec(key.getBytes("UTF-8")); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES"); SecretKey secretKey = keyFactory.generateSecret(desKeySpec); IvParameterSpec iv = new IvParameterSpec(key.getBytes("UTF-8")); cipher.init(Cipher.DECRYPT_MODE, secretKey, iv); byte[] retByte = cipher.doFinal(bytesrc); return new String(retByte); &#125; 3、动态秘钥加密方式1、DES加密常用的常量 123456789 private final static String HEX = "0123456789ABCDEF"; //DES是加密方式 CBC是工作模式 PKCS5Padding是填充模式 private final static String TRANSFORMATION = "DES/CBC/PKCS5Padding"; //初始化向量参数，AES 为16bytes. DES 为8bytes. private final static String IVPARAMETERSPEC = "01020304"; //DES是加密方式 private final static String ALGORITHM = "DES";// SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法 private static final String SHA1PRNG = "SHA1PRNG"; 2、动态生成秘钥 123456789101112131415161718192021222324252627282930 /** 生成随机数，可以当做动态的密钥 加密和解密的密钥必须一致，不然将不能解密*/ public static String generateKey() &#123; try &#123; SecureRandom localSecureRandom = SecureRandom.getInstance(SHA1PRNG); byte[] bytes_key = new byte[20]; localSecureRandom.nextBytes(bytes_key); String str_key = toHex(bytes_key); return str_key; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; //二进制转字符 public static String toHex(byte[] buf) &#123; if (buf == null) return ""; StringBuffer result = new StringBuffer(2 * buf.length); for (int i = 0; i &lt; buf.length; i++) &#123; appendHex(result, buf[i]); &#125; return result.toString(); &#125; private static void appendHex(StringBuffer sb, byte b) &#123; sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f)); &#125; 3、处理秘钥 方式一、 12345678910111213141516171819// 对密钥进行处理 private static Key getRawKey(String key) throws Exception &#123; KeyGenerator kgen = KeyGenerator.getInstance(ALGORITHM); //for android SecureRandom sr = null; // 在4.2以上版本中，SecureRandom获取方式发生了改变 if (android.os.Build.VERSION.SDK_INT &gt;= 17) &#123; sr = SecureRandom.getInstance(SHA1PRNG, "Crypto"); &#125; else &#123; sr = SecureRandom.getInstance(SHA1PRNG); &#125; // for Java // secureRandom = SecureRandom.getInstance(SHA1PRNG); sr.setSeed(key.getBytes()); kgen.init(64, sr); //DES固定格式为64bits，即8bytes。 SecretKey skey = kgen.generateKey(); byte[] raw = skey.getEncoded(); return new SecretKeySpec(raw, ALGORITHM); &#125; 方式二 123456/ 对密钥进行处理 private static Key getRawKey(String key) throws Exception &#123; DESKeySpec dks = new DESKeySpec(key.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM); return keyFactory.generateSecret(dks); &#125; 4、加密实现 123456789101112131415161718192021222324252627282930/** * DES算法，加密 * * @param data 待加密字符串 * @param key 加密私钥，长度不能够小于8位 * @return 加密后的字节数组，一般结合Base64编码使用 */ public static String encode(String key, String data) &#123; return encode(key, data.getBytes()); &#125; /** * DES算法，加密 * * @param data 待加密字符串 * @param key 加密私钥，长度不能够小于8位 * @return 加密后的字节数组，一般结合Base64编码使用 */ public static String encode(String key, byte[] data) &#123; try &#123; Cipher cipher = Cipher.getInstance(TRANSFORMATION); IvParameterSpec iv = new IvParameterSpec(IVPARAMETERSPEC.getBytes()); cipher.init(Cipher.ENCRYPT_MODE, getRawKey(key), iv); byte[] bytes = cipher.doFinal(data); return Base64.encodeToString(bytes, Base64.DEFAULT); &#125; catch (Exception e) &#123; return null; &#125; &#125; 5、解密实现 123456789101112131415161718192021222324252627282930/** * 获取编码后的值 * * @param key * @param data * @return */ public static String decode(String key, String data) &#123; return decode(key, Base64.decode(data, Base64.DEFAULT)); &#125; /** * DES算法，解密 * * @param data 待解密字符串 * @param key 解密私钥，长度不能够小于8位 * @return 解密后的字节数组 */ public static String decode(String key, byte[] data) &#123; try &#123; Cipher cipher = Cipher.getInstance(TRANSFORMATION); IvParameterSpec iv = new IvParameterSpec(IVPARAMETERSPEC.getBytes()); cipher.init(Cipher.DECRYPT_MODE, getRawKey(key), iv); byte[] original = cipher.doFinal(data); String originalString = new String(original); return originalString; &#125; catch (Exception e) &#123; return null; &#125; &#125; 三、AES加密1、简单介绍高级加密标准 2、加密使用方法1、AES用到的常量 1234567private final static String HEX = "0123456789ABCDEF"; //AES是加密方式 CBC是工作模式 PKCS5Padding是填充模式 private static final String CBC_PKCS5_PADDING = "AES/CBC/PKCS5Padding"; //AES 加密 private static final String AES = "AES"; // SHA1PRNG 强随机种子算法, 要区别4.2以上版本的调用方法 private static final String SHA1PRNG="SHA1PRNG"; 2、动态生成秘钥 123456789101112public static String generateKey() &#123; try &#123; SecureRandom localSecureRandom = SecureRandom.getInstance(SHA1PRNG); byte[] bytes_key = new byte[20]; localSecureRandom.nextBytes(bytes_key); String str_key = toHex(bytes_key); return str_key; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; 3、对秘钥进行处理 123456789101112131415161718192021222324252627private static byte[] getRawKey(byte[] seed) throws Exception &#123; KeyGenerator kgen = KeyGenerator.getInstance(AES); //for android SecureRandom sr = null; // 在4.2以上版本中，SecureRandom获取方式发生了改变 int sdk_version = android.os.Build.VERSION.SDK_INT; // Android 6.0 以上 if(sdk_version&gt;23)&#123; sr = SecureRandom.getInstance(SHA1PRNG,new CryptoProvider()); //4.2及以上 &#125;else if(android.os.Build.VERSION.SDK_INT &gt;= 17)&#123; sr = SecureRandom.getInstance(SHA1PRNG, "Crypto"); &#125;else &#123; sr = SecureRandom.getInstance(SHA1PRNG); &#125; // for Java // secureRandom = SecureRandom.getInstance(SHA1PRNG); sr.setSeed(seed); //256 bits or 128 bits,192bits kgen.init(128, sr); //AES中128位密钥版本有10个加密循环，192比特密钥版本有12个加密循环，256比特密钥版本则有14个加密循环。 SecretKey skey = kgen.generateKey(); byte[] raw = skey.getEncoded(); return raw; &#125; 4、加密 123456789101112public static String encrypt(String key, String cleartext) &#123; if (TextUtils.isEmpty(cleartext)) &#123; return cleartext; &#125; try &#123; byte[] result = encrypt(key, cleartext.getBytes()); return new String(Base64.encode(result,Base64.DEFAULT)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; 或者 12345678private static byte[] encrypt(String key, byte[] clear) throws Exception &#123; byte[] raw = getRawKey(key.getBytes()); SecretKeySpec skeySpec = new SecretKeySpec(raw, AES); Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING); cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] encrypted = cipher.doFinal(clear); return encrypted; &#125; 5、解密 12345678910111213public static String decrypt(String key, String encrypted) &#123; if (TextUtils.isEmpty(encrypted)) &#123; return encrypted; &#125; try &#123; byte[] enc = Base64.decode(encrypted,Base64.DEFAULT); byte[] result = decrypt(key, enc); return new String(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; 或者 12345678private static byte[] decrypt(String key, byte[] encrypted) throws Exception &#123; byte[] raw = getRawKey(key.getBytes()); SecretKeySpec skeySpec = new SecretKeySpec(raw, AES); Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING); cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(new byte[cipher.getBlockSize()])); byte[] decrypted = cipher.doFinal(encrypted); return decrypted; &#125; 6、辅助方法 1234567891011121314151617181920212223242526272829 //二进制转字符 public static String toHex(byte[] buf) &#123; if (buf == null) return ""; StringBuffer result = new StringBuffer(2 * buf.length); for (int i = 0; i &lt; buf.length; i++) &#123; appendHex(result, buf[i]); &#125; return result.toString(); &#125; private static void appendHex(StringBuffer sb, byte b) &#123; sb.append(HEX.charAt((b &gt;&gt; 4) &amp; 0x0f)).append(HEX.charAt(b &amp; 0x0f)); &#125;// 增加 CryptoProvider 类 public static class CryptoProvider extends Provider &#123; /** * Creates a Provider and puts parameters */ public CryptoProvider() &#123; super("Crypto", 1.0, "HARMONY (SHA1 digest; SecureRandom; SHA1withDSA signature)"); put("SecureRandom.SHA1PRNG", "org.apache.harmony.security.provider.crypto.SHA1PRNG_SecureRandomImpl"); put("SecureRandom.SHA1PRNG ImplementedIn", "Software"); &#125; &#125; 本文参考： 《安卓AES加解密(兼容Android7.0)》 《Android数据加密之Rsa加密》]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热修复原理]]></title>
    <url>%2Fposts%2F181c4c4a.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插件化原理]]></title>
    <url>%2Fposts%2F60f13ddc.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序猿]]></title>
    <url>%2Fposts%2F8266392b.html</url>
    <content type="text"><![CDATA[​ “先生不知何许人也，亦不详其姓字。时年二十有二，英俊朗逸，秀发蓬勃。始入IT大厂，朝九晚五，日食三餐。好读书，曰《X语言入门》、《X语言应用实践》、《X语言高阶编程》。 ​ 次年，二十有三，英俊尚可，然寡言少语，身影飄忽，秀发日疏。一人一烟一Computer，长坐不起，日复一日。所观者，《编程语言的科学与艺术》、《编程之美》、《编程之道》、《编程之禅》。 ​ 而今年约三十，不复俊逸。其目，炯炯然有所虑，其背，日益佝偻，其发，隐约可见地中海。常持杯，与沸水枸杞为伴，嗜书，然所读者与众不同，唤作《颈椎病康复指南》。 ​ 观其状，时人不解。或曰，必为程序猿也！”]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点总结]]></title>
    <url>%2Fposts%2F28ca84cb.html</url>
    <content type="text"><![CDATA[Android进阶部分 Android 基础部分 Flutter部分 Java 部分 设计模式 数据结构/算法部分 给出一张完整的总结图 思维导图高清版地址：processon]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android采用ChromeIntent方式实现从浏览器启动应用]]></title>
    <url>%2Fposts%2F8e25ebb8.html</url>
    <content type="text"><![CDATA[在很多应用中需要我们从浏览器中直接启动应用，而网上大多数采用的是scheme的方式，即在启动activity的mainfest文件中配置如下字段： 12345678&lt;activity android:name="com.example.MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;data android:scheme="example" android:host="test" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 然后在网页的连接设置为example://test/… 来启动应用，但是如果手机中没有应用，该url会跳转到一个错误的界面。 google官方在chrome中推出了一种Android Intents的方式来实现应用启动，通过在iframe中设置src为的方式，具体示例如下。 12345678intent:HOST/URI-path // Optional host#Intent;package=[string];action=[string];category=[string];component=[string]; scheme=[string];end; 我们定义一个a标签为 1&lt;pre name="code" class="html"&gt;&lt;pre name="code" class="html"&gt;&lt;a href="intent://zhangmiao/#Intent;scheme=myapp;package=com.what.ever.myapp;end"&gt;Do Whatever&lt;/a&gt; 然后在mainfest文件中定义要启动的activity 1234567891011&lt;activity android:name=".TestUrlScheme" &gt; &lt;intent-filter&gt; &lt;!-- 显示数据 --&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;!-- 定义成浏览器类型，有URL需要处理时会过滤 --&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;!-- 打开以whatever协议的URL,这个自己随便定义。 --&gt; &lt;data android:scheme="myapp" android:host="zhangmiao" android:path="/" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 然后在浏览器中点击a标签，就可以启动应用程序的对应activity了，如果手机中没有相应的应用，那么是否会跳转到错误页面呢，将a标签设置为 1&lt;a href="intent://whatever/#Intent;scheme=myapp;package=com.what.ever.myapp;S.browser_fallback_url=http%3A%2F%2Fzxing.org;end"&gt;Do Whatever&lt;/a&gt; 这样如果没有对应应用，该链接就会跳转到S.browser_fallback_url指定的url上。 其中参数的类型如下 123456789String =&gt; 'S'Boolean =&gt;'B'Byte =&gt; 'b'Character =&gt; 'c'Double =&gt; 'd'Float =&gt; 'f'Integer =&gt; 'i'Long =&gt; 'l'Short =&gt; 's' 1intent://RequestType/?name=zhangmiao&amp;age=18#Intent;scheme=appname;package=com.example.appname;S.browser_fallback_url=http%3A%2F%2Fzxing.org;end 然后在启动activity的onCreate函数中利用bundle接收参数就行了 12345678910111213Bundle parametros = getIntent().getExtras();if (extras != null)&#123; String name = extras.getString("name"); Integer age = extras.getInt("age"); if (name!=null &amp;&amp; age!=null) &#123; //do whatever you have to //... &#125;&#125;else&#123; //no extras, get over it!!&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android渐变色xml文件]]></title>
    <url>%2Fposts%2F2851801a.html</url>
    <content type="text"><![CDATA[在drawable目录下新建drawable resource file，修改xml代码 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;!-- android:startColor="#aa000000" 渐变起始色值 android:centerColor="" 渐变中间色值 android:endColor="#ffffffff" 渐变结束颜色 android:angle="45" 渐变的方向 默认为0 从做向右 ，90时从下向上 必须为45的整数倍 android:type="radial" 渐变类型 有三种 线性linear 放射渐变radial 扫描线性渐变sweep android:centerX="0.5" 渐变中心相对X坐标只有渐变类型为放射渐变时有效 android:centerY="0.5" 渐变中心相对Y坐标只有渐变类型为放射渐变时有效 android:gradientRadius="100" 渐变半径 非线性放射有效 --&gt; &lt;gradient android:startColor="#b7bbd9" android:endColor="#5CACEE" android:angle="90" /&gt;&lt;/shape&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常代码写作规范及优化建议]]></title>
    <url>%2Fposts%2Fa54cde26.html</url>
    <content type="text"><![CDATA[批量数据处理每次读取数据时，批量读取，然后在应用中进行分组、分发，例如： 订单列表页涉及到用户、订单、商品等表，批量把当前页的订单、用户、商品一次性读取回来，然后在应用中进行数据的组装，以减少sql请求量，降低数据库压力，加快操作响应速度。 线程池的使用建议尽量避免使用 1@Async 注解，因为这个是共享了Spring提供的线程池，大量使用的时候，容易造成线程池溢出，建议使用自定义的线程池，并且估算好以下参数： 核心线程数、最大线程数 存活时长 任务队列及长度 自定义ThreadFactory，指定线程名称 根据业务指定拒绝策略 HashMap不要在多线程环境下使用应用默认都是多线程环境的，所以在定义HashMap对象的时候一定要清楚的知道当前有没有多线程的问题 控制数据量大小每次操作数据的时候，一定要清楚的知道当前操作的数据可能的量，并清楚的知道最大的量是多少、未来的增长数据和空间，以防止引起内存不足，我们的系统的内存大部分是4-8个G； 除非能确定数据量有限且不增长，否则都应该分批操作，保证每批数据的有限性，以防随着数据量大后造成系统风险。 对于需要较长时间的业务，比如导入数据、调用第三方接口之类，最好做成任务类型 数据和操作的安全性、可追溯性 App端：不允许通过前端传入用户ID来操作对应用户的数据；对用户的私有数据操作，一定要检查当前数据是否属于当前用户，包括但不限于：地址、订单、关注、购物车、评论、个人信息、账户余额等 Backend端：后台对用户的操作有权限校验，当前是基于URL做的，所以要确保当前操作的数据一定要在某个url之下，比如菜单url是/ic/item，那么点开这个菜单以后展现的界面里所有的操作对应的url，都要在/ic/item这个url之后（之下），比如/ic/item/to-add，/ic/item/do-add/_ajax 上传到OSS的内容，如果是公司私有的，一定不能使用公有读权限上传，以防造成信息泄露。 关键配置不要直接写在配置文件里，当前我们是写的启动脚本里（配置中心还没有做） 关键数据的操作和修改，一定要有对应的操作日志的记录，以确保可追溯 定时任务 如果是定时执行的，约定只在整点或半点的时候执行，以便大家在发布系统的时候能知道在哪些时间点避免发布； 如果要是对过去一段时间的数据进行定时处理，请确保处理的数据的时间范围大两个（或更长时间）或以上的定时执行时间差内，以便让当前处理的数据能覆盖到上一次定时执行的数据范围，以便上次未执行或执行失败时，能做重试处理 App端不做任务定时任务，以确保APP端系统的稳定 根据自身业务情况，可以考虑放到redis队列里去，然后由多台机子一起跑这个队列里的数据，这样的话即使服务器频繁重启也不会中断任务。 配置的内外网之分为了加速操作的执行速度，在能使用内网的时候，一定使用内网连接，例如：Redis/Mysql/OSS等，请大家在添加或修改线上或测试环境配置的时候，一定要了解当前是否可以使用内网。 外部服务调用如果有对外部服务的调用，一定要想好如果服务不可用、服务响应时间过长、或者服务响应结果有错，会不会对系统造成压力或影响；尤其是当该调用在事务方法中时，有可能造成事务时间过长，数据库连接被占满，系统不可用。 事务处理 要清楚的理解当前操作是否需要事务，能避免事务操作的就不要使用事务 如果是使用事务，那就需要清楚的知道什么时候可以返回结果，什么时候应该抛出异常，以使事务生效 事务中尽量避免长时操作 延迟或异步给出不必要的数据对于非必要的数据，可以延迟或异步给出，以加快操作的响应速度。例如之前后台的订单详情页，除了加速订单相关数据外，还会加载订单的物流信息，造成整个订单详情页响应时间超长，后来优化了一下，延迟加载物流信息，整个响应速度就极大的提升了；又比如前端很多页面都有优有推荐数据，为了显示页面，除了要读取必要的数据，还要等待推荐数据的返回才能显示页面，就造成了整个页面的响应过慢。 异步处理，加快响应速度 对于有多个长时操作，但是互相之间没有依赖的，可以让每个操作异步处理，然后在最后再等待所有的操作结果返回，汇总结果，再输出，以加快操作的响应速度。 除此之外，尽量使用消息系统 幂等性自己写的方法、接口，特别是比较重要的业务，一定要处理好幂等性，不管是消息的消费还是对外暴露的API等等。 缓存的使用 对于耗时的操作，能使用缓存的尽量使用缓存 对于变动不频繁但是使用频繁的，可以使用缓存 对于不会变的数据，可以使用本地缓存，但是要注意缓存数据量的大小，以免造成内存压力 数据库索引写sql查数据的时候，除了要考虑数据量外，要检查是否有对应的索引使用，防止查询过慢。 一般一个表的索引不要超过6个，索引应建立在离散度比较高且在查询条件中出现频度较高的字段上，索引尽量在建表的时候考虑好，后期数据量大了再加索引的话会比较困难。 其他 使用集合时，估算出可能需要的容量，并以此指定集合的容量，以避免频繁扩容 字符串拼接时，建议使用StringBuilder（Java8中会自动使用） 数据库中存储时间，建议用时间戳（10位，到秒），鉴于历史问题，如果旧表使用的是dateTime，那么后续旧表加时间字段时也用dateTime类型。 读取数据库时间以及和前端交互时，注意时区的问题 数据库中存储金额，都使用分，计算过程涉及取舍时不能精确到分，总和会出现差距 调用方法都检查返回结果；提供方法时尽量避免null结果返回，区分集合和普通对象，处理好返回值为 null 的情况 方法和变量命名是直观且和它所对应的业务意义一至 对于业务逻辑，要写好注释，描述清楚代码所对应的业务逻辑，且注释和代码逻辑要真的一致，对于 map 一定要注释好 key 和 value 分别对应什么 关键的业务要记录好日志，谁，什么时候，做了什么事情，数据变化情况 logger.error 注意多个参数，可能丢失堆栈 异常处理：只捕获自己可以处理的异常，不能处理的不要捕获 java7 开始，jdk排序算法已改变，需要满足：自反性，传递性，对称性 集合类判断是否为空，使用 CollectionUtil 不要使用 size() &gt; 0 定期review定期的去APM系统中或Kibana中检查操作的响应速度和耗时处]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效能人士的七个习惯]]></title>
    <url>%2Fposts%2Ff66419fe.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android混淆使用手册]]></title>
    <url>%2Fposts%2F635b293f.html</url>
    <content type="text"><![CDATA[首先，这里说的的混淆其实是包括了代码压缩、代码混淆以及资源压缩等的优化过程。依靠 ProGuard，混淆流程将主项目以及依赖库中未被使用的类、类成员、方法、属性移除，这有助于规避64K方法数的瓶颈；同时，将类、类成员、方法重命名为无意义的简短名称，增加了逆向工程的难度。而依靠 Gradle 的 Android 插件，我们将移除未被使用的资源，可以有效减小 apk 安装包大小。 本文由两部分构成： 第一部分给出混淆的最佳实践，力求让零基础的新手都可以直接使用混淆； 第二部分会介绍一下混淆的整体、自定义混淆规则的语法与实践、自定义资源保持的规则等。 一、Android混淆最佳实践1. 混淆配置一般情况下，app module 的 build.gradle 文件默认会有如下结构： 12345678android &#123; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 因为开启混淆会使编译时间变长，所以debug模式下不应该开启。我们需要做的是： 将release下minifyEnabled的值改为true，打开混淆； 加上shrinkResources true，打开资源压缩。 修改后文件内容如下： 123456789android &#123; buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125; 2. 自定义混淆规则在 app module 下默认生成了项目的自定义混淆规则文件 proguard-rules.pro，多方调研后，一份适用于大部分项目的混淆规则最佳实践如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#指定压缩级别-optimizationpasses 5#不跳过非公共的库的类成员-dontskipnonpubliclibraryclassmembers#混淆时采用的算法-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*#把混淆类中的方法名也混淆了-useuniqueclassmembernames#优化时允许访问并修改有修饰符的类和类的成员 -allowaccessmodification#将文件来源重命名为“SourceFile”字符串-renamesourcefileattribute SourceFile#保留行号-keepattributes SourceFile,LineNumberTable#保持泛型-keepattributes Signature#保持所有实现 Serializable 接口的类成员-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;#Fragment不需要在AndroidManifest.xml中注册，需要额外保护下-keep public class * extends android.support.v4.app.Fragment-keep public class * extends android.app.Fragment# 保持测试相关的代码-dontnote junit.framework.**-dontnote junit.runner.**-dontwarn android.test.**-dontwarn android.support.test.**-dontwarn org.junit.** 真正通用的、需要添加的就是上面这些，除此之外，需要每个项目根据自身的需求添加一些混淆规则： 第三方库所需的混淆规则。正规的第三方库一般都会在接入文档中写好所需混淆规则，使用时注意添加。 在运行时动态改变的代码，例如反射。比较典型的例子就是会与 json 相互转换的实体类。假如项目命名规范要求实体类都要放在model包下的话，可以添加类似这样的代码把所有实体类都保持住：-keep public class **.*Model*.** {*;} JNI中调用的类。 WebView中JavaScript调用的方法 Layout布局使用的View构造函数、android:onClick等。 3. 检查混淆结果混淆过的包必须进行检查，避免因混淆引入的bug。 一方面，需要从代码层面检查。使用上文的配置进行混淆打包后在 &lt;module-name&gt;/build/outputs/mapping/release/ 目录下会输出以下文件： dump.txt描述APK文件中所有类的内部结构 mapping.txt提供混淆前后类、方法、类成员等的对照表 seeds.txt列出没有被混淆的类和成员 usage.txt列出被移除的代码 我们可以根据 seeds.txt 文件检查未被混淆的类和成员中是否已包含所有期望保留的，再根据 usage.txt 文件查看是否有被误移除的代码。 另一方面，需要从测试方面检查。将混淆过的包进行全方面测试，检查是否有 bug 产生。 4. 解出混淆栈混淆后的类、方法名等等难以阅读，这固然会增加逆向工程的难度，但对追踪线上 crash 也造成了阻碍。我们拿到 crash 的堆栈信息后会发现很难定位，这时需要将混淆反解。 在 &lt;sdk-root&gt;/tools/proguard/ 路径下有附带的的反解工具（Window 系统为 proguardgui.bat，Mac 或 Linux 系统为 proguardgui.sh）。 这里以 Window 平台为例。双击运行 proguardgui.bat 后，可以看到左侧的一行菜单。点击 ReTrace，选择该混淆包对应的 mapping 文件（混淆后在 &lt;module-name&gt;/build/outputs/mapping/release/ 路径下会生成 mapping.txt 文件，它的作用是提供混淆前后类、方法、类成员等的对照表），再将 crash 的 stack trace 黏贴进输入框中，点击右下角的 ReTrace ，混淆后的堆栈信息就显示出来了。 以上使用 GUI 程序进行操作，另一种方式是利用该路径下的 retrace 工具通过命令行进行反解，命令是 1retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;] 例如： 1retrace.bat -verbose mapping.txt obfuscated_trace.txt 注意事项： 所有在 AndroidManifest.xml 涉及到的类已经自动被保持，因此不用特意去添加这块混淆规则。（很多老的混淆文件里会加，现在已经没必要） proguard-android.txt 已经存在一些默认混淆规则，没必要在 proguard-rules.pro 重复添加，该文件具体规则见附录1： 二、混淆简介Android中的“混淆”可以分为两部分，一部分是 Java 代码的优化与混淆，依靠 proguard 混淆器来实现；另一部分是资源压缩，将移除项目及依赖的库中未被使用的资源(资源压缩严格意义上跟混淆没啥关系，但一般我们都会放一起讲)。 1. 代码压缩 代码混淆是包含了代码压缩、优化、混淆等一系列行为的过程。如上图所示，混淆过程会有如下几个功能： 压缩。移除无效的类、类成员、方法、属性等； 优化。分析和优化方法的二进制代码；根据proguard-android-optimize.txt中的描述，优化可能会造成一些潜在风险，不能保证在所有版本的Dalvik上都正常运行。 混淆。把类名、属性名、方法名替换为简短且无意义的名称； 预校验。添加预校验信息。这个预校验是作用在Java平台上的，Android平台上不需要这项功能，去掉之后还可以加快混淆速度。 这四个流程默认开启。 在 Android 项目中我们可以选择将“优化”和“预校验”关闭，对应命令是-dontoptimize、-dontpreverify（当然，默认的 proguard-android.txt 文件已包含这两条混淆命令，不需要开发者额外配置）。 2. 资源压缩资源压缩将移除项目及依赖的库中未被使用的资源，这在减少 apk 包体积上会有不错的效果，一般建议开启。具体做法是在 build.grade 文件中，将 shrinkResources 属性设置为 true。需要注意的是，只有在用minifyEnabled true开启了代码压缩后，资源压缩才会生效。 资源压缩包含了“合并资源”和“移除资源”两个流程。 “合并资源”流程中，名称相同的资源被视为重复资源会被合并。需要注意的是，这一流程不受shrinkResources属性控制，也无法被禁止， gradle 必然会做这项工作，因为假如不同项目中存在相同名称的资源将导致错误。gradle 在四处地方寻找重复资源： src/main/res/ 路径 不同的构建类型（debug、release等等） 不同的构建渠道 项目依赖的第三方库 合并资源时按照如下优先级顺序： 1依赖 -&gt; main -&gt; 渠道 -&gt; 构建类型 举个例子，假如重复资源同时存在于main文件夹和不同渠道中，gradle 会选择保留渠道中的资源。 同时，如果重复资源在同一层次出现，比如src/main/res/ 和 src/main/res2/，则 gradle 无法完成资源合并，这时会报资源合并错误。 “移除资源”流程则见名知意，需要注意的是，类似代码，混淆资源移除也可以定义哪些资源需要被保留，这点在下文给出。 三、自定义混淆规则在上文“混淆配置”中有这样一行代码 1proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' 这行代码定义了混淆规则由两部分构成：位于 SDK 的 tools/proguard/ 文件夹中的 proguard-android.txt 的内容以及默认放置于模块根目录的 proguard-rules.pro 的内容。前者是 SDK 提供的默认混淆文件（内容见附录1），后者是开发者自定义混淆规则的地方。 1. 常见混淆命令： optimizationpasses dontoptimize dontusemixedcaseclassnames dontskipnonpubliclibraryclasses dontpreverify dontwarn verbose optimizations keep keepnames keepclassmembers keepclassmembernames keepclasseswithmembers keepclasseswithmembernames 在第一部分 Android 混淆最佳实践中已介绍部分需要使用到的混淆命令，这里不再赘述，详情请查阅官网。需要特别介绍的是与保持相关元素不参与混淆的规则相关的几种命令： 命令 作用 -keep 防止类和成员被移除或者被重命名 -keepnames 防止类和成员被重命名 -keepclassmembers 防止成员被移除或者被重命名 -keepnames 防止成员被重命名 -keepclasseswithmembers 防止拥有该成员的类和成员被移除或者被重命名 -keepclasseswithmembernames 防止拥有该成员的类和成员被重命名 2. 保持元素不参与混淆的规则形如： 123[保持命令] [类] &#123; [成员] &#125; “类”代表类相关的限定条件，它将最终定位到某些符合该限定条件的类。它的内容可以使用： 具体的类 访问修饰符（public、protected、private） 通配符*，匹配任意长度字符，但不含包名分隔符(.) 通配符**，匹配任意长度字符，并且包含包名分隔符(.) extends，即可以指定类的基类 implement，匹配实现了某接口的类 $，内部类 “成员”代表类成员相关的限定条件，它将最终定位到某些符合该限定条件的类成员。它的内容可以使用： 匹配所有构造器 匹配所有域 匹配所有方法 通配符*，匹配任意长度字符，但不含包名分隔符(.) 通配符**，匹配任意长度字符，并且包含包名分隔符(.) 通配符***，匹配任意参数类型 …，匹配任意长度的任意类型参数。比如void test(…)就能匹配任意 void test(String a) 或者是 void test(int a, String b) 这些方法。 访问修饰符（public、protected、private） 举个例子，假如需要将name.huihui.test包下所有继承Activity的public类及其构造函数都保持住，可以这样写： 123-keep public class name.huihui.test.** extends Android.app.Activity &#123; &lt;init&gt;&#125; 3. 常用的自定义混淆规则 不混淆某个类 1-keep public class name.huihui.example.Test &#123; *; &#125; 不混淆某个包所有的类 1-keep class name.huihui.test.** &#123; *; &#125; 不混淆某个类的子类 1-keep public class * extends name.huihui.example.Test &#123; *; &#125; 不混淆所有类名中包含了“model”的类及其成员 1-keep public class **.*model*.** &#123;*;&#125; 不混淆某个接口的实现 1-keep class * implements name.huihui.example.TestInterface &#123; *; &#125; 不混淆某个类的构造方法 123-keepclassmembers class name.huihui.example.Test &#123; public &lt;init&gt;(); &#125; 不混淆某个类的特定的方法 123-keepclassmembers class name.huihui.example.Test &#123; public void test(java.lang.String); &#125; 不混淆某个类的内部类 123-keep class name.huihui.example.Test$* &#123; *; &#125; 四、自定义资源保持规则1. keep.xml用shrinkResources true开启资源压缩后，所有未被使用的资源默认被移除。假如你需要定义哪些资源必须被保留，在 res/raw/ 路径下创建一个 xml 文件，例如 keep.xml。 通过一些属性的设置可以实现定义资源保持的需求，可配置的属性有： tools:keep 定义哪些资源需要被保留（资源之间用“,”隔开） tools:discard 定义哪些资源需要被移除（资源之间用“,”隔开） tools:shrinkMode 开启严格模式 当代码中通过 Resources.getIdentifier() 用动态的字符串来获取并使用资源时，普通的资源引用检查就可能会有问题。例如，如下代码会导致所有以“img_”开头的资源都被标记为已使用。 12String name = String.format("img_%1d", angle + 1);res = getResources().getIdentifier(name, "drawable", getPackageName()); 我们可以设置 tools:shrinkMode 为 strict 来开启严格模式，使只有确实被使用的资源被保留。 以上就是自定义资源保持规则相关的配置，举个例子： 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:tools="http://schemas.android.com/tools" tools:keep="@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*" tools:discard="@layout/unused2" tools:shrinkMode="strict"/&gt; 2. 移除替代资源一些替代资源，例如多语言支持的 strings.xml，多分辨率支持的 layout.xml 等，在我们不需要使用又不想删除掉时，可以使用资源压缩将它们移除。 我们使用 resConfig 属性来指定需要支持的属性，例如 123456android &#123; defaultConfig &#123; ... resConfigs "en", "fr" &#125;&#125; 其他未显式声明的语言资源将被移除。 参考资料 Shrink Your Code and Resources proguard Android安全攻防战，反编译与混淆技术完全解析（下） Android混淆从入门到精通 Android代码混淆之ProGuard 附录 proguard-android.txt文件内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#包名不混合大小写-dontusemixedcaseclassnames#不跳过非公共的库的类-dontskipnonpubliclibraryclasses#混淆时记录日志-verbose#关闭预校验-dontpreverify#不优化输入的类文件-dontoptimize#保护注解-keepattributes *Annotation*#保持所有拥有本地方法的类名及本地方法名-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保持自定义View的get和set相关方法-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;#保持Activity中View及其子类入参的方法-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;#枚举-keepclassmembers enum * &#123; **[] $VALUES; public *;&#125;#Parcelable-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;#R文件的静态成员-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;-dontwarn android.support.**#keep相关注解-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Activity标签属性]]></title>
    <url>%2Fposts%2F9bf9542d.html</url>
    <content type="text"><![CDATA[Activity 是 Android 系统四大应用组件之一，用户可与 Activity 提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件等操作 开发者必须在清单文件中声明要使用的 Activity，这样系统才能访问它。声明方式是在 &lt; application &gt; 元素中添加 &lt; activity &gt; 子元素 123456789101112&lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".Example"&gt; &lt;/activity&gt; &lt;/application&gt; 可以为&lt; activity &gt;元素设置多个属性值以定义 UI 风格或者运行属性。 android:name 属性是唯一必需的属性，用于指定 Activity 的类名 &lt; activity &gt;包含的属性如下所示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;activity android:allowEmbedded=["true" | "false"] android:allowTaskReparenting=["true" | "false"] android:alwaysRetainTaskState=["true" | "false"] android:autoRemoveFromRecents=["true" | "false"] android:banner="drawable resource" android:clearTaskOnLaunch=["true" | "false"] android:configChanges=["mcc", "mnc", "locale", "touchscreen", "keyboard", "keyboardHidden", "navigation", "screenLayout", "fontScale", "uiMode", "orientation", "screenSize", "smallestScreenSize"] android:documentLaunchMode=["intoExisting" | "always" | "none" | "never"] android:enabled=["true" | "false"] android:excludeFromRecents=["true" | "false"] android:exported=["true" | "false"] android:finishOnTaskLaunch=["true" | "false"] android:hardwareAccelerated=["true" | "false"] android:icon="drawable resource" android:label="string resource" android:launchMode=["standard" | "singleTop" | "singleTask" | "singleInstance"] android:maxRecents="integer" android:multiprocess=["true" | "false"] android:name="string" android:noHistory=["true" | "false"] android:parentActivityName="string" android:permission="string" android:process="string" android:relinquishTaskIdentity=["true" | "false"] android:resizeableActivity=["true" | "false"] android:screenOrientation=["unspecified" | "behind" | "landscape" | "portrait" | "reverseLandscape" | "reversePortrait" | "sensorLandscape" | "sensorPortrait" | "userLandscape" | "userPortrait" | "sensor" | "fullSensor" | "nosensor" | "user" | "fullUser" | "locked"] android:stateNotNeeded=["true" | "false"] android:supportsPictureInPicture=["true" | "false"] android:taskAffinity="string" android:theme="resource or theme" android:uiOptions=["none" | "splitActionBarWhenNarrow"] android:windowSoftInputMode=["stateUnspecified", "stateUnchanged", "stateHidden", "stateAlwaysHidden", "stateVisible", "stateAlwaysVisible", "adjustUnspecified", "adjustResize", "adjustPan"] &gt; &lt;/activity&gt; 一、android:allowEmbedded**表示该 Activity 可作为另一 Activity 的嵌入式子项启动。 它尤其适用于子项所在的容器（如 Display）为另一 Activity 所拥有的情况。 例如，用于 Wear 自定义通知的 Activity 必须声明此项，以便 Wear 在其上下文流中显示 Activity，后者位于另一进程中。该属性的默认值为 false 二、android:allowTaskReparenting当启动 Activity 的任务接下来转至前台时，Activity 是否能从该任务转移至与其有亲和关系的任务。“true”表示它可以转移，“false”表示它仍须留在启动它的任务处。如果未设置该属性，则对 Activity 采用由 &lt; application &gt; 元素的 allowTaskReparenting 属性设置的值。 默认值为“false” 正常情况下，当 Activity 启动时，会与启动它的任务关联，并在其整个生命周期中一直留在该任务处。可以利用该属性强制 Activity 在其当前任务不再显示时将其父项更改为与其有亲和关系的任务。该属性通常用于使应用的 Activity 转移至与该应用关联的主任务例如，如果电子邮件包含网页链接，则点击链接会调出可显示网页的 Activity。 该 Activity 由浏览器应用定义，但作为电子邮件任务的一部分启动。 如果将其父项更改为浏览器任务，它会在浏览器下一次转至前台时显示，当电子邮件任务再次转至前台时则会消失 Activity 的亲和关系由 taskAffinity 属性定义。 任务的亲和关系通过读取其根 Activity 的亲和关系来确定。因此，按照定义，根 Activity 始终位于具有相同亲和关系的任务之中。 由于具有“singleTask”或“singleInstance”启动模式的 Activity 只能位于任务的根，因此更改父项仅限于“standard”和“singleTop”模式 三、android:alwaysRetainTaskState系统是否始终保持 Activity 所在任务的状态 ，“true”表示保持，“false”表示允许系统在特定情况下将任务重置到其初始状态。 默认值为“false”。该属性只对任务的根 Activity 有意义，对于所有其他 Activity，均忽略该属性 正常情况下，当用户从主屏幕重新选择某个任务时，系统会在特定情况下清除该任务（从根 Activity 之上的堆栈中移除所有 Activity）。 系统通常会在用户一段时间（如 30 分钟）内未访问任务时执行此操作 不过，如果该属性的值是“true”，则无论用户如何到达任务，将始终返回到最后状态的任务。 例如，在网络浏览器这类存在大量用户不愿失去的状态（如多个打开的标签）的应用中，该属性会很有用 四、android:autoRemoveFromRecents由具有该属性的 Activity 启动的任务是否一直保留在概览屏幕中，直至任务中的最后一个 Activity 完成为止。 若为 true，则自动从概览屏幕中移除任务。 它会替换调用方使用的 FLAG_ACTIVITY_RETAIN_IN_RECENTS 五、android:banner一种为其关联项提供扩展图形化横幅的可绘制资源。 将其与 &lt; activity &gt; 标记联用可为特定 Activity 提供默认横幅，也可与 &lt; application &gt; 标记联用，为所有应用 Activity 提供横幅 系统使用横幅在 Android TV 主屏幕中表示应用。 由于横幅只显示在主屏幕中，因此只应由包含的 Activity 能够处理 CATEGORY_LEANBACK_LAUNCHER Intent 的应用指定 必须将该属性设置为对包含图像的可绘制资源的引用（例如 “@drawable/banner”），该属性没有默认值 六、android:clearTaskOnLaunch是否每当从主屏幕重新启动任务时都从中移除根 Activity 之外的所有 Activity ，“true”表示始终将任务清除到只剩其根 Activity，“false”表示不做清除。 默认值为“false”。该属性只对启动新任务的 Activity（根 Activity）有意义；对于任务中的所有其他 Activity，均忽略该属性 当值为“true”时，每次用户再次启动任务时，无论用户最后在任务中正在执行哪个 Activity，也无论用户是使用返回还是主屏幕按钮离开，都会将用户转至任务的根 Activity。 当值为“false”时，可在某些情况下清除任务中的 Activity（请参阅 alwaysRetainTaskState 属性），但并非一律可以 例如，假定有人从主屏幕启动了 Activity P，然后从那里转到 Activity Q。该用户接着按了主屏幕按钮，然后返回到 Activity P。正常情况下，用户将看到 Activity Q，因为那是其最后在 P 的任务中执行的 Activity。 不过，如果 P 将此标志设置为“true”，则当用户按下主屏幕将任务转入后台时，其上的所有 Activity（在本例中为 Q）都会被移除， 因此用户返回任务时只会看到 P 如果该属性和 allowTaskReparenting 的值均为“true”，则如上所述，任何可以更改父项的 Activity 都将转移到与其有亲和关系的任务，其余 Activity 随即被移除 七、android:configChanges列出 Activity 将自行处理的配置更改。在运行时发生配置更改时，默认情况下会关闭 Activity 然后将其重新启动，但使用该属性声明配置将阻止 Activity 重新启动。 Activity 会保持运行状态，并且系统会调用其 onConfigurationChanged() 方法。应避免使用该属性，并且只应在万不得已的情况下使用 属性值 说明 mcc IMSI 移动国家/地区代码 (MCC) 发生了变化 - 检测到了 SIM 并更新了 MCC mnc IMSI 移动网络代码 (MNC) 发生了变化 - 检测到了 SIM 并更新了 MNC locale 语言区域发生了变化 — 用户为文本选择了新的显示语言 touchscreen 触摸屏发生了变化（这种情况通常永远不会发生） keyboard 键盘类型发生了变化 — 例如，用户插入了一个外置键盘 keyboardHidden 键盘无障碍功能发生了变化 — 例如，用户显示了硬件键盘 navigation 导航类型（轨迹球/方向键）发生了变化（这种情况通常永远不会发生） screenLayout 屏幕布局发生了变化 — 这可能是由激活了其他显示方式所致 fontScale 字体缩放系数发生了变化 — 用户选择了新的全局字号 uiMode 用户界面模式发生了变化 — 这可能是因用户将设备放入桌面/车载基座或夜间模式发生变化所致。 请参阅 UiModeManager。 此项为 API 级别 8 中新增配置 orientation 屏幕方向发生了变化 — 用户旋转了设备。注：如果您的应用面向 API 级别 13 或更高级别（按照 minSdkVersion 和 targetSdkVersion 属性所声明的级别），则还应声明 “screenSize” 配置，因为当设备在横向与纵向之间切换时，该配置也会发生变化 screenSize 当前可用屏幕尺寸发生了变化。它表示当前可用尺寸相对于当前纵横比的变化，因此会在用户在横向与纵向之间切换时发生变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。此项为 API 级别 13 中新增配置 smallestScreenSize 物理屏幕尺寸发生了变化。它表示与方向无关的尺寸变化，因此只有在实际物理屏幕尺寸发生变化（如切换到外部显示器）时才会变化。 对此配置的变更对应于smallestWidth 配置的变化。 不过，如果您的应用面向 API 级别 12 或更低级别，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重新启动 Activity）。此项为 API 级别 13 中新增配置 layoutDirection 布局方向发生了变化。例如，从从左至右 (LTR) 更改为从右至左 (RTL)。 此项为 API 级别 17 中新增配置 所有这些配置变更都可能影响应用看到的资源值。 因此，调用 onConfigurationChanged() 时，通常有必要再次获取所有资源（包括视图布局、可绘制对象等）以正确处理变化 八、android:documentLaunchMode指定每次启动任务时应如何向其中添加新的 Activity 实例。 该属性允许用户让多个来自同一应用的文档出现在概览屏幕中该属性有四个值，会在用户使用该应用打开文档时产生以下效果： 属性值 说明 intoExisting Activity 会为文档重复使用现有任务。使用该值与不设置 FLAG_ACTIVITY_MULTIPLE_TASK 标志、但设置 FLAG_ACTIVITY_NEW_DOCUMENT 标志所产生的效果相同，如使用 Intent 标志添加任务中所述 always Activity 为文档创建新任务，即便文档已打开也是如此。 这与同时设置 FLAG_ACTIVITY_NEW_DOCUMENT 和 FLAG_ACTIVITY_MULTIPLE_TASK 标志的效果相同 none 该 Activity 不会为 Activity 创建新任务。这是默认值，它只会在设置了 FLAG_ACTIVITY_NEW_TASK 时创建新任务。 概览屏幕将按其默认方式对待此 Activity：为应用显示单个任务，该任务将从用户上次调用的任意 Activity 开始继续执行 never 即使 Intent 包含 FLAG_ACTIVITY_NEW_DOCUMENT，该 Activity 也不会启动到新文档之中。 设置此值会替代 FLAG_ACTIVITY_NEW_DOCUMENT 和 FLAG_ACTIVITY_MULTIPLE_TASK 标志的行为（如果在 Activity 中设置了其中一个标志），并且概览屏幕将为应用显示单个任务，该任务将从用户上次调用的任意 Activity 开始继续执行 对于除“none”和“never”以外的值，必须使用 launchMode=”standard” 定义 Activity。 如果未指定此属性，则使用 documentLaunchMode=”none” 九、android:enabled系统是否可将 Activity 实例化 — “true” 表示可以，“false”表示不可以。 默认值为“true” &lt; application &gt; 元素具有自己的 enabled 属性，该属性适用于所有应用组件，包括 Activity。 &lt; application &gt; 和 &lt; activity &gt; 属性必须都是“true”（因为它们都默认使用该值），系统才能将 Activity 实例化。 如果任何一个属性是“false”，则无法进行实例化 十、android:excludeFromRecents是否应将该 Activity 启动的任务排除在最近使用的应用列表（即概览屏幕）之外。 也就是说，当该 Activity 是新任务的根 Activity 时，此属性确定任务是否应出现在最近使用的应用列表中。 如果应将任务排除在列表之外，请设置“true”，如果应将其包括在内，则设置“false”。 默认值为“false” 十一、android:exportedActivity 是否可由其他应用的组件启动 ，“true”表示可以，“false”表示不可以。若为“false”，则 Activity 只能由同一应用的组件或使用同一用户 ID 的不同应用启动 默认值取决于 Activity 是否包含 Intent 过滤器。没有任何过滤器意味着 Activity 只能通过指定其确切的类名称进行调用。 这意味着 Activity 专供应用内部使用（因为其他应用不知晓其类名称）。 因此，在这种情况下，默认值为“false”。另一方面，至少存在一个过滤器意味着 Activity 专供外部使用，因此默认值为“true” 该属性并非限制 Activity 对其他应用开放度的唯一手段。 您还可以利用权限来限制哪些外部实体可以调用 Activity（请参阅 permission 属性） 十二、android:finishOnTaskLaunch每当用户再次启动其任务（在主屏幕上选择任务）时，是否应关闭（完成）现有 Activity 实例，“true”表示应关闭，“false”表示不应关闭。 默认值为“false”如果该属性和 allowTaskReparenting 均为“true”，则优先使用该属性。 Activity 的亲和关系会被忽略。 系统不是更改 Activity 的父项，而是将其销毁 十三、android:hardwareAccelerated是否应为此 Activity 启用硬件加速渲染，“true”表示应启用，“false”表示不应启用。 默认值为“false” 从 Android 3.0 开始，为应用提供了硬件加速 OpenGL 渲染器，以改善许多常见 2D 图形运算的性能。 启用硬件加速渲染器时，Canvas、Paint、Xfermode、ColorFilter、Shader 和 Camera 中的大多数运算都会得到加速。这可以提高动画、滚动的流畅度和总体响应速度，即便是并不明确使用框架 OpenGL 库的应用也会受益。 由于启用硬件加速会增加资源消耗，因此应用将占用更多内存 请注意，并非所有 OpenGL 2D 运算都会得到加速。如果启用硬件加速渲染器，请对应用进行测试，以确保其在利用渲染器时不会出错 十四、android:iconActivity 的图标。该图标会在需要在屏幕上表示 Activity 时显示给用户。 例如，代表启动任务的 Activity 的图标显示在启动器窗口中。该图标通常附带标签（请参阅 android:label 属性） 必须将该属性设置为对包含图像定义的可绘制资源的引用。 如果未设置该属性，则改为使用为应用整体指定的图标（请参阅 &lt; application &gt; 元素的 icon 属性） 这个 Activity 的图标 — 无论设置于此处还是由 &lt; application &gt; 元素设置 — 同时也是 Activity 所有 Intent 过滤器的默认图标（请参阅 &lt; intent-filter &gt; 元素的 icon 属性） 十五、android:label一种可由用户读取的 Activity 标签。该标签会在必须将 Activity 呈现给用户时显示在屏幕上。 它通常与 Activity 图标一并显示 如果未设置该属性，则改为使用为应用整体设置的标签（请参阅 &lt; application &gt; 元素的 label 属性） 这个 Activity 的标签 — 无论设置于此处还是由 &lt; application &gt; 元素设置 — 同时也是 Activity 所有 Intent 过滤器的默认标签（请参阅 &lt; intent-filter &gt; 元素的 label 属性） 应将该标签设置为对字符串资源的引用，以便可以像用户界面中的其他字符串那样进行本地化。不过，为便于开发应用，也可将其设置为原始字符串 十六、android:launchMode有关应如何启动 Activity 的指令。共有四种模式与 Intent 对象中的 Activity 标志（FLAG_ACTIVITY_ 常量*）协同工作，以确定在调用 Activity 处理 Intent 时应执行的操作。 这些模式是：standard 、singleTop 、singleTask 、singleInstance默认模式是“standard”**** 如下表所示，这些模式分为两大类，“standard”和“singleTop”Activity 为一类，“singleTask”和“singleInstance”为另一类。使用“standard”或“singleTop”启动模式的 Activity 可多次实例化。 实例可归属任何任务，并且可以位于 Activity 堆栈中的任何位置。 它们通常启动到名为 startActivity() 的任务之中（除非 Intent 对象包含 FLAG_ACTIVITY_NEW_TASK 指令，在此情况下会选择其他任务，请参阅 taskAffinity 属性） 相比之下，“singleTask”和“singleInstance”Activity 只能启动任务。 它们始终位于 Activity 堆栈的根位置。此外，设备一次只能保留一个 Activity 实例 — 只允许一个此类任务 “standard”和“singleTop”模式只在一个方面有差异： 每次“standard”Activity 有新的 Intent 时，系统都会创建新的类实例来响应该 Intent。每个实例处理单个 Intent。同理，也可创建新的“singleTop”Activity 实例来处理新的 Intent。 不过，如果目标任务在其堆栈顶部已有一个 Activity 实例，那么该实例将接收新 Intent（通过调用 onNewIntent()）；此时不会创建新实例。在其他情况下 — 例如，如果“singleTop”的一个现有实例虽在目标任务内，但未处于堆栈顶部，或者虽然位于堆栈顶部，但不在目标任务中 — 则系统会创建一个新实例并将其推送到堆栈上 同理，如果您向上导航到当前堆栈上的某个 Activity，该行为由父 Activity 的启动模式决定。 如果父 Activity 有启动模式 singleTop（或 up Intent 包含 FLAG_ACTIVITY_CLEAR_TOP），则系统会将该父项置于堆栈顶部，并保留其状态。 导航 Intent 由父 Activity 的 onNewIntent() 方法接收。 如果父 Activity 有启动模式 standard（并且 up Intent 不包含 FLAG_ACTIVITY_CLEAR_TOP），则系统会将当前 Activity 及其父项同时弹出堆栈，并创建一个新的父 Activity 实例来接收导航 Intent “singleTask”和“singleInstance”模式同样只在一个方面有差异： “singleTask”Activity 允许其他 Activity 成为其任务的组成部分。 它始终位于其任务的根位置，但其他 Activity（必然是“standard”和“singleTop”Activity）可以启动到该任务中。 相反，“singleInstance”Activity 则不允许其他 Activity 成为其任务的组成部分。它是任务中唯一的 Activity。 如果它启动另一个 Activity，系统会将该 Activity 分配给其他任务 — 就好像 Intent 中包含 FLAG_ACTIVITY_NEW_TASK 一样。 用例 启动模式 多个实例？ 注释 大多数 Activity 的正常启动 standard 是 默认值。系统始终会在目标任务中创建新的 Activity 实例并向其传送 Intent 大多数 Activity 的正常启动 singleTop 有条件 如果目标任务的顶部已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例 专用启动（不建议用作常规用途） singleTask 否 系统在新任务的根位置创建 Activity 并向其传送 Intent。 不过，如果已存在一个 Activity 实例，则系统会通过调用该实例的 onNewIntent() 方法向其传送 Intent，而不是创建新的 Activity 实例 专用启动（不建议用作常规用途） singleInstance 否 与“singleTask””相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。 该 Activity 始终是其任务唯一仅有的成员 如上表所示，standard 是默认模式，并且适用于大多数的 Activity 类型。对许多类型的 Activity 而言，SingleTop 也是一个常见并且有用的启动模式。 其他模式 — singleTask 和 singleInstance 不适合大多数应用因为它们所形成的交互模式可能让用户感到陌生，并且与大多数其他应用迥异。 无论选择哪一种启动模式，请务必在启动期间以及使用返回按钮从其他 Activity 和任务返回该 Activity 时对其进行易用性测试。 十七、android:maxRecents概览屏幕中位于此 Activity 根位置的任务数上限。 达到该条目数时，系统会从概览屏幕中移除最近最少使用的实例。 该值必须是整数，有效值为 1-50（低内存设备使用 25），默认值为 16 十八、android:multiprocess是否可以将 Activity 实例启动到启动该实例的组件进程内 ，“true”表示可以，“false”表示不可以。默认值为“false”正常情况下，新的 Activity 实例会启动到定义它的应用进程内，因此所有 Activity 实例都在同一进程内运行。 不过，如果该标志设置为“true”，Activity 实例便可在多个进程内运行，这样系统就能在任何使用实例的地方创建实例（前提是权限允许这样做），但这几乎毫无必要性或可取之处 十九、android:name实现 Activity 的类的名称，是 Activity 的子类。 该属性值应为完全限定类名称（例如，“com.example.project.ExtracurricularActivity”）。不过，为了简便起见，如果名称的第一个字符是句点（例如，“.ExtracurricularActivity”），则名称将追加到 &lt; manifest &gt; 元素中指定的软件包名称。开发者必须指定该名称 二十、android:noHistory当用户离开 Activity 并且其在屏幕上不再可见时，是否应从 Activity 堆栈中将其移除并调用其 finish() 方法。默认值为“false”，“true”值表示 Activity 不会留下历史轨迹。 它不会留在任务的 Activity 堆栈内，因此用户将无法返回 Activity。 在此情况下，如果启动另一个 Activity 来获取该 Activity 的结果，系统永远不会调用 onActivityResult()。该属性是在 API 级别 3 引入的 二十一、android:parentActivityNameActivity 逻辑父项的类名称。此处的名称必须与为相应 &lt; activity &gt; 元素的 android:name 属性指定的类名称一致 系统会读取该属性，以确定当用户按下操作栏中的“向上”按钮时应该启动哪一个 Activity。 系统还可以利用这些信息通过 TaskStackBuilder 合成 Activity 的返回栈 该属性是在 API 级别 16 引入的，要支持 API 级别 4 - 16，还可以使用为 “android.support.PARENT_ACTIVITY“ 指定值的 &lt; meta-data &gt; 元素来声明父 Activity。例如： 123456789&lt;activity android:name="com.example.app.ChildActivity" android:label="@string/title_child_activity" android:parentActivityName="com.example.app.MainActivity" &gt; &lt;!-- Parent activity meta-data to support API level 4+ --&gt; &lt;meta-data android:name="android.support.PARENT_ACTIVITY" android:value="com.example.app.MainActivity" /&gt;&lt;/activity&gt; 二十二、android:permission客户端启动 Activity 或以其他方式令其响应 Intent 而必须具备的权限的名称。 如果系统尚未向 startActivity() 或 startActivityForResult() 的调用方授予指定权限，其 Intent 将不会传递给 Activity如果未设置该属性，则对 Activity 应用 &lt; application &gt; 元素的 permission 属性设置的权限。 如果这两个属性均未设置，则 Activity 不受权限保护 二十三、android:process应在其中运行 Activity 的进程的名称。正常情况下，应用的所有组件都在为应用创建的默认进程名称内运行，无需使用该属性。 但在必要时，可以使用该属性替换默认进程名称，以便让应用组件散布到多个进程中 如果为该属性分配的名称以冒号（“:”）开头，则会在需要时创建应用专用的新进程，并且 Activity 会在该进程中运行。如果进程名称以小写字符开头，Activity 将在该名称的全局进程中运行，前提是它拥有相应的权限。这可以让不同应用中的组件共享一个进程，从而减少资源占用 &lt; application &gt; 元素的 process 属性可为所有组件设置一个不同的默认进程名称 二十四、android:relinquishTaskIdentityActivity 是否将其任务标识符交给任务栈中在其之上的 Activity。 如果任务根 Activity 的该属性设置为“true”，则任务会用其内的下一个 Activity 的 Intent 替换基本 Intent。 如果下一个 Activity 的该属性也设置为“true”，则该 Activity 会将基本 Intent 给予其在同一任务中启动的任何 Activity。 系统继续为每个 Activity 执行此过程，直至遇到的某个 Activity 将该属性设置为“false”为止。 默认值为“false” 如果该属性设置为“true”，则 Activity 还可利用 ActivityManager.TaskDescription 来更改概览屏幕中的标签、颜色和图标 二十五、android:resizeableActivity指定应用是否支持多窗口显示。您可以在 &lt; activity &gt; 或 &lt; application &gt; 元素中设置该属性 如果将该属性设置为 true，则用户可以分屏和自由形状模式启动 Activity。 如果将该属性设置为 false，Activity 将不支持多窗口模式。 如果该值为 false，且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示 该属性是在 API 级别 24 添加的，如果应用面向 API 级别 24 或更高级别，但未对该属性指定值，则该属性的值默认设为 true 二十六、android:screenOrientationActivity 在设备上的显示方向。如果 Activity 是在多窗口模式下运行，系统会忽略该属性其值可以是下列任一字符串： 属性值 说明 unspecified 默认值。由系统选择方向。在不同设备上，系统使用的政策以及基于政策在特定上下文所做的选择可能有所差异 behind 与 Activity 栈中紧接着它的 Activity 的方向相同 landscape 横向方向（显示的宽度大于高度） portrait 纵向方向（显示的高度大于宽度） reverseLandscape 与正常横向方向相反的横向方向。API 级别 9 中的新增配置 reversePortrait 与正常纵向方向相反的纵向方向。API 级别 9 中的新增配置 sensorLandscape 横向方向，但根据设备传感器，可以是正常或反向的横向方向。API 级别 9 中的新增配置 sensorPortrait 纵向方向，但根据设备传感器，可以是正常或反向的纵向方向。API 级别 9 中的新增配置 userLandscape 横向方向，但根据设备传感器和用户的传感器首选项，可以是正常或反向的横向方向。 如果用户锁定了基于传感器的旋转，其行为与 landscape 相同，否则，其行为与 sensorLandscape 相同。API 级别 18 中的新增配置 userPortrait 纵向方向，但根据设备传感器和用户的传感器首选项，可以是正常或反向的纵向方向。 如果用户锁定了基于传感器的旋转，其行为与 portrait 相同，否则，其行为与 sensorPortrait 相同。API 级别 18 中的新增配置 sensor 方向由设备方向传感器决定。显示方向取决于用户如何手持设备，它会在用户旋转设备时发生变化。 但一些设备默认情况下不会旋转到所有四种可能的方向。要允许全部四种方向，请使用 “fullSensor” fullSensor 方向由 4 种方向中任一方向的设备方向传感器决定。这与 “sensor” 类似，不同的是它允许所有 4 种可能的屏幕方向，无论设备正常情况下采用什么方向（例如，一些设备正常情况下不使用反向纵向或反向横向，但它支持这些方向）。 API 级别 9 中的新增配置 nosensor 决定方向时不考虑物理方向传感器。传感器会被忽略，因此显示不会随用户对设备的移动而旋转。 除了这个区别，系统在选择方向时使用的政策与“unspecified”设置相同 user 用户当前的首选方向 fullUser 如果用户锁定了基于传感器的旋转，其行为与 user 相同，否则，其行为与 fullSensor 相同，允许所有 4 种可能的屏幕方向。 API 级别 18 中的新增配置 locked 将方向锁定在其当前的任意旋转方向。API 级别 18 中的新增配置 如果声明其中一个横向或纵向值，系统将其视为对 Activity 运行方向的硬性要求。 因此，声明的值支持通过 Google Play 之类的服务进行过滤，这样就能将应用只提供给支持 Activity 所要求方向的设备。 例如，如果声明了 “landscape”、”reverseLandscape” 或 “sensorLandscape”，则应用将只提供给支持横向方向的设备。 不过，还应通过 &lt; uses-feature &gt; 元素明确声明，应用要求采用纵向或横向方向。 例如，&lt; uses-feature android:name=”android.hardware.screen.portrait”/ &gt;。这纯粹是 Google Play（以及其他支持它的服务）提供的一种过滤行为，平台本身并不能控制当设备仅支持特定方向时应用能否安装 二十七、android:stateNotNeeded能否在不保存 Activity 状态的情况下将其终止并成功重新启动 ，“true”表示可在不考虑其之前状态的情况下重新启动，“false”表示需要之前状态。 默认值为“false” 正常情况下，为保存资源而暂时关闭 Activity 前，系统会调用其 onSaveInstanceState() 方法。 该方法将 Activity 的当前状态存储在一个 Bundle 对象中，然后在 Activity 重新启动时将其传递给 onCreate()。 如果该属性设置为“true”，系统可能不会调用 onSaveInstanceState()，并且会向 onCreate() 传递 null 而不是 Bundle，这与它在 Activity 首次启动时完全一样 “true”设置可确保 Activity 能够在未保留状态时重新启动。 例如，显示主屏幕的 Activity 可以使用该设置来确保其由于某种原因崩溃时不会被移除 二十八、android:supportsPictureInPicture指定 Activity 是否支持画中画显示。如果 android:resizeableActivity 是 false，系统会忽略该属性。该属性是在 API 级别 24 添加的 二十九、android:taskAffinity与 Activity 有着亲和关系的任务。从概念上讲，具有相同亲和关系的 Activity 归属同一任务（从用户的角度来看，则是归属同一“应用”）。 任务的亲和关系由其根 Activity 的亲和关系确定 亲和关系确定两件事 - Activity 更改到的父项任务（请参阅 allowTaskReparenting 属性）和通过 FLAG_ACTIVITY_NEW_TASK 标志启动 Activity 时将用来容纳它的任务 默认情况下，应用中的所有 Activity 都具有相同的亲和关系。您可以设置该属性来以不同方式组合它们，甚至可以将在不同应用中定义的 Activity 置于同一任务内。 要指定 Activity 与任何任务均无亲和关系，请将其设置为空字符串 如果未设置该属性，则 Activity 继承为应用设置的亲和关系（请参阅 &lt; application &gt; 元素的 taskAffinity 属性）。 应用默认亲和关系的名称是 &lt; manifest &gt; 元素设置的软件包名称 三十、android:theme对定义 Activity 总体主题的样式资源的引用。它会自动将 Activity 的上下文设置为使用该主题，它还可以引发 Activity 启动前的“启动”动画以更加符合 Activity 的实际外观 如果未设置该属性，则 Activity 继承通过 &lt; application &gt; 元素的 theme 属性为应用整体设置的主题。 如果该属性也未设置，则使用默认系统主题 三十一、android:uiOptions针对 Activity UI 的附加选项，该属性是在 API 级别 14 添加的，必须是下列值之一 属性值 说明 none 无附加 UI 选项。这是默认值 splitActionBarWhenNarrow 当水平空间受限时（例如在手持设备上的纵向模式下时）在屏幕底部添加一个栏以显示应用栏（也称为操作栏）中的操作项）。 应用栏不是以少量操作项形式出现在屏幕顶部的应用栏中，而是分成了顶部导航区和底部操作项栏。 这可以确保操作项以及顶部的导航和标题元素都能获得合理的空间。 菜单项不会拆分到两个栏中，它们始终一起出现 三十二、android:windowSoftInputModeActivity 的主窗口与包含屏幕软键盘的窗口的交互方式。 该属性是在 API 级别 3 引入的该属性的设置影响两个方面： 当 Activity 成为用户注意的焦点时软键盘的状态 — 隐藏还是可见。 对 Activity 主窗口所做的调整 — 是否将其尺寸调小以为软键盘腾出空间，或者当窗口部分被软键盘遮挡时是否平移其内容以使当前焦点可见 该设置必须是下表所列的值之一，或者是一个“state…”值加上一个“adjust…”值的组合。 在任一组中设置多个值（例如，多个“state…”值）都会产生未定义结果。各值之间使用垂直条“ | ”分隔 1&lt;activity android:windowSoftInputMode="stateVisible|adjustResize" . . . &gt; 属性值 说明 stateUnspecified 不指定软键盘的状态（隐藏还是可见）。 将由系统选择合适的状态，或依赖主题中的设置。这是对软键盘行为的默认设置 stateUnchanged 当 Activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏 stateHidden 当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 隐藏软键盘 stateAlwaysHidden 当 Activity 的主窗口有输入焦点时始终隐藏软键盘 stateVisible 在正常的适宜情况下（当用户向前导航到 Activity 的主窗口时）显示软键盘 stateAlwaysVisible 当用户选择 Activity 时 — 也就是说，当用户确实是向前导航到 Activity，而不是因离开另一 Activity 而返回时 — 显示软键盘 adjustUnspecified 不指定 Activity 的主窗口是否调整尺寸以为软键盘腾出空间，或者窗口内容是否进行平移以在屏幕上显露当前焦点。 系统会根据窗口的内容是否存在任何可滚动其内容的布局视图来自动选择其中一种模式。 如果存在这样的视图，窗口将进行尺寸调整，前提是可通过滚动在较小区域内看到窗口的所有内容。这是对主窗口行为的默认设置 adjustResize 始终调整 Activity 主窗口的尺寸来为屏幕上的软键盘腾出空间 adjustPan 不调整 Activity 主窗口的尺寸来为软键盘腾出空间， 而是自动平移窗口的内容，使当前焦点永远不被键盘遮盖，让用户始终都能看到其输入的内容。 这通常不如尺寸调正可取，因为用户可能需要关闭软键盘以到达被遮盖的窗口部分或与这些部分进行交互]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于RecyclerView的解析]]></title>
    <url>%2Fposts%2Fe545b7b2.html</url>
    <content type="text"><![CDATA[前言虽然在日常开发中，大伙或多或少都会接触到 RecyclerView，但通常，也就是写写 adapter，用个系统提供的 LayoutManager，写写点击事件，处理处理复杂的 item 布局。 也就是说，大部分场景下，我们其实并不会去接触到 RecyclerView 的大部分其他功能，比如自定义 LayoutManager ，自定义 Item 动画，自定义边界样式，自定义滑动效果，自定义回收策略等等之类的功能。 那么，本篇就专门来试用下这些功能，力求将 RecyclerView 支持的所有功能都试一遍，只有清楚了这个控件都支持哪些功能效果，那么分析起它的架构、原理才会有一个比较清晰的脉络。 目录由于本篇篇幅特长，特意做了个目录，让大伙对本篇内容先有个大概的了解。 另外，由于有些平台可能不支持 `` 解析，所以建议大伙可借助本篇目录，或平台的目录索引进行快速查阅。 1.LayoutManager 1.1 LinearLayoutManager 基本效果介绍 findFirstCompletelyVisibleItemPosition() findFirstVisibleItemPosition() findLastCompletelyVisibleItemPosition() findLastVisibleItemPosition() setRecycleChildrenOnDetach() 1.2 GridLayoutManager 基本效果介绍 setSpanSizeLookUp() 1.3 StaggeredGridLayoutManager 基本效果介绍 setFullSpan() findXXX() 系列方法介绍 2.ViewHolder getAdapterPosition() getLayoutPosition() setIsRecyclable() 3.LayoutParams 4.Adapter 基本用法介绍 onViewRecycled() onViewAttachedFromWindow() onViewDetachedFromWindow() onAttachedToRecyclerView() onDetachedFromRecyclerView() registerAdapterDataObserver() unregisterAdapterDataObserver() 5.RecyclerView addOnItemTouchListener() addOnScrollListener() setHasFixedSize() setLayoutFrozen() setPreserveFocusAfterLayout() findChildViewUnder() findContainingItemView() findContainingViewHolder() findViewHolderXXX() 6.Recycler setItemViewCacheSize() setViewCacheExtension() setRecycledViewPool() setRecyclerListener() 7.ItemAnimator SimpleItemAnimator DefaultItemAnimator 8.ItemDecoration DividerItemDecoration ItemTouchHelper FastScroller 9.OnFlingListener SnapHelper LinearSnapHelper PagerSnapHelper 正文阅读须知： 本篇力求列举 RecyclerView 所有功能的使用示例，由于篇幅原因，并不会将实现代码全部贴出，只贴出关键部分的代码。 本篇所使用的 RecyclerView 的版本是 26.0.0。 下列标题中，但凡是斜体字，表示该知识点目前暂时没理清楚，留待后续继续补充。 1. LayoutManagerRecyclerView 的 support 包里默认提供了三个 LayoutManager，分别是下列三个，可用于实现大部分场景的布局需求：线性布局、网格布局、瀑布流布局等等。 1.1 LinearLayoutManager线性布局，用它可以来实现横竖自由切换的线性布局，先来看看它的构造函数： 1234567891011121314public class LinearLayoutManager extends RecyclerView.LayoutManager implements ItemTouchHelper.ViewDropHandler, RecyclerView.SmoothScroller.ScrollVectorProvider &#123; public LinearLayoutManager(Context context) &#123; this(context, VERTICAL, false); &#125; public LinearLayoutManager(Context context, int orientation, boolean reverseLayout) &#123; ... &#125; public LinearLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; ... &#125;&#125; 总共三个，我们分别来看看它们各自的使用场景： 第一个构造函数 123//用法(在Activity里初始化控件后)：LinearLayoutManager layoutManager = new LinearLayoutManager(this);mRecyclerView.setLayoutManager(layoutManager); 很简单，这种时候默认就是竖直方向的线性布局，效果图： 在 Tv 应用中，这种竖直方向的 LinearLayoutManager 使用场景大多都是用于显示菜单项，使用频率并不是特别高，但在手机应用中，这种的使用频率算是特别高的了，几乎每个 app 都会有竖直方向的滑动列表控件。 第二个构造函数 1234//用法(在Activity里初始化控件后)：//第二个参数就是用于指定方向是竖直还是水平，第三个参数用于指定是否从右到左布局，基本都是false，我们的习惯都是左到右的排列方式LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);mRecyclerView.setLayoutManager(layoutManager); 第二个参数就是用于指定方向是竖直还是水平，第三个参数用于指定是否从右到左布局，基本都是false，我们的习惯都是左到右的排列方式，来看看效果： 在 Tv 应用中，这种布局就比较常见了，常见的还有网格布局，多行布局等等；而在手机应用中，水平滑动的列表控件也还是有，但会比竖直的少见一些。 第三个构造函数 12345678//xml文件：&lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_main" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" app:layoutManager="LinearLayoutManager" /&gt; 这种方式基本没见过吧，我也是看了 LinearLayoutManager 源码的构造函数，才发现，原来还有这种方式，可以直接在 xml 布局文件中指定 RecyclerView 的 LayoutManager，这时候，android:orientation 就是用来指定 LinearLayoutManager 的布局方向了。 那么使用这种 xml 方式时，还有哪些属性可以配置呢？直接去看对应的 LayoutManager 的源码就清楚了，比如： 123456789101112131415161718192021//LinearLayoutManager.java/** * Constructor used when layout manager is set in XML by RecyclerView attribute * "layoutManager". Defaults to vertical orientation. * * @attr ref android.support.v7.recyclerview.R.styleable#RecyclerView_android_orientation * @attr ref android.support.v7.recyclerview.R.styleable#RecyclerView_reverseLayout * @attr ref android.support.v7.recyclerview.R.styleable#RecyclerView_stackFromEnd *///上面是源码的注释，当在 xml 中通过 app:layoutManager="LinearLayoutManager" 之后，那么此时就还可以再使用三个属性来配置 LinearLayoutManager,如下：//android:orientation="horizontal"//app:reverseLayout="false"//app:stackFromEnd="false"public LinearLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; Properties properties = getProperties(context, attrs, defStyleAttr, defStyleRes); setOrientation(properties.orientation); setReverseLayout(properties.reverseLayout); setStackFromEnd(properties.stackFromEnd); setAutoMeasureEnabled(true);&#125; 另外两个 LayoutManager 同理。 以上，仅仅就是 LinearLayoutManager 支持的布局样式，我们只需要设置布局方向后，其他都不用管了。那么，LinearLayoutManager 是否还有提供其他一些可选功能来让我们使用呢？接下去就一起再看看： setOrientation() 用于设置布局方向，如果不通过构造函数来指定，也可以通过该方法指定，就两个值：LinearLayoutManager.HORIZONTALLinearLayoutManager.VERTICAL findFirstCompletelyVisibleItemPosition() findFirstVisibleItemPosition() findLastCompletelyVisibleItemPosition() findLastVisibleItemPosition() 上述四个方法作用从方法命名就可以很直观的理解了，但有些细节需要注意一下： 两个查找全部可见的 item 方法并不是我们正常意义上的全部可见，而是指在布局方向上是否已全部可见。说得白点，如果是 HORIZONTAL 水平样式，如上图，那么它只会去计算左右方向上是否全部可见来判定，比如我们特意在代码中通过 layout_marginTop=”-100dp” 来将控件移出屏幕一部分，如下： 此时，按照我们正常意义上来理解是没有一个 item 处于全部可见的，因为每个 item 的上半部分都被移出屏幕了。但是调用那两个查找全部可见的 item 方法，仍然会返回 0 和 4，因为它只去判断水平方向是否全部可见。 findFirst 就是判断左边第一个 item 的左边界是否可见，findLast 就是判断右边最后一个 item 的右边界是否可见。如果布局方向是竖直的，那么同样的道理。这点细节需要注意一下。 还有另外两个查找第一个或最后一个可见的 item 方法也有个细节需要注意一下，如果这个 item 是有设置了 ItemDecoration，那么如果 ItemDecoration 这部分区域是可见的，也会判定该 item 是可见的。 setRecycleChildrenOnDetach() 12345678910111213141516/** * Set whether LayoutManager will recycle its children when it is detached from * RecyclerView. * &lt;p&gt; * If you are using a &#123;@link RecyclerView.RecycledViewPool&#125;, it might be a good idea to set * this flag to &lt;code&gt;true&lt;/code&gt; so that views will be available to other RecyclerViews * immediately. * &lt;p&gt; * Note that, setting this flag will result in a performance drop if RecyclerView * is restored. * * @param recycleChildrenOnDetach Whether children should be recycled in detach or not. */public void setRecycleChildrenOnDetach(boolean recycleChildrenOnDetach) &#123; mRecycleChildrenOnDetach = recycleChildrenOnDetach;&#125; 先来看看源码注释，注释里说了，这个方法是用来设置，当它（LinearLayoutManager）从 RecyclerView 上面 detached 时是否要回收所有的 item。而且，它还建议我们，如果我们项目里有复用 RecyclerViewPool 的话，那么开启这个功能会是一个很好的辅助，它可以将这些 item 回收起来给其他 RecyclerView 用。最后，还指明了一点，开启这个功能的话，当 RecyclerView 恢复时，也就是从 detached 又变回 attached，那么会消耗一定的性能来绘制。 有两种场景会导致 LinearLayoutManager 从 RecyclerView 上被 detached，一种是：setLayoutManager()，而另外一种是：RecyclerView 从视图树上被 remove 掉。 但经过测试（你也可以去看源码），setLayoutManager() 时，如果之前有设置过 LayoutManger，那么内部会自动先去将之前 LayoutManager 的所有 item 回收，然后再给新的 LayoutManager 复用。此时，这个方法并没有什么卵用。 也就是说，上面说了有两种场景会触发到该方法开启的回收工作，但实际上，第一种场景内部默认的工作中就包含了回收工作，那么有没有通过这个方法来开启并没有任何影响。只有第二种场景下，要不要去处理回收工作才是由该方法来控制。 所以我怀疑是不是 Google 工程师太懒了，没有同步更新这个方法的注释。注释的第一句 when 后面应该改成： 1Set whether LayoutManager will recycle its children when RecyclerView is detached from Window. 我觉得这样才比较合理一点，但纯属个人观点哈，也许是我某个地方理解错了。 那么这个方法开启的回收工作到底有什么使用场景呢？ 这类场景还是有的，我举个例子，比如当前页面是通过 ViewPager + Fragment 来实现的，每个 Fragment 里又有 RecyclerView 控件，那么如果当页面布局信息需要更新时，有时候是直接暴力的通过 ViewPager 的 setAdapter() 来刷新，那么此时，旧的 fragment 其实就全被移除掉了，然后 new 了新的 fragment 绘制新的布局信息。 这样，新的 fragment 里新的 RecyclerView 的 item 就又需要全部重新创建了，如果用这个方法开启了回收工作，那么当旧的 fragment 被移除时会触发到 RecyclerView 的 detachedFromWindow 的回调，那么此时这个回收工作就会去将 item 回收到 RecyclerViewPool 中，如果新的 fragment 里的 RecyclerView 复用了这个 RecyclerViewPool，就可以省掉重新创建 item 的消耗，达到直接复用 item 的效果。 小结一下，其实也就是 RecyclerView 有更换新的实例对象时，这个方法开启的回收工作是有一定的好处的。但如果同一个 RecyclerView 实例对象存在从 attached 到 detached 又到 attached 的场景，默认没有开启回收工作时，由于 item 一直都附着在 RecyclerView 上，所以当重新 attached 时就可以直接显示出来了。但如果用该方法开启了回收工作，等于是要重新在 onBind 一次了，这点也是在注释中有提到的。 所以，这是一把双刃剑，有好有坏，有符合的场景下再去开启使用吧。 RecyclerView 内嵌 RecyclerView 另外，LayoutManager 里还有许多 public 的接口，这些方法涉及的方面是 RecyclerView 内嵌 RecyclerView 的场景，比如：collectInitialPrefetchPositions()setInitialPrefetchItemCount()等等，但目前还没搞懂这些相关方法的用法及效果，等待后续补充。 1.2 GridLayoutManager网格样式的布局管理器，同样，先来看看它的构造函数： 123456789101112131415161718//注意看，GridLayoutManager 是继承的 LinearLayoutManger 的public class GridLayoutManager extends LinearLayoutManager &#123; public GridLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); ... &#125; public GridLayoutManager(Context context, int spanCount) &#123; super(context); setSpanCount(spanCount); &#125; public GridLayoutManager(Context context, int spanCount, int orientation, boolean reverseLayout) &#123; super(context, orientation, reverseLayout); setSpanCount(spanCount); &#125; &#125; GridLayoutManager 继承自 LinearLayoutManager， 并在它的继承上补充了 spanCount 的概念，也就是说 LinearLayoutManager 是只支持线性布局，要么一行，要么一列。而 GridLayoutManager 补充了 spanCount 概念后，支持多行或者多列，这就是网格布局了。 使用方面跟 LinearLayoutManager 基本一样，只是在构造函数内需要多传一个 spanCount 参数，来指定多少行或多少列，来看看效果图： 2 行 12GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 2, LinearLayoutManager.HORIZONTAL, false);mRecyclerView.setLayoutManager(gridLayoutManager); 4 列 12GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 4);mRecyclerView.setLayoutManager(gridLayoutManager); 这种网格布局不管是 Tv 应用还是手机应用都挺常见的，Tv 上经常需要有多行或多列的形式来展示各个卡位信息，而手机上一些类似于九宫格之类的布局也可以用这个实现。 但有一些细节同样需要注意一下： 如果指定 HORIZONTAL 样式，即以多行形式进行布局，那么 item 布局的顺序则是以竖直方向来进行，如上图中标注的 item 序号，并且，此时的 RecyclerView 只支持水平方向的滑动，不支持竖直方向。如果指定 VERTICAL 样式，则相反。 其实想想也很容易理解，GridLayoutManager 是继承自 LinearLayoutManager，只是在它基础上补充了 spanCount 概念，滑动的实现还是延用 LinearLayoutManager 的逻辑，那么如果指定水平样式，自然就只有水平方向可滑动。 当设置成水平样式，水平方向可滑动的话，那么水平方向的长度自然就是可根据 item 数量动态增加的，此时自然要按照竖直方向来进行 item 布局，否则还以行为优先的话，哪里知道尽头是哪里，什么时候该换行布局了。 还有一点细节需要注意，当使用 GridLayoutManager 时，RecyclerView 的宽高在 match_parent 和 wrap_content 两种情况下的表现完全不一样，具体表现怎样，有兴趣的可以去试一下，这里就简单举个例子给大伙有个直观印象： 4 列，RecycerView 宽高为 wrap_content 模式，item 设置具体宽高数值 4 列，RecyclerView 宽高为 match_parent 模式，item 设置具体宽高数值 简单点说，就是在 match_parent 模式下，如果指定了水平样式，那么在竖直方向上，GridLayoutManager 会保证让所有行都显示出来，如果 item 指定了具体宽高，全部显示出来还不足以铺满 RecyclerView，那么会自动将剩余空间平均分配到每个 item 之间的间隙。 如果 RecyclerView 高度不足以让所有行都显示出来，那么就会出现 item 重叠现象。这就是在 match_parent 下的表现，至于 wrap_content 则完全根据 item 设定的宽高来考虑了，不会再有自动分配剩余空间或者 Item 重叠之类的工作了。 所以，使用 GridLayoutManager 时，RecyclerView 的宽高模式需要注意一下。 setSpanCount() 通过构造函数指定了 spanCount 后也还可以继续通过该方法进行修改 LinearLayoutManager 的方法 由于是继承关系，所有 LinearLayoutManager 中的四个 findFirstCompletelyVisibleItemPosition() 方法一样可以使用，但在 LinearLayoutManager 一节中对这四个方法所讲的注意事项在这里就更加明显了，使用时需要注意一下。 setSpanSizeLookup() 通常情况下，网格布局样式下，每个小格的大小基本都是一样的，但如果我们想实现如下的效果呢： 区别于常见的网格布局，这里有的小格就占据了多个网格，这种效果就可以通过该方法来实现了。 上述布局是设定了 HORIZONTAL 水平方向的 GridLayoutManager，并且设定为 3 行，默认情况下每个 item 占据一个小格，按照竖直方向依次布局。 通过 setSpanSizeLookup() 方法就可以自定义为每个 item 指定它在竖直方向要占据多少个小格，最多不超过设定的行数，上述例子中每个 item 最多就只能占据 3 行的高度。如果在该列的剩余空间不足 item 设定占据的行数，那么会将该列剩余的空间空闲出来，将该 item 移到下列进行布局。 同样的道理，当设定为 VERTICAL 竖直方向的样式时，那么可以自定义为每个 item 设定要占据的列数，最多不超过指定的列数。 示例： 123456789101112131415161718192021222324GridLayoutManager gridLayoutManager = new GridLayoutManager(this, 3, LinearLayoutManager.HORIZONTAL, false);//自定义item占据的小格大小时需要重写 getSpanSize()，返回值就是占据的小格数量gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; //以下代码仅为上图示例为写，具体场景中应该根据需求具体编写 if (position == 3) &#123; return 2; &#125; if (position == 7) &#123; return 3; &#125; return 1; &#125; //这个方法也很重要，但我还没搞清楚它的具体效果，从注释上来看，该方法是用于指定 item 在该行或该列上具体哪个位置，比如将GridLayoutManager设置为3行水平样式，那么第1个卡位就是在第一列的 0 位置，第2个卡位 1，一次类推。但该方法具体被调用的场景还没理清 @Override public int getSpanIndex(int position, int spanCount) &#123; return super.getSpanIndex(position, spanCount); &#125;&#125;);//官方建议说，如果延用默认的 getSpanIndxe() 的实现逻辑的话，那么建议调用下述方法来进行优化，否则每次布局计算时会很耗性能。 gridLayoutManager.getSpanSizeLookup().setSpanIndexCacheEnabled(true);mRecyclerView.setLayoutManager(gridLayoutManager); 虽然提供了该方法让网格布局可以更加多样化布局，但仍然无法满足一些场景，比如当设定为多行的样式时，此时就只支持自定义每个 item 占据的行数，只有行数！也就是说，所有的卡位顶多只会在高度方面不一样，同一列的卡位的宽度都是一样的。那么，如果需求是五花八门的网格布局，每个卡位都有可能占据多行的情况下又占据多列，用这个就没法实现了。 1.3 StaggeredGridLayoutManager英文直译过来是：交错式的网格布局管理者，不过我还是喜欢网上大伙的说法：瀑布流。 首先，也还是来看看它的构造方法： 12345678910public class StaggeredGridLayoutManager extends RecyclerView.LayoutManager implements RecyclerView.SmoothScroller.ScrollVectorProvider &#123; public StaggeredGridLayoutManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; ... &#125; public StaggeredGridLayoutManager(int spanCount, int orientation) &#123; ... &#125;&#125; 只有两个构造方法，第一个跟 LinearLayoutManager 一样，用于在 xml 布局文件中直接指定 LayoutManager 时用的。 第二个构造方法才是我们经常使用它的入口，两个参数，说白点就是用来设置成多行的瀑布流或者多列的瀑布流样式。 这里顺便提一点不怎么重要的，注意到没有，这里的构造方法是不需要 Context，那么为啥另外两个 LayoutManager 却需要呢？它们之间有什么不同么？ 哈哈哈，答案是没啥不同，LinearLayoutManager 实际上也是不需要 Context 的，看看它的源码就会发现它根本没使用这个参数，可能是早期版本有需要用到，然后新版不需要了，为了让开发者兼容旧代码，就一直留着的吧。 竖直方向瀑布流 12StaggeredGridLayoutManager staggeredGridLayoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);mRecyclerView.setLayoutManager(staggeredGridLayoutManager); 瀑布流的样式在手机应用上比较常见，尤其图片查看相关的应用，在 Tv 应用上这种瀑布流布局就比较少见了。 瀑布流的方向可以选择水平或者竖直，两者只是方向上的区别而已，水平方向的效果图就不贴了。 有点细节需要注意一下，瀑布流样式在布局 item 时，并不是说一定按照某个方向某个顺序来布局。当设定为竖直方向时，以水平方向为顺序，寻找水平方向上最靠近顶端的位置来布局 item，所以并不是说一定按照第 1 列、第 2 列、第 3 列这种顺序来布局。 瀑布流样式和网格样式的区别 也许有人会疑惑，瀑布流就是设置下几行或者几列，然后设定下方向而已。网格样式时不也一样是设置下几行或几列，也一样是要再设置个方向。那么为什么瀑布流不可以直接用网格样式来实现呢？它们两者有什么区别么？ 有去尝试过的就清楚了，这是两种完全不一样的布局样式。下面以两者都设置为竖直方向多列的样式来区分： 网格样式每一行中的所有 item 高度是一致的，不同行可以不一样，但同行的都是一样的，因此它就实现不了瀑布流的样式了；瀑布流所有的 item 高度都允许不一样，所有能实现瀑布流样式。 网格样式支持 item 占据多列的宽度；瀑布流支持 item 占据总列数的宽度，不支持只占据其中几列。 当设置为水平方向样式时，以上结论中行列对调，宽度高度对调。 setFullSpan() 该方法是 StaggeredGridLayoutManager 内部类 LayoutParams 的方法，用这个方法可以设置 item 是否要占据总宽度或总高度，当瀑布流中有某个 item 需要横穿的场景时，可以使用这个方法，效果如下： setOrientation() setSpanCount() 不解释，上面两个 LayoutManager 中介绍过了。 findFirstCompletelyVisibleItemPositions() findFirstVisibleItemPositions() findLastCompletelyVisibleItemPositions() findLastVisibleItemPositions() 作用跟 LinearLayoutManager 的一样，但有些许区别，因为这里需要传入 int[] 类型的参数，返回的结果也是 int[] 类型的。 就以上上图的布局为例，来看下打出来的日志： 得到的结果是个数组，数组的大小就是构造方法中传入的 spanCount。 简单点说，上面四个方法的作用，是以每行或每列为单位来寻找相对应的首个（末个）可见或完全可见的 item。 为什么要这么做呢？ 我想了想，还是想不出比较合理的解释，大概硬套了下，感觉也许是因为瀑布流的布局下是没办法确定 item 的大小的，如果还像 LinearLayoutManager 只寻找首个或末个完全可见的 item 时，也许它并不是处于当前屏的最顶部或最底部，就像上图日志中的 position=7 的 item，它虽然是最后完全可见的 item，但并不是位于最底部，最底部是 6 的 item。 在这种场景下，如果我们的需求是要找到处于最底部的 item 时，如果还只是像 LinearLayoutManager 只寻找最后完全可见的 item 时，就没办法做到了。那么，如果你想说，那干脆将寻找最后一个完全可见 item 改成寻找位于最底部的完全可见的 item，不就好了。那如果这时我的需求是要寻找最后一个 item 而不是最底部的呢？ 所以，瀑布流它直接以每行或每列为单位，将该行/列的首（末）个可见或完全可见的 item 信息都全部给我们，我们需要哪些数据，是最后一个，还是最底部一个，就自行去处理这些信息好了。 以上，纯属个人观点。 setGapStrategy() invalidateSpanAssignments() 这两个方法还没理清它们是干嘛用的，网上有资料说是用于解决滑动时 item 自动变换位置以及顶部留白问题，但我不是很清楚，后续有时间再继续查证。 2. ViewHolderViewHolder 大伙也不陌生了，但没想到我会单独开个小节来讲吧，也是，平时使用时顶多就是继承它，然后重写一下构造方法而已，但其实，它本身携带着很多信息，利用得当的话，可以方便我们处理很多事情。 getAdapterPosition() getLayoutPosition() 将这两个放在一起讲，因为这两个很类似，不理清它们之间的区别的话，很容易搞乱，源码中的注释其实已经说得很清楚了。 在大部分场景下，这两个的值都是一样的，但在涉及到刷新时，由于 Android 是每隔 16.6 ms 刷新一次屏幕，如果在某一帧开始时，adapter 关联的数据源发生的变化，item 被移除或者新增了，我们一般都会调用 notifyDataSetChanged() 或者 notifyItem系列() 方法来刷新，但 RecyclerView 会直到下个帧来的时候才会去刷新界面。 那么，从调用了 notifyDataSetChanged() 到界面刷新这之间就会存在一定的时间差，在这段时间内，数据源与界面呈现的 Item 就不是一致性的了，如果这时候有需要区分实际数据源的 Item 和界面呈现 Item 的需求，那么这两个方法就派上用场了。 getLayoutPosition()：返回的一直是界面上呈现的 Item 的位置信息，即使某个 Item 已经从数据源中被移除。 getAdapterPosition()：当数据源发生变化，且界面已经刷新过后即 onBindViewHolder() 已经被调用了后，返回的值跟 getLayoutPosition() 一致；但当数据源发生变化，且在 onBindViewHolder() 被调用之前，如果调用了 notifyDataSetChanged(), 那么将返回无效的位置标志 -1；如果调用了 notifyItem系列()，那么将返回 Item 在数据源中的位置信息。 示例场景： 12345678910111213141516171819202122232425262728mDataList.remove(0);//1. 场景1mAdapter.notifyDataSetChanged();logPosition();//2. 场景2mAdapter.notifyItemRemove(0);logPosition();//3. 场景3mAdapter.notifyItemRemove(0);mRecyclerView.post(new Runnable() &#123; @Override public void run() &#123; logPosition(); &#125;&#125;)private void logPosition() &#123; for (int i = 0; i &lt; mRecyclerView.getChildCount(); i++) &#123; View view = mRecyclerView.getChildAt(i); int layPosi = mRecyclerView.findContainingViewHolder(view).getLayoutPosition(); int adapterPosi = mRecyclerView.findContainingViewHolder(view).getAdapterPosition(); int oldPosi = mRecyclerView.findContainingViewHolder(view).getOldPosition(); LogUtils.d(TAG, "getLayoutPosition = " + layPosi); LogUtils.d(TAG, "getAdapterPosition = " + adapterPosi); &#125;&#125; 场景1：由于数据源发生变化后，调用了 notifyDataSetChanged()，在这之后马上去遍历界面上的 Item 元素，分别输出 ViewHolder 的几个方法，那么打日志的时间点肯定是在界面刷新之前，所以可以看到这些方法的区别： 0 position 的 Item 明明已经从数据源中被移除掉了，但由于日志打印的时机是在界面刷新之前，因此可以看到通过 getLayoutPosition() 获取到的是界面上还未刷新之前的 Item 的信息，而由于是调用了 notifyDataSetChanged() 去通知，因此 getAdapterPosition() 对于所有 Item 都返回无效的位置标志 -1。 场景2：同理，这次也是在数据源发生变化，界面刷新之前就去打印日志了，但是是通过 notifyItemRemove() 通知，这个时候 getAdapterPosition() 方法返回的值跟上面就有所差别了： 由于这次是通过 notifyItemRemove() 方法来通知的，因此，此时可以通过 getAdapterPositon() 来获取到界面还未刷新之前的 Item 的实际在数据源中的 position 信息。position = 0 的 Item 由于已经从数据源中移除，因此返回 -1，之后的所有 Item 位置自动向前移 1 位。 场景3：上面讲解时一直强调说，只有在数据源发生变化且界面刷新之前，这两个方法才会有所区别，所以场景 3 就来模拟一下，通过 mRecyclerView.post() 的工作由于消息队列的同步屏障机制会被延迟到下一帧的屏幕刷新之后才执行（详情翻看我的历史博客），所以可以来比较下两次日志的区别，你就清楚了： 左边的日志是场景 2 所打的日志，右边的日志是场景 3 下的日志。由于场景 3 将日志的执行时机延迟到下一帧的界面刷新之后，所有，可以看到，界面刷新之后，原本的第一个 Item 就被移除掉了。既然界面已经刷新了，那么数据源和界面的呈现其实就是一致的了，所以 getLayoutPosition() 返回的值就跟 getAdapterPosition() 是一致的了。 小结：说得白点，getLayoutPosition() 会返回 Item 在界面上呈现的位置信息，不管数据源有没有发生变化，界面是否已刷新，总之你在界面上看到的 Item 在哪个位置，这个方法就会返回那个位置信息，注释里也说了，我们大部分场景下，使用这个方法即可。 getAdapterPosition() 的使用场景是，当数据源发生变化，且界面刷新之前，你又需要获取 Item 在数据源中的实际位置时才需要考虑使用该方法。另外，使用该方法时，还要注意你是用哪种 notifyXXX 来通知刷新。这个方法的实际应用场景我还没遇到过，后续有用到再继续补充。 getOldPosition() 这个看注释说是用于处理动画时用的，但还没找到相关的场景，也没理解具体有啥样，后续再继续研究。 getItemId() 返回在 adapter 中通过 getItemId(int position) 为该 item 生成的 id，没有在 adapter 重写那个方法的话，就返回 RecyclerView.NO_ID。 用途在 adapter 一节讲解。 getItemViewType() 返回在 adapter 中通过 getItemViewType() 为该 item 设定的 type，没有在 adapter 重写那个方法的话，默认就是单一类型的 item type。 item type 是用于实现不同 item 样式。 setIsRecyclable() RecyclerView 最大的特性就是它内部实现了一套高效的回收复用机制，而回收复用是以 ViewHolder 为单位进行管理的，每个 item 都会对应一个 ViewHolder，默认都是会参与进回收复用机制中。 但可以通过该方法来标志该 ViewHolder 不会被回收 3. LayoutParamsRecyclerView 自定义了 LayoutParams 内部类，在每个 Item 的 LayoutParams 携带了一些额外的信息，需要的话，我们也可以通过这里来获取这些信息。 123456789public static class LayoutParams extends android.view.ViewGroup.MarginLayoutParams &#123; ... public boolean viewNeedsUpdate() &#123;...&#125; public boolean isViewInvalid() &#123;...&#125; public boolean isItemRemoved() &#123;...&#125; public boolean isItemChanged() &#123;...&#125; public int getViewLayoutPosition() &#123;...&#125; public int getViewAdapterPosition() &#123;...&#125;&#125; 公开的接口有以上几个，也就是说，我们可以通过 LayoutParams 获取到 item 的 position 信息、状态信息，是否需要刷新，是否被移除等等。 更多的应用场景留待后续补充。 4. Adapteradapter 大伙肯定是最熟悉的了，写 RecyclerView 打交道最多的也就是 adapter 了，所以一些基本知识我就一笔带过了，本节着重介绍各种可选功能。 onCreateViewHolder() onBindViewHolder() getItemCount() RecyclerView.ViewHolder 以上是写一个 adapter 时必须实现的四点，它们决定了 item 长啥样，填充啥数据，以及有多少个 item，有了这些信息，一个 RecyclerView 列表也就出来了。 notifyDataSetChanged() notifyItemChanged() notifyItemXXX() 系列 以上是用于刷新 item，当数据源发生变化时，我们手动去刷新 item。官方说了， item 的更新分两种，一种是数据需要更新，这类刷新不涉及到 item 的位置变化；而另一种属于结构刷新，就是涉及到 item 的位置变化。 使用 notifyDataSetChanged() 时，它不管你分哪种形式的刷新，强制所有 item 重新绑定数据，重新布局操作。 以上都属于常用的基本功能，一句话带过，下面介绍一些可选功能： onViewRecycled() onViewAttachedFromWindow() onViewDetachedFromWindow() onAttachedToRecyclerView() onDetachedFromRecyclerView() 这些方法基本都是 item 或 adapter 的一些生命周期的回调，所以分别来看看每个方法都是什么时候会被回调的，可以用来处理什么场景，做些啥工作： onViewRecycled()：当 ViewHolder 已经确认被回收，且要放进 RecyclerViewPool 中前，该方法会被回调。 首先需要明确，RecyclerView 的回收机制在工作时，会先将移出屏幕的 ViewHolder 放进一级缓存中，当一级缓存空间已满时，才会考虑将一级缓存中已有的 ViewHolder 移到 RecyclerViewPool 中去。所以，并不是所有刚被移出屏幕的 ViewHoder 都会回调该方法。 另外，注释中也说了，该方法的回调是在 ViewHolder 放进 RecyclerViewPool 中前，而 ViewHolder 在放进 Pool 中时会被 reset，因为上一节中也说过，其实 ViewHolder 本身携带着很多信息。那么，在该方法回调时，这些信息还没被重置掉，官方建议我们可以在这里释放一些耗内存资源的工作，如 bitmap 的释放。 onViewAttachedFromWindow()onViewDetachedFromWindow()： RecyclerView 本质上也是一个 ViewGroup，那么它的 Item 要显示出来，自然要 addView() 进来，移出屏幕时，自然要 removeView() 出去，对应的就是这两个方法的回调。 所以，当 Item 移出屏幕时，onViewRecycled() 不一定会回调，但 onViewDetachedFromWindow() 肯定会回调。相反，当 Item 移进屏幕内时，另一个方法则会回调。 那么，其实，在一定场景下，可以通过这两个回调来处理一些 Item 移出屏幕，移进屏幕所需要的工作。为什么说一定场景下呢，因为如果调用了 notifyDataSetChanged() 的话，会触发所有 Item 的 detached 回调先触发再触发 onAttached 回调。 onAttachedToRecyclerView()onDetachedFromRecyclerView()： 这两个回调则是当 RecyclerView 调用了 setAdapter() 时会触发，旧的 adapter 回调 onDetached，新的 adapter 回调 onAttached。 我们同样可以在这里来做一些资源回收工作，更多其他应用场景留待后续补充。 registerAdapterDataObserver() unregisterAdapterDataObserver() 用于注册监听 notifyXXX() 系列方法的事件，当调用了 notifyXXX() 系列的方法时，注册监听后就可以接收到回调。 setHasStableIds() getItemId() 这两方法看注释是说用于回收复用机制中，给 ViewHoler 设置一个唯一的标识符，但具体的使用场景还不清楚，后续有用到，再补充。 另，setHasStableIds() 必须在 setAdapter() 方法之前调用，否则会抛异常。 5. RecyclerView5.1 addOnItemTouchListener()咋一看到这个方法，我还以为 RecyclerView 也把 item 的点击事件封装好了，终于不用我们自己去写了呢。看了下源码注释才发现，这个方法的作用是用于根据情况是否拦截触屏事件的分发。先看一下它的参数类型：OnItemTouchListener 12345public interface OnItemTouchListener &#123; boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e); void onTouchEvent(RecyclerView rv, MotionEvent e); void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept);&#125; 是不是感觉接口里的方法很熟悉，没错，就是触屏事件分发流程中的拦截和处理的两个方法。 通常我们都说在自定义 View 中重写这几个方法来将触屏事件拦截，交由自己处理。RecyclerView 也是一个 View，如果你有 RecyclerView 需要拦截触屏事件自己处理的需求，那么你可以选择继承 RecyclerView，也可以选择调用这个方法。 5.2 addOnScrollListener()RecyclerView 是一个列表控件，自然会涉及到滑动，所以它提供了滑动状态的监听接口，当我们需要在滑动状态变化时相对应的工作时，可以调用该方法注册滑动监听。来看看它的参数：OnScrollListener 1234567891011public abstract static class OnScrollListener &#123; /** * Callback method to be invoked when RecyclerView's scroll state changes. * * @param recyclerView The RecyclerView whose scroll state has changed. * @param newState The updated scroll state. One of &#123;@link #SCROLL_STATE_IDLE&#125;, * &#123;@link #SCROLL_STATE_DRAGGING&#125; or &#123;@link #SCROLL_STATE_SETTLING&#125;. */ public void onScrollStateChanged(RecyclerView recyclerView, int newState)&#123;&#125; public void onScrolled(RecyclerView recyclerView, int dx, int dy)&#123;&#125;&#125; onScrolled()：滑动的实现本质上就是每一帧时要么通过动画，要么通过修改属性，一帧帧内处理一小段滑动，整个过程连起来就是一个流畅的滑动效果。这个方法就是每帧内处理的滑动距离，理想状态下，每帧都会回调一次，直到滑动结束。 如果想得到滑动的距离，方向的话，可以在这个方法里做。 onScrollStateChanged()：该方法则是滑动状态变化时的回调，一共设置了三种状态： SCROLL_STATE_IDLE：停止滑动时的状态 SCROLL_STATE_DRAGGING：手指拖动时的状态 SCROLL_STATE_SETTLING：惯性滑动时的状态（这是我的理解） 在手机应用上和 Tv 应用上，这些状态的回调还是有所区别的，所以分开来说一下： 手机应用： 手机上的 RecyclerView 列表控件，通常都是通常手指拖动来触发滑动的，因此在手指触摸并拖动的那个时刻，这个方法会被回调，参数传入 SCROLL_STATE_DRAGGING 表示进入拖动状态。 当手指放开的时候，分两种情况，一是手指放开后 RecyclerView 又根据惯性滑动了一段距离，只要有稍微滑动就算，那么这个时候进入惯性滑动时该方法会被回调，参数传入 SCROLL_STATE_SETTLING 表示进入了惯性滑动状态。当最终停止滑动后，该方法还会被回调，参数传入 SCROLL_STATE_IDLE。 另外一种情况是，手指放开后，RecyclerView 并没有任何滑动了，通常是手指很慢的拖动情况下放开，这时候该方法就会只回调一次，参数传入 SCROLL_STATE_IDLE，因为在手指还没放开前就已经停止滑动了，放开后更不会滑动，所以直接进入停止滑动状态。 所以，在手机应用上，ReyclerView 的滑动状态变化有两种，一是从 SCROLL_STATE_DRAGGING 到 SCROLL_STATE_SETTLING 再到 SCROLL_STATE_IDLE；另外一种是直接从 SCROLL_STATE_DRAGGING 到 SCROLL_STATE_IDLE。 Tv 应用： 由于 Tv 应用没有触摸事件，只有遥控器事件，因此 RecyclerView 滑动的触发都是由遥控器方向键操作后由于焦点的变化来触发的，所以在 Tv 应用上不会有 SCROLL_STATE_DRAGGING 这个状态。 每次滑动都是从 SCROLL_STATE_SETTLING 到 SCROLL_STATE_IDLE。 两者有所区别，需要注意一下，如果从事 Tv 应用开发的话。 5.3 setHasFixedSize()看方法注释，它是说，当你能够确定后续通过 notifyItemXXX() 系列方法来刷新界面时，RecyclerView 控件的宽高不会因为 item 而发生变化，那么这时候可以通过该方法来让 ReyclerView 每次刷新界面时不用去重新计算它本身的宽高。 从代码层面上来看，也就是说，当调用该方法设置了后，之后通过 notifyItemXXX() 系列方法刷新界面时，RecyclerView 的 onMeasure(), onLayout() 就不会被调用了，而是直接调用 LayoutManager 的 onMeasure()。 但这样做具体有什么好处，提高性能一点，但其他的就不清楚了。想了想，当 ReyclerView 控件的宽高模式是 match_parent 时，其实这个方法可以使用，因为此时它的宽高就不会受到 item 的因素影响了。如果模式为 wrap_content，那这个方法就不要用了。 5.4 setLayoutFrozen()这方法可以禁掉 RecyclerView 的布局请求操作，而 RecyclerView 的滑动，item 的添加或移除本质上都会触发 RecyclerView 的重新测量、布局操作。 所以，调用该方法，其实等效于关闭了 ReyclerView 的刷新，不管数据源发生了何种变化，不管用户滑动了多长距离，都不会去刷新界面，看起来就像是不响应一样，但等到再次调用该方法参数传入 false 后，就会立马去根据变化后的数据源来刷新界面了。 使用场景还是有的，假如有些场景暂时不想让 RecyclerView 去刷新，比如此时有其他动画效果正在执行中，RecyclerView 刷新多少会有些耗时，万一导致了当前动画的卡顿，那么体验就不好了。所以，这个时候可以暂时将 ReyclerView 的刷新关闭掉，但后面记得要重新开启。 5.5 setPreserveFocusAfterLayout()这个还没搞清它的应用场景是什么，注释是说，当在进行布局工作时，有些时候，会由于 item 的状态发生改变，或者由于动画等原因，导致焦点丢失。通过该方法可以再这些工作之后，再继续保持之前 item 的焦点状态。这个方法默认就是开启的。 但我测试了下，不管有没有开启这个方法，notifyDataSetChanged() 时，焦点仍然会乱飘，后续再继续查证。 5.6 findChildViewUnder()方法参数是 (float x, float y)，作用是查找指定坐标点 (x, y) 落于 RecyclerView 的哪个子 View 上面，这里的坐标点是以 RecyclerView 控件作为坐标轴，并不是以屏幕左上角作为坐标原点。 具体应用场景，目前还没遇到过，后续补充。 5.7 findContainingItemView()该方法参数是 （View view），作用正如命名上的理解，查找含有指定 View 的 ItemView，而 ItemView 是指 RecyclerView 的直接子 View。 通常，RecyclerView 的 Item 布局都不会简单到直接就是一个具体的 TextView，往往都挺复杂的，比如： Item 布局的结构至少如下： 1234&lt;RelativeLayout&gt; &lt;ImageView/&gt; &lt;TextView/&gt;&lt;/RelativeLayout&gt; 这种 item 已经算是很简单的了，那么如果我们当前拿到的是 TextView 对象，通过该方法就可以找到这个 TextView 的根布局，即 RecyclerView 的直接子 View，这里是 RelativeLayout 对象。 应用场景： 我想到一种应用场景，通常我们点击事件都是作用于具体的某个 View，比如上面的 TextView，那我们在点击事件的回调中就只能拿到 TextView 对象而已。而通过这个方法，我们可以拿到这个 TextView 所属的 ItemView。拿到 ItemView 之后可以做些什么呢？ 看需求场景，反正总有些场景是需要用到根布局的。还有一点就是，RecyclerView 内部其实自定义了一个 LayoutParams，作用于它的直接子 View。所以只要我们可以拿到 RecyclerView 的直接子 View，就可以拿到它对应的 LayoutParams，那么就可以通过 LayoutParams 拿到一些这个 item 的信息，比如 position 等等。 5.8 findContainingViewHolder()该方法参数是 （View view），作用跟上述方法类似，用于查找含有指定 View 的 ItemView 所对应的 ViewHolder。 这里就不展开介绍了，该方法跟上述的方法基本一模一样，区别就仅仅是一个用于查找 ItemView，一个用于查找 ItemView 对应的 ViewHoler。 至于应用场景，拿到 ViewHolder 能做的事就更多了，而是 LayoutParams 提供的信息其实内部也是去 ViewHolder 中拿的，所以实际上 Item 携带的各种信息基本都在 ViewHolder 上面了。 5.9 findViewHolderXXX()既然 ViewHolder 携带着大量 Item 的相关信息，RecyclerView 自然也就提供了各种方式来获取 ViewHolder，这个系列的方法如下： findViewHolderForAdapterPosition() findViewHolderForLayoutPosition() findViewHolderForItemId() findContainingViewHolder() 通过 position, id, view 都可以获取到对应的 ViewHolder 对象。 6. RecyclerRecycler 是 RecyclerView 的一个内部类，主要职责就是处理回收复用相关工作的。 回收复用的单位是 ViewHolder，至于 Item 移出屏幕是怎样回收，回收到哪里，Item 移进屏幕时是怎样复用，整个流程是先复用再回收，还是先回收再复用，还是两边同时进行等等一系列的工作都是交由 Recycler 来处理。 关于回收复用机制的部分原理，基于滑动场景解析RecyclerView的回收复用机制原理](https://www.jianshu.com/p/9306b365da57)，感兴趣的可以先去看看。 本篇侧重点是介绍各个接口的含义和使用场景，至于回收复用机制，后续肯定还会继续深入去分析，敬请期待。 6.1 setItemViewCacheSize()有看到上面链接那篇文章的应该就清楚，当 item 被移出屏幕外时，其实这个 item 的 ViewHolder 会被回收掉，而 Recycler 里有一种分级缓存的概念。 分级缓存，说得白点，就是不同的容器，容器之间有优先级，回收时先将 ViewHolder 缓存到高优先级的容器中，容器满了的话，那就将容器腾出个位置来，被腾出来的 ViewHolder 这时就可以放到优先级较低的容器中。分级缓存的概念就是这样。 移出屏幕的 ViewHolder 会被缓存到两个容器中，按优先级高到低分别是：mCachedViews 和 mRecyclerPool 该方法就是用于设置 mCachedViews 容器的大小，默认值为 2，可通过该方法随时改变缓存容器的大小。 应用场景： 要搞清楚应用场景，那得先明白 mCachedViews 这一级的缓存有什么作用，建议还是到上面给出的链接的那篇文章看一看，就明白了。 这里大概说一下，个人对于 mCachedViews 这一级缓存的理解：这一级的缓存仅仅就只是用来缓存而已，里面存储的 ViewHolder 并没有通用的能力。换句话说也就是，只有原来位置的 Item 可复用这级容器里的 ViewHolder，其他位置的 Item 没办法使用。效果就好像是 ViewPager 之类的缓存一样，所以我才说它仅仅只有缓存的功能。 这样能达到的效果就是：当某个 Item 刚被移出屏幕外，下一步又立马移进屏幕时，此时并不会去触发到 Adapter 的 onBindXXX 的调用，也就是说，这一级缓存里的 ViewHolder 可直接 addView 到 RecyclerView 上面，不需要重新去设置数据，因为它原本携带的数据都还处于正常状态，并没有被重置掉。 6.2 setViewCacheExtension()当 Item 要被移进屏幕时，Recycler 会先去那些不需要重新调用 onBindViewHolder() 的缓存容器中寻找是否有可直接复用的 Item，如果没找到，那么会接着调用开发者自定义扩展的复用工作，如果在这里也没找到，那么才会去 RecyclerViewPool 中根据 type 来寻找可复用的，再没找到最后就直接调用 onCreateViewHolder() 新建一个来使用。 先来看看开发者要怎么自定义扩展： 12345678910111213/** * 我删了一些注释，留下一些困惑的点 * 1. Note that, Recycler never sends Views to this method to be cached. It is developers * responsibility to decide whether they want to keep their Views in this custom cache * or let the default recycling policy handle it. */public abstract static class ViewCacheExtension &#123; /** * 2.This method should not create a new View. Instead, it is expected to return * an already created View that can be re-used for the given type and position. */ public abstract View getViewForPositionAndType(Recycler recycler, int position, int type);&#125; 看着好像很简单是吧，就只需要实现一个方法，返回指定 position 和 type 下的 Item 的 View 即可，网上所有分析到回收复用机制时也全部都是这么一笔带过。 但实际上，存在很多困惑点，这个到底该怎么用？ 注释 1 里说了，Recycler 永远也不会将 ItemView 发送到这个类里来缓存，然后还说由开发者自行决定是要自己维护这些缓存还说交由 Recycler 来处理。 困惑1：交由 Recycler 来处理我能理解，毕竟 Recycler 只在复用的过程中开了个接口给开发者扩展使用，但回收的过程并没有开任何接口给开发者扩展。也正是基于这点，我就不理解官方说的让开发者自行维护，怎么维护？ 注释 2 中，官方告诉我们在这个方法中，不要去新建一个新的 ItemView，而是直接从旧的里面拿一个复用。 困惑2：我又不知道怎么自己去维护 ViewHolder，那不新建一个 ItemView 又该如何使用，直接借助 Recycler？但 Recycler 不是只开放了 getViewForPosition()？本来内部在复用时就是自己调了这个方法，我们在这个方法内部走到开发者扩展自定义扩展的流程时再重新调一下？那不是就陷入嵌套循环里了？有什么意义或者应用场景么？ 最最困惑的一点，国内居然找不到任何一篇讲解如何使用这个自定义缓存的相关文章！？ 不清楚是由于他们文章的标题太过抽象没加入我的关键词过滤中，还是我关键词提取太烂，总之就是找不到任何一篇相关文章。所以，这小节先埋个坑，我打算后续抽时间自己来研究一下，到底应该如何使用自定义 RecyclerView 的缓存策略，到底都有哪些应用场景。 6.3 setRecycledViewPool()最后一级缓存就是 RecyclerViewPool，这个容器有三个特性： 缓存到 RecyclerViewPool 中的 ViewHolder，携带的信息都会被重置，因此从这个容器中取 ViewHolder 去复用时，都会触发 onBindViewHolder() 重新绑定数据。 多个 RecyclerView 可共用同一个 RecyclerViewPool 容器。 该容器以 Item 的 type 区分缓存，每种 type 的默认存储容量为 5。 一般当我们需要修改这个缓存容器的大小，或者需要设置多个 RecyclerView 共用一个 RecyclerViewPool 时才需要调用到该方法。并且，官方在注释中也给出一种应用场景：使用 ViewPager 时各页面中的 RecyclerView 有相同的 Item 布局结构。 应用场景： 我们来举个例子，就不用官方给的例子了，我额外补充一种场景：界面上存在多行可分别左右滑动的列表控件，即每行是一个 RecyclerView，每行里的 Item 布局样式一致，这时候就可以让每一行的 RecyclerView 共用一个 RecyclerViewPool 缓存池了，如下： 以上布局的实现是外层一个竖直方向的 RecyclerView，它的每一个 Item 都是占据一行的水平方向的 RecyclerView，也就是嵌套 RecyclerView 的方式，实现可上下滑动且每一行均可左右滑动的效果。 这里的每一行的 RecyclerView 里的每个 Item 项的样式均一致，那么这种场景下，可以让每一行的 RecyclerView 都共用同一个 RecyclerViewPool 缓存池。这样的好处是，当某一行被移出屏幕时，可以将这一行的每个卡位都回收起来，供其他行使用，而不至于每一行每次都是重新创建。 但有些注意事项： 外层 RecyclerView 缓存复用的应该仅仅是每一行的 RecyclerView 控件而已，不应该包括每一行 RecyclerView 内部的卡位控件，因为各行卡位的个数并不一定相同。 对于外层 RecyclerView 来说，它的 Item 是每一行的 RecyclerView 控件，所以当某一行被移出屏幕时，它仅仅是将这一行的 RecyclerView 控件从它本身 remove 掉，并回收起来。因此，此时这一行的 RecyclerView 还是携带着它的卡位子 View 的，所以需要我们手动去将这些卡位回收、并从父控件上 remove 掉。 这个操作可以在外层 RecyclerView 的 adapter 的 onViewRecycled() 回调中进行，也可以在内层每个 RecyclerView 的 adapter 的 onViewDetachedFromWindow() 回调中进行。 移除并回收卡位可通过 setAdapter(null) 配合 RecyclerView 本身的 removeAllView() 或者 LayoutManager 的 removeAllView() 实现 。或者直接使用 LinearLayoutManager 的 setRecycleChildrenOnDetach() 功能。 6.4 setRecyclerListener()12345678910//RecyclerView$Recycler#void dispatchViewRecycled(ViewHolder holder) &#123; if (mRecyclerListener != null) &#123; mRecyclerListener.onViewRecycled(holder); &#125; if (mAdapter != null) &#123; mAdapter.onViewRecycled(holder); &#125; ...&#125; 所以，这个方法设置的监听 Item 的回收，回调的时机跟 adapter 的 onViewRecycled() 一模一样，都是在 mCachedViews 容器满了之后，放入 RecyclerViewPool 之前被回调。 7. ItemAnimatorRecyclerView 是支持对每个 item 做各种各样动画的，那么什么时候才该去执行这些 item 动画呢？说白了，也就是 adapter 数据源发生变化的时候，那么变化的方式无外乎就是四种：add, remove, change, move。相对应的，也就是这些状态时的 item 动画。 所以当要自定义实现 ItemAnimator 时，需要实现的方法如下： 12345678public abstract boolean animateAppearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo); public abstract boolean animateDisappearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);public abstract boolean animatePersistence(@NonNull ViewHolder viewHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);public abstract boolean animateChange(@NonNull ViewHolder oldHolder, @NonNull ViewHolder newHolder, @NonNull ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo);public abstract void runPendingAnimations();public abstract void endAnimation(ViewHolder item);public abstract void endAnimations();public abstract boolean isRunning(); 看起来，要实现一个自定义的 Item 好像很复杂，要实现这么多方法。网上这方面的文章已经非常多了，也都跟你说清了每个方法的含义是什么，在这里写些什么，甚至流程都帮你列出来了。 但大伙会不会好奇，这帮牛人是咋这么清楚的呢？ 其实，Google 内部已经封装好了一个默认动画的实现，有时间大伙可以自己过一下源码，看看默认动画是怎么做的，理解清楚了后，举一反三下，其实也就懂了。 我目前也不懂，但我就是带着这么一种想法，也是打算这么去做的。虽然跟着大神的文章，最后确实能实现想要的效果，但其实掌握并不是很牢，并不大清楚为什么需要这么写，只是因为大神说这里这么写，然后就这么写了。 所以，有时间有精力，还是建议深入源码中去学习，自己梳理出来的知识终归是自己的。 7.1 SimpleItemAnimator当 adapter 数据源发生变化，通知了 RecyclerView 去刷新界面时，RecyclerView 会去通知 ItemAnimaotr 此时相应的动画行为。 比如 add 了一个 Item，那么就会去触发 ItemAnimator 的 animateAppearance() 方法，并将这个 ItemView 在刷新前后不同的信息，如默认携带的信息是 RecyclerView 内部类 ItemHolderInfo，这个类里有关于这个 Item 的坐标信息。 那么，开发者就可以在这些回调方法里自行判断刷新前后的 Item 的不同信息来决定是否需要进行相对应的动画。 而 SimpleItemAnimator 其实就是帮忙处理这件事，也就是说，它在四个回调中，如 animateAppearance() 中，根据 Item 前后的坐标信息来判断该 Item 需要进行的动画类型。 比如 animateAppearance()： 1234567891011@Overridepublic boolean animateAppearance(@NonNull ViewHolder viewHolder, @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo) &#123; if (preLayoutInfo != null &amp;&amp; (preLayoutInfo.left != postLayoutInfo.left || preLayoutInfo.top != postLayoutInfo.top)) &#123; // slide items in if before/after locations differ return animateMove(viewHolder, preLayoutInfo.left, preLayoutInfo.top, postLayoutInfo.left, postLayoutInfo.top); &#125; else &#123; return animateAdd(viewHolder); &#125;&#125; 对于 RecyclerView 回调了 animateAppearance() 方法后，SimpleItemAnimator 内部对其进行的分类，根据参数判断，最终是要执行 animateMove() 类型的动画，还是执行 animateAdd() 类型的动画。 同理，对于另外三个回调方法，SimpleItemAnimator 内部同样对其进行了封装处理，简单的通过刷新前后 Item 的坐标信息来进行动画类型的区分。 所以，这个类并没有实现任何动画的逻辑，它只是将动画的准备工作做好，简化开发者开发。所以，如果想要自定义 ItemAnimator，其实没必要从零开始继承自 ItemAnimator 自己写，是可以借助 SimpleItemAnimator 这个类的。 7.2 DefaultItemAnimatorRecyclerView 默认有提供 Item 的动画，而 SimpleItemAnimator 只是处理跟动画无关的准备工作，那么具体的默认动画的实现就是在 DefaultItemAnimator 这个类中实现的了。 先看一下这个类的结构： 它是继承自 SimpleItemAnimator 的，我们如果想要自定义实现一些 Item 动画，需要写的东西，大概就跟上图类似。 想要自定义 Item 动画，真的可以来参考、借鉴这个类的实现，能学到的东西很多。 我也还没深入去仔细学习，大概过了一眼，这里就大概说下： 这个类用了很多集合来维护各种不同类型的动画，在四个 animateXXX() 方法中通过集合记录相对应类型的动画和做了动画的初始化工作。 然后在 runPendingAnimations() 方法中，依次遍历这些集合，将记录的动画取出来执行，动画的实现方式是通过 View.animate() 方式实现，这种方式的动画本质上是借助了 ValueAnimator 机制，在每帧的回调过程中手动调用 setXXX() 来实现的动画效果。具体分析可参考一篇文章：View.animate()动画ViewPropertyAnimator原理解析。 大体上的流程原理就是这样，当然，这个类做的事肯定不止这些，还包括了集合的清理维护工作，动画的维护等等，所以很值得去借鉴学习一番。但这里就只给出大概的流程，本篇重点不在这里。 下面就来列举下，默认实现的各类型的动画分别是什么： animateAdd -&gt; 透明度 0 ~ 1 的动画，默认动画时长 120 ms animateChange -&gt; 涉及两个 ItemView，旧的跟新的，默认动画时长 250ms 旧 ItemView：透明度从原有值 ~ 0，位置从原坐标移动到新 ItemView 坐标的动画组合 新 ItemView：透明度从 0 ~ 1，位置从旧 ItemView 坐标移动到新坐标的动画组合 animateMove -&gt; 从原坐标位置移动到新坐标位置的移动动画，默认动画时长 250 ms animateRemove -&gt; 从原有透明度 ~ 0 的动画，默认动画时长 120 ms 所以，RecyclerView 默认的 Item 动画其实也就透明度和移动动画两种，而且大多数情况下都只是单一的动画，只有 change 类型时才会是组合动画。 效果展示： 首先，可通过下列方式修改动画时长，这里将动画时长延长，方便查看效果 1mRecyclerView.getItemAnimator().setAddDuration(1000); 可以看到，动画基本就只有透明度动画跟移动动画两种。 另外，只有通过 notifyItemXXX() 方式更新数据源时才会触发动画行为，如果是通过 notifyDataSetChange() 方式，则不会触发动画。 8. ItemDecorationRecyclerView 支持为每个 Item 之间自定义间隔样式，是要空段距离，还是要以分割线隔开，还是要唯美唯幻的边框，想长啥样都行，自己写得出来就可以了，它给我们提供了这个接口。 本节就先介绍下系统内置的几种样式，内置里一共有三个类继承该类，分别是 DividerItemDecoration，ItemTouchHelper，FastScroller。前两个都是 public 权限，最后一个包权限，下面分别看看它们都有哪些效果，最后再来看看如何自定义。 8.1 DividerItemDecoration看一下这个类的注释： 123456789101112131415161718192021222324/** * DividerItemDecoration is a &#123;@link RecyclerView.ItemDecoration&#125; that can be used as a divider * between items of a &#123;@link LinearLayoutManager&#125;. It supports both &#123;@link #HORIZONTAL&#125; and * &#123;@link #VERTICAL&#125; orientations. * &lt;pre&gt; * mDividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(), * mLayoutManager.getOrientation()); * recyclerView.addItemDecoration(mDividerItemDecoration); * &lt;/pre&gt; */public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; /** * Sets the &#123;@link Drawable&#125; for this divider. * * @param drawable Drawable that should be used as a divider. */ public void setDrawable(@NonNull Drawable drawable) &#123; if (drawable == null) &#123; throw new IllegalArgumentException("Drawable cannot be null."); &#125; mDivider = drawable; &#125; ...&#125; 怎么用，类注释也给我们示例了，有点可惜的是，它只能用于 LinearLayoutManager 这种布局，而 GridLayoutManager 继承自 LinearLayoutManager，所以它也可以用，但需要注意的是，它只有一个方向会生效。来看看如何使用和效果： 123456789DividerItemDecoration itemDecoration = new DividerItemDecoration(mContext, LinearLayoutManager.HORIZONTAL);itemDecoration.setDrawable(getResources().getDrawable(R.drawable.divider_space));mRecyclerView.addItemDecoration(itemDecoration);//R.drawable.divider_space&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;size android:width="20dp" android:height="20dp"/&gt;&lt;/shape&gt; 我们在 xml 中写宽度为 20dp 的空隙，然后调用 setDrawable() 应用，看看效果： 这样就可以达到将 item 隔离开的效果了，中间这个空隙的样式你可以自己通过 xml 写，也可以直接使用图片，都可以，只要是 Drawable 类型的即可。 虽然说，RecyclerView 不像 ListView 只要设置个属性就可以达到设置 Item 之间空隙的样式，但它也内置了基本的实现，其实也已经方便了我们的使用。 8.2 ItemTouchHelper这是一个工具类，也是 Google 为了方便开发人员实现 item 的拖拽和移动等等效果所提供的一个辅助工具类。借助这个类可以很容易实现 item 的侧滑删除、长按拖拽等功能。 由于这部分我没有研究过，日常也较少接触，所以暂时先从网上搜索一篇文章，以下的效果图来自大神的博客，会给出链接，侵权删。后续有接触相关需求时再自行来研究一番。 推荐博客： ItemTouchHelper源码分析 8.3 FastScroller这个类也是继承自 ItemDecoration，但它的类权限只是包权限，不开放给外部使用，稍微看了下注释，说是用来处理动画以及快速滑动相关的支持，具体原理是什么，如何生效，留待后续深入研究时再来分析。 8.4 自定义ItemDecoration上面说过系统默认提供的 DividerItemDecoration 只支持用于 LinearLayoutManager，而如果用于 GridLayoutManager 时，只有一个方向会生效，那么下面我们就以 GridLayoutManager 为例，来看看，如何自定义写 ItemDecoration。 用 GridLayoutManager 实现一个四列的布局，然后让除了四个边的 Item 外，内部的每个 Item 之间相互间隔 20 dp 的空隙。为了能更明显看出，将 20dp 的空隙用红色绘制出来。 先来看下效果： 4 列布局 &amp; 2 行布局 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MyItemDecoration extends RecyclerView.ItemDecoration &#123; private int spanCount;//几行或几列 private int orientation;//方向 private int itemSpace;//空隙大小 private Rect mBounds = new Rect(); private Paint mPaint;//用来将空隙绘制成红色的画笔 public MyItemDecoration(GridLayoutManager gridLayoutManager) &#123; spanCount = gridLayoutManager.getSpanCount(); orientation = gridLayoutManager.getOrientation(); initPaint(); &#125; private void initPaint() &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setColor(Color.RED); &#125; public void setItemSpace(int space) &#123; itemSpace = space; &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; c.save(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds); c.drawRect(mBounds, mPaint); &#125; c.restore(); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; //获取当前view的layoutPosition int itemPosition = parent.getChildLayoutPosition(view); //计算该View位于哪一行哪一列 int positionOfGroup = itemPosition % spanCount; int itemGroup = itemPosition / spanCount; //根据不同方向进行不同处理，最终效果都要实现除四周的View 外，内部的View之间横竖都以相同空隙间隔开 //实现方式，以水平方向为例： //每个view的left和bottom都设置相同间隙 //去掉第1列的left，和最后一行的bottom，也就实现了除四周外内部view都以相同间隙空隔开 if (orientation == LinearLayoutManager.HORIZONTAL) &#123; outRect.set(itemSpace, 0, 0, itemSpace); if (itemGroup == 0) &#123; outRect.left = 0; &#125; if (positionOfGroup == (spanCount - 1)) &#123; outRect.bottom = 0; &#125; &#125; else if (orientation == LinearLayoutManager.VERTICAL) &#123; outRect.set(0, itemSpace, itemSpace, 0); if (itemGroup == 0) &#123; outRect.top = 0; &#125; if (positionOfGroup == (spanCount - 1)) &#123; outRect.right = 0; &#125; &#125; &#125;&#125; 注意事项：由于 GridLayoutManager 会根据设置的 Orientation 方向，默认为 VERTICAL 数值方向，以及 RecyclerView 的宽高模式来决定是否自动将某一方向的空隙平均分配给各 Item，这点需要注意一下。 以上的例子想说明，如果要自定义写 Iiem 间的空隙，那么关键点在于重写两个方法： getItemOffsets() onDraw() 第 1 个方法会携带很多参数，最重要的是 outRect 这个参数，它是一个 Rect 类型的对象，重写这个方法并设置了这个 outRect 的 left, top, right, bottom，就相当于设置了对应这个 view 的四周分别有多大的空隙。 其他的参数是用来给我们辅助使用，如果不需要区分对待，每个 item 的四周都是同样的间隔空隙，那直接设置 outRect 即可。 如果需要像上述例子那样，要求四周的 Item 的间隙要区别于内部 item 的间隙，那么就需要判断出这个 View 的位置，因此可以通过其他参数辅助配合实现。 onDraw() 这个方法就是用于绘制，注意这个方法参数只给了 RecyclerView，而绘制 item 的 Decoration 是针对于每个 item 而言的，所以内部需要通过遍历子 View 来对每个 item 进行绘制操作。 当然，我这里写得很粗糙，考虑到性能优化方面，绘制过度方面等等因素，通常是需要使用到 canvas.clipRect()。这部分代码建议可以参考 DividerItemDecoration 内部的实现。 9. OnFlingListenerRecyclerView 是可滑动控件，在平常使用过程中，我们可能就是上滑，下滑，左边滑滑，右边滑滑，能够刷新更多列表即可，通常都没太过去注意到滑动的细节。 但其实，滑动策略也是支持多样化的。 比如，如果想要实现不管以多大的加速度滑动，滑多长距离，最终停下来时都系统有个 ItemView 是居中显示的效果。 再比如，只希望翻页滑动，当手指滑动距离小于翻页时，自动滑回原位进行翻页等等。 这些滑动策略其实就可以直接借助内置的两个类来实现：LinearSnapHelper 和 PagerSnapHelper ps：本来以为这种滑动策略也是支持由焦点触发的滑动行为的，最后测试时才发现，原来只支持手指触摸式的滑动行为。由于我是搞 Tv 应用开发的，Tv 应用没有触摸事件，只有遥控器事件，滑动是由于焦点的变化触发的滑动行为。而在 Tv 上，Item 居中的需求也非常常见，但利用这个是无法实现的。所以，我就先不打算深入了解这块了，后续有时间再来慢慢研究。附上鸿神公众号中的一篇文章，大伙看这篇就行了。 Android中使用RecyclerView + SnapHelper实现类似ViewPager效果 9.1 SnapHelper9.2 LinearSnapHelper9.3 PagerSnapHelper]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android判断当前应用是否开启消息通知]]></title>
    <url>%2Fposts%2F7299f542.html</url>
    <content type="text"><![CDATA[当APP有推送功能时，需要判断当前app在手机中是否开启了允许消息推送，否则即使添加了推送代码仍然收不到通知 12345678910private boolean isNotificationEnabled(Context context) &#123; boolean isOpened = false; try &#123; isOpened = NotificationManagerCompat.from(context).areNotificationsEnabled(); &#125; catch (Exception e) &#123; e.printStackTrace(); isOpened = false; &#125; return isOpened; &#125; Api24以上，NotificationManagerCompat中提供了areNotificationsEnabled()方法。该方法中已经对API19以下，API19-24，API24以上，这三种情况做了判断。直接使用其返回值即可。 该方法如果返回true表示打开了消息通知，如果返回false则没有打开。没有打开则跳转设置界面。代码如下： 12345678910111213141516171819private void gotoSet() &#123; Intent intent = new Intent(); if (Build.VERSION.SDK_INT &gt;= 26) &#123; // android 8.0引导 intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("android.provider.extra.APP_PACKAGE", getPackageName()); &#125; else if (Build.VERSION.SDK_INT &gt;= 21) &#123; // android 5.0-7.0 intent.setAction("android.settings.APP_NOTIFICATION_SETTINGS"); intent.putExtra("app_package", getPackageName()); intent.putExtra("app_uid", getApplicationInfo().uid); &#125; else &#123; // 其他 intent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); intent.setData(Uri.fromParts("package", getPackageName(), null)); &#125; intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125; 我们可以在Activity的onCreate中进行判断： 123456//判断该app是否打开了通知，如果没有的话就打开手机设置页面if (!isNotificationEnabled()) &#123; gotoSet();&#125; else &#123; //当前app允许消息通知&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android调用系统分享]]></title>
    <url>%2Fposts%2Fc19f18fd.html</url>
    <content type="text"><![CDATA[获取Android系统分享列表123456789101112131415161718192021public List&lt;AppInfoVo&gt; getShareApps(Context context) &#123; PackageManager packageManager = context.getPackageManager(); List&lt;AppInfoVo&gt; appInfoVos = new ArrayList&lt;AppInfoVo&gt;(); List&lt;ResolveInfo&gt; resolveInfos = new ArrayList&lt;ResolveInfo&gt;(); Intent intent = new Intent(Intent.ACTION_SEND, null); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.setType("*/*"); PackageManager pManager = context.getPackageManager(); resolveInfos = pManager.queryIntentActivities(intent, PackageManager .COMPONENT_ENABLED_STATE_DEFAULT); for (int i = 0; i &lt; resolveInfos.size(); i++) &#123; AppInfoVo appInfoVo = new AppInfoVo(); ResolveInfo resolveInfo = resolveInfos.get(i); appInfoVo.setAppName(resolveInfo.loadLabel(packageManager).toString()); appInfoVo.setIcon(resolveInfo.loadIcon(packageManager)); appInfoVo.setPackageName(resolveInfo.activityInfo.packageName); appInfoVo.setLauncherName(resolveInfo.activityInfo.name); appInfoVos.add(appInfoVo); &#125; return appInfoVos; &#125; 分享文本信息1234Intent intent = new Intent(Intent.ACTION_SEND);intent.setType("text/plain");intent.putExtra(Intent.EXTRA_TEXT,"This is a text");startActivity(Intent.createChooser(intent,"Share")); 分享单张图片1234567String path = Environment.getExternalStorageDirectory() + File.separator;//sd根目录File file = new File(path, "test" + ".png");//这里test.png是sd卡根目录下的一个图片文件Uri imageUri = Uri.fromFile(file);Intent intent = new Intent(Intent.ACTION_SEND);intent.setType("image/*");intent.putExtra(Intent.EXTRA_STREAM, imageUri);startActivity(Intent.createChooser(intent, "Share")); 分享视频12345678910String path = Environment.getExternalStorageDirectory() + File.separator;//sd根目录File file = new File(path, "test" + ".mp4");Uri audioUri = Uri.fromFile(file);ComponentName comp = new ComponentName("com.tencent.mobileqq", "com.tencent.mobileqq.activity.JumpActivity");Intent shareIntent = new Intent();shareIntent.setComponent(comp);shareIntent.setAction(Intent.ACTION_SEND);shareIntent.putExtra(Intent.EXTRA_STREAM, audioUri);shareIntent.setType("audio/*");startActivity(Intent.createChooser(shareIntent, "分享视频")); 分享多个文件1234567891011121314String path = Environment.getExternalStorageDirectory() + File.separator;//sd根目录ArrayList&lt;Uri&gt; imageUris = new ArrayList&lt;&gt;();File file = new File(path, "test" + ".png");File file2 = new File(path, "test2" + ".png");Uri imageUri = Uri.fromFile(file);Uri imageUri2 = Uri.fromFile(file2);imageUris.add(imageUri);imageUris.add(imageUri2);Intent intent = new Intent(Intent.ACTION_SEND_MULTIPLE);intent.setType("image/*");intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM,imageUris);startActivity(Intent.createChooser(intent, "Share")); 指定分享到微信朋友1234567ComponentName comp = new ComponentName("com.tencent.mm", "com.tencent.mm.ui.tools.ShareImgUI");Intent shareIntent = new Intent();shareIntent.setComponent(comp); shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);shareIntent.setType("image/*");startActivity(Intent.createChooser(shareIntent, "分享多张图片")); 指定分享到微信朋友圈1234567ComponentName comp = new ComponentName("com.tencent.mm", "com.tencent.mm.ui.tools.ShareToTimeLineUI");Intent shareIntent = new Intent();shareIntent.setComponent(comp);shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE); shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);shareIntent.setType("image/*");startActivity(Intent.createChooser(shareIntent, "分享多张图片")); 指定分享到QQ好友1234567ComponentName comp = new ComponentName("com.tencent.mobileqq", "com.tencent.mobileqq.activity.JumpActivity");Intent shareIntent = new Intent();shareIntent.setComponent(comp);shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE); shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, imageUris);shareIntent.setType("image/*");startActivity(Intent.createChooser(shareIntent, "分享多张图片")); 视频指定分享到QQ空间12345678910String path = Environment.getExternalStorageDirectory() + File.separator;//sd根目录File file = new File(path, "test" + ".mp4");Uri audioUri = Uri.fromFile(file);ComponentName comp = new ComponentName("com.qzone", "com.qzonex.module.maxvideo.activity.QzonePublishVideoActivity");Intent shareIntent = new Intent();shareIntent.setComponent(comp);shareIntent.setAction(Intent.ACTION_SEND);shareIntent.putExtra(Intent.EXTRA_STREAM, audioUri);shareIntent.setType("video/*");startActivity(Intent.createChooser(shareIntent, "分享视频")); 分享到指定程序只要获得包名和相应Activity即可 微信朋友圈“com.tencent.mm”“com.tencent.mm.ui.tools.ShareToTimeLineUI” 微信朋友“com.tencent.mm”“com.tencent.mm.ui.tools.ShareImgUI” QQ好友“com.tencent.mobileqq”“com.tencent.mobileqq.activity.JumpActivity” QQ空间分享视频“com.qzone”“com.qzonex.module.maxvideo.activity.QzonePublishVideoActivity” QQ空间分享图片、文字“com.qzone”“com.qzonex.module.operation.ui.QZonePublishMoodActivity” 新浪微博“com.sina.weibo”“com.sina.weibo.composerinde.ComposerDispatchActivity”]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大神进阶之路自定义View]]></title>
    <url>%2Fposts%2F37e124c4.html</url>
    <content type="text"><![CDATA[什么是自定义View定义在Android系统中，界面中所有能看到的元素都是View。默认情况下，Android系统为开发者提供了很多View，比如用于展示文本信息的TextView，用于展示图片的ImageView等等。但有时，这并不能满足开发者的需求，例如，开发者想要用一个饼状图来展示一组数据，这时如果用系统提供的View就不能实现了，只能通过自定义View来实现。那到底什么是自定义View呢？ 自定义View就是通过继承View或者View的子类，并在新的类里面实现相应的处理逻辑（重写相应的方法），以达到自己想要的效果。 继承结构Android中的所有UI元素都是View的子类： PS：由于涉及的类太多，如果将所有涉及到的类全部加到类图里面，类图将十分大，所以此处只列出了View的直接子类。 视图体系用到的设计模式Android View体系如下： 仔细观察，你会发现，Android View的体系结构和设计模式中的组合模式的结构如出一辙： Android View体系结构中的ViewGroup对应于组合模式中抽象构件（Component和Composite），Android View体系结构中的View对应于组合模式中的叶子构件（Leaf）： 为什么要自定义View大多数情况下，开发者常常会因为下面四个原因去自定义View： 让界面有特定的显示风格、效果 让控件具有特殊的交互方式 优化布局 封装 让界面有特定的显示风格、效果默认情况下，Android系统为开发者提供了很多控件，但有时，这并不能满足开发者的需求。例如，开发者想要用一个饼状图来展示一组数据，这时如果用系统提供的View就不能实现了，只能通过自定义View来实现。 让控件具有特殊的交互方式默认情况下，Android系统为开发者提供的控件都有属于它们自己的特定的交互方式，但有时，控件的默认交互方式并不能满足开发者的需求。例如，开发者想要缩放ImageView中的图片内容，这时如果用系统提供的ImageView就不能实现了，只能通过自定义ImageView来实现。 优化布局有时，有些布局如果用系统提供的控件实现起来相当复杂，需要各种嵌套，虽然最终也能实现了想要的效果，但性能极差，此时就可以通过自定义View来减少嵌套层级、优化布局。 封装有些控件可能在多个地方使用，如大多数App里面的底部Tab，像这样的经常被用到的控件就可以通过自定义View将它们封装起来，以便在多个地方使用。 如何自定义View在说「如何自定义View？」之前，我们需要知道「自定义View都包括哪些内容」？ 自定义View包括三部分内容： 布局（Layout） 绘制（Drawing） 触摸反馈（Event Handling） 布局阶段：确定View的位置和尺寸。 绘制阶段：绘制View的内容。 触摸反馈：确定用户点击了哪里。 其中布局阶段包括测量（measure）和布局（layout）两个过程，另外，布局阶段是为绘制和触摸反馈阶段做支持的，它并没有什么直接作用。正是因为在布局阶段确定了 View 的尺寸和位置，绘制阶段才知道往哪里绘制，触摸反馈阶段才知道用户点的是哪里。 在自定义View和自定义ViewGroup中，布局和绘制流程虽然整体上都是一样的，但在细节方面，自定义View和自定义ViewGroup还是不一样的，所以，接下来分两类进行讨论： 自定义View布局、绘制流程 自定义ViewGroup布局、绘制流程 自定义View布局、绘制流程「自定义 View 布局、绘制」主要包括三个阶段： 测量阶段（measure） 布局阶段（layout） 绘制阶段（draw） 自定义View测量阶段在View的测量阶段会执行两个方法（在测量阶段，View的父View会通过调用 View 的measure()方法将父View对View尺寸要求传进来。紧接着View的measure()方法会做一些前置和优化工作，然后调用View的onMeasure()方法，并通过onMeasure()方法将父View对View的尺寸要求传入。在自定义View中，只有需要修改View的尺寸的时候才需要重写onMeasure()方法。在onMeasure()方法中根据业务需求进行相应的逻辑处理，并在最后通过调用setMeasuredDimension()方法告知父View自己的期望尺寸）： measure() onMeasure() measure()：调度方法，主要做一些前置和优化工作，并最终会调用onMeasure()方法执行实际的测量工作； onMeasure()：实际执行测量任务的方法，主要用与测量View尺寸和位置。在自定义View的onMeasure()方法中，View根据自己的特性和父View对自己的尺寸要求算出自己的期望尺寸，并通过setMeasuredDimension()方法告知父View自己的期望尺寸。 onMeasure()计算View期望尺寸方法如下： 参考父View的对View的尺寸要求和实际业务需求计算出View的期望尺寸： 解析widthMeasureSpec 解析heightMeasureSpec 将「根据实际业务需求计算出View的尺寸」根据「父View的对View的尺寸要求」进行相应的修正得出View的期望尺寸（通过调用resolveSize()方法） 通过setMeasuredDimension()保存View的期望尺寸（实际上是通过setMeasuredDimension()告知父View自己的期望尺寸）; 注意： 多数情况下，这里的期望尺寸就是View的最终尺寸。不过最终View的期望尺寸和实际尺寸是不是一样还要看它的父View会不会同意。View的父View最终会通过调用View的layout()方法告知View的实际尺寸，并且在layout()方法中View需要将这个实际尺寸保存下来，以便绘制阶段和触摸反馈阶段使用，这也是View需要在layout()方法中保存自己实际尺寸的原因——因为绘制阶段和触摸反馈阶段要使用啊！ 自定义View布局阶段在View的布局阶段会执行两个方法（在布局阶段，View的父View会通过调用View的layout()方法将View的实际尺寸（父View根据View的期望尺寸确定的View的实际尺寸）传给View，View需要在layout()方法中将自己的实际尺寸保存（通过调用View的setFrame()方法保存，在setFrame()方法中，又会通过调用onSizeChanged()方法告知开发者View的尺寸修改了）以便在绘制和触摸反馈阶段使用。保存View的实际尺寸之后，View的layout()方法又会调用View的onLayout()方法，不过View的onLayout()方法是一个空实现，因为它没有子View）： layout() onLayout() layout()：保存View的实际尺寸。调用setFrame()方法保存View的实际尺寸，调用onSizeChanged()通知开发者View的尺寸更改了，并最终会调用onLayout()方法让子View布局（如果有子View的话。因为自定义View中没有子View，所以自定义View的onLayout()方法是一个空实现）； onLayout()：空实现，什么也不做，因为它没有子View。如果是ViewGroup的话，在onLayout()方法中需要调用子View的layout()方法，将子View的实际尺寸传给它们，让子View保存自己的实际尺寸。因此，在自定义View中，不需重写此方法，在自定义ViewGroup中，需重写此方法。 注意： layout()&amp;onLayout()并不是「调度」与「实际做事」的关系，layout()和onLayout()均做事，只不过职责不同。 自定义View绘制阶段在View的绘制阶段会执行一个方法——draw()，draw()是绘制阶段的总调度方法，在其中会调用绘制背景的方法drawBackground()、绘制主体的方法onDraw()、绘制子View的方法dispatchDraw()和绘制前景的方法onDrawForeground()。 draw()：绘制阶段的总调度方法，在其中会调用绘制背景的方法drawBackground()、绘制主体的方法onDraw()、绘制子View的方法dispatchDraw()和绘制前景的方法onDrawForeground()； drawBackground()：绘制背景的方法，不能重写，只能通过xml布局文件或者setBackground()来设置或修改背景； onDraw()：绘制View主体内容的方法，通常情况下，在自定义View的时候，只用实现该方法即可； dispatchDraw()：绘制子View的方法。同onLayout()方法一样，在自定义View中它是空实现，什么也不做。但在自定义ViewGroup中，它会调用ViewGroup.drawChild()方法，在ViewGroup.drawChild()方法中又会调用每一个子View的View.draw()让子View进行自我绘制； onDrawForeground()：绘制View前景的方法，也就是说，想要在主体内容之上绘制东西的时候就可以在该方法中实现。 注意： Android里面的绘制都是按顺序的，先绘制的内容会被后绘制的盖住。如，你在重叠的位置「先画圆再画方」和「先画方再画圆」所呈现出来的结果是不同的，具体表现为下表： 自定义View布局、绘制流程时序图 自定义ViewGroup布局、绘制流程「自定义ViewGroup布局、绘制」主要包括三个阶段： 测量阶段（measure） 布局阶段（layout） 绘制阶段（draw） 自定义ViewGroup测量阶段同自定义View一样，在自定义ViewGroup的测量阶段会执行两个方法： measure() onMeasure() measure()：调度方法，主要做一些前置和优化工作，并最终会调用onMeasure()方法执行实际的测量工作； onMeasure() ：实际执行测量任务的方法，与自定义View不同，在自定义ViewGroup的 onMeasure() 方法中，ViewGroup会递归调用子View的measure()方法，并通过measure()将ViewGroup对子View的尺寸要求（ViewGroup会根据开发者对子View的尺寸要求、自己的父View（ViewGroup的父View） 对自己的尺寸要求和自己的可用空间计算出自己对子View的尺寸要求）传入，对子View进行测量，并把测量结果临时保存，以便在布局阶段使用。测量出子View的实际尺寸之后，ViewGroup会根据子View的实际尺寸计算出自己的期望尺寸，并通过setMeasuredDimension()方法告知父View（ViewGroup 的父 View）自己的期望尺寸。 具体流程如下： 运行前，开发者在xml中写入对ViewGroup和ViewGroup子View的尺寸要求layout_xxx ViewGroup在自己的onMeasure()方法中，根据开发者在xml中写的对ViewGroup子View的尺寸要求、自己的父View（ViewGroup的父View） 对自己的尺寸要求和自己的可用空间计算出自己对子View的尺寸要求，并调用每个子View的measure()将ViewGroup对子View的尺寸要求传入，测量子View尺寸 ViewGroup在子View计算出期望尺寸之后（在ViewGroup的onMeasure()方法中，ViewGroup递归调用每个子View的measure()方法，子View在自己的onMeasure()方法中会通过调用setMeasuredDimension()方法告知父View（ViewGroup）自己的期望尺寸），得出子View的实际尺寸和位置，并暂时保存计算结果，以便布局阶段使用 ViewGroup根据子View的尺寸和位置计算自己的期望尺寸，并通过setMeasuredDimension()方法告知父View自己的期望尺寸。如果想要做的更好，可以在「ViewGroup根据子View的尺寸和位置计算出自己的期望尺寸」之后，再结合ViewGroup的父View对ViewGroup的尺寸要求进行修正（通过resolveSize()方法），这样得出的ViewGroup的期望尺寸更符合ViewGroup的父View对ViewGroup的尺寸要求 自定义ViewGroup布局阶段同自定义 View 一样，在自定义 ViewGroup 的布局阶段会执行两个方法： layout() onLayout() layout()：保存ViewGroup的实际尺寸。调用setFrame()方法保存ViewGroup的实际尺寸，调用onSizeChanged()通知开发者ViewGroup的尺寸更改了，并最终会调用onLayout()方法让子View布局； onLayout()：ViewGroup会递归调用每个子View的layout()方法，把测量阶段计算出的子View的实际尺寸和位置传给子View，让子View保存自己的实际尺寸和位置。 自定义ViewGroup绘制阶段同自定义View一样，在自定义ViewGroup的绘制阶段会执行一个方法——draw()。draw()是绘制阶段的总调度方法，在其中会调用绘制背景的方法 drawBackground()、绘制主体的方法onDraw()、绘制子View的方法 dispatchDraw()和绘制前景的方法onDrawForeground()： draw()：绘制阶段的总调度方法，在其中会调用绘制背景的方法drawBackground()、绘制主体的方法onDraw()、绘制子View的方法dispatchDraw()和绘制前景的方法onDrawForeground()； 在ViewGroup中，你也可以重写绘制主体的方法onDraw()、绘制子View的方法dispatchDraw()和绘制前景的方法onDrawForeground()。但大多数情况下，自定义ViewGroup是不需要重写任何绘制方法的。因为通常情况下，ViewGroup的角色是容器，一个透明的容器，它只是用来盛放子View的。 自定义ViewGroup布局、绘制流程时序图 自定义View步骤 自定义属性的声明与获取 重写测量阶段相关方法（onMeasure()） 重写布局阶段相关方法（onLayout()（仅ViewGroup需要重写）） 重写绘制阶段相关方法（onDraw()绘制主体、dispatchDraw()绘制子View和onDrawForeground() 绘制前景） onTouchEvent() onInterceptTouchEvent()（仅ViewGroup有此方法） 实战演练自定义View自定义View的绘制内容 自定义View，它的内容是「三个半径不同、颜色不同的同心圆」，效果图如下： 自定义属性的声明与获取 1234567891011//在 xml 中自定义 View 属性&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;!--CircleView--&gt; &lt;declare-styleable name="CircleView"&gt; &lt;attr name="circle_radius" format="dimension" /&gt; &lt;attr name="outer_circle_color" format="reference|color" /&gt; &lt;attr name="middle_circle_color" format="reference|color" /&gt; &lt;attr name="inner_circle_color" format="reference|color" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 1234567//在 View 构造函数中获取自定义 View 属性TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView);mRadius = typedArray.getDimension(R.styleable.CircleView_circle_radius, getResources().getDimension(R.dimen.avatar_size));mOuterCircleColor = typedArray.getColor(R.styleable.CircleView_outer_circle_color, getResources().getColor(R.color.purple_500));mMiddleCircleColor = typedArray.getColor(R.styleable.CircleView_middle_circle_color, getResources().getColor(R.color.purple_500));mInnerCircleColor = typedArray.getColor(R.styleable.CircleView_inner_circle_color, getResources().getColor(R.color.purple_500));typedArray.recycle(); 重写测量阶段相关方法（onMeasure()） 由于不需要自定义View的尺寸，所以，不用重写该方法。 重写布局阶段相关方法（onLayout()（仅 ViewGroup 需要重写）） 由于没有子View需要布局，所以，不用重写该方法。 重写绘制阶段相关方法（onDraw()绘制主体、dispatchDraw()绘制子View和onDrawForeground()绘制前景） 12345678910//重写 onDraw() 方法，自定义 View 内容@Overrideprotected void onDraw(Canvas canvas) &#123; mPaint.setColor(mOuterCircleColor); canvas.drawCircle(mRadius, mRadius, mRadius, mPaint); mPaint.setColor(mMiddleCircleColor); canvas.drawCircle(mRadius, mRadius, mRadius * 2/3, mPaint); mPaint.setColor(mInnerCircleColor); canvas.drawCircle(mRadius, mRadius, mRadius/3, mPaint);&#125; onTouchEvent() 由于View不需要和用户交互，所以，不用重写该方法。 onInterceptTouchEvent()（仅ViewGroup有此方法） ViewGroup的方法。 最终效果如下： 此时，即使你在xml中将CircleView的宽、高声明为「match_parent」，你会发现最终的显示效果都是一样的。 主要原因是：默认情况下，View的onMeasure()方法在通过setMeasuredDimension()告知父View自己的期望尺寸时，会调用getDefaultSize()方法。在getDefaultSize()方法中，又会调用getSuggestedMinimumWidth()和getSuggestedMinimumHeight()获取建议的最小宽度和最小高度，并根据最小尺寸和父View对自己的尺寸要求进行修正。 最主要的是，在getDefaultSize()方法中修正的时候，会将MeasureSpec.AT_MOST和MeasureSpec.EXACTLY一视同仁，直接返回父View对View的尺寸要求： 12345678910111213141516171819202122232425262728293031323334//1. 默认 onMeasure 的处理protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125;//2. getSuggestedMinimumWidth()protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;//3. getSuggestedMinimumHeight()protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125;//4. getDefaultSize()public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: //MeasureSpec.AT_MOST、MeasureSpec.EXACTLY 一视同仁 result = specSize; break; &#125; return result;&#125; 正是因为在getDefaultSize()方法中处理的时候，将MeasureSpec.AT_MOST和MeasureSpec.EXACTLY一视同仁，所以才有了上面「在xml中应用CircleView的时候，无论将CircleView的尺寸设置为match_parent还是wrap_content效果都一样」的现象。 具体分析如下： 注： 上表中，「View的父View对View的尺寸要求」是View的父View根据「开发者对子View的尺寸要求」、「自己的父View（View的父View的父View） 对自己的尺寸要求」和「自己的可用空间」计算出自己对子View的尺寸要求。 另外，由执行结果可知，上表中的specSize实际上等于View的尺寸： 12019-08-13 17:28:26.855 16024-16024/com.smart.a03_view_custom_view_example E/TAG: Width（getWidth()）: 1080 Height（getHeight()）: 1584 自定义View的尺寸和绘制内容 自定义View，它的内容是「三个半径不同、颜色不同的同心圆」，效果图如下： 自定义属性的声明与获取 1234567891011//在 xml 中自定义 View 属性&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;!--CircleView--&gt; &lt;declare-styleable name="CircleView"&gt; &lt;attr name="circle_radius" format="dimension" /&gt; &lt;attr name="outer_circle_color" format="reference|color" /&gt; &lt;attr name="middle_circle_color" format="reference|color" /&gt; &lt;attr name="inner_circle_color" format="reference|color" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 1234567//在 View 构造函数中获取自定义 View 属性TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView);mRadius = typedArray.getDimension(R.styleable.CircleView_circle_radius, getResources().getDimension(R.dimen.avatar_size));mOuterCircleColor = typedArray.getColor(R.styleable.CircleView_outer_circle_color, getResources().getColor(R.color.purple_500));mMiddleCircleColor = typedArray.getColor(R.styleable.CircleView_middle_circle_color, getResources().getColor(R.color.purple_500));mInnerCircleColor = typedArray.getColor(R.styleable.CircleView_inner_circle_color, getResources().getColor(R.color.purple_500));typedArray.recycle(); 重写测量阶段相关方法（onMeasure()） 1234567891011121314//onMeasure()@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //2.1 根据 View 特点或业务需求计算出 View 的尺寸 mWidth = (int)(mRadius * 2); mHeight = (int)(mRadius * 2); //2.2 通过 resolveSize() 方法修正结果 mWidth = resolveSize(mWidth, widthMeasureSpec); mHeight = resolveSize(mHeight, heightMeasureSpec); //2.3 通过 setMeasuredDimension() 保存 View 的期望尺寸（通过 setMeasuredDimension() 告知父 View 的期望尺寸） setMeasuredDimension(mWidth, mHeight);&#125; 重写布局阶段相关方法（onLayout()（仅ViewGroup需要重写）） 由于没有子View需要布局，所以，不用重写该方法。 重写绘制阶段相关方法（onDraw()绘制主体、dispatchDraw()绘制子View和onDrawForeground()绘制前景） 12345678910// 重写 onDraw() 方法，自定义 View 内容@Overrideprotected void onDraw(Canvas canvas) &#123; mPaint.setColor(mOuterCircleColor); canvas.drawCircle(mRadius, mRadius, mRadius, mPaint); mPaint.setColor(mMiddleCircleColor); canvas.drawCircle(mRadius, mRadius, mRadius * 2/3, mPaint); mPaint.setColor(mInnerCircleColor); canvas.drawCircle(mRadius, mRadius, mRadius/3, mPaint);&#125; onTouchEvent() 由于View不需要和用户交互，所以，不用重写该方法。 onInterceptTouchEvent()（仅 ViewGroup 有此方法） ViewGroup的方法。 最终效果如下： 当在xml中将MeasuredCircleView的宽、高声明为「match_parent」时，显示效果跟CircleView显示效果一样。 但是，当在xml中将MeasuredCircleView的宽、高声明为「wrap_content」时，显示效果是下面这个样子： 其实，也很好理解： 自定义ViewGroup自定义ViewGroup，标签布局，效果图如下： 无论是自定义View还是自定义ViewGroup，大致的流程都是一样的： 自定义属性的声明与获取 重写测量阶段相关方法（onMeasure()） 重写布局阶段相关方法（onLayout()（仅 ViewGroup 需要重写）） 重写绘制阶段相关方法（onDraw() 绘制主体、dispatchDraw() 绘制子 View 和 onDrawForeground() 绘制前景） onTouchEvent() onInterceptTouchEvent()（仅 ViewGroup 有此方法） 只不过，大多数情况下，ViewGroup不需要「自定义属性」和「重写绘制阶段相关方法」，但有些时候还是需要的，如，开发者想在ViewGroup的所有子View上方绘制一些内容，就可以通过重写ViewGroup的onDrawForeground()来实现。 自定义属性的声明与获取 在自定义ViewGroup中「自定义属性的声明与获取」的方法与在自定义View中「自定义属性的声明与获取」的方法一样，且因为大多数情况下，在自定义ViewGroup中是不需要自定义属性的，所以，在这里就不自定义属性了。 重写测量阶段相关方法（onMeasure()） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//2. 重写测量阶段相关方法（onMeasure()）；@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //2.1 解析 ViewGroup 的父 View 对 ViewGroup 的尺寸要求 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(widthMeasureSpec); int heightSize = MeasureSpec.getSize(widthMeasureSpec); //2.2 ViewGroup 根据「开发者在 xml 中写的对 ViewGroup 子 View 的尺寸要求」、「自己的父 View（ViewGroup 的父 View）对自己的尺寸要求」和 //「自己的可用空间」计算出自己对子 View 的尺寸要求，并将该尺寸要求通过子 View 的 measure() 方法传给子 View，让子 View 测量自己（View）的期望尺寸 //具体代码查看原文... //2.3 ViewGroup 暂时保存子 View 的尺寸，以便布局阶段和绘制阶段使用 Rect childBound; if(mChildrenBounds.size() &lt;= i)&#123; childBound = new Rect(); mChildrenBounds.add(childBound); &#125;else&#123; childBound = mChildrenBounds.get(i); &#125; //此处不能用 child.getxxx() 获取子 View 的尺寸值，因为子 View 只是量了尺寸，还没有布局，这些值都是 0// childBound.set(child.getLeft(), child.getTop(), child.getRight(), child.getBottom()); childBound.set(lineWidthUsed, heightUsed, lineWidthUsed + child.getMeasuredWidth(), heightUsed + child.getMeasuredHeight()); lineWidthUsed += child.getMeasuredWidth() + mItemSpace; widthUsed = Math.max(lineWidthUsed, widthUsed); lineHeight = Math.max(lineHeight, child.getMeasuredHeight()); &#125; //2.4 ViewGroup 将「根据子 View 的实际尺寸计算出的自己（ViewGroup）的尺寸」结合「自己父 View 对自己的尺寸要求」进行修正，并通 //过 setMeasuredDimension() 方法告知父 View 自己的期望尺寸 int measuredWidth = resolveSize(widthUsed, widthMeasureSpec); int measuredHeight = resolveSize((heightUsed + lineHeight + getPaddingBottom()), heightMeasureSpec); setMeasuredDimension(measuredWidth, measuredHeight);&#125;//重写generateLayoutParams()//2.2.1 在自定义 ViewGroup 中调用 measureChildWithMargins() 方法计算 ViewGroup 对子 View 的尺寸要求时，//必须在 ViewGroup 中重写 generateLayoutParams() 方法，因为 measureChildWithMargins() 方法中用到了 MarginLayoutParams，//如果不重写 generateLayoutParams() 方法，那调用 measureChildWithMargins() 方法时，MarginLayoutParams 就为 null，//所以在自定义 ViewGroup 中调用 measureChildWithMargins() 方法时，必须重写 generateLayoutParams() 方法。@Overridepublic LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs);&#125; 重写布局阶段相关方法（onLayout()（仅ViewGroup需要重写）） 12345678910//重写布局阶段相关方法（onLayout()（仅 ViewGroup 需要重写））；@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; for (int i = 0; i &lt; getChildCount(); i++) &#123; //应用测量阶段计算出的子 View 的尺寸值布局子 View View child = getChildAt(i); Rect childBound = mChildrenBounds.get(i); child.layout(childBound.left, childBound.top, childBound.right, childBound.bottom); &#125;&#125; 重写绘制阶段相关方法（onDraw()绘制主体、dispatchDraw()绘制子View和onDrawForeground()绘制前景） 默认情况下，自定义ViewGroup时是不需要重写任何绘制阶段的方法的，因为ViewGroup的角色是容器，一个透明的容器，它只是用来盛放子View的。 注意： 默认情况下，系统会自动调用View Group的dispatchDraw()方法，所以不需要重写该方法 出于效率的考虑，ViewGroup默认会绕过draw()方法，换而直接执行dispatchDraw()，以此来简化绘制流程。所以如果你自定义了一个ViewGroup，并且需要在它的除dispatchDraw()方法以外的任何一个绘制方法内绘制内容，你可能会需要调用View.setWillNotDraw(false)方法来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些ViewGroup是已经调用过setWillNotDraw(false)了的，例如ScrollView）。除了可以通过调用View.setWillNotDraw(false)方法来切换到完整的绘制流程之外，你还可以通过给ViewGroup设置背景来切换到完整的绘制流程 onTouchEvent() 由于ViewGroup不需要和用户交互，所以，不用重写该方法。 onInterceptTouchEvent()（仅ViewGroup有此方法） 由于ViewGroup不需要和用户交互且ViewGroup不需要拦截子View的MotionEvent，所以，不用重写该方法。 最终效果如下： 总结自定义View包括三部分内容： 布局（Layout） 绘制（Drawing） 触摸反馈（Event Handling） 其中布局阶段确定了View的位置和尺寸，该阶段主要是为了后面的绘制和触摸反馈做支持；绘制阶段主要用于绘制View的内容（大多数情况下，只用实现OnDraw方法（Where）方法、按照指定顺序调用相关API（How）即可实现自定义绘制（What））；触摸反馈阶段确定了用户点击了哪里，三者相辅相成，缺一不可。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0到1优雅实现沉浸式状态栏]]></title>
    <url>%2Fposts%2Fd649dac6.html</url>
    <content type="text"><![CDATA[ImmersionStatusBar 1. 概述现在市面上绝大多数APP都实现了沉浸式状态栏的效果，该效果可以极大地提升用户的使用体验。但是，APP默认的情况下只是设定一个固定的状态栏颜色，那么就需要我们通过代码去动态修改状态栏颜色的。那么，如何去实现呢？ 首先来说，从Android 4.4开始才能实现沉浸式状态栏的，所以如果您的APP也支持Android 4.4以下版本，那还需要对Android 4.4以下版本做“不支持沉浸式状态栏”处理。 那么，从Android 4.4开始，大概可以分成三个阶段来实现沉浸式状态栏： Android4.4(API 19) - Android 5.0(API 21)：这个阶段的实现方式为：通过FLAG_TRANSLUCENT_STATUS设置状态栏为透明并且为全屏模式，然后通过添加一个与StatusBar一样大小的View，将View的背景设置为要设置的颜色，从而实现沉浸式。 Android 5.0(API 21) - Android 6.0(API 23)： 从Android 5.0开始，加入了一个重要的属性android:statusBarColor和方法setStatusBarColor()，通过这个方法我们就可以轻松实现沉浸式状态栏。但是在Android 6.0以下版本官方不支持设置状态栏的文字和图标颜色，目前只有小米和魅族的ROM提供了支持。 Android 6.0(API 23)以上版本：其实Android 6.0以上的实现方式和Android 5.0+ 是一样的，区别是从Android 6.0开始，官方支持改变状态栏的文字和图标的颜色。 2. 实现方案2.1 前期工作为了实现沉浸式状态栏的效果，我们需要做一些前期工作，如下： 2.1.1 修改应用主题为了更好地演示沉浸式状态栏的效果，我们修改应用的主题，使其不要显示Android默认的标题栏。 打开styles.xml文件，可以改成如下代码，并且将colorPrimary等颜色设置删掉： 12&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt;&lt;/style&gt; 2.1.2 获取状态栏高度新建一个StatusBarUtils.java文件，在里面添加一个获取状态栏高度的方法，以后我们都会用的到这个方法。之后我们的核心代码也在这个工具类里实现。代码如下： 123456789101112131415public class StatusBarUtils &#123; public static int getHeight(Context context) &#123; int statusBarHeight = 0; try &#123; int resourceId = context.getResources().getIdentifier("status_bar_height", "dimen", "android"); if (resourceId &gt; 0) &#123; statusBarHeight = context.getResources().getDimensionPixelSize(resourceId); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return statusBarHeight; &#125;&#125; 下面我们就按照从高版本到低版本的顺序来讲解如何更优雅地实现沉浸式状态栏。 2.2 Android 5.0+2.2.1 设置状态栏颜色在StatusBarUtils类里添加如下方法，实现设置状态栏颜色的功能： 123456789public static void setColor(@NonNull Window window, @ColorInt int color) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.setStatusBarColor(color); &#125;&#125; 修改状态栏颜色的功能其实就是对Window进行操作，而该Window可以是Activity或Dialog等持有的Window，所以我们就封装了一个传递Window的方法。 为了便于对Activity直接操作，可以再增加一个如下方法： 12345public static void setColor(Context context, @ColorInt int color) &#123; if (context instanceof Activity) &#123; setColor(((Activity) context).getWindow(), color); &#125;&#125; 下面测试一下，新建一个Activity，将其布局背景设置为某个颜色，例如主题色，布局代码如下： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:background="@color/colorPrimaryDark"&gt;&lt;/LinearLayout&gt; 在没设置状态栏颜色时，展示效果如下： 接下来在Activity的onCreate()方法里调用设置状态栏颜色的方法，代码如下： 123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_color); StatusBarUtils.setColor(this, getResources().getColor(R.color.colorPrimaryDark));&#125; 展示效果如下： 这样状态栏和内容的颜色就可以一样啦！ 2.2.2 设置状态栏文字颜色下面我们把背景和状态栏颜色改成纯绿色（#00FF00），看看效果： 发现颜色好亮啊，状态栏里的文字都看不清了。在这种情况下，我们是可以将状态栏文字的颜色改成深色的，官方也仅支持设置状态栏文字和图标的深色模式和浅色模式，但是官方仅在Android 6.0以上版本提供支持。设置代码如下： 1234567891011private static void setTextDark(Window window, boolean isDark) &#123; if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123; View decorView = window.getDecorView(); int systemUiVisibility = decorView.getSystemUiVisibility(); if (isDark) &#123; decorView.setSystemUiVisibility(systemUiVisibility | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; else &#123; decorView.setSystemUiVisibility(systemUiVisibility &amp; ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; &#125;&#125; 同样再增加一个对Activity的支持： 12345public static void setTextDark(Context context, boolean isDark) &#123; if (context instanceof Activity) &#123; setTextDark(((Activity) context).getWindow(), isDark); &#125;&#125; 为了能够根据状态栏背景颜色的深浅而自动设置文字的颜色，我们再新增一个判断颜色深浅的方法： 123public static boolean isDarkColor(@ColorInt int color) &#123; return ColorUtils.calculateLuminance(color) &lt; 0.5;&#125; 然后在setColor()方法里新增一行设置状态栏文字颜色的代码，如下： 12345678910public static void setColor(@NonNull Window window, @ColorInt int color) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.setStatusBarColor(color); setTextDark(window, !isDarkColor(color)); &#125;&#125; 运行一下，就可以看到效果了： 上面是Android 6.0以上版本的实现，那么对于Android 6.0以下的手机怎么办呢？目前Android 5.0-6.0的手机只有小米MIUI和魅族Flyme系统提供了支持。小米MIUI的设置方法如下： 12345678910111213private static void setMIUIDark(Window window, boolean isDark) &#123; try &#123; Class&lt;? extends Window&gt; clazz = window.getClass(); int darkModeFlag; Class&lt;?&gt; layoutParams = Class.forName("android.view.MiuiWindowManager$LayoutParams"); Field field = layoutParams.getField("EXTRA_FLAG_STATUS_BAR_DARK_MODE"); darkModeFlag = field.getInt(layoutParams); Method extraFlagField = clazz.getMethod("setExtraFlags", int.class, int.class); extraFlagField.invoke(window, isDark ? darkModeFlag : 0, darkModeFlag); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 魅族Flyme的设置方法如下： 123456789101112131415161718192021222324private static void setFlymeDark(Window window, boolean isDark) &#123; if (window != null) &#123; try &#123; WindowManager.LayoutParams lp = window.getAttributes(); Field darkFlag = WindowManager.LayoutParams.class .getDeclaredField("MEIZU_FLAG_DARK_STATUS_BAR_ICON"); Field meizuFlags = WindowManager.LayoutParams.class .getDeclaredField("meizuFlags"); darkFlag.setAccessible(true); meizuFlags.setAccessible(true); int bit = darkFlag.getInt(null); int value = meizuFlags.getInt(lp); if (isDark) &#123; value |= bit; &#125; else &#123; value &amp;= ~bit; &#125; meizuFlags.setInt(lp, value); window.setAttributes(lp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后在setTextDark()方法中添加如下代码： 123456789101112131415161718192021private static void setTextDark(Window window, boolean isDark) &#123; if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123; View decorView = window.getDecorView(); int systemUiVisibility = decorView.getSystemUiVisibility(); if (isDark) &#123; decorView.setSystemUiVisibility(systemUiVisibility | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; else &#123; decorView.setSystemUiVisibility(systemUiVisibility &amp; ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125; &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; switch (OSUtils.getRomType()) &#123; case MIUI: setMIUIDark(window, isDark); break; case Flyme: setFlymeDark(window, isDark); break; default: &#125; &#125;&#125; Android 6.0以下运行效果同上，我就不给大家截图了。 2.2.3 设置状态栏透明当我们APP的背景是一张图片时，未设置沉浸式状态栏的效果如下： 这时一般我们需要将图片顶到状态栏里，也就是整个内容布局顶到状态栏里，并设置状态栏的颜色透明，才能实现沉浸式状态栏的效果。 那么，在我们的StatusBarUtils类里添加如下代码： 123456789public static void setTransparent(@NonNull Window window) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); window.setStatusBarColor(Color.TRANSPARENT); &#125;&#125; 同样针对Activity，增加如下方法： 12345public static void setTransparent(Context context) &#123; if (context instanceof Activity) &#123; setTransparent(((Activity) context).getWindow()); &#125;&#125; 最后在Activity的onCreate()方法里设置一下： 123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_transparent); StatusBarUtils.setTransparent(this);&#125; 运行，显示效果如下： 针对这种情况，大家在实现布局时不要忘了把状态栏的高度也考虑进去。 以上就是Android 5.0以上沉浸式状态栏的实现了。 2.3 Android 4.4+下面针对Android 4.4-5.0的手机进行实现。实现原理是将内容布局设为全屏，然后在布局的顶部添加一个和状态栏一样高度的View，将该View的背景设置成我们想要的颜色。当需要将状态栏设置纯颜色时，为了和Android 5.0以上版本保持一致，我们对内容布局的上边设置一个padding，大小为状态栏的高度。 为了能复用这个View，我们新增一个自定义的ID，在values文件夹下新建ids.xml文件，新增代码如下： 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;item name="fake_status_bar_view" type="id"/&gt;&lt;/resources&gt; 然后在StatusBarUtils类里添加如下代码： 12345678910111213141516171819202122232425262728293031private static final int FAKE_STATUS_BAR_VIEW_ID = R.id.fake_status_bar_view;@RequiresApi(api = Build.VERSION_CODES.KITKAT)public static void setColor(@NonNull Window window, @ColorInt int color, boolean isTransparent) &#123; Context context = window.getContext(); window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); ViewGroup decorView = (ViewGroup) window.getDecorView(); View contentView = decorView.findViewById(android.R.id.content); if (contentView != null) &#123; contentView.setPadding(0, isTransparent ? 0 : getHeight(context), 0, 0); &#125; View fakeStatusBarView = decorView.findViewById(FAKE_STATUS_BAR_VIEW_ID); if (fakeStatusBarView != null) &#123; fakeStatusBarView.setBackgroundColor(color); if (fakeStatusBarView.getVisibility() == View.GONE) &#123; fakeStatusBarView.setVisibility(View.VISIBLE); &#125; &#125; else &#123; // 绘制一个和状态栏一样高的矩形 View statusBarView = new View(context); FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, getHeight(context)); statusBarView.setLayoutParams(layoutParams); statusBarView.setBackgroundColor(color); statusBarView.setId(FAKE_STATUS_BAR_VIEW_ID); decorView.addView(statusBarView); &#125;&#125; 2.3.1 设置状态栏颜色在设置纯颜色时，我们还需要将该颜色与黑色进行1:1的混合。为什么要这么设置呢？因为状态栏的文字和图标颜色默认是白色的，并且在Android 5.0以下是不能修改的，所以如果修改成较浅的颜色，就会导致状态栏文字看不清的现象，因此做一个比较暗的浮层效果更好一些。 那么将setColor()方法改成如下代码： 123456789101112public static void setColor(@NonNull Window window, @ColorInt int color) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.setStatusBarColor(color); setTextDark(window, !isDarkColor(color)); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; setColor(window, ColorUtils.blendARGB(Color.TRANSPARENT, color, 0.5f), false); &#125;&#125; 展示效果如下： 2.3.2 设置状态栏透明在设置状态栏透明时，为了也能清楚地看清状态栏的文字，我们直接设置状态栏的颜色为50%透明度的黑色。 于是，修改setTransparent()方法如下： 1234567891011public static void setTransparent(@NonNull Window window) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); window.setStatusBarColor(Color.TRANSPARENT); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; setColor(window, 0x80000000, true); &#125;&#125; 展示效果如下： 这样，Android 4.4以上的手机就适配完毕了。 3. 特殊场景现在来针对一些特殊场景进行适配，比如启动页、刘海屏和弹窗等等。 3.1 启动页对于启动页，一般都会把状态栏收上去，这需要适配刘海屏，否则刘海区域会显示黑的一片。其实Android P以上提供了适配刘海屏的方法，在启动页Activity添加如下代码： 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); StatusBarUtils.setTransparent(this); // 适配刘海屏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; WindowManager.LayoutParams layoutParams = getWindow().getAttributes(); layoutParams.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; getWindow().setAttributes(layoutParams); &#125;&#125; 但是一些手机厂商的刘海屏手机系统版本是低于Android P的，不过也都提供了适配的方法。适配方式是在AndroidManifest.xml文件里的application标签下添加如下代码： 123456789101112&lt;!-- 允许绘制到小米刘海屏机型的刘海区域 --&gt;&lt;meta-data android:name="notch.config" android:value="portrait" /&gt;&lt;!-- 允许绘制到华为刘海屏机型的刘海区域 --&gt;&lt;meta-data android:name="android.notch_support" android:value="true" /&gt;&lt;!-- 允许绘制到oppo、vivo刘海屏机型的刘海区域 --&gt;&lt;meta-data android:name="android.max_aspect" android:value="2.2" /&gt; 另外，对于Android 5.0以下的手机，适配完刘海屏后会在顶部多一块黑色半透明的View，那我们将其改成全透明的，修改onCreate()方法如下： 1234567891011121314151617@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); StatusBarUtils.setTransparent(this); // 适配刘海屏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123; WindowManager.LayoutParams layoutParams = getWindow().getAttributes(); layoutParams.layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES; getWindow().setAttributes(layoutParams); &#125; // 适配Android 4.4 if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; StatusBarUtils.setColor(getWindow(), Color.TRANSPARENT, true); &#125;&#125; 这样，启动页的效果就适配好了，效果如下： 3.2 弹窗对于弹窗，只有全屏弹窗才能修改状态栏文字的颜色。详见Android非全屏的Window无法设置SYSTEM_UI_FLAG_LIGHT_STATUS_BAR问题分析。 4.参考 Android关于沉浸式状态栏总结 MIUI 9 &amp; 10“状态栏黑色字符”实现方法变更通知 魅族开放平台 - 状态栏变色 简洁明了的刘海屏适配方案]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>沉浸式状态栏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android对于有时间戳和token验证的网络请求的处理]]></title>
    <url>%2Fposts%2F86cc3f20.html</url>
    <content type="text"><![CDATA[有些项目为了提高安全性，设计接口时增加了时间戳和token效验，如下所示： 时间戳上表中的参数时间戳必须与服务器当前时间对应，前后不能超过10秒，超过则请求失败： 你肯定想问，如果手机系统时间不正确，比服务器快了或慢了10秒以上，那不每次都会请求失败吗？别着急，这样的接口设计，肯定会有一个获取服务器时间戳的接口： 思路是这样的，每次APP启动的时候获取一次服务器时间戳，然后与手机本地时间相减，计算出差额，并保存；当其他的网络请求需要传入时间戳参数时，用保存的时间差额加上手机当前时间，就可以得到正确的时间戳了： 时间差 = 获取的服务器时间戳 - 手机当前时间 时间戳 = 手机当前时间 + 时间差 当然，现在的手机大部分都是联网获取时间，很少会出现比标准时间差10秒以上的情况，服务器的时间也是标准时间，因此，只传入手机的当前时间也能符合90%的情况。 那剩下的情况是什么呢？ ​ 1、网速慢的时候，请求时间和读取时间会比较长，很可能会超过10秒； ​ 2、出国用户或国外用户，不在一个时区； ​ 3、用户主动或被动调整了手机系统时间。 这些情况下，如果只传入手机的当前时间，是无法请求到正确的数据的，所以还是要计算时间差。 至于每次APP启动的时候获取一次服务器时间戳，这个时机对不对呢？ 用户在使用App的过程中，很少会出现系统时间的调整，如果恰巧赶上，可以在接收到时间戳超期的错误码后，提示用户退出APP重新启动一次。当然也可以注册时间调整的广播接收者，接收到时间调整后，重新计算一次时间差。 至于网速慢的情况还是不能解决，加上提示用户重启APP和注册广播接收者这些不太优雅的操作，我们要寻找其他的思路。 怎么能彻底并且优雅的解决时间戳超期的问题呢？ 其实我们不必每次APP启动都请求一次服务器时间戳，只有收到时间戳超期的错误之后，才有必要获取，此时计算出时间差，并保存，以后所有的请求都可以用这个时间差了，直到下一次再收到时间戳超期的错误，再获取一次即可。至于这个错误的请求，可以在计算出时间差之后，再重新请求一次。 跟着上述的思路，我们自然而然想到在请求回调基类里筛选这个时间戳超期错误，筛选出这个错误后，同步请求一次服务器时间戳，再进行一次之前的请求。想想就很困难，因为要保证在子线程里完成，还要记住之前的请求是什么，这条路走不通。 不卖关子了，okhttp的拦截器可以解决以上问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Interceptor interceptor = new Interceptor() &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Response response= chain.proceed(request); ResponseBody body = response.body(); BufferedSource source = body.source(); source.request(Long.MAX_VALUE); Buffer buffer = source.buffer(); Charset charset = Charset.forName("UTF-8"); String json = buffer.clone().readString(charset); BaseBean baseBean = gson.fromJson(json, BaseBean.class); String code = baseBean.getCode(); if (code.equals("0210")) &#123;// 时间戳超期 // 同步请求时间戳 Request timeRequest = new Request.Builder() .url("http://uc.hivoice.cn:80/timestamp.jsp") .build(); Response timeResponse = chain.proceed(timeRequest); int timeCode = timeResponse.code(); if (timeCode == 200) &#123; // 计算时间差 String timestamp = timeResponse.body().string().trim(); long dTime = System.currentTimeMillis() / 1000 - Long.parseLong(timestamp); SpUtil.setDTime(dTime); // 构建新的请求 FormBody.Builder builder = new FormBody.Builder(); FormBody formBody = (FormBody) request.body(); List&lt;String&gt; param = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; formBody.size(); i++) &#123; String name = formBody.encodedName(i); if (name.equals("timestamp")) &#123; builder.add("timestamp", timestamp); param.add(timestamp); &#125; else if (!name.equals("signature")) &#123; String value = formBody.encodedValue(i); param.add(value); builder.add(name, value); &#125; &#125; String signature = SignUtil.getSignature(param); builder.add("signature", signature); Request newRequest = request.newBuilder().method("POST", builder.build()).build(); response = chain.proceed(newRequest); &#125; &#125; return response; &#125;&#125;; OkHttpClient httpClient = new OkHttpClient.Builder() .addInterceptor(interceptor) .build(); 上述是针对post请求，考虑到这类请求多少post请求就没有区分，实际项目中如果有get请求也会发生时间戳超时问题，必须要做区分。 Tokentoken也是这样，往往是APP启动的时候获取一次，保存下来，后面的请求传入这个参数即可。 但是有些情况下，会错过这个获取时机： ​ 1、APP启动时手机没有联网，启动以后才联网； ​ 2、用户启动APP以后一直没有退出，直到token过期。 对于第一种情况，有人说可以注册广播接收者，监测手机的网络状态，如果启动的时候没有网络则用户联网以后再获取token，这个思路是对的，但是有一种情况是监测不到网络变化的，即用户用安全管家之类的软件禁了APP的网络的情况。 当然，可以提示用户退出APP，重新进入。但是前面说过，这样做不太优雅，而且主流APP也没有发现过这种情况。 综上所述，token验证失败的处理也应该用okhttp的拦截器处理，思路和步骤与时间戳一致，不再重复。 关于性能有人可能会担心性能问题，肯定会有影响，但是影响极其有限，因为官方出品的日志拦截器也是这么做的，看不出有什么影响。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>时间戳超期</tag>
        <tag>token效验失败</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式二十一之桥接模式]]></title>
    <url>%2Fposts%2Fbf1f23e5.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习桥接模式 介绍桥接模式（BridgePattern）也称为桥梁模式，是结构型模式之一。在现实生活中大家都知道 ”桥梁“ 是连接河道两岸的主要交通枢纽，简而言之其作用就是连接河的两边，而我们的桥接模式与现实中的情况很相似，也是承担着连接 ”两边“ 的作用，那么具体是哪两边呢？这里先不着急，我们先来看看定义吧。 定义将抽象部分与实现部分分离，使它们都可以独立地进行变化。 使用场景从模式的定义中我们大致可以了解到，这里的 ”桥梁“ 的作用其实就是连接 ”抽象部分“ 与 “实现部分”，但是事实上，任何多维度变化类或者说多个树状类之间的耦合都可以使用桥接模式来实现解耦。 UML 类图 Abstraction: 抽象部分 RefinedAbstraction: 优化的抽象部分 Implementor: 实现部分 ConcreteImplementorA/B: 实现部分的具体实现。 Client: 客户类，客户端程序。 代码示例需求背景: 我们去店里面买咖啡，对不同的咖啡不同的定义。 咖啡抽象类: 1234567891011121314public abstract class coffee &#123; protected CoffeeAdditives impl; public coffee(CoffeeAdditives impl) &#123; this.impl = impl; &#125; /** * 制作什么得咖啡由子类决定 */ public abstract void makeCoffee();&#125; 大杯咖啡制作具体类: 1234567891011public class LargeCoffee extends coffee&#123; public LargeCoffee(CoffeeAdditives impl) &#123; super(impl); &#125; @Override public void makeCoffee() &#123; System.out.println("制作大杯咖啡-&gt;" + impl.addSomething()); &#125;&#125; 小杯咖啡制作具体类: 12345678910public class SmallCoffee extends coffee &#123; public SmallCoffee(CoffeeAdditives impl) &#123; super(impl); &#125; @Override public void makeCoffee() &#123; System.out.println("制作小杯咖啡"+ impl.addSomething()); &#125;&#125; 咖啡加糖/原味抽象类: 1234public interface CoffeeAdditives &#123; public String addSomething();&#125; 咖啡加糖/原味具体类: 1234567891011121314public class Ordinary implements CoffeeAdditives &#123; @Override public String addSomething() &#123; return "原味"; &#125;&#125;复制代码public class Sugar implements CoffeeAdditives &#123; @Override public String addSomething() &#123; return "加糖"; &#125;&#125; test: 1234567891011121314151617181920@Testpublic void testBridge()&#123; //原味 CoffeeAdditives coffeeAdditives = new Ordinary(); //加糖 CoffeeAdditives coffeeAdditives1 = new Sugar(); //大杯原味 LargeCoffee largeCoffee = new LargeCoffee(coffeeAdditives); largeCoffee.makeCoffee(); //小杯原味 SmallCoffee smallCoffee = new SmallCoffee(coffeeAdditives); smallCoffee.makeCoffee(); //大杯加糖 LargeCoffee largeCoffee2 = new LargeCoffee(coffeeAdditives1); largeCoffee2.makeCoffee(); //小杯加糖 SmallCoffee smallCoffee3 = new SmallCoffee(coffeeAdditives1); smallCoffee3.makeCoffee();&#125; output: 1234制作大杯咖啡-&gt;原味制作小杯咖啡原味制作大杯咖啡-&gt;加糖制作小杯咖啡加糖 从上面代码可以知道，不管 Coffee 变化了还是 CoffeeAdditives 变化了，其相对于对方而言都是独立的没有什么过多的交集，两者之间唯一的联系就是 Coffee 中保持的对 Coffeeadditives 的引用，就是开头介绍所说的枢纽，这就是桥接模式的简单示例。 总结优点: 分离抽象与实现、灵活的扩展。 缺点: 不容易设计。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式二十之外观模式]]></title>
    <url>%2Fposts%2F3b61575f.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习外观模式 介绍外观模式 (Facade) 在开发过程中的运用评率非常高，尤其是在现阶段，各种第三方 SDK “充斥” 在我们周边，而这些 SDK 大多会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装 API 的常用手段，例如，网路模块、图片模块，可能你已经在开发中运用无数次外观模式，只是没有在理论中认识它，下面我们就来学习它。 定义要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 使用场景 为一个复杂子系统提供一个简单接口。子系统往往因为不断演化而变得越来越复杂，甚至可能被替换。大多数模式使用时都会产生更多、更小的类，这使子系统更具可重用性的同时也更容易对子系统进行定制、修改，这种易变性使得隐藏子系统的具体实现变得尤为重要。Facade 可以提供一个简单统一的接口，对外隐藏子系统的具体实现、隔离变化。 当你需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过 Facade 接口进行通信，从而简化了它们之间的依赖关系。 UML 类图 Facade: 系统对外的统一接口，系统内部系统地工作。 代码示例需求背景:手机的外观模式（电话功能，短信功能，GPS, 拍照） 手机抽象类: 1234567891011121314151617181920212223242526public abstract class AbstractMobile &#123; /** * 定义一个打电话功能 */ protected Phone phone = null; /** * 定义一个拍照功能 */ protected ICamera camera = null; public AbstractMobile(Phone phone, ICamera camera) &#123; this.phone = phone; this.camera = camera; &#125; public abstract void dail(); public abstract void videoChat(); public abstract void hangup(); public abstract void takePicture(); public abstract void stop();&#125; 手机实现类: 12345678910111213141516171819202122232425262728293031323334353637public class MobilePhone extends AbstractMobile &#123; public MobilePhone(Phone phone, ICamera camera) &#123; super(phone, camera); &#125; public void dail() &#123; phone.dail(); &#125; ; @Override public void videoChat() &#123; System.out.println("视频聊天呼叫中..."); camera.openCamera(); &#125; @Override public void hangup() &#123; phone.hangup(); &#125; @Override public void takePicture() &#123; camera.takePicture(); &#125; @Override public void stop() &#123; camera.stop(); phone.hangup(); &#125;&#125; 功能接口类 1234567891011public interface Phone &#123; /** * 打电话 */ public void dail(); /** * 挂断 */ public void hangup();&#125; 1234567891011121314151617public interface ICamera &#123; /** * 打开相机预览 */ public void openCamera(); /** * 拍照 */ public void takePicture(); /** * 关闭相机 */ public void stop();&#125; 功能实现类: 12345678910111213141516public class CameraImpl implements ICamera &#123; @Override public void openCamera() &#123; System.out.println("打开相机"); &#125; @Override public void takePicture() &#123; System.out.println("拍照"); &#125; @Override public void stop() &#123; System.out.println("关闭相机"); &#125;&#125; 1234567891011public class PhoneImpl implements Phone &#123; @Override public void dail() &#123; System.out.println("打电话"); &#125; @Override public void hangup() &#123; System.out.println("挂断电话"); &#125;&#125; test: 123456789101112@Testpublic void testFacade()&#123; Phone phone = new PhoneImpl(); ICamera camera = new CameraImpl(); MobilePhone mobilePhone = new MobilePhone(phone,camera); mobilePhone.dail(); mobilePhone.videoChat(); mobilePhone.takePicture(); mobilePhone.stop();&#125; output: 123456打电话视频聊天呼叫中...打开相机拍照关闭相机挂断电话 从上述代码可以看到，外观模式就是统一接口封装。将子系统的逻辑、交互隐藏起来，为用户提供一个高层次的接口，是的系统更加易用，同时也对外隐藏了具体的实现，这样即使具体的子系统发生了变化，用户也不会知道，因为用户使用的是 Facade 高层次接口，内部的变化对于用户来说并不可见。这样一来就将变化隔离开来，使得系统更为灵活。 总结外观模式是一个使用频率较高的设计模式，它的精髓就在于 ”封装“ 二字。通过一个高层次结构为用户提供统一的 API 入口，使得用户通过一个类型就基本能够操作整个系统，这样减少了用户的成本，也能够提升系统的灵活性。 优点: 对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。 外观类对子系统的接口封装，使得系统更易于使用。 缺点: 外观类接口膨胀。由于子系统的接口都有外观类统一对外暴露，使得外观类的 API 接口较多，在一定程度上增加了用户使用成本。 外观类没有遵循开闭原则，当业务出现更换时，可能需要直接修改外观类。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十九之享元模式]]></title>
    <url>%2Fposts%2F7a00ed5e.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习享元模式 介绍享元模式是对象池的一种实现，享元模式用来尽可能减少内存使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能、避免内存移除等。 定义使用共享对象可以有效地支持大量的细粒度的对象。 使用场景 系统中存在大量的相似对象。 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。 需要缓冲池的场景。 UML 类图 Flyweiget : 享元对象抽象基类或者接口 ConcreteFlyweiget: 具体的享元对象。 FlyweigetFactory: 享元工厂，负责管理享元对象池和创建享元对象。 代码示例需求背景: 过年回家买车票，如果在并发 1W 人次同时 http 请求数据，如果后台每次都重新创建一个查询的车票结果，那么必然会造成大量重复对象的创建、销毁、使得 GC 任务繁重、内存高居不下。 展示车票信息接口 123public interface Ticket &#123; public void showTicketInfo(String info);&#125; 展示车票具体实现: 12345678910111213141516171819public class TrainTicket implements Ticket &#123; public String from; public String to; public String bunk; public int price; public TrainTicket(String from, String to) &#123; this.from = from; this.to = to; &#125; @Override public void showTicketInfo(String info) &#123; bunk = info; price = new Random().nextInt(300); System.out.println("购买从" + from + " -&gt; " + to + "的 " + bunk + " 火车票 ，价格：" + price); &#125;&#125; 车票信息管理: 12345678910111213141516171819public class TicketFactory &#123; static Map&lt;String, Ticket&gt; sTicketMap = new ConcurrentHashMap&lt;&gt;(); public static Ticket getTicket(String from, String to) &#123; String key = from + "-" + to; if (sTicketMap.containsKey(key)) &#123; //使用已经存在的对象 System.out.println("使用存在的对象 = [" + from + "], to = [" + to + "]"); return sTicketMap.get(key); &#125; else &#123; System.out.println("创建对象 = [" + from + "], to = [" + to + "]"); TrainTicket trainTicket = new TrainTicket(from, to); sTicketMap.put(key, trainTicket); return trainTicket; &#125; &#125;&#125; test: 1234567891011121314151617@Testpublic void testFlaweiget()&#123; Ticket ticket1 = TicketFactory.getTicket("北京", "上海"); ticket1.showTicketInfo("上铺"); Ticket ticket7 = TicketFactory.getTicket("北京", "上海"); ticket7.showTicketInfo("下铺"); Ticket ticket2 = TicketFactory.getTicket("北京", "上海"); ticket2.showTicketInfo("上铺"); Ticket ticket3 = TicketFactory.getTicket("北京", "上海"); ticket3.showTicketInfo("上铺"); Ticket ticket4 = TicketFactory.getTicket("北京", "成都"); ticket4.showTicketInfo("下铺"); Ticket ticket5 = TicketFactory.getTicket("北京", "上海"); ticket5.showTicketInfo("上铺"); Ticket ticket6 = TicketFactory.getTicket("北京", "上海"); ticket6.showTicketInfo("上铺");&#125; output: 1234567891011121314创建对象 = [北京], to = [上海]购买从北京 -&gt; 上海的 上铺 火车票 ，价格：36使用存在的对象 = [北京], to = [上海]购买从北京 -&gt; 上海的 下铺 火车票 ，价格：261使用存在的对象 = [北京], to = [上海]购买从北京 -&gt; 上海的 上铺 火车票 ，价格：100使用存在的对象 = [北京], to = [上海]购买从北京 -&gt; 上海的 上铺 火车票 ，价格：247创建对象 = [北京], to = [成都]购买从北京 -&gt; 成都的 下铺 火车票 ，价格：224使用存在的对象 = [北京], to = [上海]购买从北京 -&gt; 上海的 上铺 火车票 ，价格：262使用存在的对象 = [北京], to = [上海]购买从北京 -&gt; 上海的 上铺 火车票 ，价格：114 从上面的查询结果得知，如果已经查询了就使用缓存，没有就创建对象。 总结享元模式是实现比较简单，但是它的作用在某些场景确实极其重要的。它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。 享元模式的有点在于大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的。 享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。 享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十八之装饰模式]]></title>
    <url>%2Fposts%2F9cdd1e4f.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习装饰模式 介绍装饰模式 (也称为 Decorator Pattern) 也称为包装模式，属于结构型模式之一，其使用一种对客户端透明的方式来动态的扩展对象的功能，同时它也是继承关系的一种替代方案之一。在现实生活中你也看见很多装饰模式的例子，或者可以大胆地说装饰模式无处不在，就拿人来说，人需要各式各样的衣着，不管你穿着怎么，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层 “遮羞物” 而已，这就是装饰模式。 定义动态的给一个对象田爱军一些额外的职责。就是增加功能来说，装饰模式生成子类更为灵活。 使用场景需要透明且动态地扩展类的功能时。 UML 类图 Component: 抽象组件，可以试一个接口或者抽象类，其充当的就是被装饰的原始对象。 ConcreteComponent: 组件具体实现类，该类是 Component 类的基本实现，也是我们装饰的具体对象。 Decorator: 抽象装饰者。 ConcreteDecorator: 装饰者具体实现类 代码示例业务背景: 为 boy 穿衣 定义一个抽象的穿衣行为: 1234567public abstract class Person &#123; /** * Person 下有一个穿着的抽象方法 */ public abstract void dressed();&#125; 声明一个具体行为实现: 123456public class Boy extends Person &#123; @Override public void dressed() &#123; System.out.println("男孩穿着内裤"); &#125;&#125; 定义一个用来装饰具体行为的抽象: 12345678910111213public abstract class PersonCloth extends Person &#123; protected Person person ; public PersonCloth(Person person) &#123; this.person = person; &#125; @Override public void dressed() &#123; person.dressed(); &#125;&#125; 具体装饰实现: 12345678910111213141516171819202122232425262728public class ExpensiveCloth extends PersonCloth &#123; public ExpensiveCloth(Person person) &#123; super(person); &#125; @Override public void dressed() &#123; super.dressed(); //穿短袖 dressShirt(); //穿皮衣 dressLeather(); //穿牛仔裤 dressJean(); &#125; private void dressShirt() &#123; System.out.println("穿上短袖"); &#125; private void dressLeather() &#123; System.out.println("穿上皮衣"); &#125; private void dressJean() &#123; System.out.println("穿上牛仔裤"); &#125;&#125; 123456789101112131415public class CheapCloth extends PersonCloth &#123; public CheapCloth(Person person) &#123; super(person); &#125; @Override public void dressed() &#123; super.dressed(); dressShorts(); &#125; private void dressShorts() &#123; System.out.println("穿条短裤"); &#125;&#125; test: 1234567891011121314@Testpublic void testDecorator()&#123; //首先得有一个男孩 Person person = new Boy(); //先穿上便宜的衣服 PersonCloth cheapCloth = new CheapCloth(person); cheapCloth.dressed(); //或者在穿上有点档次的衣服 PersonCloth personCloth = new ExpensiveCloth(person); personCloth.dressed();&#125; output: 1234567男孩穿着内裤穿条短裤男孩穿着内裤穿上短袖穿上皮衣穿上牛仔裤 总结装饰模式和我们前面讲的 代理模式 有点类似，有时候甚至容易混淆，倒不是说会把代理当成装饰，而是常常会是将装饰看作代理，装饰模式是以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是给一个对象提供一个代理对象，并有代理对象来控制对原有的对象的引用。装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十七之适配器模式]]></title>
    <url>%2Fposts%2F16194dff.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习适配器模式 介绍适配器模式在我们开发中使用率极高，从最早的 ListView、GridView 到现在的 RecyclerView 都需要使用 Adapter ，并且在开发中我们遇到的优化问题，出错概率较大的地方也基本都出在 Adapter,这是一个让人又爱又恨的角色。 说到底，适配器是将两个不兼容的类融合到一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。例如，经常碰到要两个没有关系的类型之间进行交互，第一个解决方案是修改各自类的接口，但是如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时怎么办？这种情况我们往往会使用一个 Adapter,在这两种接口之间创建一个 “混血儿” 接口，这个 Adapter 会将这两个接口进行兼容，在不修改原有代码的情况下满足需求。 定义 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 使用场景 系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容。 想要建立一个可以重复使用的类，用于一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。 需要统一的输出接口，而输入端的类型不可预知。 UML 类图 Target: 目标角色，也就是所期待得到的接口。注意：由于这里讨论的是类适配器，因此目标不可以是类。 Adaptee: 现在需要适配的接口。 Adapter: 适配器角色，也是本模式的核心。适配器把源接口换成目标接口，当然，这一角色不可以是接口，而必须是具体类。 代码示例简单示例适配器模分为两种，即类适配器和对象适配器，我们先来看类适配器。 业务背景: 用电源接口做例子，笔记本电脑的电源一般是 5V 电压，但是我们生活中的电线电压一般都是 220V 。这个时候就出现了不匹配的状况，在软件开发中我们称为接口不兼容，此时就需要适配器来进行一个接口转换。在软件开发中有一句话正好体现了这点：任何问题都可以加一个中间层来解决。这个层我们可以理解为这里的 Apapter 层，通过这层来进行一个接口转换就达到了兼容的目的。 在上述电源接口这个示例中， 5V 电压就是 Target 接口，220V 电压就是 Adapter 类，而将电压从 220V 转换到 5V 就是 Adapter。 类适配器: target: 1234public interface FiveVolt &#123; int getVolt5();&#125; Adapter 角色，需要被转换的对象 123456public class Volt220 &#123; public int getVolt220()&#123; return 220; &#125;&#125; Adapter 角色，将 220 -&gt; 5 V 的电压: 123456public class VoltAdapter extends Volt220 implements FiveVolt &#123; @Override public int getVolt5() &#123; return 5; &#125;&#125; test: 12345@Testpublic void testAdapter1()&#123; VoltAdapter voltAdapter = new VoltAdapter(); System.out.println("voltAdapter:"+voltAdapter.getVolt5());&#125; output: 1voltAdapter:5 Target 角色给出了需要的目标接口，而 Adapter 类则是需要被转换的对象。Adapter 则是将 Volt220 转换成 Target 的接口。对应的 Target 的目标是要获取 5V 的输出电压，而 Adapter 真正输出电压是 220V ，此时就需要电源适配器类将 220V 电压转换为 5V 电压，解决接口不兼容的问题。 对象适配器: 我们只需要变换下 Adapter 对象，如下: 123456789101112131415161718public class VoltAdapter extends Volt220 implements FiveVolt &#123; private Volt220 mVolt220; public VoltAdapter(Volt220 mVolt220) &#123; this.mVolt220 = mVolt220; &#125; @Override public int getVolt220() &#123; return mVolt220.getVolt220(); &#125; @Override public int getVolt5() &#123; return 5; &#125;&#125; test / output: 12345 VoltAdapter voltAdapter = new VoltAdapter(new Volt220()); System.out.println("voltAdapter:"+voltAdapter.getVolt5());voltAdapter:5 这种实现方式直接将要被适配的对象传递到 Adapter 中，使用组合的形式是吸纳接口兼容的效果。这比类适配器方式更为灵活，它的另一个好处是被适配的对象中的方法不会暴露出来，而类适配由于继承了被适配对象，因此，被适配对象类的函数在 Adapter 类中也都含有，这使得 Adapter 类出现了一些奇怪的接口，用户使用成本较高，因此，对象适配器模式更加灵活、实用。 总结Adapter 模式的经典实现在于将原本不兼容的接口融合在一起，使之能够很好的进行合作。但是，在实际开发中，Adapter 模式也有一些灵活的实现。例如 ListView 中的隔离变化，使得整个 UI 架构变得更灵活，能够拥抱变化。Adapter 模式在开发中运用非常广泛，因此，掌握 Adapter 模式是非常必要的。 优点: 更好的复用性，系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 更好的扩展性，在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 缺点: 过多地使用适配器，会让系统非常凌乱，不易整体把握。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十六之组合模式]]></title>
    <url>%2Fposts%2Ff6bae352.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习组合模式 介绍组合模式（Composite Pattern）也称为部分整体模式 (Part Whole Pattern) ，属于结构性设计模式，组合模式比较简单，它将一组相似的对象看做一个对象处理，并根据一个树状结构来组合对象，然后提供一个统一的方法去访问相应的对象，以此忽略掉对象与对象集合之间的差别。 定义将对象组合成树形结构以表示 ”部分-整体“ 的层次结构，使得用户对整个对象和组合对象的使用具有一致性。 使用场景 表示对象的 ”部分-整体“ 层次结构时。 从一个整体中能够独立出部分模块或功能的场景。 UML 类图 Component: 抽象根节点，为组合中的对象声明接口。在适当的情况下，实现所有类共有接口的缺省行为。声明一个接口用于访问和管理 Component 的子节点。可在递归结构中定义一个接口，用于访问一个父节点，并在合适的情况下实现它。 Composite: 定义有子节点的那些枝干节点的行为，存储子节点，在 Component 接口中实现与子节点有关的操作。 Leaf: 在组合中表示叶子节点对象，叶子节点没有子节点，在组合中定义节点对象的行为。 Client: 通过 Component 接口操纵组合节点的对象。 代码示例简单示例抽象根节点: 12345678910111213141516171819202122232425262728293031323334353637public abstract class Component &#123; /** * 节点名称 */ protected String name; public Component(String name) &#123; this.name = name; &#125; /** * 具体的逻辑方法由子类实现 */ public abstract void doSomething(); /** * 添加子节点 * @param component */ public abstract void addChild(Component component); /** * 移除子节点 * @param component */ public abstract void removeChild(Component component); /** * 获取子节点 * @param index * @return */ public abstract Component getChildren(int index);&#125; 枝干节点: 123456789101112131415161718192021222324252627282930313233343536public class Composite extends Component &#123; /** * 存储节点的容器 */ private List&lt;Component&gt; mLists = new ArrayList&lt;&gt;(); public Composite(String name) &#123; super(name); &#125; @Override public void doSomething() &#123; System.out.println("name: " + name); if (mLists != null &amp;&amp; mLists.size() &gt; 0) &#123; for (Component component : mLists) &#123; component.doSomething(); &#125; &#125; &#125; @Override public void addChild(Component component) &#123; mLists.add(component); &#125; @Override public void removeChild(Component component) &#123; mLists.remove(component); &#125; @Override public Component getChildren(int index) &#123; return mLists.get(index); &#125;&#125; 叶子节点: 1234567891011121314151617181920212223242526public class Leaf extends Component &#123; public Leaf(String name) &#123; super(name); &#125; @Override public void doSomething() &#123; System.out.println("name: " + name); &#125; @Override public void addChild(Component component) &#123; throw new UnsupportedOperationException("叶子节点没有子节点"); &#125; @Override public void removeChild(Component component) &#123; throw new UnsupportedOperationException("叶子节点没有子节点"); &#125; @Override public Component getChildren(int index) &#123; throw new UnsupportedOperationException("叶子节点没有子节点"); &#125;&#125; test: 1234567891011121314151617181920212223@Testpublic void testComponent() &#123; //构造一个根节点 Component root = new Composite("Root"); //构造枝干节点 Component branchA = new Composite("branchA"); Component branchB = new Composite("branchB"); //构造叶子节点 Component leafA = new Leaf("leafA"); Component leafB = new Leaf("LeafB"); //将叶子节点添加至枝干节点中 branchA.addChild(leafA); branchB.addChild(leafB); //将枝干节点添加进跟节点 root.addChild(branchA); root.addChild(branchB); root.doSomething();&#125; output: 12345name: Rootname: branchAname: leafAname: branchBname: LeafB 实战 业务背景: 用代码表示文件夹跟文件的组合关系; 文件和文件夹抽象类: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class Dir &#123; /** * 声明一个 List 成员变量存储文件夹下面所有元素 */ protected List&lt;Dir&gt; mDirs = new ArrayList&lt;&gt;(); /** * 当前文件或文件夹名称 */ protected String name; public Dir(String name) &#123; this.name = name; &#125; /** * 添加一个文件或文件夹 * @param dir */ public abstract void addDir(Dir dir); /** * 移除一个文件或文件夹 * @param dir */ public abstract void removeDir(Dir dir); /** * 清空文件夹下面所有的元素 */ public abstract void clear(); /** * 输出文件夹下目录结构 */ public abstract void print(); /** * 获取文件夹下所有的文件或子文件夹 */ public abstract List&lt;Dir&gt; getFiles(); /** * 获取文件或文件夹名称 * @return */ public String getName()&#123; return name; &#125;&#125; 具体文件夹类: 12345678910111213141516171819202122232425262728293031323334353637383940public class Folder extends Dir &#123; public Folder(String name) &#123; super(name); &#125; @Override public void addDir(Dir dir) &#123; mDirs.add(dir); &#125; @Override public void removeDir(Dir dir) &#123; mDirs.remove(dir); &#125; @Override public void clear() &#123; mDirs.clear(); &#125; @Override public void print() &#123; System.out.print(getName() + " ("); Iterator&lt;Dir&gt; iterator = mDirs.iterator(); while (iterator.hasNext()) &#123; Dir dir = iterator.next(); dir.print(); if (iterator.hasNext()) &#123; System.out.print(", "); &#125; &#125; System.out.print(")"); &#125; @Override public List&lt;Dir&gt; getFiles() &#123; return mDirs; &#125;&#125; 具体文件类: 123456789101112131415161718192021222324252627282930public class File extends Dir &#123; public File(String name) &#123; super(name); &#125; @Override public void addDir(Dir dir) &#123; throw new UnsupportedOperationException("文件对象不支持该操作"); &#125; @Override public void removeDir(Dir dir) &#123; throw new UnsupportedOperationException("文件对象不支持该操作"); &#125; @Override public void clear() &#123; throw new UnsupportedOperationException("文件对象不支持该操作"); &#125; @Override public void print() &#123; System.out.println("name: "+name); &#125; @Override public List&lt;Dir&gt; getFiles() &#123; throw new UnsupportedOperationException("文件对象不支持该操作"); &#125;&#125; test: 1234567891011121314151617181920212223242526272829303132333435@Testpublic void testComponent2()&#123; //构造一个目录对象表示 sdcard 盘跟目录 Dir diskSdcard = new Folder("sdcard"); // sdcard 下有一个文件 diskSdcard.addDir(new File("bug.log")); //sdcard 下还有一个子目录 android Dir android = new Folder("android"); //android 目录下有一个目录 Dir data = new Folder("data"); data.addDir(new File("2019-09-14.log")); android.addDir(data); diskSdcard.addDir(android); //sdcard 下还有一个子目录 baidu Dir baidu = new Folder("baidu"); //android 目录下有一个目录 Dir cache = new Folder("cache"); cache.addDir(new File("offline.baidu")); baidu.addDir(cache); diskSdcard.addDir(baidu); //sdcard 下还有一个子目录 downloads Dir downloads = new Folder("downloads"); //android 目录下有一个目录 Dir f360 = new Folder("360"); f360.addDir(new File("360.log")); downloads.addDir(f360); diskSdcard.addDir(downloads); //打印文件结构 diskSdcard.print();&#125; output: 12345678sdcard ( //文件 name: bug.log, //文件夹 android (data (name: 2019-09-14.log)), baidu (cache (name: offline.baidu)), downloads (360 (name: 360.log))) 这里我们以括号作为一个文件夹的内容范围，如上输出所以 adcard 下文件夹有 3 个子文件夹 Android、baidu、downloads 子文件夹，以及一个 bug.log 文件，而在 3 个子文件夹中还各自包含子文件夹和文件，一个典型的树状嵌套解耦，这就是一个组合模式。 总结优点: 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让高层模块忽略了层次的差异，方便对整个层次结构进行控制。 高层模块可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了高层模块的代码。 在组合模式中增加了新的枝干构件和叶子构件都很方便，无须对现有类库进行任何修改，符合 “开闭原则”。 组合模式为树状结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和树干对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 缺点: 早新增构件时不好对树干中的构件类型进行限制，不能依赖类型系统来施加这些约束，因为在大多数情况下，它们都来自于想听的抽象层，此时，必须进行类型检查来实现，这个实现过程较为复杂。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十五之代理模式]]></title>
    <url>%2Fposts%2F6e2d1f5e.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习代理模式 介绍代理模式 (Proxy Pattren) 也称为委托模式，是属于结构型设计模式，其重要性不言而喻，相信在看过本篇文章之后会发现不少设计模式中都有代理模式的影子。那么何为代理模式？其实代理在我们日常生活中并不少见，对于程序员来说最常接触的莫过于代理上网了，连上代理服务器地址，就可以轻松畅游全世界的网络；总而言之，也许你并不留意，但是代理是无处不在，现实生活如此，我们的 Code 世界里也是如此！既然这样，我们来探究下代理模式倒是有多普遍。下面首先看下代理模式的定义吧。 定义为其它对象提供一种代理以控制对这个对象的访问。 使用场景当无法或不想直接访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。 UML 类图 Subject: 抽象主题类；该类的主要职责是声明真实主题与代理的共同接口方法，该类既可以是一个抽象类也可以是一个接口。 RealSubject: 真实主题类；该类也称为被委托类或被代理类，该类定义了代理所表示的真实对象，由其执行具体的业务逻辑方法，而客户类则通过代理类间接地调用真实主题中定义的方法。 ProxySubject: 代理类；该类也称为委托类或代理类，该类持有一个对真实主题类的引用，在其所实现的接口方法中调用真实主题类中相应的接口方法执行，以此起到代理的作用。 Client: 客户类，即使用代理类的类型。 代码示例代理模式可以大致分为两大部分，一是静态代理，而是动态代理。静态代理是只有具体的代理对象，而动态代理则与静态代理相反，通过反射机制动态地生成代理者的对象，也就是说我们在 code 阶段压根不需要知道代理对象是谁，代理谁将会在执行阶段决定。下面我们就来看下吧 简单示例静态代理业务背景: X 程序员在公司上班时，遇见了公司拖欠工资甚至克扣工资的情况，这种情况下 X 程序员还是通过法律途径来解决问题，这个时候就需要请一个律师来作为自己的诉讼代理人，先看下面的代码示例吧 诉讼接口类: 12345678910111213141516171819202122public interface ILawsuit &#123; /** * 提交申请 */ void submit(); /** * 举行举证 */ void burden(); /** * 开始辩护 */ void defend(); /** * 诉讼完成 */ void finish();&#125; 具体诉讼人（X程序员）: 123456789101112131415161718192021222324public class XProgrammer implements ILawsuit &#123; @Override public void submit() &#123; System.out.println("老板欠 X 程序员工资，申请仲裁!"); &#125; @Override public void burden() &#123; System.out.println("这是合同书和过去一年的银行工资流水"); &#125; @Override public void defend() &#123; System.out.println("证据确凿！不需要再说什么了！"); &#125; @Override public void finish() &#123; System.out.println("诉讼成功！判决老板即日起 7 天内结算工资！"); &#125;&#125; X程序员请的律师（代理对象）: 123456789101112131415161718192021222324252627282930public class ProxyLawyer implements ILawsuit &#123; /** * 持有一个具体被代理者的引用，这里就是 X 程序员，也可以是其它 Y 程序员 只是具体说明。 */ private ILawsuit mLawsuit; public ProxyLawyer(ILawsuit lawsuit) &#123; mLawsuit = lawsuit; &#125; @Override public void submit() &#123; mLawsuit.submit(); &#125; @Override public void burden() &#123; mLawsuit.burden(); &#125; @Override public void defend() &#123; mLawsuit.defend(); &#125; @Override public void finish() &#123; mLawsuit.finish(); &#125;&#125; test: 123456789101112131415@Testpublic void testProxy()&#123; //X 程序员 ILawsuit lawsuit = new XProgrammer(); //程序员请的律师，把自己的事务交于律师来处理 ILawsuit proxyLawyer = new ProxyLawyer(lawsuit); //律师开始处理 proxyLawyer.submit(); proxyLawyer.burden(); proxyLawyer.defend(); proxyLawyer.finish();&#125; output: 1234老板欠 X 程序员工资，申请仲裁!这是合同书和过去一年的银行工资流水证据确凿！不需要再说什么了！诉讼成功！判决老板即日起 7 天内结算工资！ 动态代理动态代理其实也很简单，Java 给我们提供了一个很便捷的动态代理接口 InvocationHandler ,实现该接口需要重写其调用方法 invoke。 下面我们就上面的示例来稍加改动一下: 动态代理类(这里可以理解为律师对象) 1234567891011121314151617public class DynamicProxy implements InvocationHandler &#123; /** * 代理者的引用（这里可以理解为 X 程序员） */ private Object object; public DynamicProxy(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //通过反射调用其代理者的方法 return method.invoke(object,args); &#125;&#125; test: 123456789101112131415161718192021@Testpublic void testDynamicProxy()&#123; //X 程序员 ILawsuit lawsuit = new XProgrammer(); //构造一个动态代理对象（程序员请的律师，把自己的事务交于律师来处理） DynamicProxy dynamicProxy = new DynamicProxy(lawsuit); //拿到代理者身上的 ClassLoader ClassLoader classLoader = lawsuit.getClass().getClassLoader(); //动态的构造一个代理者律师出来 ILawsuit proxyLawyer = (ILawsuit) Proxy.newProxyInstance(classLoader, new Class[]&#123;ILawsuit.class&#125;, dynamicProxy); //律师开始处理 proxyLawyer.submit(); proxyLawyer.burden(); proxyLawyer.defend(); proxyLawyer.finish();&#125; output: 1234老板欠 X 程序员工资，申请仲裁!这是合同书和过去一年的银行工资流水证据确凿！不需要再说什么了！诉讼成功！判决老板即日起 7 天内结算工资！ 运行结果和静态代理一样，由此可见动态代理通过一个代理类来代理 N 多个被代理类，其本质是对代理者与被代理者进行解耦，使两者没有直接的耦合关系。相对而言静态代理则是能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同的代理类，最为复杂，但是静态代理更符合面向对象原则。在开发时具体使用哪种方式来实现代理，就看自己的偏好了。 总结代理模式应用广泛，在后面的结构型模式中，你都可以看到代理模式的影子，有些模式单独作为一种设计模式，倒不如说是对代理模式的一种针对性优化。而且代理模式几乎没有缺点可言，它是细分化至很小的一种模式，如果非得说一个缺点的话，那么就是设计模式的通病，对类的增加。不过在这种孰优孰劣的局势下，就算对类的稍微增加又有什么问题呢，是吧？]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十四之中介者模式]]></title>
    <url>%2Fposts%2F386c7d9.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习中介者模式 介绍中介者模式 (Mediator Pattern) 也称为调解者模式或调停者模式，Mediator 本身就有调停者和调解者的意思。在日常生活中调停者或调解者这个角色我们见得比较多的是 ”和事佬“，也就是说调解两个有争端的人的角色。 定义中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立变化。中介者模式将多对多的相互作用转化为一对多的相互作用。中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 使用场景当对象之间的交互操作很多且每个对象的行为操作都依赖彼此时，为防止在修改一个对象的行为时，同时涉及修改很多其他对象的行为，可采用中介者模式来解决紧耦合问题。该模式将对象之间的多对多变成一对多关系，中介者对象将系统从网状结构变成以调解者为中心的星形结构，达到降低系统的复杂性，提高可扩展性的作用。 UML 类图 Mediator: 抽象中介者角色，定义了同事对象到中介者对象的接口，一般以抽象类的方式实现。 ConcreteMediator: 具体中介者角色，继承于抽象中介者，实现了父类定义的方法，它从具体的同事对象接收消息，向具体同事对象发出命令。 Colleague: 抽象同事类角色，定义了中介者对象的接口，它只知道中介者而不知道其它的同事对象。 ConcreteColleagueA/B: 具体同事类角色，继承于抽象同事类，每个具体同事类都知道本身在小范围内的行为，而不知道它在大范围内的目的。 代码示例简单示例中介抽象类: 12345678910111213141516171819202122232425public abstract class Mediator &#123; /** * 具体同事类 A */ protected ConcreteColleagueA concreteColleagueA; /** * 具体同事类 B */ protected ConcreteColleagueB concreteColleagueB; /** * 抽象中介方法、子类实现 */ public abstract void method(); public void setConcreteColleagueA(ConcreteColleagueA concreteColleagueA)&#123; this.concreteColleagueA = concreteColleagueA; &#125; public void setConcreteColleagueA(ConcreteColleagueB concreteColleagueB)&#123; this.concreteColleagueB = concreteColleagueB; &#125;&#125; 具体中介者: 12345678public class ConcreteMediator extends Mediator &#123; @Override public void method() &#123; concreteColleagueA.action(); concreteColleagueB.action(); &#125;&#125;复制代码 抽象同事: 123456789101112131415public abstract class Colleague &#123; /** * 中介者对象 */ protected Mediator mediator; /** * 同事角色具体行为，由子类实现 */ public abstract void action(); public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125; 具体同事实现类A/B 1234567891011public class ConcreteColleagueA extends Colleague &#123; public ConcreteColleagueA(Mediator mediator) &#123; super(mediator); &#125; @Override public void action() &#123; System.out.println("ConcreteColleagueA 将信息递交给中介者处理"); &#125;&#125; 123456789public class ConcreteColleagueB extends Colleague &#123; public ConcreteColleagueB(Mediator mediator) &#123; super(mediator); &#125; public void action() &#123; System.out.println("ConcreteColleagueB 将信息递交给中介者处理"); &#125;&#125; test 1234567@Testpublic void testMediator()&#123; ConcreteMediator mediator = new ConcreteMediator(); mediator.setConcreteColleagueA(new ConcreteColleagueA(mediator)); mediator.setConcreteColleagueB(new ConcreteColleagueB(mediator)); mediator.method();&#125; output 12ConcreteColleagueA 将信息递交给中介者处理ConcreteColleagueB 将信息递交给中介者处理 实战需求: 用代码演示电脑中的主板怎么把 CPU、内存、显卡、IO 设备 等组合在一起的,并控制他们播放音视频数据？用中介者模式 抽象中介类: 12345678public abstract class Mediator &#123; /** * 同事对象改变时通知中介者的方法 * 在同事对象改变时由中介者去通知其它同事对象 */ public abstract void changed(Colleague c);&#125; 具体抽象中介类: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MainBoard extends Mediator &#123; /** * 光驱设备 */ private CDDevice cdDevice; /** * CPU */ private CPU cpu; /** * 声卡设备 */ private SoundCard soundCard; /** * 光驱设备 */ private GraphicsCard graphicsCard; @Override public void changed(Colleague c) &#123; //如果是光驱读取了数据 if (c == cdDevice)&#123; handleCD((CDDevice)c); &#125; //如果 CPU 处理完数据 if (c == cpu)&#123; handleCPU((CPU)c); &#125; &#125; /** * 处理 CPU 读取数据后与其它设备的交互 * @param cpu */ private void handleCPU(CPU cpu) &#123; this.soundCard.soundPlay(cpu.getDataSound()); this.graphicsCard.videoPlay(cpu.getDataVideo()); &#125; /** * 处理光驱读取数据后与其它设备的交互 * @param cdDevice */ private void handleCD(CDDevice cdDevice) &#123; this.cpu.decodeData(cdDevice.read()); &#125; /** * 设置 CPU */ public void setCPU(CPU cpu)&#123; this.cpu = cpu; &#125; /** * 设置 CD */ public void setCdDevice(CDDevice cdDevice)&#123; this.cdDevice = cdDevice; &#125; /** * 设置声卡 */ public void setSoundCard(SoundCard soundCard)&#123; this.soundCard = soundCard; &#125; /** * 设置显卡 */ public void setGraphicsCard(GraphicsCard graphicsCard)&#123; this.graphicsCard = graphicsCard; &#125;&#125; 抽象同事: 12345678910111213141516171819202122public class CDDevice extends Colleague &#123; private String videoData;//视频数据 public CDDevice(Mediator mediator) &#123; super(mediator); &#125; /** * 读取视频数据 * @return */ public String read()&#123; return videoData; &#125; /** * 加载视频数据 */ public void load()&#123; videoData = "视频数据,音频数据"; mediator.changed(this); &#125;&#125; cpu、GraphicsCard,SoundCard, 这几个实现都差不多就不在贴代码了。 操作类: 12345678910111213141516171819202122232425@Testpublic void testMediator2()&#123; //构造主板对象--也就是中介者 MainBoard mainBoard = new MainBoard(); //分别构造零部件 CPU cpu = new CPU(mainBoard); CDDevice cdDevice = new CDDevice(mainBoard); GraphicsCard graphicsCard = new GraphicsCard(mainBoard); SoundCard soundCard = new SoundCard(mainBoard); //将各个零部件安装到主板身上 mainBoard.setCdDevice(cdDevice); mainBoard.setCPU(cpu); mainBoard.setGraphicsCard(graphicsCard); mainBoard.setSoundCard(soundCard); //安装完成后，开始播放视频。 cdDevice.load();&#125; output: 12音频 = [音频数据]视频 = [视频数据] 从上述程序演示中大家可以明白，中介者模式就是用来协调多个对象之间的交互，就像上面实例中的主板，如果没有主板这个中介者，那么计算机里的没一个零部件都要与其它零部件建立关联，比如 CPU 要与内存交互、CPU 要与显卡交互、CPU 要与 IO 设备交互等，这么一来就会构成一个错综复杂的网状图，而中介者模式的出现则是将这一个错综复杂的网状图编程一个结构清晰的星状图，其中心就是中介者。 总结在面向对象的编程语言里，一个类必然会与其他类产生依赖关系，如果这种依赖关系如网状般错综复杂，那么必然会影响我们的代码执行效率，适当的使用中介者模式可以对这种依赖关系解耦使逻辑结构清晰，但是，如果几个类之间的依赖关系并不复杂，使用中介者模式反而使得原本不复杂的逻辑结构变得复杂，所以，我们在决定使用中介者模式之前要多考虑权衡利弊。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十三之访问者模式]]></title>
    <url>%2Fposts%2Ffa7c7db8.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习访问者模式 介绍访问者模式是一种将数据操作与数据结构分离的设计模式，它是 《设计模式》中较为复杂的一个，但它的使用频率并不高，正如《设计模式》的作者 GOF 对访问者模式的描述：大多数情况下，你并不需要使用访问者模式，但是当你一旦需要使用它时，那你就是真正的需要它了。 访问者模式的基本思想是，软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个 accept 方法用来接受访问者对象的访问。访问者是一个接口，它拥有一个 visit 方法，这个方法对访问到的对象结构中不同类型的元素做出不同的处理。在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施 accept 方法，在每一个元素的 accept 方法中会调动访问者的 visit 方法，从而使访问者得到以处理对象结构的每一个元素，我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果。 定义 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。 使用场景 对象结构比较稳定，但经常需要在此对象进行很多不同的并且不相关的操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作 “污染” 这些对象的类，也不希望在增加新操作时修改这些类。 UML 类图 Visitor：接口或者抽象类，它定义了对每一个元素 (Element) 访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素个数是一样的，因此，访问者模式要求元素的类族要稳定，如果经常添加、移除元素类，必然会导致频繁地修改 Visitor 接口，如果出现这种情况，则说明不适合使用访问者模式。 ConcreteVisitor: 具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。 ElementA、ElementB: 具体的元素类，它提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 ObjectStructure: 定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素供访问者访问。 代码示例 访问者模式是一个结构、概念都较为复杂的模式，使用频率也不高，但是并不代表可以将它的作用忽略，当有合适的场景时，访问者模式会带来意向不到的灵活性，下面我们就以一个简单的示例说明下： 简单示例需求: 公司的领导层年底对员工进行绩效考核，但是每个领导对于员工的关注点不同，所以要不同的访问处理。 员工抽象类 12345678910111213141516171819public abstract class Staff &#123; public String name; /** * 员工 kpi */ public int kpi; public Staff(String name) &#123; this.name = name; kpi = new Random().nextInt(10); &#125; /** * 接受公司领导层对员的访问 * @param visitor */ public abstract void accept(Visitor visitor);&#125; Staff 类定义了员工的基本信息及一个 accept 方法，表示接受公司领导的访问，由子类具体实现，下面来看看，具体实现。 程序员： 123456789101112131415161718public class Engineer extends Staff &#123; public Engineer(String name) &#123; super(name); &#125; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; /** * 工程师这一年写的代码量 */ public int getCodeLines()&#123; return new Random().nextInt(10 * 10000); &#125;&#125; 经理: 1234567891011121314151617181920public class Manager extends Staff&#123; public Manager(String name) &#123; super(name); &#125; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; /** * 一年做的产品数量 * @return */ public int getProducts()&#123; return new Random().nextInt(10); &#125;&#125; 在程序员、经理类中添加了各自的实现，因为他们的差异性才能使得访问者模式发挥它的工作。Staff、Engineer、Manager 这 3 个类就是对象结构，这些类相对稳定，不会发生变化。 员工报表: 123456789101112131415161718192021public class BusinesssReport &#123; private List&lt;Staff&gt; mStaff = new ArrayList&lt;&gt;(); public BusinesssReport()&#123; mStaff.add(new Manager("DevYK 经理")); mStaff.add(new Engineer("IOS 工程师")); mStaff.add(new Engineer("Android 工程师")); mStaff.add(new Engineer("Java 工程师")); mStaff.add(new Engineer("C++ 工程师")); &#125; /** * 为访问者展示报表 */ public void showReport(Visitor visitor)&#123; for (Staff staff : mStaff) &#123; staff.accept(visitor); &#125; &#125;&#125; 公司领导层抽象访问者封装: 123456789101112public interface Visitor &#123; /** * 访问工程师类型 */ public void visit(Engineer engineer); /** * 访问经理类型 */ public void visit(Manager leader);&#125; CEO 访问员工实现: 123456789101112public class CEOVisitor implements Visitor &#123; @Override public void visit(Engineer engineer) &#123; System.out.println("engineer = [" + "name: " + engineer.name + " kpi: " + engineer.kpi + "]"); &#125; @Override public void visit(Manager leader) &#123; System.out.println("leader = [" + "name: " + leader.name + " kpi: " + leader.kpi + " 产品数量：" + leader.getProducts() + "]"); &#125;&#125; CTO 访问员工实现 1234567891011public class CTOVisitor implements Visitor &#123; @Override public void visit(Engineer engineer) &#123; System.out.println("engineer = [" + engineer.name + " 代码行数："+engineer.getCodeLines()+"]"); &#125; @Override public void visit(Manager leader) &#123; System.out.println("leader = [" + leader.name + " 产品数量："+leader.getProducts()+"]"); &#125;&#125; Client 客户端代码 –》年总进行访问 1234567891011@Testpublic void textVisitor()&#123; //构建报表 BusinesssReport businesssReport = new BusinesssReport(); //给 CEO 汇报的报表 System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;给 CEO 汇报的报表"); businesssReport.showReport(new CEOVisitor()); //给 CTO 汇报的报表 System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;给 CTO 汇报的报表"); businesssReport.showReport(new CTOVisitor());&#125; 客户端代码中，首先构建了一个报表对象，该对象中维护了所有员工的集合，然后通过报表类的 showReport 函数为 Visitor 对象提供一个访问接口，在这个函数中查看所有员工信息，然后调用员工的 accept 函数接受公司领导层的访问，每个访问者对不同职位的员工调用对应的 visit 函数实现不同的操作。绩效如下： ouput: 12345678910111213&gt;&gt;&gt;&gt;&gt;&gt;&gt;给 CEO 汇报的报表leader = [name: DevYK 经理 kpi: 6 产品数量：6]engineer = [name: IOS 工程师 kpi: 3]engineer = [name: Android 工程师 kpi: 1]engineer = [name: Java 工程师 kpi: 3]engineer = [name: C++ 工程师 kpi: 9]&gt;&gt;&gt;&gt;&gt;&gt;&gt;给 CTO 汇报的报表leader = [DevYK 经理 产品数量：4]engineer = [IOS 工程师 代码行数：81491]engineer = [Android 工程师 代码行数：25627]engineer = [Java 工程师 代码行数：61337]engineer = [C++ 工程师 代码行数：51714] 在上述示例中， Staff 扮演了 Element 角色，而 Engineer 和 Manager 都是 ConcreteElement; CEOVisitor 和 CTOVisitor 都是具体的访问者 Visitor 对象实现；而 BusinessReport 就是 ObjectStructure; Client 就是客户端代码，详细结构可以下下面的 UML 类图 总结优点: 各自角色职责分明，符合单一职责原则； 具有优秀的可扩展性； 使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。 灵活性。 缺点： 具体元素对访问者公布细节，违反了迪米特原则； 具体元素变更时导致修改成本大； 违反了依赖导致原则，为了达到 “区别对待” 而依赖了具体类，没有依赖抽象； 在使用该模式之前，我们应该明确它的使用场景、它能解决什么问题等，以此来避免滥用设计模式。所以，在学习设计模式时，一定要理解模式的适用性及优缺点。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十二之模板方法模式]]></title>
    <url>%2Fposts%2Fafa4869b.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习模板方法模式 介绍在面向对象开发过程中，通常会遇到这样的一个问题，我们知道一个算法所需的关键步骤，并确定了这些步骤的执行顺序，但是，某些步骤的具体实现是未知的，或者说某些步骤的实现是会随着环境的变化而改变的，例如，执行程序的流程大致如下: 检查代码的正确性； 链接相关的类库； 编译相关代码； 执行程序； 对于不同的程序设计语言，上述 4 个步骤都是不一样的，但是，它们的执行流程是固定的，这类问题的解决方案就是这们这篇的主要内容 - 模板方法模式。 定义定义一个操作中算法的框架，将一些步骤交于子类具体实现，使得子类可以改变一个算法的结构即可重定义该算法的某些特定步骤。 使用场景 多个子类有公有的方法，并且逻辑基本相同时。 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。 UML 类图 AbsTemplate: 抽象类，定义了一套算法框架。 ConcreteImplA: 具体实现类 A。 ConcreteImpleB: 具体实现类 B。 代码示例模板方法模式实际上是封装一个固定流程，就像是一套执行模板一样，第一步该做什么，第二步该做什么都已经在抽象类中定义好。而子类可以有不同的算法实现，在框架不被修改的情况下实现某些步骤的算法替换，下面就就以简单示例来说明一下。 简单示例需求： 用代码简要描述开机过程 定义抽象的模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class AbstractComputer &#123; /** * 开启电源 */ protected void powerOn()&#123; System.out.println("开启电源"); &#125; /** * 硬件检查 */ protected void checkHardware()&#123; System.out.println("硬件检查"); &#125; /** * 加载系统 */ protected void loadSystem()&#123; System.out.println("加载系统"); &#125; /** * 屏幕显示 */ protected void showScreen()&#123; System.out.println("屏幕显示"); &#125; /** * 输入用户信息 */ protected void login()&#123; System.out.println("密码验证成功，进入主页面。"); &#125; /** * 启动计算机方法，步骤固定为开启电源、硬件检查、加载系统、屏幕显示、登录。设计为 final 防止被重写 */ public final void startUp()&#123; System.out.println("------&gt;&gt;&gt;&gt;&gt;&gt;&gt; startup "); powerOn(); checkHardware(); loadSystem(); showScreen(); login(); System.out.println("------&gt;&gt;&gt;&gt;&gt;&gt;&gt; Successful"); &#125;&#125; 抽象模板实现 A 12345678public class CoderComputer extends AbstractComputer &#123; @Override protected void login() &#123; System.out.println("密码输入完成，交于系统检查。"); super.login(); &#125;&#125; 抽象模板实现 B 1234567891011121314public class MilitaryComputer extends AbstractComputer &#123; @Override protected void checkHardware() &#123; super.checkHardware(); System.out.println("检查防火墙"); &#125; @Override protected void login() &#123; System.out.println("视网膜扫描 \n 视网膜验证成功"); super.login(); &#125;&#125; test 123456789@Testpublic void testTemplate()&#123; AbstractComputer abstractComputerA = new CoderComputer(); abstractComputerA.startUp(); AbstractComputer abstractComputerB = new MilitaryComputer(); abstractComputerB.startUp();&#125; output 123456789101112131415161718192021程序员电脑启动流程------&gt;&gt;&gt;&gt;&gt;&gt;&gt; startup 开启电源硬件检查加载系统屏幕显示密码输入完成，交于系统检查。密码验证成功，进入主页面。------&gt;&gt;&gt;&gt;&gt;&gt;&gt; Successful军用电脑启动流程------&gt;&gt;&gt;&gt;&gt;&gt;&gt; startup 开启电源硬件检查检查防火墙加载系统屏幕显示视网膜扫描 视网膜验证成功密码验证成功，进入主页面。------&gt;&gt;&gt;&gt;&gt;&gt;&gt; Successful 通过上面的模板例子可以看到 ，在 startUp 方法中有一些固定的执行顺序，但是，不同的场景执行实现的步骤各不相同，因此子类需要复写相应的方法来进行自定义处理，这里需要注意的是 startUp 为 final 方法，这样就可以保证模板的执行顺序不被外部更改，子类更改某一时刻执行的具体实现，这样就保证了整个逻辑流程的稳定性。 总结模板方法模式用 4 个字概括就是：流程封装。也就是把某个固定的流程封装到一个 final 函数中，并让子类能够定制这个流程中的某些或者所有步骤，这就要求父类提取共用的代码，提升代码复用率，同时也带来了更好的可扩展性。 优点: 封装不变部分，扩展可变部分。 提取公共部分代码，便于维护。 缺点: 模板方法会带来代码阅读的难度，会让用户觉得难以理解。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十一之迭代器模式]]></title>
    <url>%2Fposts%2F1cfae984.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习迭代器模式 介绍迭代器模式 (Iterator Pattern) 又称为游标 (Cursor) 模式 ，是行为型设计模式之一。迭代器模式算是一个比较古老的设计模式，其源于对容器的访问，比如 Java 的 List 、Map 、数组等，我们知道对容器对象的访问必然会设计遍历算法，我们可以将遍历的方法封装在容器中，或者不提供遍历方法。如果我们将遍历的方法封装到容器中，那么对于容器类来说就承担了过多的功能，容器类不仅仅要维护自身内部的数据元素而且还要对外提供遍历的接口方法，因为遍历状态的存储问题还不能对同一个容器同时进行多个遍历操作，如果我们不提供遍历方法而让使用者自己去实现，又会让容器内部细节暴露无遗，正因于此，迭代模式应运而生，在客户访问类与容器体之间插入了一个第三者 - 迭代器，很好地解决了上面所述的弊端。 定义提供一种方法顺序访问一个容器对象中的各个元素，而又不需要暴露该对象的内部表示。 使用场景遍历一个容器对象时。 UML 类图 Iterator: 迭代器接口。迭代器接口负责定义、访问和遍历元素的接口。 Concrete Iterator: 具体迭代器类。具体迭代器类的目的主要是实现迭代器接口，并记录遍历的当前位置。 Aggregate: 容器接口。容器接口负责提供创建具体迭代器角色的接口。 Concrete Aggregate: 具体容器类。具体迭代器角色与该容器相关联。 Client: 客户类。 代码示例简单示例迭代器接口 1234567891011121314public interface Iterator&lt;T&gt; &#123; /** * 是否还有下一个元素 * @return true 表示有，false 表示没有 */ boolean hasNext(); /** * 返回当前位置的元素并将位置移动到下一位 * @return */ T next();&#125; 具体迭代器类 123456789101112131415161718192021222324252627282930public class ConcreteIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; /** * 模拟用一个 List */ private List&lt;T&gt; mList = new ArrayList&lt;&gt;(); private int cursor = 0; public ConcreteIterator(List&lt;T&gt; list) &#123; this.mList = list; &#125; @Override public boolean hasNext() &#123; return cursor != mList.size(); &#125; @Override public T next() &#123; //定义一个临时变量 T obj = null; if (this.hasNext()) &#123; obj = this.mList.get(cursor++); &#125; return obj; &#125;&#125; 容器接口 123456789101112131415161718192021public interface Aggregate&lt;T&gt; &#123; /** * 添加一个对象 * @param t */ void add(T t); /** * 删除的对象 * @param t */ void remove(T t); /** * 获取容器的迭代器 * @return */ Iterator&lt;T&gt; iterator();&#125; 具体容器类 1234567891011121314151617181920212223public class ConcreteAggregate&lt;T&gt; implements Aggregate&lt;T&gt;&#123; /** * 模拟具体容器 */ private List&lt;T&gt; mLists = new ArrayList&lt;&gt;(); @Override public void add(T t) &#123; mLists.add(t); &#125; @Override public void remove(T t) &#123; mLists.remove(t); &#125; @Override public Iterator&lt;T&gt; iterator() &#123; return new ConcreteIterator&lt;T&gt;(mLists); &#125;&#125; 客户类 12345678910111213141516@Testpublic void testIterators() &#123; //创建容器 Aggregate&lt;String&gt; aggregate = new ConcreteAggregate&lt;&gt;(); aggregate.add("1"); aggregate.add("2"); aggregate.add("3"); aggregate.add("4"); //拿到容器迭代器，使用迭代器遍历 Iterator&lt;String&gt; iterator = aggregate.iterator(); while (iterator.hasNext()) &#123; System.out.println("Aggregate: " + iterator.next()); &#125;&#125; Output: 1234Aggregate: 1Aggregate: 2Aggregate: 3Aggregate: 4 总结对于迭代器模式来说，其自身优点很明显也很单一，支持以不同的方式去遍历一个容器对象，也可以有多个遍历，弱化了容器类与遍历算法之间的关系，其缺点就是对类文件的增加。 大家也可能会想到其他语言，如 C++、Python 、PHP 等，他们内部也有众多容器体的定义，当然，也有相应的迭代器。迭代器模式发展至今，几乎每一种高级语言都有相应的内置实现，对于开发者而言，已经极少会去自己实现迭代器了，因此，对于迭代器模式在于了解而非应用。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式十之备忘录模式]]></title>
    <url>%2Fposts%2F6afac2a.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习备忘录模式 介绍备忘录模式属于行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态，这有点像我们平时口头禅 ”有没有后悔药“ 。备忘录模式实现的方式需要保证被保存的对象状态不能被对象外部访问，目的是为了保护好被保存的这些对象状态的完整性以及内部实现不向外暴露。 定义在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可将该对象恢复到原先保存的状态。 使用场景 需要保存一个对象在某一个时刻的状态或部分状态。 如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。 UML 类图 Originator: 负责创建一个备忘录，可以记录、恢复自身的内部状态。同时 Originator 还可以根据需要决定 Memento 存储自身的哪些内部状态。 Memento: 备忘录角色，用于存储 Originator 的内部状态，并且可以防止 Originator 以外的对象访问 Memento。 Caretaker: 负责存储备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其它对象。 代码示例需求: 开发一款简单记事本, 包括撤销、重做功能。 代码: 负责管理记事本的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class NoteCaretaker &#123; /** * 最大存储容量 */ private static final int MAX = 50; /** * 初始化 50 个容量 */ private List&lt;Memorandum&gt; mMemorandumLists = new ArrayList&lt;&gt;(MAX); /** * 存档位置 */ private int mIndex = 0; /** * 保存备忘录到记录列表中 */ public void saveMemorandum(Memorandum memorandum) &#123; if (mMemorandumLists.size() &gt; MAX)&#123; mMemorandumLists.remove(0); &#125; mMemorandumLists.add(memorandum); mIndex = mMemorandumLists.size() - 1; &#125; /** * 获取上一个存档信息，相当于撤销功能 */ public Memorandum getPrevMemorandum()&#123; mIndex = mIndex &gt; 0 ? --mIndex : mIndex; return mMemorandumLists.get(mIndex); &#125; /** * 获取下一个存档信息 */ public Memorandum getNextMemorandum()&#123; mIndex = mIndex &lt; mMemorandumLists.size() - 1? ++mIndex : mIndex; return mMemorandumLists.get(mIndex); &#125;&#125; 在 NodeCaretaker 中会维护一个备忘录列表，然后使用 mIndex 标识编辑器当前所在的记录点，通过 getPrev getNext 分别获取上一个、下一个记录点的备忘录，以此来达到撤销、重做的功能。 1234567891011121314151617181920212223242526272829303132333435public class NodeEditText extends EditText &#123; public NodeEditText(Context context) &#123; super(context); &#125; public NodeEditText(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public NodeEditText(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; /** * 创建备忘录对象，即存储编辑器的指定数据 * @return */ public Memorandum createMemorandum()&#123; Memorandum memorandum = new Memorandum(); memorandum.text = getText().toString().trim(); memorandum.cursor = getSelectionStart(); return memorandum; &#125; /** * 从备忘录中恢复数据 */ public void restore(Memorandum memorandum)&#123; setText(memorandum.text); setSelection(memorandum.cursor); &#125;&#125; 自定义一个记事本编辑器，添加2个函数，分别是 createMemorandum 、restore 函数。createMemorandum 函数是创建一个存储了编辑器文本，光标位置数据的 Memorandum 对象，并且返回给客户端；restore 函数是从 Memorandum 对象中恢复编辑器的文本和光标位置。 备忘录模式就介绍到这里了，主要还是要明确每个类的职责，遵从面向对象六大原则开发。 总结优点： 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态。 实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点： 消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>备忘录模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式九之观察者模式]]></title>
    <url>%2Fposts%2F871a12ed.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习观察者模式 介绍观察者模式是一个使用率非常高的模式，它最常用的地方是 GUI 系统、订阅-发布，因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得她们之间的依赖性更小，甚至做到毫无依赖。以 GUI 系统来说，应用的 UI 具有易变性，尤其是前期随着业务的改变或者产品的需求更改，应用界面也会经常性变化，但是业务逻辑基本变化不大，此时， GUI 系统需要一套机制来应对这种情况，使得 UI 层与具体的业务逻辑解耦，观察者模式此时就派上用场了。 定义定义对象间一种 1 对 N 的关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 使用场景 关联行为场景，需要注意的是，关联行为是可拆分的，而不是 “组合” 关系。 事件多级触发场景。 跨系统的消息交换场景，如消息队列、事件总线的消息机制。 UML 类图 Subject : 抽象主题，也就是被观察者的角色，抽象主题角色把所有观察者 对象的引用保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject: 具体主题，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发出通知，具体主题角色又叫做具体被观察者角色。 Observer: 抽象观察者，该角色实现抽象观察者角色所定义的更新接口，以便在主题的状态发生变化时更新自身的状态。 实战需求：订阅某网站技术文章，有更新就推送。 定义一个观察者对象 - 用户 1234567891011121314151617181920212223242526public class Coder implements Observer &#123; private String name; public Coder(String name) &#123; this.name = name; &#125; /** * 有更新将执行 * @param o * @param arg */ @Override public void update(Observable o, Object arg) &#123; System.out.println("o = [" + o + "], arg = [" + name + " " + (String) arg + "]"); &#125; @Override public String toString() &#123; return "Coder&#123;" + "name='" + name + '\'' + '&#125;'; &#125;&#125; 定义被观察者对象 - 技术网站 123456789101112public class JueJ extends Observable &#123; /** * 推送 * @param content */ public void post(String content)&#123; //标识状态或者内容需要发生改变 setChanged(); //通知所有订阅者 notifyObservers(content); &#125;&#125; 测试： 123456789101112131415161718@Testpublic void testObserver()&#123; //创建被观察者--》技术网站 JueJ jueJ = new JueJ(); //创建观察者 Coder coderA = new Coder("A"); Coder coderB = new Coder("B"); Coder coderC = new Coder("C"); //产生订阅关系，加入被观察者列表中，有更新就推送给它们 jueJ.addObserver(coderA); jueJ.addObserver(coderB); jueJ.addObserver(coderC); //有更新了，通知观察者们 jueJ.post("Dev_YK: 更新了一篇设计模式文章，点击进行查看。" );&#125; Output: 123o = [com.devyk.android_dp_code.observer.JueJ@48533e64], arg = [C Dev_YK: 更新了一篇设计模式文章，点击进行查看。]o = [com.devyk.android_dp_code.observer.JueJ@48533e64], arg = [B Dev_YK: 更新了一篇设计模式文章，点击进行查看。]o = [com.devyk.android_dp_code.observer.JueJ@48533e64], arg = [A Dev_YK: 更新了一篇设计模式文章，点击进行查看。] 可以看到所有订阅了某技术网站的用户都收到了通知更新，一对多的订阅-发布系统就完成了。 总结观察者模式主要的作用就是解耦，将观察者与被观察者完全隔离，只依赖于 Observe 和 Observable 抽象。 优点： 观察者和被观察者之间是抽象耦合，应对业务变化。 增强系统灵活性，可扩展性。 缺点： 在应用观察者模式时需要考虑一下开发效率和运行效率问题，程序中包括一个被观察者、多个观察者、开发和调试等内容会比较复杂，而且在 Java 中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这个情况下，一般考虑使用异步方式。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式八之责任链模式]]></title>
    <url>%2Fposts%2F61fa11d3.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习责任链模式 介绍责任链模式 (Iterator Pattern) ,属于行为型设计模式之一。什么是 “链” ？我们将多个节点首尾相连所构成的模型称为链 。就好比生活中一个个铁圆环一个连这一个环环相扣一样。 定义使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到处理为止。 使用场景 多个对象可以处理同一个请求，但是具体由哪个对象处理则在运行时动态决定。 在请求处理者不明确的情况下向多个对象中的一个提交一个请求。 需要动态指定一组对象处理请求。 UML 类图 Handler : 抽象处理者角色，声明一个请求处理的方法，并在其中保持一个对下一个处理节点 Handler 的引用。 ConcreteHandler: 具体处理角色，对请求进行处理，如果不能处理则将该请求转发给下一个请求。 实战简单示例1： 定义抽象处理者: 12345678910111213141516171819202122232425262728293031323334353637public abstract class Handler &#123; private String TAG = getClass().getSimpleName(); /** * 下一个节点来负责处理 */ public Handler nextHandler; /** * 开始处理请求 */ public final void handlerRequest(HandlerRequest handlerRequest)&#123; if (getHandlerRequestLevel() == handlerRequest.getRequestLevel())&#123; handler(handlerRequest); &#125;else &#123; if (nextHandler != null) &#123; nextHandler.handlerRequest(handlerRequest); &#125;else &#123; Log.i(TAG,"当前事件"+handlerRequest.getRequestLevel() + "都不处理"); &#125; &#125; &#125; /** * 具体处理方式 * @param handlerRequest */ protected abstract void handler(HandlerRequest handlerRequest); /** * 获取处理对象的处理级别 * @return */ protected abstract int getHandlerRequestLevel();&#125; 定义抽象请求者： 1234567891011121314151617181920212223public abstract class HandlerRequest &#123; /** * 处理对象 */ private Object obj; public HandlerRequest(Object obj) &#123; this.obj = obj; &#125; /** * 获取处理对象内容 */ public Object getContent()&#123; return obj; &#125; /** * 获取请求级别 */ public abstract int getRequestLevel();&#125; 定义具体处理者： 123456789101112131415public class HandlerA extends Handler &#123; private String TAG = getClass().getSimpleName(); @Override protected void handler(HandlerRequest handlerRequest) &#123; System.out.println("handlerRequest = [" +TAG + " " + (String) handlerRequest.getContent() + "]"); &#125; @Override protected int getHandlerRequestLevel() &#123; return 1; &#125;&#125; 1234567891011121314public class HandlerB extends Handler &#123; private String TAG = getClass().getSimpleName(); @Override protected void handler(HandlerRequest handlerRequest) &#123; System.out.println("handlerRequest = [" + TAG + " " +(String) handlerRequest.getContent() + "]"); &#125; @Override protected int getHandlerRequestLevel() &#123; return 2; &#125;&#125; 定义具体请求者： 12345678910public class RequestA extends HandlerRequest &#123; public RequestA(Object obj) &#123; super(obj); &#125; @Override public int getRequestLevel() &#123; return 1; &#125;&#125; 12345678910public class RequestB extends HandlerRequest &#123; public RequestB(Object obj) super(obj); &#125; @Override public int getRequestLevel() &#123; return 2; &#125;&#125; 定义 Client 测试： 123456789101112131415161718192021/** * 客户处理 */@Testpublic void testIterator() &#123; //构造处理对象 Handler handlerA = new HandlerA(); Handler handlerB = new HandlerB(); //交给下一个节点处理 handlerA.nextHandler = handlerB; //构造请求对象 HandlerRequest handlerRequestA = new RequestA("A"); HandlerRequest handlerRequestB = new RequestB("B"); //发起请求 handlerA.handlerRequest(handlerRequestA); handlerA.handlerRequest(handlerRequestB);&#125; Output: 12handlerRequest = [HandlerA A]handlerRequest = [HandlerB B] 从测试代码可以看到 ，我们的 handlerA 的下一个请求交给了 handlerB，那么在发起请求的时候内部就会判断，如果当前发起请求的级别跟处理事件的级别不符合的话 ，就交给下一个节点来判断，如果都没有找到就报空。 实战示例2： 在 Android 中我们知道 Broadcast 可以分为 2 种，一种是普通广播，一种是有序广播，普通广播是异步的，发出时可以被所有的接收者收到；而有序广播则是根据优先级依次传播的，直到接收者将其处理，是不是觉得有序广播跟我们的责任链模式很相似，通过广播也能达到实现责任链事件的处理，下面先看代码： 先动态注册 3 个广播 12345678910111213141516private void registerOrderBroadcast() &#123; IntentFilter filter = new IntentFilter(); filter.addAction("com.it.dp_order"); filter.setPriority(1000); IntentFilter filterB = new IntentFilter(); filterB.addAction("com.it.dp_order"); filterB.setPriority(500); registerReceiver(new ReceiverB(),filterB); IntentFilter filterC = new IntentFilter(); filterC.addAction("com.it.dp_order"); filterC.setPriority(100); registerReceiver(new ReceiverC(),filterC); registerReceiver(new ReceiverA(),filter);&#125; 12345678910111213141516171819202122232425public class ReceiverA extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent == null) &#123; return; &#125; int limit = intent.getIntExtra("limit", -1); if (limit == 100) &#123; if (intent.getStringExtra("MEG") != null) &#123; Log.i("ReceiverA","我处理了"); Toast.makeText(context,intent.getStringExtra("MEG"),Toast.LENGTH_SHORT).show(); &#125; //处理事件，终止广播 abortBroadcast(); &#125; else &#123; Log.i("ReceiverA","我不处理，分发下去"); //添加信息，继续分发，直到任务处理 Bundle bundle = new Bundle(); bundle.putInt("limit",1000); bundle.putString("MEG","中午啦，该吃饭了！"); setResultExtras(bundle); &#125; &#125;&#125; …其它 2 个广播省略 内部代码只有 limit == ? 不一样 发送一个有序广播： 12345678public void order(View view) &#123; Intent intent = new Intent(); intent.setAction("com.it.dp_order"); intent.putExtra("limit",1000); intent.putExtra("MEG","中午了，该吃饭了"); sendOrderedBroadcast(intent,null);&#125; Output: 1232019-09-08 13:40:41.551 28992-28992/com.devyk.android_dp_code I/ReceiverA: 我不处理，分发下去2019-09-08 13:40:41.557 28992-28992/com.devyk.android_dp_code I/ReceiverB: 我不处理，分发下去2019-09-08 13:40:41.574 28992-28992/com.devyk.android_dp_code I/ReceiverC: 我处理了 这里我们动态注册了 3 个广播，优先级越高越先收到 A，B 都不符合要求，所以下发下去，最后在 C 接收者里面处理。 总结优点： 可以对请求者和处理者关系解耦，提高代码灵活性。 缺点： 对链中请求处理者的遍历，如果处理者太多，那么遍历会影响一定的性能，特别是在一些递归调用中，要慎用。 但总体来说，优点是大于缺点的，缺点相对于优点来说还是可控的。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式七之状态模式]]></title>
    <url>%2Fposts%2F1942adf8.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习状态模式 介绍状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。状态模式和策略模式的结构几乎完全一样，但它们的目的、本质却完全不一样。状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立、可相互替换的。用一句话来表述，状态模式把对象的行为包装在不同的状态对象里，每一个状态对象都有一个共同抽象状态的基类。状态模式的意图是让一个对象在其内部改变的时候，其行为也随之改变。 定义当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。 使用场景 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。 代码中包含大量与对象状态有关的条件语句，例如，一个操作中含有庞大的分支语句 (if-else / switch-case) , 且这些分支依赖于该对象的状态。 状态模式将每一个条件分支放入一个独立的类中，这使得你可以根据对象自身的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化，这样通过多态来去除过多的、重复的 if - else 等分支语句。 UML 类图 Context: 环境类，定义客户感兴趣的接口，维护一个 State 子类的实例，这个实例定义了对象的当前状态。 State: 抽象状态类或者状态接口，定义一个或者一组接口，表示该状态下的行为。 ConcreteStateA、ConcreteStateB: 具体状态类，每一个具体的状态类实现抽象 State 中定义的接口，从而达到不同状态下的不同行为。 实战在开发中，我们用到状态模式最常见的地方应该是用户登录系统。在用户登录和未登录的情况下，对于同一事件的处理行为是不一样的，例如，在淘宝中，用户在未登录的情况下点击购买，此时会先让用户登录，然后在做购买支付的操作。 下面我们就用状态模式来简单实现这个过程，首先创建 2 个 Activity , 一个是 LoginActivity, 一个是 HomeActivity , HomeActivity 是应用入口，有购买和注销用户功能。 12345678910111213141516//抽取公共的状态类public interface IUserState &#123; /** * 购物 * @param id */ void Shopping(Context context,int id); /** * 注销 * @param context * @param token */ void loginOut(Context context,String token);&#125; 1234567891011121314151617//具体登录状态实现类public class LoginState implements IUserState &#123; private String TAG = getClass().getSimpleName(); @Override public void Shopping(Context context,int id) &#123; Log.i(TAG, "购买商品-》" + id + " 即将支付"); Toast.makeText(context,"购买商品-》" + id + " 即将支付",Toast.LENGTH_LONG).show(); &#125; @Override public void loginOut(Context context,String token) &#123; Log.i(TAG, "退出系统成功"); LoginContext.getInstance().setState(new LoginOutState()); Toast.makeText(context,"退出系统成功",Toast.LENGTH_LONG).show(); &#125;&#125; 123456789101112131415161718192021222324//具体未登录状态实现类public class LoginOutState implements IUserState &#123; private String TAG = getClass().getSimpleName(); @Override public void Shopping(Context context, int id) &#123; gotoLogin(context); &#125; private void gotoLogin(Context context) &#123; Intent intent = new Intent(context, LoginActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; @Override public void loginOut(Context context, String token) &#123; Log.i(TAG, "已经是退出状态"); &#125;&#125; Context 登录状态管理类: 123456789101112131415161718192021222324252627282930313233343536public class LoginContext &#123; /** * 用户状态 默认未登录 */ private IUserState mIuserState = new LoginOutState(); private LoginContext() &#123; &#125; public void shopping(Context context,int id) &#123; mIuserState.Shopping(context,id); &#125; public void loginOut(Context context)&#123; mIuserState.loginOut(context); &#125; /** * 静态内部类单例 */ private static class LoginHolder &#123; private static LoginContext loginContext = new LoginContext(); &#125; public static LoginContext getInstance() &#123; return LoginHolder.loginContext; &#125; /** * 注入用户的状态 * @param userState */ public void setState(IUserState userState)&#123; this.mIuserState = userState; &#125;&#125; UI 操作 12345678910111213141516171819202122232425public class LoginActivity extends Activity &#123; private EditText mUser; private EditText mPwd; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); mUser = findViewById(R.id.etUser); mPwd = findViewById(R.id.etPwd); &#125; public void login(View view) &#123; if (mUser.getText().toString().trim().equals("123456") &amp;&amp; mPwd.getText().toString().trim().equals("123456")) &#123; LoginContext.getInstance().setState(new LoginState()); Toast.makeText(getApplicationContext(), "登录成功", Toast.LENGTH_LONG).show(); startActivity(new Intent(this, HomeActivity.class)); finish(); &#125; &#125;&#125; 1234567891011121314151617public class HomeActivity extends Activity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_home); &#125; public void logout(View view) &#123; LoginContext.getInstance().setState(new LogoutState()); &#125; public void shopping(View view) &#123; LoginContext.getInstance().shopping(getApplicationContext(),199); &#125;&#125; 用户默认是未登录状态，此时用户在 HomeActivity 界面点击购物时，会先跳转到 LoginActivity 页面，然后登录成功之后在返回到 HomeActivity 页面，此时，用户再次点击购物就可以实现该功能了。 总结状态模式的关键点在于不同的状态下对于同一行为有不同的响应，这其实就是一个将 if~else 用多态来实现的一个具体示例，模式的运用一定要考虑所处的情景以及你要解决的问题，只有符合特定的场景才建议使用对应的模式。 优点： State 模式将所有与一个特性的状态相关的行为都放入一个状态对象中，它提供了一个更好的方法来组织与特定状态相关的代码，将繁琐的状态判断转换成结构清晰的状态类族，在避免代码膨胀的同时也保证了可扩展性与可维护性。 缺点： 状态模式的使用必然会增加系统类和对象的个数。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式六之策略模式]]></title>
    <url>%2Fposts%2F12c9315d.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习策略模式 介绍在软件开发中常常遇见这样的问题：实现某个功能可以有多种算法或者策略，我们根据实际情况选择不同的算法或者策略来完成该功能。例如，排序算法，可以有多种的实现方式。 那么，针对这种情况，应该怎么处理？是将这些算法写在一个类中，每一个方法对应一个具体的排序算法；还是将这些排序算法封装在同一个方法中，通过 if…else 或者 case 等条件判断语句来选择具体的算法。这 2 种实现方法我们都可以称之为硬编码。当然，这样是可以实现需求，但是，当很多算法在一个类时，这个类就会变得很臃肿，维护成本就会变高，并且在维护时容易发生错误，如果我们需要新增或者修改算法类的源码，这个就需要动封装好的类，那么这就违背了单一职责和开闭原则了。 如果将这些算法或者策略抽象出来，提供统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性，可维护性也就更高，这就是我们今天要学习的策略模式。 定义策略模式定义了一系列算法，并将每一个算法封装起来，而且使他们还可以相互替换，策略模式让算法独立于使用它的客户而独立变化。 使用场景 针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。 需要安全的封装多种同一类型操作时。 出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。 UML 类图 Context ：用来操作策略的上下文环境 Stragety : 策略的抽象 ConcreteStragetyA, ConcreteStragetyB 具体策略实现。 简单示例需求：对交通工具计算车费，一般轿车，中等轿车，豪华轿车。 12345678910111213 /* * 计算费用接口 * */public interface ICalculateStrategy &#123; /** * 按距离计算车费 * @param km 公里数 * @return */ int calculatePrice(int km);&#125; 各种车的计算方式 12345678910111213//普通车public class GeneralCar implements ICalculateStrategy &#123; @Override public int calculatePrice(int km) &#123; if (km &gt; 0 &amp;&amp; km &lt;= 5) return 5; if (km &gt; 5 &amp;&amp; km &lt;= 7) return 7; if (km &gt; 7 &amp;&amp; km &lt;= 10) return 10; return 10; &#125;&#125; 12345678910111213//中级车public class MediumCar implements ICalculateStrategy &#123; @Override public int calculatePrice(int km) &#123; if (km &gt; 0 &amp;&amp; km &lt;= 5) return 6; if (km &gt; 5 &amp;&amp; km &lt;= 7) return 9; if (km &gt; 7 &amp;&amp; km &lt;= 10) return 12; return 12; &#125;&#125; 12345678910111213//高级车public class LuxuryCar implements ICalculateStrategy &#123; @Override public int calculatePrice(int km) &#123; if (km &gt; 0 &amp;&amp; km &lt;= 5) return 8; if (km &gt; 5 &amp;&amp; km &lt;= 7) return 13; if (km &gt; 7 &amp;&amp; km &lt;= 10) return 15; return 13; &#125;&#125; 我们在创建一个操作 Context 策略的类 123456789101112131415161718192021public class TransportationCalculator &#123; /** * 交通工具计算费用策略类 */ private ICalculateStrategy iCalculateStrategy = new GeneralCar(); /** * 设置策略 * @param calculateStrategy */ public void setStrategy(ICalculateStrategy calculateStrategy) &#123; this. iCalculateStrategy = calculateStrategy; &#125; public int calcu(int km)&#123; return iCalculateStrategy.calculatePrice(km); &#125;&#125; 测试： 12345678910111213@Testpublic void test8()&#123; TransportationCalculator transportationCalculator = new TransportationCalculator(); System.out.println("普通车 1 km RMB:" + transportationCalculator.calcu(5)); transportationCalculator.setStrategy(new MediumCar()); System.out.println("中级车 1 km RMB:" + transportationCalculator.calcu(5)); transportationCalculator.setStrategy(new LuxuryCar()); System.out.println("豪华车 1 km RMB:" + transportationCalculator.calcu(5)); &#125; Output: 123普通车 1 km RMB:5中级车 1 km RMB:6豪华车 1 km RMB:8 有没有发现这种写法不仅结构变得清晰，而且还易维护，扩展性也很强。 总结策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。在这个模式很好地演示了开闭原则，也就是定义接口抽象，注入不同的实现，从而达到很好的可扩展性。 优点： 结构清晰明了、使用简单直观； 耦合度相对而言较低，扩展方便； 操作封装也更为彻底，数据更为安全； 缺点： 随着策略的增加，子类也会变得繁多]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式五之抽象工厂模式]]></title>
    <url>%2Fposts%2F1ef33906.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习抽象工厂模式 介绍抽象工厂模式 (Abstract Factory Pattern) 也是创建型设计模式之一。上一篇讲解了 工厂方法模式 ,那么这个抽象工厂又是怎么一回事呢？大家联想一下像是生活中的工厂肯定都是具体的，也就是说每个工厂都会生产某一种具体的产品，那么抽象工厂意味着生产出来的产品是不确定的，那这岂不是很奇怪？抽象工厂模式起源于以前对不同操作系统的图形化解决方案，如不同操作系统中的按钮和文本框控件其实现不同，展示效果也不一样，对于每一个操作系统，其本身就构成一个产品类，而按钮与文本框控件也构成一个产品类，两种产品类两种变化，各自有自己的特性，如 Android 中的 Button 和 TextView 、IOS 中的 Button 、和 TextView 、 Window Phone 中的 Button 和 TextView 等。 定义为创建一组相关或者相互依赖的对象提供一个借口，而不需要制定它们的具体类。 使用场景一个对象如有相同的约束时可以使用抽象工厂模式。是不是听起来很抽象 ？ 举个例子，Android 、IOS 、Window Phone 下都有短信软件和拨号软件，两者都属于软件的范畴，但是，它们所在的操作系统平台不一样，即便是同一家公司出品的软件，其代码实现逻辑也是不同的，这时候就可以考虑使用抽象工厂方法模式来产生 Android 、IOS 、Window Phone 下短信软件和拨号软件。 类图 AbstractFactory ：抽象工厂角色，它声明了一组用于创建一种产品的方法，每一个方法对应一种产品，如上图中的 AbstractFactory 中就定义了两个方法，分别创建产品 A 和产品 B 。 ConcreteFactory : 具体工厂角色，它实现了在抽象工厂中定义的创建产品的方法，生成一组具体产品，这些产品构成了一个产品种类，每一个产品都位于某个产品等级结构中，如上述类图中的 ConcreteFactory1 、ConcreteFactory2。 AbstractProduct: 抽象产品角色，它为每种产品声明接口，比如上述类图中的 AbstractProduct A, AbstractProduct B。 ConcreteProduct: 具体产品角色，它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法，如上图的 ConcreteProductA1 , ConcreteProductA2 , ConcreteProductB1 ,ConcreteProductB2. 代码示例其实我们平时在开发中应该很少用到抽象工厂模式，一个很重要的原因是，其相对于其他两种工厂模式来说略显复杂，对于整体架构而言修改较大且不易施展。一个很典型的例子适用于数据库模型的构建，不过对于这块来讲，大多说设计模式都能应用到其中，对于 Android 开发者来说，抽象工厂的一个更好地应用是在主题修改上，假如在项目中需要引入一套主题切换的功能，那么使用抽象工厂来构建主题框架再适合不过了，下面就以一个代码示例在说明吧： 12345678910111213141516171819/**抽象主题工厂类*/public abstract class AbstractThemeFactory &#123; protected Context mContext; public AbstractThemeFactory(Context mContext) &#123; this.mContext = mContext; &#125; /** * 创建主题按钮 */ public abstract ThemeButton createButton(); /** * 创建主题标题栏 */ public abstract ThemeToolbar createToolbar();&#125; 抽象主题工厂中只定义了创建 UI 元素的抽象方法，而具体实现则由不同的子类去完成。 12345678910111213141516/**暗色系主题工厂*/public class DarkThemeFactory extends AbstractThemeFactory &#123; public DarkThemeFactory(Context mContext) &#123; super(mContext); &#125; @Override public ThemeButton createButton() &#123; return new ButtonDrak(mContext); &#125; @Override public ThemeToolbar createToolbar() &#123; return new ToolbarDrak(mContext); &#125;&#125; 12345678910111213141516/**亮色系主题工厂*/public class LightThemeFactory extends AbstractThemeFactory &#123; public LightThemeFactory(Context mContext) &#123; super(mContext); &#125; @Override public ThemeButton createButton() &#123; return new ButtonLight(mContext); &#125; @Override public ThemeToolbar createToolbar() &#123; return new ToolbarLight(mContext); &#125;&#125; 对于 Dark ， Light 都实现了各自的主题元素，下面我们看下 UI 元素抽象类 123456789101112131415161718192021222324252627282930//抽象主题标题栏颜色abstract class ThemeToolbar extends Toolbar &#123; public ThemeToolbar(Context context) &#123; super(context); initIcon(); initTextColor(); initBackgroundColor() ; &#125; /** * 初始化图标 */ public abstract void initIcon(); /** * 初始话按钮颜色 */ public abstract void initTextColor(); /** * 初始化按钮颜色 */ public abstract void initBackgroundColor();&#125; 12345678910111213141516171819202122//抽象主题按钮类abstract class ThemeButton extends Button &#123; public ThemeButton(Context context) &#123; super(context); initTextColor(); initBackgroundColor() ; &#125; /** * 初始话按钮颜色 */ public abstract void initTextColor(); /** * 初始化按钮颜色 */ public abstract void initBackgroundColor();&#125; 主题颜色实现类，我这里就那一个举例 1234567891011121314class ButtonDark extends ThemeButton &#123; public ButtonDark(Context mContext) &#123; super(mContext); &#125; @Override public void initTextColor() &#123; setTextColor(mContext.getResources().getColor(R.color.dark_color)); &#125; @Override public void initBackgroundColor() &#123; setBackgroundColor(mContext.getResources().getColor(R.color.dark_color)); &#125;&#125; 使用： 12345DarkThemeFactory darkThemeFactory = new DarkThemeFactory(getContext();//创建暗色主题按钮ThemeButton button = darkThemeFactory.createButton();//创建亮色主题标题栏ThemeToolbar toolbar = darkThemeFactory.createToolbar(); 大家可以看到，抽象工厂模式的结构相对于简单工厂和工厂方法模式来说要复杂的多，但是其本身也是应用于较为复杂场景的解耦，比如上述事例中，我们就应对了多个层面的变化，因此在实际项目开发中是否使用抽象工厂模式还需要看具体情况。 总结优点： 一个显著的优点是分离接口与实现，客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体实现是谁，客户端只是面向产品接口编程而已，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象工厂方法模式在切换产品类时更加灵活，容易。 缺点： 随着产品类的增加，抽象工厂也得修改，相当于所有的具体工厂都得修改，不易扩展新的产品。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式四之工厂方法模式]]></title>
    <url>%2Fposts%2F3319c3e.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习工厂方法模式 介绍工厂模式 ( Factory Pattern ) ，是创建型设计模式之一。工厂方法模式是一种结构简单的模式，其在我们平时开发中应用很广泛，也许你并不知道，但是你已经使用了无数次改模式了，如 Android 中的 Activity 里各个生命周期方法，以 onCreate 方法为例，它就可以看做是一个工厂方法，我们在其中可以构造我们的 View,并通过 setContentView 返回给 Framework 处理。 定义定义一个用于创建对象的接口，让子类决定实例化哪个类。 使用场景在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用 new 就可以完成创建的对象无需使用 Factory 。 工厂模式代码示例需求：根据用户不同的权限，匹配不同的业务模块。 定义一个抽象的业务模块类 123456789public abstract class IModule &#123; /** * 根据不同的权限 拿到功能模块 * @param permission * @return */ public abstract List&lt;IFunctionModule&gt; getMoudleFun(String permission);&#125; 具体功能的实现类 1234567public class PlayMusicImpl implements IFunctionModule &#123; private String TAG = getClass().getSimpleName(); @Override public void function() &#123; Log.i(TAG,"播放音乐"); &#125;&#125; 12345678910public class PlayVideoImpl implements IFunctionModule &#123; public String TAG = getClass().getSimpleName(); @Override public void function() &#123; Log.i(TAG,"播放视频"); &#125;&#125; 12345678910public class NewsImpl implements IFunctionModule &#123; private String TAG = getClass().getSimpleName(); @Override public void function() &#123; Log.i(TAG, "看新闻"); &#125;&#125; 具体功能模块工厂开始生产需要的模块 1234567891011121314151617181920public class FunModuleFactor extends IModule &#123; @Overridepublic List&lt;IFunctionModule&gt; getMoudleFun(String permission) &#123; switch (permission) &#123; case "VIP": List&lt;IFunctionModule&gt; vipLists = new ArrayList&lt;&gt;(); vipLists.add(new PlayMusicImpl()); vipLists.add(new PlayVideoImpl()); vipLists.add(new NewsImpl()); return vipLists; default: List&lt;IFunctionModule&gt; kipLists = new ArrayList&lt;&gt;(); kipLists.add(new PlayMusicImpl()); kipLists.add(new NewsImpl()); return kipLists; &#125; &#125;&#125; 使用： 12345678910@Testpublic void test7() &#123; FunModuleFactor funModuleFactor = new FunModuleFactor(); List&lt;IFunctionModule&gt; vip = funModuleFactor.getMoudleFun("VIP"); System.out.println("VIP:" + vip.size()); List&lt;IFunctionModule&gt; kip = funModuleFactor.getMoudleFun("KIP"); System.out.println("KIP:" + kip.size());&#125; 输出: 12VIP:3KIP:2 根据上面代码可知，我们定义了一个抽象模块类 IMoudle，FunModuleFactory 实现了 IModule ,外部可以通过不同的权限来组装对应的业务功能。也就实现了这个需求。 总结总的来说，工厂方法模式是一个很好的设计模式，但是也有缺点，每次我们为工厂方法模式添加一个新的模块都要编写新的模块类，同时引入抽象层，这必然会导致类结构的复杂化，所以，在某些情况比较简单时，是否使用工厂模式，需要自己权衡利弊了。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式三之原型模式]]></title>
    <url>%2Fposts%2F7a86e223.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习原型模式 介绍原型模式是一个创建型的模式。原型二字表明了该模式应该有一个模板实例，用户从这个模板对象中复制出一个内部属性一致并且内存地址不同的对象，这个过程也就是我们俗称的 “克隆” 。被复制的实例就是我们所称的 “原型” ，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。 定义用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。 使用场景 类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型复制避免这些消耗。 通过 new 产生一个对象需要非常繁琐的数据准备和访问权限，这时可以使用原型模式。 一个对象需要提供给其它对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式复制多个对象供调用者使用，既保护性拷贝。 UML 类图 Client: 客户端用户。 Prototype: 抽象类或者接口，声明具备 clone 能力。 ConcreatePrototype: 具体的原型类 原型模式的简单实现下面以简单的文档 copy 为例来演示一下原型模式。 需求：有一个文档，文档中包含了文字和图片，用户经过了长时间的内容编辑后，打算对该文档做进一步的编辑，但是，这个编辑后的文档是否会被采用还不确定，因此，为了安全起见，用户需要将当前文档 copy 一份，然后再在文档副本上进行修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/***这里代表是具体原型类*/public class WordDocument implements Cloneable &#123; /** * 文本 */ private String mTxt; /** * 图片名列表 */ private List&lt;String&gt; mImagePath = new ArrayList&lt;&gt;(); public String getmTxt() &#123; return mTxt; &#125; public void setmTxt(String mTxt) &#123; this.mTxt = mTxt; &#125; public List&lt;String&gt; getImagePath() &#123; return mImagePath; &#125; public void addImagepath(String imagepath) &#123; mImagePath.add(imagepath); &#125; /** * 打印文档内容 */ public void println()&#123; System.out.println("---------------- start ----------------"); System.out.println("txt: " + mTxt); System.out.println("mImagePath: "); for (String path : mImagePath) &#123; System.out.println("path: " + path); &#125; System.out.println("----------------- end ----------------"); &#125; /** * 声明具备 clone 能力 * @return clone 的对象 */ @Override protected WordDocument clone() &#123; try &#123; WordDocument document = (WordDocument)super.clone(); document.mTxt = this.mTxt; document.mImagePath = this.mImagePath; return document; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; Test: 123456789101112131415161718192021222324252627282930313233@Testpublic void test4()&#123; //1. 构建文档对象 WordDocument wordDocument = new WordDocument(); //2. 编辑文档 wordDocument.setmTxt("今天是一个好天气"); wordDocument.addImagepath("/sdcard/image.png"); wordDocument.addImagepath("/sdcard/image2.png"); wordDocument.addImagepath("/sdcard/image3.png"); //打印文档内容 wordDocument.println(); System.out.println("--------------------开始clone-----\n\n"); //以原始文档为准，copy 副本 WordDocument cloneDoc = wordDocument.clone(); System.out.println(" 打印副本，看看数据 \n\n"); //打印副本，看看数据 cloneDoc.println(); //在副本文档上修改 cloneDoc.setmTxt("副奔上修改文档：老龙王哭了"); System.out.println(" 打印修改后的副本 \n\n"); //打印修改后的副本 cloneDoc.println(); System.out.println("----看会不会影响原始文档-----\n\n"); //看会不会影响原始文档？？？？？？？ wordDocument.println(); System.out.println("内存地址：\nwordDocument: "+wordDocument.toString() +"\n" + "cloneDoc: "+cloneDoc.toString());&#125; Output: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051---------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end ------------------------------------开始clone----- 打印副本，看看数据 ---------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end ---------------- 打印修改后的副本 ---------------- start ----------------txt: 副奔上修改文档：老龙王哭了mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end --------------------看会不会影响原始文档--------------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end ---------------- 内存地址：wordDocument: com.devyk.android_dp_code.prototype.WordDocument@48533e64cloneDoc: com.devyk.android_dp_code.prototype.WordDocument@64a294a6 从上面代码跟打印可以看出 cloneDoc 是通过 wordDocument.clone() 创建的并且 cloneDoc 第一次输出和 wordDocument 原始文档数据一样，既 cloneDoc 是 wordDocument 的一份副本文件。难道这样就完了吗？不知道大家有没有注意这里的 mImagePath 字段，原始对象的 clone 方法这里相当把引用地址复制给了 clone 出来的对象，如果这 2 个对象中的任意一个对其修改，那么就会对原始数据造成破坏，失去了对数据的保护。那么怎么解决这个问题，请继续往下浏览（注意：通过 clone 的对象并不会执行 构造函数！） 浅拷贝和深拷贝上述原型模式的实现实际上只是一个浅拷贝，也称为影子拷贝。这份拷贝实际上并不是将原始文档的所有字段都重新构造了一份，而是副本文档的字段引用原始文档的字段。 我们知道 A 引用 B 那么我们可以认为 A,B 都指向同一个地址，当修改 A 时 B 也会随之改变， B 修改时 A 也会随之改变。我们直接看下面代码示例： 1234567891011121314151617181920212223242526272829303132333435@Testpublic void test4() &#123; //1. 构建文档对象 WordDocument wordDocument = new WordDocument(); //2. 编辑文档 wordDocument.setmTxt("今天是一个好天气"); wordDocument.addImagepath("/sdcard/image.png"); wordDocument.addImagepath("/sdcard/image2.png"); wordDocument.addImagepath("/sdcard/image3.png"); //打印文档内容 wordDocument.println(); System.out.println("--------------------开始clone-----\n\n"); //以原始文档为准，copy 副本 WordDocument cloneDoc = wordDocument.clone(); System.out.println(" 打印副本，看看数据 \n\n"); //打印副本，看看数据 cloneDoc.println(); //在副本文档上修改 cloneDoc.setmTxt("副奔上修改文档：老龙王哭了"); cloneDoc.addImagepath("/sdcard/副本发生改变"); System.out.println(" 打印修改后的副本 \n\n"); //打印修改后的副本 cloneDoc.println(); System.out.println("----看会不会影响原始文档-----\n\n"); //看会不会影响原始文档？？？？？？？ wordDocument.println(); System.out.println("内存地址：\nwordDocument: " + wordDocument.toString() + "\n" + "cloneDoc: " + cloneDoc.toString());&#125; 注意看副本文档，我手动调用 addImagepath 添加了一个新的图片地址。那么大家猜原始文档会发生改变吗？请看下面的输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253---------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end ------------------------------------开始clone----- 打印副本，看看数据 ---------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end ---------------- 打印修改后的副本 ---------------- start ----------------txt: 副奔上修改文档：老龙王哭了mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.pngpath: /sdcard/副本发生改变----------------- end --------------------看会不会影响原始文档--------------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.pngpath: /sdcard/副本发生改变----------------- end ----------------内存地址：wordDocument: com.devyk.android_dp_code.prototype.WordDocument@48533e64cloneDoc: com.devyk.android_dp_code.prototype.WordDocument@64a294a6 注意看我们副本添加的图片地址是不是影响了原始文档的图片地址数据，那么这是怎么回事勒？对 C++ 了解的同学应该深有体会，这是因为上文中 cloneDoc 只是进行了浅拷贝，图片列表 mImagePath 只是单纯的指向了 this.mImagePath , 并没有重新构造一个 mImagePath 对象，就像开始介绍浅/深拷贝一样， A，B 对象其实指向的是同一个地址，所以不管 A，B 中任意一个对象改了指向地址的数据那么都会随之发生改变，那如何解决这个问题？答案就是采取深拷贝，即在拷贝对象时，对于引用型的字段也要采用拷贝的形式，而不是单纯引用形式，下面我们修改 clone 代码，如下： 1234567891011121314151617/** * 声明具备 clone 能力 * @return clone 的对象 */@Overridepublic WordDocument clone() &#123; try &#123; WordDocument document = (WordDocument)super.clone(); document.mTxt = this.mTxt; //进行深拷贝 document.mImagePath = (ArrayList&lt;String&gt;) this.mImagePath.clone(); return document; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null;&#125; 再来测试一下，看输出类容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152---------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end ------------------------------------开始clone----- 打印副本，看看数据 ---------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end ---------------- 打印修改后的副本 ---------------- start ----------------txt: 副奔上修改文档：老龙王哭了mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.pngpath: /sdcard/副本发生改变----------------- end --------------------看会不会影响原始文档--------------------- start ----------------txt: 今天是一个好天气mImagePath: path: /sdcard/image.pngpath: /sdcard/image2.pngpath: /sdcard/image3.png----------------- end ----------------内存地址：wordDocument: com.devyk.android_dp_code.prototype.WordDocument@48533e64cloneDoc: com.devyk.android_dp_code.prototype.WordDocument@64a294a6 通过输出内容，深拷贝解决了上述问题。 原型模式是一个非常简单的一个模式，它的核心问题就是对原始对象进行拷贝，在这个模式的使用过程中需要注意一点就是 深/浅拷贝的问题。在实际开发中，为了减少不必要的麻烦，建议大家都使用深拷贝。 这里如果对深浅拷贝感兴趣的话可以看掘金上这篇文章，不过是 JS 代码(了解原理就可以了)，很火的一篇文章值得学习一下 源码中的原型模式 ArrayList 刚刚我们 clone 文档可知，进行的 ArrayList clone ，那么 ArrayList clone 具体是怎么实现的？我们一起来看下： 12345678910111213public Object clone() &#123; try &#123; //1. ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); //2. v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125;&#125; 代码中第一步首先进行自身的 clone ,然后在对自身的数据进行 copy . Intent 下面以 Intent 来分析源码中的原型模式，首先看如下代码 12345678910public static Intent toSMS()&#123; Uri uri = Uri.parse("smsto:11202"); Intent preIntent = new Intent(Intent.ACTION_SENDTO,uri); preIntent.putExtra("sms_body","test"); //clone return (Intent) preIntent.clone(); &#125; 从代码中可以看到 preIntent.clone(); 方法拷贝了一个对象 Intent ,然后执行跳转 Activity,跳转的内容与原型数据一致。 我们继续看 Intent clone 具体实现： 12345/***进行 clone **/ @Override public Object clone() &#123; return new Intent(this); &#125; 12345678910111213141516171819202122232425262728/** * Copy constructor. */ public Intent(Intent o) &#123; this.mAction = o.mAction; this.mData = o.mData; this.mType = o.mType; this.mPackage = o.mPackage; this.mComponent = o.mComponent; this.mFlags = o.mFlags; this.mContentUserHint = o.mContentUserHint; this.mLaunchToken = o.mLaunchToken; if (o.mCategories != null) &#123; this.mCategories = new ArraySet&lt;String&gt;(o.mCategories); &#125; if (o.mExtras != null) &#123; this.mExtras = new Bundle(o.mExtras); &#125; if (o.mSourceBounds != null) &#123; this.mSourceBounds = new Rect(o.mSourceBounds); &#125; if (o.mSelector != null) &#123; this.mSelector = new Intent(o.mSelector); &#125; if (o.mClipData != null) &#123; this.mClipData = new ClipData(o.mClipData); &#125; &#125; 可以看到 clone 方法实际上在内部并没有调用 super.clone() 来实现拷贝对象，而是通过 new Intent(this)。 在开始我们提到过，使用 clone 和 new 需要根据构造对象的成本来决定，如果对象的构造成本比较高或者构造麻烦，那么使用 clone 函数效率较高，反之可以使用 new 关键字的形式。这就是和 C++ 中的 copy 构造函数完全一致，将原始对象作为构造函数的参数，然后在构造函数内将原始对象数据挨个 copy , 到此，整个 clone 过程就完成了。 总结原型模式本质就是对象 copy ,与 C++ 中的拷贝构造函数相似，他们之前容易出现的问题也都是深拷贝、浅拷贝。使用原型模式可以解决构建复杂对象的资源消耗问题，能够在某些场景下提升创建爱你对象的效率。还有一个重要的用途，就是保护性拷贝，也就是某个对象对外可能只是只读模式。 优点： 原型模式是在内存中二进制流的 copy, 要比 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 缺点： 这既是它的有点也是缺点，直接在内存中拷贝，构造函数时不会执行的，在实际开发中应该注意这个潜在的问题。 特别感谢《 Android 源码设计模式解析与实战 》]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式二之建造者模式]]></title>
    <url>%2Fposts%2F8bd761ec.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习建造者模式 介绍Builder 模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更精细的控制对象的构造流程，该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和创建过程隔离开来。 定义将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时。 当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值时。 简单代码示例这里比如我们第一次初始化应用的时候，需要初始化一些事物，比如默认记住密码，自动登录，开机登录，崩溃重启等等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.devyk.android_dp_code.builder;/** * &lt;pre&gt; * author : devyk on 2019-09-01 16:48 * blog : https://juejin.im/user/578259398ac2470061f3a3fb/posts * github : https://github.com/yangkun19921001 * mailbox : yang1001yk@gmail.com * desc : This is LoginManager * &lt;/pre&gt; */public class LoginManager &#123; /** * 记住密码 */ public boolean isSavePwd; /** * 自动登录 */ public boolean isAutoLogin; /** * 开机自启动 */ public boolean isBootLauncher; /** * 崩溃重启 */ public boolean isCrashOnRestart; public LoginManager(Builder builder)&#123; this.isAutoLogin = builder.isAutoLogin; this.isBootLauncher = builder.isBootLauncher; this.isCrashOnRestart = builder.isCrashOnRestart; this.isSavePwd = builder.isSavePwd; &#125; public static class Builder&#123; /** * 记住密码 */ boolean isSavePwd; /** * 自动登录 */ boolean isAutoLogin; /** * 开机自启动 */ boolean isBootLauncher; /** * 崩溃重启 */ boolean isCrashOnRestart; //默认属性 public Builder()&#123; this.isSavePwd = false; this.isAutoLogin = false; this.isBootLauncher = false; this.isCrashOnRestart = false; &#125; public Builder isSavePwd(boolean savePwd)&#123; this.isSavePwd = savePwd; return this; &#125; public Builder isAutoLogin(boolean autoLogin)&#123; this.isAutoLogin = autoLogin; return this; &#125; public Builder isBootLauncher(boolean bootLauncher)&#123; this.isBootLauncher = bootLauncher; return this; &#125; public Builder isCrashOnRestart(boolean onReStartApp)&#123; this.isCrashOnRestart = onReStartApp; return this; &#125; /** * 最后构建出来 * @return */ public LoginManager build()&#123; return new LoginManager(this); &#125; &#125;&#125; 使用： 12345678//直接链式调用 LoginManager loginManager = new LoginManager.Builder() .isAutoLogin(true) .isBootLauncher(true) .isCrashOnRestart(true) .build(); System.out.printf("loginManager:"+loginManager.toString()); Output: 1loginManager:LoginManager&#123;isSavePwd=false, isAutoLogin=true, isBootLauncher=true, isCrashOnRestart=true&#125; 上述代码中，通过具体的 Builder 类来具体构建 LoginManager 需要的属性，最后通过链式调用，结构变得更加清晰，更加容易控制。 Android 源码中 AlertDialog 的 Builder 模式全面解析在 Android 源码中，最常用之一的 Builder 模式 AlertDialog.Builder, 通过 Builder 来构建复杂的 AlertDialog 对象。请先看它的使用方式: 12345678910111213141516171819private void showAlertDialog(Context context) &#123; new AlertDialog.Builder(context)// 以下通过 Builder 链式调用构造数据 .setIcon(R.drawable.ic_launcher_background) .setMessage("测试数据") .setTitle("提示") .setPositiveButton("取消", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;).setNegativeButton("确认", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;).create()//最后一步就是在 Builder 中构建出 AlerDialog 对象，并初始化数据 .show(); // 显示&#125; 从 AlertDialog.Builder(context) 可以看出 AlertDialog 是一个 Builder 建造者模式，通过 Builder 对象，组装 Dialog 的各个部分，将 Dialog 的构造和表示进行分离。下面请看 AlertDialog Builder 的相关源码； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import com.android.internal.R;public class AlertDialog extends Dialog implements DialogInterface &#123; //接收Builder成员变量 P 中的各个参数 private AlertController mAlert; ....代码省略 protected AlertDialog(Context context, boolean cancelable, OnCancelListener cancelListener) &#123; this(context, 0); setCancelable(cancelable); setOnCancelListener(cancelListener); &#125; //构造函数 protected AlertDialog(Context context, @StyleRes int themeResId) &#123; this(context, themeResId, true); &#125; // 构造 AlertDialog AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) &#123; super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = AlertController.create(getContext(), this, getWindow()); &#125; static @StyleRes int resolveDialogTheme(Context context, @StyleRes int themeResId) &#123; if (themeResId == THEME_TRADITIONAL) &#123; return R.style.Theme_Dialog_Alert; &#125; else if (themeResId == THEME_HOLO_DARK) &#123; return R.style.Theme_Holo_Dialog_Alert; &#125; else if (themeResId == THEME_HOLO_LIGHT) &#123; return R.style.Theme_Holo_Light_Dialog_Alert; &#125; else if (themeResId == THEME_DEVICE_DEFAULT_DARK) &#123; return R.style.Theme_DeviceDefault_Dialog_Alert; &#125; else if (themeResId == THEME_DEVICE_DEFAULT_LIGHT) &#123; return R.style.Theme_DeviceDefault_Light_Dialog_Alert; &#125; else if (ResourceId.isValid(themeResId)) &#123; // start of real resource IDs. return themeResId; &#125; else &#123; final TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(R.attr.alertDialogTheme, outValue, true); return outValue.resourceId; &#125; &#125; //实际上调用的是 mAlert 的 setTitle 方法 @Override public void setTitle(CharSequence title) &#123; super.setTitle(title); mAlert.setTitle(title); &#125; /** * @see Builder#setCustomTitle(View) * * //实际上调用的是 mAlert 的 setCustomTitle 方法 */ public void setCustomTitle(View customTitleView) &#123; mAlert.setCustomTitle(customTitleView); &#125; /** * 实际上调用的 mAlert 的 setMessage 方法 * @param message */ public void setMessage(CharSequence message) &#123; mAlert.setMessage(message); &#125;// ################################ BUilder 为 AlertDialog 构建的内部类 ############################################## public static class Builder &#123; //存储 AlertDialog 的各个参数，如果 title,message,icon private final AlertController.AlertParams P; public Builder(Context context) &#123; this(context, resolveDialogTheme(context, ResourceId.ID_NULL)); &#125; public Builder(Context context, int themeResId) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); &#125; /** * 设置标签头部提示 */ public Builder setTitle(@StringRes int titleId) &#123; P.mTitle = P.mContext.getText(titleId); return this; &#125; ..... 其它属性先省略 代码都大同小异 看懂一个就基本懂了 /** * Creates an &#123;@link AlertDialog&#125; with the arguments supplied to this * builder. * * 这里才是真正构建 AlertDialog 的地方，通过 Builder 来构建出来的数据 p 传递参数 * &lt;p&gt; */ public AlertDialog create() &#123; //实例化 AlertDialog 传参 final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); //将 p 中的参数应用到 dialog 中的 mAlert 对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) &#123; dialog.setCanceledOnTouchOutside(true); &#125; dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) &#123; dialog.setOnKeyListener(P.mOnKeyListener); &#125; return dialog; &#125; &#125; ...&#125; 上述代码中，Builder 类可以设置 AlertDialog 中的 title , message , buttom 等参数，这些参数都存储在 Builder 成员变量 p 中，p 中包含了与 AlertDialog 视图中对应的成员变量。在调用 Builder 类的 create 函数时，此时才真正的创建 AlertDialog,并且将 Builder p 保存的参数交于 AlertDialog mAlert 对象中，既 p.apply(mAlert);我们可以看下 apply 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142 public void apply(AlertController dialog) &#123; if (mCustomTitleView != null) &#123; dialog.setCustomTitle(mCustomTitleView); &#125; else &#123; if (mTitle != null) &#123; dialog.setTitle(mTitle); &#125; if (mIcon != null) &#123; dialog.setIcon(mIcon); &#125; if (mIconId != 0) &#123; dialog.setIcon(mIconId); &#125; if (mIconAttrId != 0) &#123; dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); &#125; &#125; //赋值 if (mMessage != null) &#123; dialog.setMessage(mMessage); &#125; .... // 如果设置了 ListView 则表示多选列表，此时创建一个 ListView if ((mItems != null) || (mCursor != null) || (mAdapter != null)) &#123; createListView(dialog); &#125; //最后将 mView Dialog 中 if (mView != null) &#123; if (mViewSpacingSpecified) &#123; dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); &#125; else &#123; dialog.setView(mView); &#125; &#125; else if (mViewLayoutResId != 0) &#123; dialog.setView(mViewLayoutResId); &#125; &#125; 在 apply 函数中，只是将 AlertParams 参数设置到 AlertControler 中，当我们调用 show 就能显示对话框了，我们具体来看下 show 的源码实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 开始显示 Dialog */public void show() &#123; //如果已经显示出来了 则返回 if (mShowing) &#123; if (mDecor != null) &#123; if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123; mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); &#125; mDecor.setVisibility(View.VISIBLE); &#125; return; &#125; mCanceled = false; // 1. onCreate 生命周期方法 if (!mCreated) &#123; dispatchOnCreate(null); &#125; else &#123; final Configuration config = mContext.getResources().getConfiguration(); mWindow.getDecorView().dispatchConfigurationChanged(config); &#125; // 2. onStart 生命周期方法 onStart(); //3. 获取 Window DecorView mDecor = mWindow.getDecorView(); if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123; final ApplicationInfo info = mContext.getApplicationInfo(); mWindow.setDefaultIcon(info.icon); mWindow.setDefaultLogo(info.logo); mActionBar = new WindowDecorActionBar(this); &#125; //4. 获取布局参数 WindowManager.LayoutParams l = mWindow.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) &#123; WindowManager.LayoutParams nl = new WindowManager.LayoutParams(); nl.copyFrom(l); nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; l = nl; &#125; //5. 将 mDecor 添加到 WindowManager 中 mWindowManager.addView(mDecor, l); mShowing = true; //通知可以显示了 sendShowMessage();&#125; 在 show() 中主要做了如下几个事儿： 通过dispatchOnCreate 函数调用 AlertDialog 生命周期 onCreate 函数； 然后在调用 onStart 最后通过 windowManager 把 Dialog 的 DecorView 添加进去 那么按照构建，内容视图应该是在生命周期的 onCreate 里面 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mAlert.installContent(); &#125;public void installContent() &#123; int contentView = selectContentView(); //设置框口内容视图 mWindow.setContentView(contentView); //初始化 AlertDialog 其它子视图的内容 setupView(); &#125; 虽然 installContent 代码少，但是及其重要，它调用了 Window 对象的 setContentView, 此处的 setContentView 与 Activity setContentView 中的实现一模一样，都是调用 window 的方法。 最后 setupView 就是初始化 AlertDialog 布局中各个参数，在调用完该函数之后 Dialog 的视图内容就全部显示完毕了，而这些各区域的视图都属于 mAlertDialogLayout 布局中的子 View ,Window 对象关联了mAlertDialogLayout 的整个布局树，当调用完 setupView 之后整个视图树的数据也就填充完毕，当用户调用 show 函数时， WindowManager 会将 window 对象的 DecorView (也就是 mAlertDialogLayout 对应的视图)添加到用户的窗口上，并且显示出来。到这里 Dialog 就出现在了手机屏幕中。 实战经过简单示例与分析源码中的 Builder 模式，相信大家对建造者模式已经有了一定了解了，现在我们就 Builder 模式来对ImageLoader 示例 改造。请看改造后的 ImageLoader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//增加了 Builder 配置类/** * &lt;pre&gt; * author : devyk on 2019-09-01 19:03 * blog : https://juejin.im/user/578259398ac2470061f3a3fb/posts * github : https://github.com/yangkun19921001 * mailbox : yang1001yk@gmail.com * desc : This is ImageLoaderConfig * &lt;/pre&gt; */public class ImageLoaderConfig &#123; /** * 图片缓存对象 */ public IImageCache imageCache = new MemoryCache(); /** * 允许最大线程数量 */ public int threadCount = -1; /** * 失败显示的图片配置 */ public int errorIcon = -1; /** * 图片下载 */ public IDownloader downloader = new HttpURLConnectionDownloaderImp(); private ImageLoaderConfig() &#123; &#125; /** * 配置 Builder */ public static class Builder &#123; /** * 图片缓存对象 */ IImageCache imageCache = new MemoryCache(); /** * 允许最大线程数量 */ int threadCount = Runtime.getRuntime().availableProcessors() + 1; /** * 失败显示的图片配置 */ int errorIcon = -1; /** * 图片下载 */ IDownloader downloader = new HttpURLConnectionDownloaderImp(); //设置线程数量 public Builder setThreadCount(int threadCount) &#123; this.threadCount = threadCount; return this; &#125; //设置缓存 public Builder setCache(IImageCache iImageCache) &#123; this.imageCache = iImageCache; return this; &#125; //图片下载 public Builder setDownLoader(IDownloader iDownloader) &#123; this.downloader = iDownloader; return this; &#125; //设置显示失败的图片 public Builder setLoaderErrorIcon(int icon) &#123; this.errorIcon = icon; return this; &#125; private void applyConfig(ImageLoaderConfig config) &#123; config.errorIcon = this.errorIcon; config.imageCache = this.imageCache; config.threadCount = this.threadCount; config.downloader = this.downloader; &#125; /** * 根据已经设置好的属性创建配置好对象 */ public ImageLoaderConfig create() &#123; ImageLoaderConfig config = new ImageLoaderConfig(); applyConfig(config); return config; &#125; &#125;&#125; 通过上面代码可以看到 ImageLoader 需要的业务，都可以在 ImageLoaderConfig Builder 配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/** * &lt;pre&gt; * author : devyk on 2019-08-27 00:11 * blog : https://juejin.im/user/578259398ac2470061f3a3fb/posts * github : https://github.com/yangkun19921001 * mailbox : yang1001yk@gmail.com * desc : This is ImageLoader * &lt;/pre&gt; */public class ImageLoader &#123; private String TAG = getClass().getSimpleName(); /** * 默认内存缓存 */ private IImageCache mCache; /** * 图片下载 */ private IDownloader mImageDownloader; /** * 线程池 */ private ExecutorService mExecutorService; /** * 主线程管理 */ private Handler mHandler = new Handler(Looper.getMainLooper()); /** * 显示失败的图片 */ private int mErrorIcon ; private static ImageLoader instance; private ImageLoaderConfig imageLoaderConfig; public static ImageLoader getInstance() &#123; if (instance == null) instance = new ImageLoader(); return instance; &#125; private ImageLoader() &#123; &#125; public void init(ImageLoaderConfig imageLoaderConfig) &#123; this.imageLoaderConfig = imageLoaderConfig; checkConfig(); &#125; private void checkConfig() &#123; if (imageLoaderConfig == null) return; if (imageLoaderConfig.imageCache == null) &#123; //图片缓存 this.mCache = new MemoryCache(); &#125; else &#123; this.mCache = imageLoaderConfig.imageCache; &#125; if (imageLoaderConfig.threadCount != -1) &#123; //线程池，线程数据量为 CPU 的数量 this.mExecutorService = Executors.newFixedThreadPool(imageLoaderConfig.threadCount); &#125; if (imageLoaderConfig.errorIcon != -1) this.mErrorIcon = imageLoaderConfig.errorIcon; //图片下载 this.mImageDownloader = imageLoaderConfig.downloader; &#125; /** * 加载图片 */ public void loadImage(final String url, final ImageView imageView) &#123; Bitmap bitmap = mCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; imageView.setTag(url); //如果内存缓存中没有图片，就开启网络请求去下载 mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap imager = mImageDownloader.downLoader(url); if (imager == null) return; if (imageView.getTag().equals(url)) &#123; displayImage(imager, imageView); &#125; mCache.put(url, imager); &#125; &#125;); &#125; /** * 显示图片 * * @param downBitmap * @param imageView */ private void displayImage(final Bitmap downBitmap, final ImageView imageView) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; Log.i(TAG, "下载图片"); imageView.setImageBitmap(downBitmap); &#125; &#125;); &#125;&#125; 使用： 123456789101112/** * 初始化配置 */public void config() &#123; ImageLoaderConfig config = new ImageLoaderConfig.Builder() .setCache(new DoubleCache(getApplicationContext())) .setLoaderErrorIcon(R.drawable.ic_launcher_background) .setThreadCount(10) .setDownLoader(new HttpURLConnectionDownloaderImp()) .create(); ImageLoader.getInstance().init(config);&#125; 通过配置之后就可以正常使用了，各种 setter 函数不会再用户调用 ImageLoader 方法时出现在视野中，它已经被隔离到了 Builder 模式中。清晰、简单的 API 也是一个开源库必须要保证的地方。 总结Builder 模式在 Android 源码，开源库（Okhttp…）等常用，将配置的构建和表示分离开来，同时也是将配置从目标类中隔离出来，避免过多的 setter,Builder 模式比较常见的实现形式就是链式调用，这样使得代码更加简洁，易懂。 优点： 良好的封装性，使用建造者模式可以是客服端不必知道产品内部组成细节。 独立，易扩展。 缺点： 会产生多余的 Builder 对象，消耗内存。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式一之单列模式]]></title>
    <url>%2Fposts%2Fed2ac199.html</url>
    <content type="text"><![CDATA[通过理论,代码示例,Android源码来学习单列模式 介绍单例模式是应用最为广泛的模式之一，也可能是很多入门或初级工程师唯一会使用的设计模式之吧，在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个实例类。有利于我们的调用，避免一个相同的类重复创建实例，比如一个网络请求，图片请求/下载，数据库操作等，如果频繁创建同一个相同对象的话，很消耗资源，因此，没有理由让它们构造多个实例。全局都需要使用这个功能的时候，避免重复创建，就可以用单例，这就是单例使用场景。 定义确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 使用场景应用中重复使用某个类时，为了避免多次创建产生的资源消耗，那么这个时候就可以考虑使用单例设计模式。 单例 UML 类图 实现单例模式主要有如下几个关键点: 构造函数不对外开放，一般为 private; 通过一个静态方法或者枚举返回单例对象； 确保单例类的对象有且只有一个，尤其是在多线程环境下； 确保单例类对象在反序列化时不会被重新构建对象。 单例示例饿汉式单例模式是设计模式中比较简单的，只有一个单例类，没有其他层次结构与抽象。该模式需要确保该类只能生成一个对象，通常是该类需要消耗较多的资源或者没有多个实例的情况。例如下面的代码： 12345678910111213public class DaoManager &#123; /** * 饿汉式单例 */ private static DaoManager instance = new DaoManager(); private DaoManager()&#123;&#125; public static DaoManager getInstance()&#123; return instance; &#125;&#125; 测试 12345678910111213@Testpublic void test()&#123; String dao = DaoManager.getInstance().toString(); String dao1 = DaoManager.getInstance().toString(); String dao2 = DaoManager.getInstance().toString(); String dao3 = DaoManager.getInstance().toString(); System.out.println(dao); System.out.println(dao1); System.out.println(dao2); System.out.println(dao3);&#125; Output 1234com.devyk.android_dp_code.singleton.DaoManager@28ba21f3com.devyk.android_dp_code.singleton.DaoManager@28ba21f3com.devyk.android_dp_code.singleton.DaoManager@28ba21f3com.devyk.android_dp_code.singleton.DaoManager@28ba21f3 从上面代码可以看到 DaoManager 不能通过 new 的形式构造对象，只能通过 getInstance() 拿到实例，而 DaoManager 对象是静态的，那么在声明的时候已经初始化了，这就保证了对象的唯一性，从输入结果中发现， DaoManager 四次输出的地址都是一样的。这个实现的核心在与将 DaoManager 类的构造方法私有化，使得外部程序不能通过构造来 new 对象，只能通过 getInstance() 来返回一个对象。 懒汉模式懒汉模式是声明了一个静态对象，并且在第一调用的时候进行初始化，而上面的饿汉纸则是在声明的时候已经初始化了。懒汉式的实现如下： 1234567891011121314151617public class DaoManager2 &#123; private static DaoManager2 instance; private DaoManager2()&#123;&#125; /** * 保证线程安全的懒汉式 * @return */ public static synchronized DaoManager2 getInstance()&#123; if (null == instance) &#123; instance = new DaoManager2(); &#125; return instance; &#125;&#125; 细心的读者可能已经发现了，getInstance() 方法中添加了 synchronized 关键字， getInstance 是一个同步方法，保证了在多线程情况下单例对象唯一性。细想下，大家可能会发现一个问题，即使 instance 已经被初始化，每次调用都会进行同步检查，这样会消耗不必要的资源，这也是懒汉单例模式存在的最大问题。 最后总结一下，懒汉单例模式的优点是单例只有再使用的时候进行初始化，在一定程度上节约了资源；缺点是第一次加载时需要进行初始化，反应稍慢，最大的问题就是每次调用的时候 getInstance 都进行同步，造成不必要的开销。这种模式一般不建议使用。 Double Check Lock 实现单例DCL 方式实现单例模式的有点是既能够在需要时初始化单例，又能保证线程安全，且单例对象初始化后调用 instance 不进行同步锁，代码如下： 12345678910111213141516171819202122public class DaoManager3 &#123; private static DaoManager3 sinstance; private DaoManager3() &#123; &#125; /** * 保证线程安全的懒汉式 * * @return */ public static DaoManager3 getInstance() &#123; if (null == sinstance) &#123; synchronized (DaoManager3.class) &#123; if (null == instance) sinstance = new DaoManager3(); &#125; &#125; return sinstance; &#125;&#125; 本段代码的亮点就在于 getInstance 方法上，可以看到 getInstance 方法对 instance 进行了两次判空；第一层判断主要是为了避免不必要的同步，第二层的判断则是为了在 null 的情况下创建实例。是不是看起来有点迷糊，下面在来解释下： 1sinstance = new DaoManager3(); 这个步骤，其实在jvm里面的执行分为三步： 在堆内存开辟内存空间; 在堆内存中实例化 DaoManager3 里面的各个参数; 把对象指向堆内存空间; 由于在 JDK 1.5 以前 Java 编译器允许处理器乱序执行，以及 JMM 无法保证 Cache, 寄存器（Java 内存模型）保证按照 1，2，3 的顺序执行。所以可能在 2 还没执行时就先执行了 3，如果此时再被切换到线程 B 上，由于执行了 3，sinstance 已经非空了，会被直接拿出来用，这样的话，就会出现异常。而且不易复现不易跟踪是一个隐藏的 BUG。 不过在 JDK 1.5 之后，官方也发现了这个问题，故而具体化了 volatile ，即在 JDK 1.6 以后，只要定义为 private volatile static DaoManager3 sinstance ; 就可解决 DCL 失效问题。volatile 确保 sinstance 每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。 DCL 优点：资源利用率高，第一次执行 getInstance 时单例对象才会被实例化，效率高。 DCL 缺点：第一次加载时，反应稍慢，也由于 Java 内存模型的原因偶尔会失败。在高并发环境下也有一定的缺陷，虽然发生概率很小。 DCL 模式是使用最多的模式，它能够在需要时才被实例化，并且能够在绝大多数场景下保证单例对象的唯一性，除非你的代码在并发场景比较复杂或者低于 JDK 6 版本下使用，否则，这种方式一般能够满足需求。 静态内部类单例模式DCL 虽然在一定程度上解决了资源消耗、多余的同步、线程安全等问题，但是，它还是在某些情况下出现失效的问题，这个问题被称为双重检查锁定失效，在《Java 并发编程实践》一书的最后谈到了这个问题，并指出这种 “优化” 是丑陋的，不赞成使用。而建议使用如下的代码替代。 12345678910111213141516public class DaoManager4 &#123; private DaoManager4()&#123;&#125; public static DaoManager4 getInstance()&#123; return DaoManager4Holder.sInstance; &#125; /** * 静态内部类 * */ private static class DaoManager4Holder&#123; private static final DaoManager4 sInstance = new DaoManager4(); &#125;&#125; 那么，静态内部类又是如何实现线程安全的呢？首先，我们先了解下类的加载时机。 类加载时机：JAVA 虚拟机在有且仅有的 5 种场景下会对类进行初始化。 遇到 new、getstatic、setstatic 或者 invokestatic 这4个字节码指令时，对应的 java 代码场景为：new 一个关键字或者一个实例化对象时、读取或设置一个静态字段时 ( final 修饰、已在编译期把结果放入常量池的除外)、调用一个类的静态方法时。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没进行初始化，需要先调用其初始化方法进行初始化。 当初始化一个类时，如果其父类还未进行初始化，会先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的类)，虚拟机会先初始化这个类。 当使用 JDK 1.7 等动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 这 5 种情况被称为是类的主动引用，注意，这里《虚拟机规范》中使用的限定词是”有且仅有”，那么，除此之外的所有引用类都不会对类进行初始化，称为被动引用。静态内部类就属于被动引用的行列。 我们再回头看下 getInstance() 方法，调用的是 DaoManager4Holder.sInstance ，取的是DaoManager4Holder 里的 sInstance 对象，跟上面那个 DCL 方法不同的是 ，getInstance()方法并没有多次去 new 对象，故不管多少个线程去调用 getInstance() 方法，取的都是同一个sInstance 对象，而不用去重新创建。当 getInstance() 方法被调用时，DaoManager4Holder 才在 DaoManager4 的运行时常量池里，把符号引用替换为直接引用，这时静态对象sInstance 也真正被创建，然后再被 getInstance() 方法返回出去，这点同饿汉模式。那么sInstance 在创建过程中又是如何保证线程安全的呢？在《深入理解JAVA虚拟机》中，有这么一句话: 虚拟机会保证一个类的 () 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 () 方法，其他线程都需要阻塞等待，直到活动线程执行 () 方法完毕。如果在一个类的 () 方法中有耗时很长的操作，就可能造成多个进程阻塞 (需要注意的是，其他线程虽然会被阻塞，但如果执行 () 方法后，其他线程唤醒之后不会再次进入 () 方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。 故而，可以看出 sInstance 在创建过程中是线程安全的，所以说静态内部类形式的单例可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。 那么，是不是可以说静态内部类单例就是最完美的单例模式了呢？其实不然，静态内部类也有着一个致命的缺点，就是传参的问题，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如 Context 这种参数，所以，我们创建单例时，可以在静态内部类与 DCL 模式里自己斟酌。 枚举单例前面讲解了几个单例模式的实现方式，这几个实现方式不是稍显麻烦就是会在某种情况下出现问题，那么还有没有更简单的实现方式勒？ 我们先来看看下面的实现方式。 12345678public enum DaoManager5 &#123; INSTANCE; public void doSomething()&#123; Log.i("DAO-&gt;","枚举单例"); &#125;&#125; 没错，就是枚举单例！ 写法简单简单是枚举单例最大的优点，枚举在 Java 中与普通的类时一样的，不仅能够拥有字段，还能够拥有自己的方法。最重要的是默认枚举实例的创建是线程安全的，并且在任何情况下它都是一个单例。 优点：枚举本身是线程安全的，且能防止通过反射和反序列化创建实例。 缺点：对 JDK 版本有限制要求，非懒加载。 使用容器实现单例模式学习了上面 5 大单例模式，最后在来介绍一种容器单例模式，请看下面代码实现： 12345678910111213141516171819public class DaoManager6 &#123; /** * 定义一个容器 */ private static Map&lt;String,Object&gt; singletonMap = new HashMap&lt;&gt;(); private DaoManager6()&#123;&#125; public static void initDao(String key,Object instance)&#123; if (!singletonMap.containsKey(key))&#123; singletonMap.put(key,instance); &#125; &#125; public static Object getDao(String key)&#123; return singletonMap.get(key); &#125;&#125; 在程序的初始，可以将单例类型注入到统一管理类中，在使用的时候根据 key 获取对应单例对象，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。 Android 源码中单例模式Android 源码中涉及了大量的单例模式，这里就拿较为熟悉的 context.getSystemService(String name); 容器单例模式，以 Context.LAYOUT_INFLATER_SERVICE 举例。 从 setContentView 入口，全方位分析 LayoutInflater 总结单例模式在应用中时属于使用频率最高的一种设计模式了，但是由于客户端通常没有高并发的情况，因此，选择哪种实现方式并不会有太大的影响。当然，考虑效率和并发的场景还是推荐大家使用 DCL 或 静态内部类单例模式。 注意：如果单例对象必须持有参数的话，那么最好建议使用弱引用来接收参数，如果是 Context 级别的类型，建议使用 context.getApplication() 否则容易造成内存泄漏; 感谢你的阅读，谢谢！]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单列模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过代码示例来学习面向对象六大原则]]></title>
    <url>%2Fposts%2F6a4629d8.html</url>
    <content type="text"><![CDATA[在阅读 Android 系统底层源码或者开源框架源码时，发现内部大量的设计模式，如果你对设计模式不懂的话，那么阅读源码真的是寸步难行。那么这篇文章我们先来学习面向对象的六大原则，设计模式大概 23 种，后面我们一步一步来学习它。 单一职责原则单一职责原则的英文名称是 Single Responsibility Principle ，缩写是 SRP 。 SRP 的定义是：就一个类而言，应该仅有一个引起变化的原因。简单的来说，就是一个类中应该是一组相关性很高的函数、数据的封装。单一职责的划分界限也并不是那么的清晰，很多时候都是靠个人经验来给定界限，当然，最大的的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。 下面我们就以 图片加载库 的例子代码来对类的职责简单说明下，在设计一个图片加载库之前，我们需要先大概画下 UML 类图，有了 UML 图之后写代码就能更加的清晰。 从上面 UML 类图可以看出 ImageLoader 只负责加载图片，MemoryCache 实现 IImageCache 负责往内存中存/取缓存，到这里也许有的同学对单一职责有了一定概念了，相信看完下面的代码，你已经对单一职责掌握的差不多了，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ImageLoader &#123; /** * 内存缓存 */ private IImageCache mMemoryCache; /** * 图片下载 */ private IDownloader mImageDownloader; /** * 线程池 */ private ExecutorService mExecutorService; /** * 主线程管理 */ private Handler mHandler = new Handler(Looper.getMainLooper()); private static ImageLoader instance; public static ImageLoader getInstance() &#123; if (instance == null) instance = new ImageLoader(); return instance; &#125; public ImageLoader() &#123; //图片缓存 this. mMemoryCache = new MemoryCache(); //图片下载 this.mImageDownloader = new HttpURLConnectionDownloaderImp(); //线程池，线程数据量为 CPU 的数量 this.mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); &#125; /** * 加载图片 */ public void loadImage(final String url, final ImageView imageView) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; imageView.setTag(url); //如果内存缓存中没有图片，就开启网络请求去下载 mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap imager = mImageDownloader.downLoader(url); if (imager == null) return; if (imageView.getTag().equals(url)) &#123; displayImage(imager, imageView); &#125; mMemoryCache.put(url,imager); &#125; &#125;); &#125; /** * 显示图片 * * @param downBitmap * @param imageView */ private void displayImage(final Bitmap downBitmap, final ImageView imageView) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; imageView.setImageBitmap(downBitmap); &#125; &#125;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class MemoryCache implements IImageCache &#123; /** * 初始化内存缓存 */ private LruCache&lt;String, Bitmap&gt; mMemoryLru; public MemoryCache() &#123; init(); &#125; private void init() &#123; int currentMaxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); //内存缓存的大小 int cacheSize = currentMaxMemory / 4; mMemoryLru = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; @Override public void put(String url, Bitmap bitmap) &#123; mMemoryLru.put(url,bitmap); &#125; @Override public Bitmap get(String url) &#123; return mMemoryLru.get(url); &#125;&#125; 通过上面代码可以看出 ImageLoader 负责图片加载的逻辑，而 MemoryCache 负责缓存，这 2 个类职责分明，就像公司里面不同部门干不同的活一样。但是，如果这 2 类写在一起的话，缺点一下就出来了，不仅功能职责不分明，而且代码也比较臃肿，耦合太重。 现在虽然代码结构变得清晰，职责也分明了，但是可扩展性还需要进一步优化，下面我们就来慢慢优化吧。 开闭原则开闭原则英文全称是 Open Close Principle,缩写 OCP ，它是 Java 世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。 开闭原则的定义是：软件中的对象 (类、模块、函数等) 应该对于扩展是开放的，但是，对于修改是封闭的 这就是开放-关闭原则。 上一小节的 ImageLoader 职责单一，结构清晰，应该算是一个不错的开始了，但是 Android 中应用内存是有限制的，当应用重新启动，那么原有的缓存就不在了。现在我们加上本地磁盘缓存，为了遵从开闭原则的思想，我又对 ImageLoader 重新设计了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ImageLoader &#123; private String TAG = getClass().getSimpleName(); /** * 默认内存缓存 */ private IImageCache mMemoryCache; /** * 线程池 */ private ExecutorService mExecutorService; /** * 主线程管理 */ private Handler mHandler = new Handler(Looper.getMainLooper()); private static ImageLoader instance; public static ImageLoader getInstance() &#123; if (instance == null) instance = new ImageLoader(); return instance; &#125; public ImageLoader() &#123; mMemoryCache = new MemoryCache(); //线程池，线程数据量为 CPU 的数量 mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); &#125; /** * 用户配置缓存策略 * * @param imageCache */ public void setImageCache(IImageCache imageCache) &#123; this.mMemoryCache = imageCache; &#125; /** * 加载图片 */ public void loadImage(final String url, final ImageView imageView) &#123; ..... &#125; /** * 显示图片 * * @param downBitmap * @param imageView */ private void displayImage(final Bitmap downBitmap, final ImageView imageView) &#123; ..... &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//磁盘缓存public class DiskCache implements IImageCache &#123; private DiskLruCache mDiskLruCache; private static final int MAX_SIZE = 10 * 1024 * 1024;//10MB //IO缓存流大小 private static final int IO_BUFFER_SIZE = 8 * 1024; //缓存个数 private static final int DISK_CACHE_INDEX = 0; public DiskCache(Context context) &#123; try &#123; File cacheDir = CacheUtils.getDiskCacheDir(context, "bitmapCache"); if (!cacheDir.exists()) &#123; cacheDir.mkdirs(); &#125; mDiskLruCache = DiskLruCache.open(cacheDir, ImageLoaderUtils.getAppVersion(context), 1, MAX_SIZE); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void put(String url, Bitmap bitmap) &#123; OutputStream outputStream = null; DiskLruCache.Snapshot snapshot = null; BufferedOutputStream out = null; BufferedInputStream in = null; String key = ImageLoaderUtils.hashKeyForDisk(url); try &#123; snapshot = mDiskLruCache.get(key); if (snapshot != null) &#123; DiskLruCache.Editor editor = mDiskLruCache.edit(key); if (editor != null) &#123; outputStream = editor.newOutputStream(DISK_CACHE_INDEX); InputStream inputStream = ImageLoaderUtils.bitmap2InputStream(bitmap, 50); in = new BufferedInputStream(inputStream, IO_BUFFER_SIZE); out = new BufferedOutputStream(outputStream, IO_BUFFER_SIZE); int b; while ((b = in.read()) != -1) &#123; out.write(b); &#125; editor.commit(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (snapshot != null) &#123; snapshot.close(); &#125; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public Bitmap get(String url) &#123; //通过key值在缓存中找到对应的Bitmap Bitmap bitmap = null; String key = ImageLoaderUtils.hashKeyForDisk(url); try &#123; DiskLruCache.Snapshot snapshot = mDiskLruCache.get(key); if (snapshot == null) return null; //得到文件输入流 InputStream fileInputStream = snapshot.getInputStream(DISK_CACHE_INDEX); if (fileInputStream != null) bitmap = BitmapFactory.decodeStream(fileInputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536public class DoubleCache implements IImageCache &#123; private String TAG = getClass().getSimpleName(); /** * 内存缓存 */ private IImageCache mMemoryCache; /** * 磁盘缓存 */ private IImageCache mDiskCache; public DoubleCache(Context context) &#123; this.mMemoryCache = new MemoryCache(); this.mDiskCache = new DiskCache(context); &#125; @Override public void put(String key, Bitmap bitmap) &#123; mMemoryCache.put(key, bitmap); mDiskCache.put(key, bitmap); &#125; @Override public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap != null) &#123; Log.i(TAG,"使用内存缓存"); return bitmap; &#125; Log.i(TAG,"使用磁盘缓存"); return mDiskCache.get(url); &#125;&#125; 123456789101112public interface IImageCache &#123; /** * 存图片 */ void put(String url, Bitmap bitmap); /** * 获取图片 */ Bitmap get(String url);&#125; IImageCache 接口简单定义了 存储/获取 两个函数，缓存的 url 就是图片网络地址，值就是缓存的图片，经过这次重构我们扩展了内存/磁盘缓存，细心的同学可能注意到了， ImageLoader 类中增加了一个 setImageCache (IImageCache cache) 函数，用户可以通过该函数来设置缓存，也就是通常说的依赖注入。下面看看怎么配置: 1234567891011121314151617public void config() &#123; //使用双缓存 ImageLoader.getInstance().setImageCache(new DoubleCache(getApplicationContext())); //用户自定义 ImageLoader.getInstance().setImageCache(new IImageCache() &#123; @Override public void put(String url, Bitmap bitmap) &#123; &#125; @Override public Bitmap get(String url) &#123; return null; &#125; &#125;); &#125; 在上述代码中，通过 setImageCache() 方法注入不同的缓存实现，这样不仅能够使 ImageLoader 更简单，健壮，也使得 ImageLoader 的可扩展性，灵活性能高，MemoryCache 、DiskCache 、DoubleCache 缓存图片的具体实现完全一样，但是，他们的一个特点是都实现了 ImageCache 接口，并且通过 setImageCache() 注入到 IImageCache 中，这样就实现了千变万化的缓存策略，且扩展不会导致内部的修改，哈哈，这就是我们之前所说的开闭原则。 里氏替换原则里氏替换原则英文全称是 Liskov Substitution Principle , 缩写是 LSP。LSP 的第一种定义是：如果对每一个类型为 S 的对象 O1, 都有类型为 T 的对象 O2, 使得以 T 定义的所有程序 P 在所有的对象 O1都替换成 O2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。上面这种描述确实有点不好理解，我们再来看第二种里氏替换原则定义：所有引用基类的地方必须能透明地使用其子类的对象。 我们知道，面向对象语言的三大特点是 继承，封装，多态，里氏替换原则就是依赖于 继承，多态这两大特性。里氏替换原则通俗来说的话就是，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本不用知道是父类还是子类，但是反过来就不行了，有子类出现的地方，父类就不一定能适应，说了这么多，其实最终总结就两个字：抽象。 为了我们能够深入理解直接看下面代码示例吧: ​ 123456789101112131415161718192021222324//框口类public class Window&#123; public void show(View view)&#123; view.draw(); &#125;&#125;//建立视图对象，测量视图的宽高为公用代码，绘制实现交给具体的子类pubic abstract class View&#123; public abstract void draw(); public vid measure(int width,int height)&#123; //测量视图大小 &#125;&#125;public class ImageView extends View&#123; draw&#123; //绘制图片 &#125;&#125;... extends View&#123; ...&#125; 上述示例代码中， Window 依赖于 View , 而 View 定义了一个视图抽象， measure 是各个子类共享的方法，子类通过重写 View 的draw 方法实现具有各自特色的功能，在这里，这个功能就是绘制自身的内容，在任何继承 View 类的子类都可以传递给 show 函数，这就是所说的里氏替换。 里氏替换原则的核心原理是抽象，抽象又依赖于继承这个特性，在 OOP 当中，继承的优缺点都相当明显，优点： 代码复用，减少创建类的成本，每个子类都拥有父类的方法和属性； 子类于父类基本相似，但又与父类有所区别； 提高代码的可扩展性； 继承的缺点： 继承是侵入性的，只要继承就必须拥有父类的所有属性和方法； 可能造成子类代码冗余，灵活性降低，因为子类必须拥有父类的属性和方法。 事务都是都利和弊，须合理利用。 继续拿上面的 ImageLoader 缓存策略来说明里氏替换原则，用户只需要指定具体的缓存对象就可以通过 ImageCache 的 setImageCache() 函数就可以替换 ImageLoader 的缓存策略，这就使得 ImageLoader 的缓存系统有了无限的可能性，也保证了可扩展性。 开闭和里氏往往是生世相依，不离不弃，通过里氏替换来达到程序的扩展，对修改的关闭效果。然而，这两个原则都同时强调了一个 OOP 的重要性 - 抽象，因此，在开发过程中，运用抽象是走向代码优化的重要一步。 依赖倒置原则依赖倒置原则英文全称是 Dependence Inversion Principle, 简写 DIP 。依赖倒置原则指代了一种特定的解耦形式，使得高层次的模块不依赖于底层次模块的实现细节的目的，依赖模块被颠倒了。这个概念有点不好理解，这到底是什么意思勒？ 依赖倒置有几个关键点： 高层模块不应该依赖底层模块，两者都应该依赖起抽象； 抽象不应该依赖细节； 细节应该依赖抽象； 在 Java 语言中，抽象就是接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，其特点就是可以直接实例化，也就是可以加上一个 new 关键字产生一个对象。高层模块就是调用端，底层模块就是具体实现类。依赖倒置原则在 Java 语言中的表现就是: 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的 ，这又是一个将理论抽象化的实例，其实一句话可以概括：面向接口编程，或者说是面向抽象编程，面向接口编程是面向对象精髓之一，也就是上面两节强调的抽象。 这里我们还是以 ImageLoader 来说明，先看下面代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ImageLoader &#123; private String TAG = getClass().getSimpleName(); /** * 默认内存缓存(直接依赖于细节，而不是抽象) */ private MemoryCache mMemoryCache; /** * 线程池 */ private ExecutorService mExecutorService; /** * 主线程管理 */ private Handler mHandler = new Handler(Looper.getMainLooper()); private static ImageLoader instance; public static ImageLoader getInstance() &#123; if (instance == null) instance = new ImageLoader(); return instance; &#125; public ImageLoader() &#123; mMemoryCache = new MemoryCache(); //线程池，线程数据量为 CPU 的数量 mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); &#125; /** * 用户配置缓存策略 * * @param imageCache */ public void setImageCache(MemoryCache imageCache) &#123; this.mMemoryCache = imageCache; &#125;...&#125; 上面代码 ImageLoader 直接依赖于细节 MemoryCache ，如果框架升级需有多级缓存也就是内存 + SD 卡缓存策略，那么就又需要改 ImageLoader 中的代码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ImageLoader &#123; private String TAG = getClass().getSimpleName(); /** * 默认内存缓存(直接依赖于细节，而不是抽象) */ private DoubleCache mMemoryCache; /** * 线程池 */ private ExecutorService mExecutorService; /** * 主线程管理 */ private Handler mHandler = new Handler(Looper.getMainLooper()); private static ImageLoader instance; public static ImageLoader getInstance() &#123; if (instance == null) instance = new ImageLoader(); return instance; &#125; public ImageLoader() &#123; mMemoryCache = new DoubleCache(); //线程池，线程数据量为 CPU 的数量 mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); &#125; /** * 用户配置缓存策略 * * @param imageCache */ public void setImageCache(DoubleCache imageCache) &#123; this.mMemoryCache = imageCache; &#125;...&#125; 在 ImageLoader 中我们把默认内存缓存改成了双缓存，这样不仅违背了没有开闭原则，也没有依赖于抽象，所以下面的代码才是正确的： 1234567891011121314151617181920212223242526272829public class ImageLoader &#123; private String TAG = getClass().getSimpleName(); /** * 默认内存缓存 默认依赖于抽象 */ private IImageCache mMemoryCache; private static ImageLoader instance; public static ImageLoader getInstance() &#123; if (instance == null) instance = new ImageLoader(); return instance; &#125; public ImageLoader() &#123; ... &#125; /** * 用户配置缓存策略 注入抽象类 * * @param imageCache */ public void setImageCache(IImageCache imageCache) &#123; this.mMemoryCache = imageCache; &#125;&#125; 在这里实现类没有发生直接的依赖，而是通过抽象发生的依赖。满足了依赖倒置基本原则，想要让程序更为灵活，那么抽象就是迈出灵活的第一步。 接口隔离原则接口隔离原则英文全称是 InterfaceSegregation Principles, 缩写 ISP 。接口隔离原则的目的是系统解耦，从而容易重构、更改和重新部署。说白了就是让客服端依赖的接口尽可能地小，这样说可能还有点抽象，还是以一个示例说明一下 未优化的接口 12345678910111213141516171819202122232425262728293031323334353637public class DiskCache implements IImageCache &#123; private DiskLruCache mDiskLruCache; private static final int MAX_SIZE = 10 * 1024 * 1024;//10MB //IO缓存流大小 private static final int IO_BUFFER_SIZE = 8 * 1024; //缓存个数 private static final int DISK_CACHE_INDEX = 0; @Override public void put(String url, Bitmap bitmap) &#123; ..... &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (snapshot != null) &#123; snapshot.close(); &#125; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 可以看见上面一段代码虽然功能达到了要求，但是各种 try…catch 嵌套，不经影响代码美观，而且可读性差。我们可以看 Cloaseable 这个类的实现差不多 160 多个实现类，如果每个类都 close 那不的疯了，我们直接抽取一个 CloseUtils 如下： 123456789101112131415161718public class CloaseUtils &#123; public static void close(Closeable... closeable) &#123; if (closeable != null) &#123; try &#123; if (closeable.length == 1)&#123; closeable[0].close(); return; &#125; for (int i = 0; i &lt; closeable.length; i++) &#123; closeable[i].close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 支持同时关闭一个，或多个实现类的 close。 改造之后的代码： 123456789101112131415161718192021222324public class DiskCache implements IImageCache &#123; private DiskLruCache mDiskLruCache; private static final int MAX_SIZE = 10 * 1024 * 1024;//10MB //IO缓存流大小 private static final int IO_BUFFER_SIZE = 8 * 1024; //缓存个数 private static final int DISK_CACHE_INDEX = 0; @Override public void put(String url, Bitmap bitmap) &#123; ..... &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; CloaseUtils.close(snapshot,out,in); &#125; &#125;&#125; 是不是清爽多了，一行代码解决了刚刚差不多 10 行代码的逻辑。而且这里基本原理就是依赖于 Closeable 抽象，而不是具体实现类（这不就是我们刚刚才说了的依赖倒置原则嘛），并且建立在最小化依赖原则的基础上，它只需要知道这个对象是否关闭，其它一概不关心，也就是这里的接口隔离原则。 迪米特原则迪米特原则英文的全称为 Law of Demeter , 缩写是 LOD , 也称为最少知识原则。虽然名字不同，但描述的是同一个原则：一个对象应该对其他对象有最少的的了解。通俗的将，一个类应该对自己需要耦合或调用的类知道的最少，类的内部如何实现与调用者或者依赖者没有关系，调用者或者依赖着只需要知道它需要的方法即可，其他的可一概不用管。类与类之间关系密切，耦合度就越大，当一个类发生改变时，对另一个类的影响也越大。 下面以一个租房例子说明: 123456789101112/**房子*/public class Room &#123; //面积 public float area; //价钱 public float price; public Room(float area,float price)&#123; this.area = area; this.price = price; &#125;&#125; 1234567891011121314/**中介*/public class Mediator&#123; List &lt;Room&gt; mRooms = new ArrayList&lt;Room&gt;(); public Mediator()&#123; for(i = 0; i &lt; 5 ; i ++)&#123; mRoom.add(new Room(14 + i,(14 + i) * 150)); &#125; &#125; public List&lt;Room&gt; getAllRooms()&#123; return mRooms; &#125;&#125; 1234567891011121314151617/**租客**/public class Tenant &#123; public void rentRoom(float roomArea,float roomPrice,Mediator mediator)&#123; List&lt;Room&gt; rooms = mediator.getAllRooms(); for(Room room : rooms)&#123; if(isSuitable(roomArea,roomPrice,room))&#123; Log.i(TAG,"租到房子了"); bread; &#125; &#125; &#125; //租金要小于等于指定的值，面积要大于等于指定的值 public boolean isSuitable(float roomArea,float roomPrice,Room room)&#123; return room.price &lt;= roomPrice &amp;&amp; room.area &gt;= roomArea; &#125;&#125; 上面的代码中可以看到，Tenant 不仅依赖了 Mediator 类，还需要频繁得于 Room 类打交道。租客只是找一个房子而已，如果把这些功能都放在 Tenant 类里面，那中介都没有存在感了吧？耦合太重了，我们只需要跟中介通信就行了，继续重构代码； 1234567891011121314151617181920212223//中介public class Mediator&#123; List&lt;Room&gt; mRooms = new ArrayList&lt;Room&gt;(); /**构造房子**/ public Mediator()&#123; for(i = 0; i &lt; 5 ; i ++)&#123; mRoom.add(new Room(14 + i,(14 + i) * 150)); &#125; &#125; public Room rentOut(float area,float price)&#123; for(Room room : mRooms)&#123; if(isSuitable(area,price,room))&#123; return room; &#125; &#125; return null; &#125;public boolean isSuitable(float area,float price ,Room room)&#123; return room.price &lt;= price &amp;&amp; room.area &gt;= area &#125;&#125; 1234567//租客public class Tenant&#123; /**是否租到房子了*/ public Room rentRoom(float roomArea,float roomPrice,Mediator mediator)&#123; return mediator.rentOut(roomArea,roomPrice); &#125;&#125; 根据上面的重构优化，我们得出结构，租客只需要跟中介通信，主要关心中介那里有没有我需要的房子，而中介勒就去他的资源库里面去找，有没有租客需要的房子，每个对象做的事儿明确。“只与直接有关系的联系” 这简单的几个字就能够将我们从复杂的关系网中抽离出来，使程序耦合度更低，稳定性更好。 总结从六大原则中我们得出了重要的结论，就是一定要有抽象的思维，面向抽象或面向接口编程。在应用开发过程中，最难的不是完成开发工作，而是后续的维护和迭代工作是否拥有可变性，扩展性，在不破坏系统的稳定性前提下依然保持 二高一低原则（高扩展，高内聚，低耦合） 在经历多个版本的迭代项目依然保持清晰，灵活，稳定的系统架构。当然这是我们一个比较理想的情况，但是我们需要往这个方向去实现努力，就相当于接口（想法）出来了，我们要去实现（接口实现类）它，遵循面向对象六大原则就是我们走向灵活软件之路所迈出的第一步，加油！ 特别感谢《 Android 源码设计模式解析与实战 》]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>六大原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐一波最近学习Gradle的项目]]></title>
    <url>%2Fposts%2F8f5f13d7.html</url>
    <content type="text"><![CDATA[最新搞了好久的 Gradle，说起 Gradle 这个东西也很奇怪，明明在 gradle 文件内是支持各种我们熟悉的代码的，比如 Java，Groovy，但是就是在里面写几个功能极其费劲，总体而言，还是对其原理缺乏认识导致的。 再者，我们在研究很多技术时，基本都离不开 Gradle 相关的知识，比如编译相关，热修复，插件化，很多性能优化相关，反正你想干涉整个打包流程，或者在编译期间搞点小动作，或多或少是要了解相关知识的。 好了，下面就推荐一些学习资源，基本上足够大家系统性学习了，当然前提是你愿意看哈… 官方用户手册如果英文足够好的话，当然首选官网了： https://docs.gradle.org/current/userguide/getting_started.html 而且官网也提供了 user guide pdf 的下载： https://docs.gradle.org/current/userguide/userguide.pdf 想离线看很方便。 Gradle User Guide 中文版https://github.com/DONGChuan/GradleUserGuide 没错，总有可爱的人，会愿意翻译 user guide然后分享出来，当然了，因为是翻译，所以内容并不是最新的，不过倒是不影响前期的学习，可以边敲边学，遇到有问题的，搜一下解决就行了。 阅读地址： https://dongchuan.gitbooks.io/gradle-user-guide-/ 一个不错的入门系列如果你就是想单纯的先入个门，那么可以花点时间看这个系列： https://www.cnblogs.com/davenkin/p/gradle-learning-1.html 对应源码: https://github.com/davenkin/gradle-learning 很早的文章了，不过依然适合入门。 一个非常棒的深入系列github 地址： https://github.com/5A59/android-training 当然也可以在掘金上看整个系列： 【Android 修炼手册】Gradle 篇 – Gradle 的基本使用 https://juejin.im/post/5cd441f851882554b86d088b 掌握 gradle 的基本使用 了解 gradle 及 android gradle plugin 了解 gradle 构建阶段及生命周期回调 掌握 Task，Transform 等概念 学会自定义 task，自定义 gradle 插件 【Android 修炼手册】Gradle 篇 – Android Gradle Plugin 主要流程分析 https://juejin.im/post/5cd640526fb9a03232199a05 了解 android gradle plugin 的构建流程 了解 android gradle plugin 的主要 task 的实现 学会 hook android 构建流程，添加自己想要的功能 【Android 修炼手册】Gradle 篇 – Android Gradle Plugin 主要 Task 分析 https://juejin.im/post/5ce913735188254e8309290b 了解 android gradle plugin 中各个 task 作用 了解 android gradle plugin 中主要 task 的实现 【Android 修炼手册】Gradle 篇 – Gradle 源码分析 https://juejin.im/post/5cf3e4dfe51d454d56535790 了解 gradle 的实现原理 这算的上是写的非常深入而且实用的一个系列了，从 基本使用-&gt; 常见 API（Task,Transform，插件-&gt; 打包过程task 分析-&gt; 核心 task 源码分析-&gt; gradle 源码分析 超赞… 最后，关于一些针对性的知识，比如你已经很明确了要自定义一个 Transform 子类的，搜索就ok 了，wanandroid 上也收录了一大批好文。 以上已经足够大家系统性学习整个 Gradle 的知识了，回见！ 转自鸿洋大神：https://mp.weixin.qq.com/s/TVuF8_304DZQ1wbe1vm1ag]]></content>
  </entry>
  <entry>
    <title><![CDATA[马云卸任挥泪洒现场，核心观点总结他所想]]></title>
    <url>%2Fposts%2Fa1768e04.html</url>
    <content type="text"><![CDATA[去年，在教师节那天，阿里巴巴集团创始人马云今天公开信宣布：一年后的阿里巴巴20周年之际，即2019年9月10日，也就是昨天，他将不再担任集团董事局主席，却留下句句触动心灵的话！ 1、我最遗憾的错误01年，我犯了一个错误，我告诉我的18位共同创业同仁，他们只能做小组经理，而所有的副总裁都得从外面聘请。 现在十年过去了，我从外面聘请的人才都走了，而我之前曾怀疑过其能力的人都成了副总或董事。 我相信两个信条：态度比能力重要，选择同样也比能力重要！ 2、 不能统一人的思想，但可以统一人的目标千万不要相信你能统一人的思想，那是不可能的。 30%的人永远不可能相信你，不要让你的同事为你干活，而让他们为我们的共同目标干活。 团结在一个共同的目标下，要比团结在一个人周围容易的多。 3、 细节好的人格局一般都差①有人觉得我牛，6分钟说服了孙正义，其实是他说服了我。见孙正义之前，我在硅谷至少被拒绝了40次。 ②做企业赢在细节，输在格局。 ③格局，“格”是人格，“局”是胸怀，细节好的人格局一般都差，格局好的人从来不重细节，两个都干好，那叫太有才！ 4、 领导比员工多什么？领导永远不要跟下属比技能，下属肯定比你强；如果不比你强，说明你请错人了。 ①要比眼光：比他看得远； ②要比胸怀：领导的胸怀是委屈撑大的，要能容人所不容； ③要比实力：抗失败的能力比他强；一个优秀的领导人的素质就是眼光、胸怀和实力。 5、 中国商人千万别在“红道”上混①人一辈子要明白钱和权两个东西是绝对不要碰在一起，当了官永远不要想有钱，当了商人千万别想权； ②钱和权这两个东西碰在一起就是炸药和雷管碰在一起，必然要爆炸； ③胡雪岩的悲哀就在于他是红顶商人； ④中国商人千万别在“红道”上混。 6、 年轻人必须思考的4大问题①什么是失败？放弃就是最大的失败。 ②什么叫坚强？经历许多磨难、委屈、不爽，你才知道什么叫坚强。 ③你的职责是什么？比别人多勤奋一点、多努力一点、多一点理想，这就是你的职责。 ④傻瓜用嘴讲话，聪明人用脑袋讲话，智者用心讲话。 7、 人生在世在做人，不是做事我跟自己讲我们到这个世界上不是来工作的，我们是来享受人生的，我们是来做人不是做事。 如果一辈子都做事的话，忘了做人，将来一定会后悔。 不管事业多成功、多伟大、多了不起，记住我们到这个世界就是享受经历这个人生的体验。 忙着做事一定会后悔。 8、 高手的竞争论①一定要争得你死我活的商战，是最愚蠢的。 ②眼睛中全是敌人，外面就全是敌人。 ③竞争的时候不要带仇恨，带仇恨一定失败。 ④竞争乐趣就像下棋一样，你输了，我们再来过，两个棋手不能打架。 ⑤真正做企业是没有仇人的，心中无敌，天下无敌。 9、 别把抱怨当习惯人是退化最严重的动物。跟兽比人很“弱肢”，和狗比人很“闻盲”，但人类“进化”了抱怨。 偶尔为之无大碍，但当抱怨成习惯，就如喝海水，喝的越多渴得越厉害。 最后发现，走在成功路上的，都是些不抱怨的“傻子们”。 世界不会记得你说了什么，但一定不会忘记你做了什么！ 10、 给初创企业者的忠告①大家看不清的机会，才是真正的机会。 ②让员工笑着干活。 ③客户第一、员工第二、股东第三。 ④抢在变化之前先变。 ⑤忘掉money，忘掉赚钱。 ⑥小聪明不如傻坚持。 ⑦心态决定姿态，姿态决定状态。 11、 谈创业①一个好的东西往往是说不清楚的，说得清楚的往往不是好东西！ ②创业要找最合适的人，不一定要找最成功的人。 ③这世界最不可靠的东西就是关系。 ④免费是世界上最昂贵的东西。 ⑤今天很残酷，明天更残酷，后天很美好。 12、 “四不”创业智慧①创业最怕就是看不见，看不起，看不懂，跟不上； ②看不见对手在哪里，看不起对手，看不懂对手为什么可以变得那么强，然后就跟不上了； ③即使对手很弱小，也一定要把对方看的很强大，即使对手很强大，也不一定要把自己看的很弱小。 13、 当你决定要创业时便意味着： ①没有了稳定的收入；②没有了请假的权利；③没有了得红包的机会。 然而却更意味着： ①收入不再受限制；②时间运用更有效；③手心向下不求人。 想法若不同，结果便不同；选择不一样，生活才变样。 14、谈机会如果一个方案有90%的人说“好”的话，我一定要把它扔到垃圾桶里去。 因为这么多人说好的方案，必然有很多人在做了，机会肯定不会是我们的了。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_build.gradle配置详解]]></title>
    <url>%2Fposts%2Faaeab884.html</url>
    <content type="text"><![CDATA[Android Studio是采用gradle来构建项目的，gradle是基于groovy语言的，如果只是用它构建普通Android项目的话，是可以不去学groovy的。当我们创建一个Android项目时会包含两个Android build.gradle配置详解文件，如下图： 一、Project的build.gradle文件：对应的build.gradle代码如下： 12345678910111213141516171819202122232425262728293031// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123;//这里是gradle脚本执行所需依赖，分别是对应的maven库和插件 repositories &#123; google()//从Android Studio3.0后新增了google()配置，可以引用google上的开源项目 jcenter()//是一个类似于github的代码托管仓库，声明了jcenter()配置，可以轻松引用 jcenter上的开源项目 &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.0'////此处是android的插件gradle，gradle是一个强大的项目构建工具 // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123;//这里是项目本身需要的依赖，比如项目所需的maven库 repositories &#123; google() jcenter() &#125;&#125;// 运行gradle clean时，执行此处定义的task任务。// 该任务继承自Delete，删除根目录中的build目录。// 相当于执行Delete.delete(rootProject.buildDir)。// gradle使用groovy语言，调用method时可以不用加（）。task clean(type: Delete) &#123; delete rootProject.buildDir&#125; buildscript{}闭包里是gradle脚本执行所需依赖，分别是对应的maven库和插件。 allprojects{}闭包里是项目本身需要的依赖，比如项目所需的maven库。 task clean(type: Delete){}是运行gradle clean时，执行此处定义的task任务，该任务继承自Delete，删除根目录中的build目录。其中buildscript包含repositories闭包和dependencies闭包。 repositories{}闭包：配置远程仓库该闭包中声明了jcenter()和google()的配置，其中jcenter是一个代码托管仓库，上面托管了很多Android开源项目，在这里配置了jcenter后我们可以在项目中方便引用jcenter上的开源项目，从Android Studio3.0后新增了google()配置，可以引用google上的开源项目。 dependencies{}闭包：配置构建工具该闭包使用classpath声明了一个Gradle插件，由于Gradle并不只是用来构建Android项目，因此此处引入相关插件来构建Android项目，其中’3.0.0’为该插件的版本号，可以根据最新的版本号来调整。 二、Module的build.gradle文件：从文件内容可以看出，主要分为三大部分，如下图所示： 1、apply plugin：12345// 声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块//而这区别：前者可以直接运行，后着是依附别的应用程序运行apply plugin: 'com.android.application' 文件中第一行使用apply plugin表示应用了一个插件，该插件一般有两种值可选： ‘com.android.application’，表示该模块为应用程序模块，可以直接运行，打包得到的是.apk文件 ‘com.android.library’，表示该模块为库模块，只能作为代码库依附于别的应用程序模块来运行，打包得到的是.aar文件 2、android{}闭包：这个闭包主要为了配置项目构建的各种属性： 2.1、添加signingConfigs{}闭包：1234567891011121314signingConfigs &#123;// 自动化打包配置 release &#123;// 线上环境 keyAlias 'test' keyPassword '123456' storeFile file('test.keystore') storePassword '123456' &#125; debug &#123;// 开发环境 keyAlias 'test' keyPassword '123456' storeFile file('test.keystore') storePassword '123456' &#125;&#125; 可以手动添加签名配置，也可以通过Project Structure 选中app，点击Singing添加，具体步骤如下图所示： 签名配置完成后可以方便带签名打包，在module的Build Variants中有两个Type，分别是debug和release，可以选择任意一个类型进行打包，并且他们会利用各自配置的Key进行打包，执行 Run app或者Build-&gt;Build apk就会自动在module name/app/build/outputs/apk路径下生成Apk文件。另一种打包方式是Build-&gt;Generate Signed APK填写签名信息生成Apk。 2.2、compileSdkVersion：设置编译时用的Android版本2.3、buildToolsVersion：设置编译时使用的构建工具的版本，Android Studio3.0后去除此项配置 2.4、defaultConfig{}闭包：123456789compileSdkVersion 27//设置编译时用的Android版本defaultConfig &#123; applicationId "com.billy.myapplication"//项目的包名 minSdkVersion 16//项目最低兼容的版本 targetSdkVersion 27//项目的目标版本 versionCode 1//版本号 versionName "1.0"//版本名称 testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"//表明要使用AndroidJUnitRunner进行单元测试&#125; applicationId：指定了项目的包名。 minSdkVersion：指定项目最低兼容的版本，如果设备小于这个版本或者大于maxSdkVersion(一般不用)将无法安装这个应用，这里指定为16，表示最低兼容到Android 4.1系统。 targetSdkVersion：指定项目的目标版本，表示在该目标版本上已经做过充分测试，系统会为该应用启动一些对应该目标系统的最新功能特性，Android系统平台的行为变更，只有targetSdkVersion的属性值被设置为大于或等于该系统平台的API版本时，才会生效。例如，若指定targetSdkVersion值为22，则表示该程序最高只在Android5.1版本上做过充分测试，在Android6.0系统上（对应targetSdkVersion为23）拥有的新特性如系统运行时权限等功能就不会被启用。 versionCode：表示版本号，一般每次打包上线时该值只能增加，打包后看不见。 versionName：表示版本名称，展示在应用市场上。 testInstrumentationRunner “android.support.test.runner.AndroidJUnitRunner”表明要使用AndroidJUnitRunner进行单元测试。 2.5、 buildTypes{}闭包：这个闭包主要指定生成安装文件的主要配置，一般包含两个子闭包，一个是debug闭包，用于指定生成测试版安装文件的配置，可以忽略不写；另一个是release闭包，用于指定生成正式版安装文件的配置。两者能配置的参数相同，最大的区别默认属性配置不一样，两种模式支持的属性配置如下图： 123456789101112131415161718192021222324252627buildTypes &#123;// 生产/测试环境配置 release &#123;// 生产环境 buildConfigField("boolean", "LOG_DEBUG", "false")//配置Log日志 buildConfigField("String", "URL_PERFIX", "\"https://release.cn/\"")// 配置URL前缀 minifyEnabled false//是否对代码进行混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件 signingConfig signingConfigs.release//设置签名信息 pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多 zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率 applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 &#125; debug &#123;// 测试环境 buildConfigField("boolean", "LOG_DEBUG", "true")//配置Log日志 buildConfigField("String", "URL_PERFIX", "\"https://test.com/\"")// 配置URL前缀 minifyEnabled false//是否对代码进行混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件 signingConfig signingConfigs.debug//设置签名信息 debuggable false//是否支持断点调试 jniDebuggable false//是否可以调试NDK代码 renderscriptDebuggable false//是否开启渲染脚本就是一些c写的渲染方法 zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率 pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多 applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 &#125;&#125; release{}闭包和debug{}闭包两者能配置的参数相同，最大的区别默认属性配置不一样： minifyEnabled：表明是否对代码进行混淆，true表示对代码进行混淆，false表示对代码不进行混淆，默认的是false。 proguardFiles：指定混淆的规则文件，这里指定了proguard-android.txt文件和proguard-rules.pro文件两个文件，proguard-android.txt文件为默认的混淆文件，里面定义了一些通用的混淆规则。proguard-rules.pro文件位于当前项目的根目录下，可以在该文件中定义一些项目特有的混淆规则。 buildConfigField：用于解决Beta版本服务和Release版本服务地址不同或者一些Log打印需求控制的。例如：配置buildConfigField(“boolean”, “LOG_DEBUG”, “true”)，这个方法接收三个非空的参数，第一个：确定值的类型，第二个：指定key的名字，第三个：传值，调用的时候BuildConfig.LOG_DEBUG即可调用。 debuggable：表示是否支持断点调试，release默认为false，debug默认为true。 jniDebuggable：表示是否可以调试NDK代码，使用lldb进行c和c++代码调试，release默认为false signingConfig：设置签名信息，通过signingConfigs.release或者signingConfigs.debug，配置相应的签名，但是添加此配置前必须先添加signingConfigs闭包，添加相应的签名信息。 renderscriptDebuggable：表示是否开启渲染脚本就是一些c写的渲染方法，默认为false。 renderscriptOptimLevel：表示渲染等级，默认是3。 pseudoLocalesEnabled：是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多。 applicationIdSuffix：和defaultConfig中配置是一的，这里是在applicationId 中添加了一个后缀，一般使用的不多。 versionNameSuffix：表示添加版本名称的后缀，一般使用的不多。 zipAlignEnabled：表示是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率，release和debug默认都为true。 2.6、sourceSets{}闭包：配置目录指向12345sourceSets &#123;//目录指向配置 main &#123; jniLibs.srcDirs = ['libs']//指定lib库目录 &#125;&#125; 配置 jniLibs.srcDirs = [‘libs’]，可以在Android studio的Android视图下生成jniLibs文件夹，可以方便我们存放jar包和库文件，其中Android视图下的jniLibs和project视图下的libs指向同一文件夹（app→libs），如下图所示： 2.7、packagingOptions{}闭包：打包时的相关配置当项目中依赖的第三方库越来越多时，有可能会出现两个依赖库中存在同一个（名称）文件。如果这样，Gradle在打包时就会提示错误（警告）。那么就可以根据提示，然后使用以下方法将重复的文件剔除，比较常用的是通过exclude去除重复的文件，例如： 123456789101112packagingOptions&#123; //pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk // 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时 只用第一个 这样打包就不会报错 pickFirsts = ['META-INF/LICENSE'] //merges何必 当出现重复文件时 合并重复的文件 然后打包入apk //这个是有默认值得 merges = [] 这样会把默默认值去掉 所以我们用下面这种方式 在默认值后添加 merge 'META-INF/LICENSE' //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor'&#125; 2.8、productFlavors{}闭包：多个渠道配置这个配置是经常会使用到的，通常在适配多个渠道的时候，需要为特定的渠道做部分特殊的处理，比如设置不同的包名、应用名等。场景：当我们使用友盟统计时，通常需要设置一个渠道ID，那么我们就可以利用productFlavors来生成对应渠道信息的包，如： 123456789101112131415161718android &#123; productFlavors &#123; wandoujia &#123; //豌豆荚渠道包配置 manifestPlaceholders = [UMENG_CHANNEL_VALUE: "wandoujia"] //manifestPlaceholders的使用在后续章节（AndroidManifest里的占位符）中介绍 &#125; xiaomi &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "xiaomi"] applicationId "com.wiky.gradle.xiaomi" //配置包名 &#125; _360 &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: "_360"] &#125; //... &#125; &#125; 当然也有更简洁的方式： 12345678910111213android &#123; productFlavors &#123; wandoujia &#123;&#125; xiaomi &#123;&#125; _360 &#123;&#125; //... &#125; productFlavors.all &#123; //批量修改，类似一个循序遍历 flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125;&#125; 配置完之后，在命令行窗口中（Terminal）中输入gradlew assembleRelease（windows）即可开始打包，在Mac系统中对应指令应该是./gradlew assembleRelease。当然，如果想要debug版本的包，将指令中assembleRelease改为assembleDebug即可。最后生成的包还是在app/build/outputs/apk中，默认命名格式如app-wandoujia-release-unsigned.apk，在module的Build Variants中可以选择相应的渠道。注：Android Studio3.0需在主app的build.gradle里面的defaultConfig {targetSdkVersion：*minSdkVersion ：*versionCode：*versionName ：*//版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度就是都是统一的了flavorDimensions “versionCode”} 2.9、lintOptions{}闭包：代码扫描分析Lint 是Android Studio 提供的 代码扫描分析工具，它可以帮助我们发现代码结构/质量问题，同时提供一些解决方案，而且这个过程不需要我们手写测试用例。 Lint 发现的每个问题都有描述信息和等级（和测试发现 bug 很相似），我们可以很方便地定位问题，同时按照严重程度进行解决。 12345//程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关lintOptions &#123; abortOnError false //即使报错也不会停止打包 checkReleaseBuilds false //打包release版本的时候进行检测&#125; 3、dependencies{}闭包：该闭包定义了项目的依赖关系，一般项目都有三种依赖方式：本地依赖、库依赖和远程依赖。本地依赖可以对本地的jar包或目录添加依赖关系，库依赖可以对项目中的库模块添加依赖关系，远程依赖可以对jcener库上的开源项目添加依赖关系。从Android Studio3.0后compile引入库不在使用，而是通过api和implementation，api完全等同于以前的compile，用api引入的库整个项目都可以使用，用implementation引入的库只有对应的Module能使用，其他Module不能使用，由于之前的项目统一用compile依赖，导致的情况就是模块耦合性太高，不利于项目拆解，使用implementation之后虽然使用起来复杂了但是做到降低偶合兴提高安全性。 12345678dependencies &#123;//项目的依赖关系 implementation fileTree(include: ['*.jar'], dir: 'libs')//本地jar包依赖 implementation 'com.android.support:appcompat-v7:27.1.1'//远程依赖 implementation 'com.android.support.constraint:constraint-layout:1.1.2' testImplementation 'junit:junit:4.12'//声明测试用例库 androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'&#125; implementation fileTree(include: [‘*.jar’], dir: ‘libs’)：implementation fileTree是一个本地依赖声明，表示将libs目录下所有.jar后缀的文件都添加到项目的构建路径当中。 implementation ‘com.android.support:appcompat-v7:27.1.1’：implementation语句为 远程依赖声明，’com.android.support:appcompat-v7:27.1.1’为一个标准的远程依赖库格式，其中com.android.support为域名部分，用于区分不同公司的库；appcompat-v7为组件名称，用于区分同一个公司的不同库；27.1.1为版本号，用于区分同一个库的不同版本。加上这句声明后，Gradle在构建项目时会先检查一下本地是否已经缓存过该库，若没有缓存则自动联网下载，下载后自动添加到项目的构建路径中去。 testImplementation和androidTestImplementation：表示声明测试用例库。 Module完整的build.gradle配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 声明是Android程序，//com.android.application 表示这是一个应用程序模块//com.android.library 标识这是一个库模块//而这区别：前者可以直接运行，后着是依附别的应用程序运行apply plugin: 'com.android.application'android &#123; signingConfigs &#123;// 自动化打包配置 release &#123;// 线上环境 keyAlias 'test' keyPassword '123456' storeFile file('test.jks') storePassword '123456' &#125; debug &#123;// 开发环境 keyAlias 'test' keyPassword '123456' storeFile file('test.jks') storePassword '123456' &#125; &#125; compileSdkVersion 27//设置编译时用的Android版本 defaultConfig &#123; applicationId "com.billy.myapplication"//项目的包名 minSdkVersion 16//项目最低兼容的版本 targetSdkVersion 27//项目的目标版本 versionCode 1//版本号 versionName "1.0"//版本名称 flavorDimensions "versionCode" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"//表明要使用AndroidJUnitRunner进行单元测试 &#125; buildTypes &#123;// 生产/测试环境配置 release &#123;// 生产环境 buildConfigField("boolean", "LOG_DEBUG", "false")//配置Log日志 buildConfigField("String", "URL_PERFIX", "\"https://release.cn/\"")// 配置URL前缀 minifyEnabled false//是否对代码进行混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件 signingConfig signingConfigs.release//设置签名信息 pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多 zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率 applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 &#125; debug &#123;// 测试环境 buildConfigField("boolean", "LOG_DEBUG", "true")//配置Log日志 buildConfigField("String", "URL_PERFIX", "\"https://test.com/\"")// 配置URL前缀 minifyEnabled false//是否对代码进行混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'//指定混淆的规则文件 signingConfig signingConfigs.debug//设置签名信息 debuggable false//是否支持断点调试 jniDebuggable false//是否可以调试NDK代码 renderscriptDebuggable false//是否开启渲染脚本就是一些c写的渲染方法 zipAlignEnabled true//是否对APK包执行ZIP对齐优化，减小zip体积，增加运行效率 pseudoLocalesEnabled false//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多 applicationIdSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 versionNameSuffix 'test'//在applicationId 中添加了一个后缀，一般使用的不多 &#125; &#125; sourceSets &#123;//目录指向配置 main &#123; jniLibs.srcDirs = ['libs']//指定lib库目录 &#125; &#125; packagingOptions&#123;//打包时的相关配置 //pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk // 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时 只用第一个 这样打包就不会报错 pickFirsts = ['META-INF/LICENSE'] //merges何必 当出现重复文件时 合并重复的文件 然后打包入apk //这个是有默认值得 merges = [] 这样会把默默认值去掉 所以我们用下面这种方式 在默认值后添加 merge 'META-INF/LICENSE' //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。 exclude 'META-INF/services/javax.annotation.processing.Processor' &#125; productFlavors &#123; wandoujia &#123;&#125; xiaomi &#123;&#125; _360 &#123;&#125; &#125; productFlavors.all &#123; //批量修改，类似一个循序遍历 flavor -&gt; flavor.manifestPlaceholders = [IFLYTEK_CHANNEL: name] &#125; //程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关 lintOptions &#123; abortOnError false //即使报错也不会停止打包 checkReleaseBuilds false //打包release版本的时候进行检测 &#125;&#125;dependencies &#123; //项目的依赖关系 implementation fileTree(include: ['*.jar'], dir: 'libs') //本地jar包依赖 implementation 'com.android.support:appcompat-v7:27.1.1' //远程依赖 implementation 'com.android.support.constraint:constraint-layout:1.1.2' testImplementation 'junit:junit:4.12' //声明测试用例库 androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_Studio_3.5：稳步推进ProjectMarble计划]]></title>
    <url>%2Fposts%2F4fc3338f.html</url>
    <content type="text"><![CDATA[我们在 Android Studio 3.5 中引入了许多质量变更，请参阅《Android Studio 3.5 Beta 现已发布》或者 Android Studio 版本说明，查看完整版变更列表。当然，您也可以先阅读一下这篇文章或收看下方视频，快速了解一下其中的若干重要变更: 腾讯视频链接: v.qq.com/x/page/w091… Bilibili 视频链接: www.bilibili.com/video/av657… 系统健康Project Marble 计划中系统健康方面的改进包括: 内存性能、输入与用户界面冻结、构建速度、CPU 使用以及 I/O 性能。我们针对这五点分别设计了新的监测机制，以便在开发过程中更准确地识别问题，此外，流程上的优化也让团队得以更好地分析用户反馈，从开发者自愿分享的统计数据和错误报告中获取更多洞见。 尽管系统健康的许多优化项可能并不为大家所熟知，不过其中还是有几个比较明显的变更，其中包括: 自动推荐内存设置 在 Android Studio 3.5 中，IDE 会识别出一个应用项目在 RAM 容量更高的机器上何时需要更多的 RAM，并在通知开发者增加内存堆大小；或者您也可以在 Appearance &amp; Behavior → Memory Settings 下自行调整设置。 用户界面冻结 在 Project Marble 计划开发期间，我们在产品分析数据中发现 IDE 中的 XML 代码编辑速度明显较慢。我们基于这个数据点优化了 XML 输入，使得 Android Studio 3.5 的性能表现有了极大的提升。从以下两张图中您可以发现，得益于输入延迟的改进，使用 XML 编辑数据绑定表达式的速度明显加快了。 改进前: 在 Android Studio 3.4 中编辑代码 改进后: 在 Android Studio 3.5 中编辑代码 构建速度 为了提高 Android Studio 3.5 的构建速度，我们采取了许多措施，其中最为重要的一项变更是为顶级注释处理器添加增量构建支持，这些处理器包括 Glide、AndroidX data binding、Dagger、Realm 和 Kotlin (KAPT)。增量支持能够显著提高构建速度。更多内容，请阅读《在 Android Studio 中加快构建速度》。 磁盘 I/O 文件访问速度 Android Studio 的许多用户都在使用微软旗下的 Windows 系统。我们发现与其他平台相比，Windows 的磁盘 I/O 文件访问耗时明显更久。深度分析数据后，我们发现在一些杀毒程序在默认设置下，并未将 Android Studio 的构建输出文件夹 (build output folder) 排除在扫描范围之外。在 Android Studio 3.5 中，一旦系统监测到这个情况，Studio 将通过弹窗引导您进行最优设置。 特性优化除改善系统健康之外，我们还重新检查了一些关键用户流程， 修复了一些错误以及若干导致不良用户体验的问题，涉及领域包括: 数据绑定、布局、Chrome OS 支持和项目升级，而应用部署流则是其中较为关键的一项改进。 Apply Changes 在 Project Marble 计划期间，我们移除了 Instant Run，然后在 Android Studio 3.5 中重新构建并实现了一个更加实用的替代方案，即 Apply Changes。Apply Changes 使用 Android Oreo 及以上版本中的平台特定 API 来确保可靠且一致的系统行为。与 Instant Run 的机制不同，更改系统配置并不会重写您的 APK 文件。为了支持此项变更，我们重构了整个部署管道，以此提升部署速度；与此同时，我们还微调了工具栏中的运行与部署按钮，希望借此为您提供更为精简的开发体验。 总结一下，Android Studio 3.5 共修复几百个错误，并针对以下核心领域引入了若干关键变更: 系统健康 内存设置 内存使用报告 减少异常 用户界面冻结 构建速度 IDE 速度 Lint 代码分析 I/O 文件访问 模拟器 CPU 使用 特性优化 Apply Changes Gradle 同步 项目更新 布局编辑器 数据绑定 应用部署 C++ 改进 Intellij 2019 平台升级 动态特性支持之条件交付 模拟器对可折叠设备及 Google Pixel 设备的支持 Chrome OS 支持 更多内容，请参阅 Android Studio 版本说明，或阅读下列与 Project Marble 计划相关的深度学习专栏或收看 Google I/O 专题分享会: Project Marble 计划: Apply Changes： medium.com/androiddeve… 在 Android Studio 中加快构建速度： medium.com/androiddeve… Android 模拟器: Project Marble 计划改进项： medium.com/androiddeve… Android Studio Project Marble 计划: Lint 性能： medium.com/androiddeve… Android Studio Project Marble 计划: 布局编辑器： medium.com/androiddeve… Google I/O: Marble 计划 — Android 开发工具有哪些更新? www.youtube.com/watch?v=8rf… 自愿数据分享与反馈我们基于开发者提交的反馈与指标数据，判断 Android Studio 中有哪些内容适用于 Project Marble 计划，并决定具体的优化项目和实现手段。开发者可自愿在 Android Studio 内勾选数据分享，收集上来的数据将帮助团队判定产品是否含有波及全体用户的问题，接着在此基础上，调整功能开发工作的顺序，优先解决最令用户头疼的问题。为了获取最优洞见，我们在产品整合了多种不同的反馈渠道，指标数据分享是其中最基本的一款反馈工具，您可通过以下路径在 Android Studio 中启用该功能 Preferences /Settings → Appearance &amp; Behavior → Data Sharing。 不知道您今年是否留意到 IDE 右下角的用户心情标志。Android Studio 通过这个小小的心情标志，了解用户的使用感受，并获取与实际用例相关的反馈。这是用户向团队提交错误报告最快的途径。 即刻体验下载 请前往下载页面，获取 Android Studio 3.5。如果您当前正在使用旧版本的 Android Studio，请直接进行升级操作即可。 如需使用上述 Android 模拟器特性，请确保您正在运行通过 Android Studio SDK 管理器下载的 Android 模拟器 v29.1.9 或更高版本。 非常感谢大家继续踊跃反馈，与我们分享您的所感所想，建议与意见，或者任何您期望看到的新特性。如果您遇到任何错误或问题，请提交错误报告，或在评论区留言。 点击这里提交产品反馈建议]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在浏览器输入URL回车之后发生了什么]]></title>
    <url>%2Fposts%2Fd674143a.html</url>
    <content type="text"><![CDATA[前言这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。 这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅. 注意：本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。 大致流程 URL 解析 DNS 查询 TCP 连接 处理请求 接受响应 渲染页面 URL 解析地址解析：首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。 HSTS由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：你所不知道的 HSTS[1]。 其他操作浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。 检查缓存 DNS 查询基本步骤 1. 浏览器缓存浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。 2. 操作系统缓存操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。 3. 路由器缓存路由器也有自己的缓存。 4. ISP DNS 缓存ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。 根域名服务器查询在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程： 根域名服务器（维基百科） 需要注意的点 递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程） 迭代方式，就是本地DNS服务器到根域名服务器查询的方式。 什么是 DNS 劫持 前端 dns-prefetch 优化 TCP 连接TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装： 1. 应用层：发送 HTTP 请求在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括： 请求报头（Request Header）：请求方法、目标地址、遵循的协议等等 请求主体（其他参数） 其中需要注意的点： 浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法 2. 传输层：TCP 传输报文传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。 在建立连接前，会先进行 TCP 三次握手。 “ 关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。 相关知识点： SYN 泛洪攻击 ” 3. 网络层：IP协议查询Mac地址将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。 判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。 “ 注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。 ” 4. 链路层：以太网协议以太网协议 根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分： 标头：数据包的发送者、接受者、数据类型 数据：数据包具体内容 Mac 地址 以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。 广播 发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。 注意：接收方回应是单播。 “ 相关知识点： ARP 攻击 ” 服务器接受请求接受过程就是把以上步骤逆转过来，参见上图。 服务器处理请求大致流程 HTTPD最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。 它会监听得到的请求，然后开启一个子进程去处理这个请求。 处理请求接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证： 验证是否配置虚拟主机 验证虚拟主机是否接受此方法 验证该用户可以使用该方法（根据 IP 地址、身份信息等） 重定向假如服务器配置了 HTTP 重定向，就会返回一个 301永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。 “ 关于更多：详见这篇文章[2] ” URL 重写然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。 否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。 然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。 以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。 浏览器接受响应浏览器接收到来自服务器的响应资源后，会对资源进行分析。 首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。 如果响应资源进行了压缩（比如 gzip），还需要进行解压。 然后，对响应资源做缓存。 接下来，根据响应资源里的 MIME[3] 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。 浏览器内核 不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。 基本流程 6.1. HTML 解析首先要知道浏览器解析是从上往下一行一行地解析的。 解析的过程可以分为四个步骤： ① 解码（encoding） 传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。 ② 预解析（pre-parsing） 预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如img标签的src属性，并将这个请求加到请求队列中。 ③ 符号化（Tokenization） 符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。 它通过一个状态机去识别符号的状态，比如遇到&lt;，&gt;状态都会产生变化。 ④ 构建树（tree construction） “ 注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。 ” 在上一步符号化中，解析器获得这些标记，然后以合适的方法创建DOM对象并把这些符号插入到DOM对象中。 1&lt;html&gt;&lt;head&gt; &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Web page parsing&lt;/h1&gt; &lt;p&gt;This is an example Web page.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浏览器容错进制 你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。 事件 当整个解析的过程完成以后，浏览器会通过DOMContentLoaded事件来通知DOM解析完成。 6.2. CSS 解析一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范[4]解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。 CSS 匹配规则 在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px }会先寻找所有的p标签然后判断它的父元素是否为div。 所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。 6.3. 渲染树其实这就是一个 DOM 树和 CSS 规则树合并的过程。 “ 注意：渲染树会忽略那些不需要渲染的节点，比如设置了display:none的节点。 ” 计算 通过计算让任何尺寸值都减少到三个可能之一：auto、百分比、px，比如把rem转化为px。 级联 浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做specificity的公式，这个公式会通过： 标签名、class、id 是否内联样式 !important 然后得出一个权重值，取最高的那个。 渲染阻塞 当遇到一个script标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。 但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。 所有我们知道： CSS 会阻塞 JS 执行 JS 会阻塞后面的 DOM 解析 为了避免这种情况，应该以下原则： CSS 资源排在 JavaScript 资源前面 JS 放在 HTML 最底部，也就是 &lt;/body&gt;前 另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：这篇文章[5] 6.4. 布局与绘制确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。 然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。 6.5. 合并渲染层把以上绘制的所有图片合并，最终输出一张图片。 6.6. 回流与重绘回流(reflow) 当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。 reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。 重绘(repaint) 改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。 每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。 回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。 比如： display:none 会触发回流，而 visibility:hidden 只会触发重绘。 6.7. JavaScript 编译执行大致流程 可以分为三个阶段： 1. 词法分析JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。 几个步骤： 分词，例如将var a = 2，，分成var、a、=、2这样的词法单元。 解析，将词法单元转换成抽象语法树（AST）。 代码生成，将抽象语法树转换成机器指令。 2. 预编译JS 有三种运行环境： 全局环境 函数环境 eval 每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。 创建执行上下文 创建执行上下文的过程中，主要做了以下三件事： 创建变量对象 参数、函数、变量 建立作用域链 确认当前执行环境是否能访问变量 确定 This 指向 3. 执行JS 线程 虽然 JS 是单线程的，但实际上参与工作的线程一共有四个： “ 其中三个只是协助，只有 JS 引擎线程是真正执行的 ” JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎 事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行 定时器触发线程：主要控制setInterval和setTimeout，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。 HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。 注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。 宏任务 分为： 同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务 异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。 微任务 微任务是ES6和Node环境下的，主要 API 有：Promise，process.nextTick。 微任务的执行在宏任务的同步任务之后，在异步任务之前。 代码例子 1234console.log(&apos;1&apos;); // 宏任务 同步setTimeout(function() &#123; console.log(&apos;2&apos;); // 宏任务 异步&#125;)new Promise(function(resolve) &#123; console.log(&apos;3&apos;); // 宏任务 同步 resolve();&#125;).then(function() &#123; console.log(&apos;4&apos;) // 微任务&#125;)console.log(&apos;5&apos;) // 宏任务 同步 以上代码输出顺序为：1,3,5,4,2 参考文档 [1] 你所不知道的 HSTS: http://t.cn/AiR8pTqx [2] 详见这篇文章: http://t.cn/AiR8pnEC [3] MIME: http://t.cn/AiR8prtm [4] 语法规范: http://t.cn/AiR80GdO [5] 这篇文章: http://t.cn/AiR80c1k [6] what-happens-when-zh_CN: http://t.cn/AiR80xb5 [7] Tags to DOM:http://t.cn/AiR80djX [8] 彻底理解浏览器的缓存机制: http://t.cn/AiR8Ovob [9] 浏览器的工作原理：新式网络浏览器幕后揭秘: http://t.cn/AiR8Oz06 [10] 深入浅出浏览器渲染原理: http://t.cn/AiR8O4fO [11] js引擎的执行过程（一）:http://t.cn/AiR8Ot3s]]></content>
      <categories>
        <category>前端</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google终于发布了Android 10正式版]]></title>
    <url>%2Fposts%2F3609d6c4.html</url>
    <content type="text"><![CDATA[前言9月4号凌晨，Google终于发布了Android 10正式版！ 全新的Logo，依然沿用经典机器人，但在图标，颜色及细节上都有明显变动。新的设计是为了更加现代，更加易用。特别是文字从绿色改为了黑色，这样的变更对视觉障碍者更加友好。 除了Logo的变化，新版Android系统的命名也有重大变动。现有的命名规则是安装英文字母顺序依次选区甜品或零食来命名。如果从09年的Cupcake算起，不算08年开始的alpha和beat测试版，到现在已经用了10年。 在新的版本中将打破甜品，零食的命名规则，可能改为Android 10。David表示：“改变命名是为了避免全球不同地区的误解，某些语言里L和R是没有区分的。另外有些地方馅饼也不是甜点，棉花糖虽然味道不错，但是在世界上有很多地区是不受欢迎的食物。” 1. 创新体验本次Android 10带来了全新的用户体验，包括： 暗黑主题 智能回复 5G网络支持 可折叠 1.1 暗黑主题对于用户来说（特别是低视力 &amp; 强光敏感），可提高屏幕内容可见度 &amp; 保护性。 1.2 智能回复 使用机器学习来预测你在回复信息时可能会说些什么，从而提供对信息的回复建议 &amp; 建议操作 如朋友约吃饭，Google会建议你发送回应短信 &amp; 在 Google 地图中直接显示位置信息 注：本在 Android P 中已提供，但仅限于谷歌专用的应用程序；本次Android 10 中，已内置到整个通知系统中。 1.3 5G网络针对之前已公布的5G网络，Android 10增加了对5G网络通信支持（提供了检测连接性的API），从而使得用户可以获得更加快速的网络冲凉体验。 1.4 可折叠支持针对应用程序窗口的多任务处理，Android 10增加了对可折叠屏的支持：设备折叠 / 展开时提供屏幕连续性来维护应用程序状态，通过优化可折叠设备，为当今的创新设备提供无缝体验。 2. 隐私保护近年来，Google对于用户的隐私保护十分看重。Android 10更新中，对于隐私保护也是核心关注点，主要包括以下： 3. 安全加强由于Android碎片化，系统的安全性一直被诟病。在Android 10中，引入了更多的确定用户安全的特性，具体如下： 4. 系统优化主要包括ART优化 &amp; 神经网络升级 4.1 ART优化ART运行时的改进可以帮助您的应用程序启动得更快、消耗更少的内存、运行得更流畅。Google对ART进行了优化： 在运行前，就预先编译应用程序的部分 在运行时，分代垃圾收集使垃圾收集在时间 &amp; CPU方面更高效，减少jank，并帮助应用程序在低端设备上更好地运行。 以下是优化对比： 4.2 神经网络升级 增加了大量在神经网络方面的新操作，包括ARGMAX、ARGMIN、量化LSTM &amp; 一系列性能优化 这使得加速更大范围的模型奠定了基础，比如用于目标检测和图像分割的模型 正在与硬件供应商和流行的机器学习框架（如TensorFlow）合作，优化和推出对NNAPI 1.2的支持 关于更新推送 Google首先面向自身的Pixel系列设备推送 对于国内，小米成为国内第一家提供Android 10更新的公司 - 其旗下的Redmi K20 Pro 首批接收到了基于 Android 10 的 MIUI 更新 最后 每次Anroid新版本的到来，就意味着我们要进行适配。 回顾历史版本让我们一起回忆这10年来陪伴我们的Android点心。这是每个Android 开发者的青春。 Cupcake 1.5 （纸杯蛋糕）– 2009年4月 Donut 1.6（甜甜圈）– 2009年9月 Eclair 2.0-1（泡芙）– 2009年10月26日 Froyo 2.2（冻酸奶）– 2010年5月 Gingerbread 2.3（姜饼）– 2010年12月 Honeycomb 3.0-2（蜂巢）– 2011年2月2日 Ice Cream Sandwich 4.0（冰淇淋三明治）– 2011年10月19日 Jelly Bean 4.1-3（果冻豆）– 2012年6月28日 KitKat 4.4（日本巧克力品牌）– 2013年11月01日 Lollipop 5.0-1（棒棒糖）– 2014年10月15日 Marshmallow 6.0（棉花糖）– 2015年9月30日 Nougat 7.0-1（牛轧糖）– 2016年8月22日 Oreo 8.0-1（奥利奥）– 2017 年 8 月 22 日 Pie 9.0（果馅派）– 2018 年 5月 9日]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>Android版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅解决Android软键盘弹出时把布局顶上去]]></title>
    <url>%2Fposts%2Ff2eb3913.html</url>
    <content type="text"><![CDATA[解决方法方法一：在你的activity中的oncreate中setContentView之前写上这个代码 1getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); 方法二：在项目的AndroidManifest.xml文件中界面对应的里加入android:windowSoftInputMode=”stateVisible|adjustResize”，这样会让屏幕整体上移。如果加上的是android:windowSoftInputMode=”adjustPan”这样键盘就会覆盖屏幕。 方法三：把顶级的layout替换成ScrollView，或者说在顶级的Layout上面再加一层ScrollView的封装。这样就会把软键盘和输入框一起滚动了，软键盘会一直处于底部。 主窗口与软键盘窗口交互设置值如下： 将覆盖在主题中设置的值 值描述 “stateUnspecified” 软键盘的状态(是否它是隐藏或可见)没有被指定。系统将选择一个合适的状态或依赖于主题的设置。这个是为了软件盘行为默认的设置。 “stateUnchanged” 软键盘被保持无论它上次是什么状态，是否可见或隐藏，当主窗口出现在前面时。 “stateHidden” 当用户选择该Activity时，软键盘被隐藏——也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。 “stateAlwaysHidden” 软键盘总是被隐藏的，当该Activity主窗口获取焦点时。 “stateVisible” 软键盘是可见的，当那个是正常合适的时(当用户导航到Activity主窗口时)。 “stateAlwaysVisible” 当用户选择这个Activity时，软键盘是可见的——也就是，也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。 “adjustUnspecified” 它不被指定是否该 Activity主窗口调整大小以便留出软键盘的空间，或是否窗口上的内容得到屏幕上当前的焦点是可见的。系统将自动选择这些模式中一种主要依赖于是否窗口的内容有任何布局视图能够滚动他们的内容。如果有这样的一个视图，这个窗口将调整大小，这样的假设可以使滚动窗口的内容在一个较小的区域中可见的。这个是主窗口默认的行为设置。 “adjustResize” 该Activity主窗口总是被调整屏幕的大小以便留出软键盘的空间 “adjustPan” 该Activity主窗口并不调整屏幕的大小以便留出软键盘的空间。相反，当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分。这个通常是不期望比调整大小，因为用户可能关闭软键盘以便获得与被覆盖内容的交互操作。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>软键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android APK 安装的原理]]></title>
    <url>%2Fposts%2F2da5bed1.html</url>
    <content type="text"><![CDATA[前言大家有没有想过一个应用的APK是怎么被安装到安卓手机上的，安装的本质是什么？我们知道，Windows应用程序的安装包是一个可执行的压缩包，安装的过程是把压缩包中的数据和依赖库拷贝到安装目录，再在桌面或启动栏创建快捷方式，那么安卓的APK安装过程是不是也是这样的呢？本文将为大家解答这些问题。 APK包的构成首先，我看一下APK包的构成，Android的APK包和Windows应用程序安装包是不同的，它只是个简单的压缩包，没有可执行的能力，我们还可以用zip工具直接解压它。 一个APK包含以下这些文件： META-INF目录：包含两个签名文件（CERT.SF和CERT.RSA），以及一个manifest文件（MANIFEST.MF） assets目录：包含工程中的asset目录下的文件，可以使用AssetManager获取 res目录：包含那些没有被编译到resources.arsc的资源 lib目录：包含适用于不同处理器的第三方依赖库，这里边可以有多个子目录，比如armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, 以及mips resources.arsc文件：存储编译好的资源，包括项目工程中的res/values目录里的xml文件，它们都被编译成二进制格式，也包括一些路径，指向那些没有被编译的资源，比如layout文件和图片 classes.dex文件：项目中的java类都被编译到该dex文件，这个文件可以被Android的Dalvik/ART虚拟机解析。 AndroidManifest.xml：二进制格式的manifest文件，这个文件是必须的。 这些文件是Android系统运行一个应用程序时会用到的数据和代码，下面介绍系统如何安装一个APK包。 安装APK我们安装应用程序，最常用的方法就是在PC上运行命令adb install 加APK的文件路径，回车等待Android设备安装完成，安装成功命令行会显示Success。那么其内部是怎样的一个过程呢？ 1. 将APK包push到手机首先，adb会将PC端的APK文件push到Android设备的/data/local/tmp目录下，一些手机会将拷贝的进度反馈给adb客户端，于是PC上的命令行会展示拷贝的进度。 2. 执行pm命令PC端的adb程序会向Android端的adbd发送shell:pm命令，于是adbd会向系统的PackageManagerService（PMS）进程发送消息，通知其安装apk包。这里我有两个理解：理解一：我们平常也可以在adb shell上执行pm命令与PMS交互，那么pm应该是个独立的进程，adbd执行pm命令，是启动了pm这个进程，这个进程再向PMS进程发送消息，通知其安装APK。理解二：adbd直接向PMS进程发送消息，通知其安装APK。不知哪个正确，这个有待继续研究，如果有童鞋了解这个，希望能不吝赐教。 3. 触发安装过程PMS首先将APK包拷贝到另外一个目录/data/app，这个目录是非系统应用的apk存放的目录，与之相对应的，系统应用的apk存放的目录是/system/frameworks、/system/app和/vendor/app。PMS内部有个AppDirObserver类，其监听着/data/app目录的变化，当apk被复制到/data/app目录之后，该类随即触发PMS对APK进行解析。 4. APK的解析我们可以先想想，Android系统是如何启动一个APP的？比如点击屏幕上的应用图标，然后一个Activity就被启动了。这个过程中，桌面程序Launcher先是向ActivityManagerService（AMS）进程发送了一个Intent，AMS随即会将这个Intent扔给PMS，PMS则解析这个Intent得到Activity的信息给到AMS，然后AMS会启动一个空进程，并通知该进程创建该Activity。那么PMS为什么会有这个Activity的信息呢？ 这就是PMS解析APK要做的事情了，而解析APK的时机又要分成两种场景： 1. 系统启动时解析APKAndroid系统在启动的时候，会启动一个system_server进程，这个进程驻留着系统多个重要的服务，其中便包含了与APK最相关的PackageManagerService服务，这个服务在启动的时候，会扫描Android系统中几个目标文件夹中的APK，对每个APK进行解析。 2. 安装过程中解析APK安装一个apk的过程，PMS也会对这个APK进行解析，其调用的是PackageManagerService.java的scanPackageLI()方法，其实在系统启动时扫描全部apk的过程也是调用该方法。 可以这样理解，系统启动的时候，是解析已经安装的所有APK，而安装单个APK时，则是用同样的方法解析这个APK，过程是一样的。 那么解析APK具体做的是什么事情呢？ 其中主要的过程就是解析APK中的AndroidManifest.xml文件，将APK的关键信息四大组件信息、权限信息等存储在内存中的PackageParser对象中，PackageParser对象的结构如图所示： 这个PackageParser包含了IntentFilter的信息，使得PMS可以根据Intent来获取一个Activity的信息。那么，PMS在得到PackageParser对象之后，接着会将这个APK的信息加入到PMS自身管理中去，比如将Activity的数据保存在mActivities对象中，将Provider的数据保存在mProviders对象中等，PKMS提供了好几个重要数据结构来保存这些数据，这些数据结构的相关信息如图所示： 除了解析和保存APK的核心数据，PMS还会创建应用程序目录：/data/data/包名，同时提取apk中的dex文件并保存到/data/dalvik-cache中，如果该APK包含了native动态库，则需要将它们从APK文件中解压并复制到对应目录中，以及对APK进行dex优化，还有其它一些细节比如APK签名的校验，杀死APK所在进程（覆盖安装的情况）等，安装过程的最后，会发送ACTION_PACKAGE_ADDED广播，通知所有其它应用有新应用安装了。 总结至此，APK安装过程就结束了。纵观整个过程，apk安装的关键就是解析AndroidManifest.xml，将重要的信息保存在PMS进程的内存中，以保证后续启动这个应用程序的组件时，可以在PMS中找到这个组件的信息。我们本来认为的更重要的代码只是进行dex优化后简单地提取到一个目录中而已，另外，APK中的资源并没有被处理，而是在启动应用进程的时候，动态去从APK包中加载而已。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>Android版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代码lint常见报错处理]]></title>
    <url>%2Fposts%2Fdb4fcd4.html</url>
    <content type="text"><![CDATA[最近一周做了一些关于Android静态代码检测的东西，对于一些常见的lint警告做了记录,其实对于常见的lint警告我们得处理步骤可以分为如下： 查看lint报错的错误类型 追踪到代码处，确定是否代码自身问题 分析该类错误影响范围 确定解决方式(规范代码、添加注解、添加规则) 规范代码一般是由于开发者在开发时，不细心造成误写等，或者是某些API过时，需要进行手动修改。 添加注解对于某些特殊需求，可以通过加注解来避免lint报错,以下给出常见的添加注解的地方 java源代码123@SuppressLint("xxxx") // xxxx代表某种lint检测类型public void test()&#123;&#125; xml首先添加命名空间 1namespace xmlns:tools="http://schemas.android.com/tools" 然后在报错地方添加 12&lt;!--xxxx代表某种lint检测类型,或者可以是直接all,禁止掉所有检测类型--&gt;tools:ignore="xxxx" 添加规则(lint.xml文件)对于某些大规模类型的，或者是知道自己必须这么干时，就可以添加规则来规避某种类型的所有lint报错或者是指定路径，亦或者是通过正则指定。 添加规则格式为： 规避一种类型 12&lt;!--xxxx代表某种lint检测类型--&gt;&lt;issue id="xxxx" severity="ignore"/&gt; 指定路径 1234567 &lt;!--xxxx代表某种lint检测类型--&gt; &lt;!--****代表指定路径或者是文件--&gt; &lt;!--####通过正则来指定相关文件或者属性等--&gt;&lt;issue id="xxxx"&gt; &lt;ignore path="****"/&gt; &lt;ignore regexp="####"/&gt;&lt;/issue&gt; 改变lint检测类型 123 &lt;!--xxxx代表某种lint检测类型--&gt; &lt;!--severity有不同种程度的类型 Fatal、Error 、Warning 、Information 、Ignore--&gt;&lt;issue id="xxxx" severity="ignore"/&gt; 接下来记录下我见到和处理的一些报错类型 1. Missing commit() on SharedPreference editor缺少commit()方法调用，添加即可;但是你或许会遇到下面这个问题,它依然会lint检测报错： 123456789public void test()&#123; SharedPreferencesUtils.apply(dataStore.edit() .putString(xxx, xxx));&#125;...public static void apply(SharedPreferences.Editor editor) &#123; editor.apply();&#125; 如果是这样的话，建议到指定方法调用处添加注解 @SuppressLint(“CommitPrefEdits”) 2. Use apply() on SharedPreferences建议使用apply()替换commit(),对于两个方法的区别，建议看看这里 3. Mismatched Styleable/Custom View Name建议在自定义View的时候，尽量保证View名称与&lt;declare-styleable 的name一致, 若有特殊需求需要对指定进行添加注解. @SuppressLint(“CustomViewStyleable”) 若存在特殊需求，则更建议在lint.xml中添加规则: 4. Duplicate ids across layouts combined with include tags在布局中，通过进来的layout，存在和父布局中相同id的view，修改建议，修改布局中id命名. 5. Using android.media.ExifInterfaceAvoid using android.media.ExifInterface;use android.support.media.ExifInterface from the support library instead. 使用support包相关替换 6. Hardcoded reference to /sdcardDo not hardcode “/data/“; use Context.getFilesDir().getPath() instead lint 给出的修改建议是使用Context.getFilesDir().getPath() 替换直接通过路径拼接，但是根据场景可以自变吧；若不想通过这种方式可以直接忽略，添加注解 类似错误场景： 1234public class DbCopyHelper &#123;public static final String DB_PATH = "/data/data/" + BuildConfig.APPLICATION_ID + "/databases/";public static void copy(Context context, String dbName, boolean force) throws Exception &#123; File dir = new File(DB_PATH); @SuppressLint(“ SdCardPath”) 若存在特殊需求，则更建议在lint.xml中添加规则: 7. Attribute unused on older versions建议添加规则 1234&lt;!--xxxx代表某个属性--&gt;&lt;issue id="UnusedAttribute"&gt; &lt;ignore regexp=".*xxxxx.*"/&gt;&lt;/issue&gt; 8. Appcompat Custom WidgetsThis custom view should extend android.support.v7.widget.AppCompatTextView instead 建议: 1234添加规则&lt;issue id="AppCompatCustomView" severity="ignore"/&gt;或者是添加注解@SuppressLint(“AppCompatCustomView”) 9. Restricted APIxxx can only be called from within the same library group 方法只能在同一个library group中调用 添加注解: @SuppressLint(“RestrictedApi”) 或者是规则 10. Invalid format string在进行字符串格式化处理的时候，需要注意formatted=“false” 的影响 直接添加： 12&lt;!--忽略string的format--&gt;&lt;issue id="StringFormatInvalid" severity="ignore"/&gt; 对于formatted=“false”的理解,在进行string.xml编写的时候，注意内容的占位符号，如果大于等于2个占位符的时候，建议使用formatted=“false”，或者使用正则方式%n$m。 11. Insecure HostnameVerifier123456HostnameVerifier hnv = new HostnameVerifier() &#123; @Override public boolean verify(String hostname, SSLSession session) &#123; return true; &#125;&#125;; 场景是直接均返回true，被认为是不安全的操作，若知道自己在干什么，可以直接添加注解 @SuppressLint(“AllowAllHostnameVerifier”) 或者添加规则 12&lt;!--忽略业务中总是返回true--&gt;&lt;issue id="BadHostnameVerifier" severity="ignore"/&gt; 12. Insecure TLS/SSL trust manager12345@Overridepublic void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; 建议添加规则 12&lt;!--忽略信任X509TrustManager带来的危险--&gt;&lt;issue id="TrustAllX509TrustManager" severity="ignore"/&gt; 13. Obsolete layout paramsInvalid layout param in a LinearLayout: layout_centerInParent 建议开发中，对布局的使用注意可用性，在参考代码的时候，注意删除修改后不可用的属性 14. Static Field Leaks注意在书写单例的时候，避免使用局部context.均转换为全局上下文 15. Node can be replaced by a TextView with compound drawables这个警告的产生，主要是在一个线性布局中存在一个textView和一个ImageView，认为一个textView可以实现类似的功能，而不用添加多余的嵌套和View； 但是对于特定的需求，不能保证能实现想要的效果，因此建议添加规则忽略： 12&lt;!--忽略对linearlayout(包含TextView和ImageView)使用的误报--&gt;&lt;issue id="UseCompoundDrawables" severity="ignore"/&gt; 16. View Holder CandidatesUnconditional layout inflation from view adapter: Should use View Holder pattern (use recycled view passed into this method as the second parameter) for smoother scrolling 建议使用ViewHolder 17. Missing baselineAligned attribute缺少baselineAligned这个属性，建议看看这里，这个警告可以根据需求自行添加属性与否，或者是添加规则和注解： 12&lt;!--忽略建议 Set android:baselineAligned="false"--&gt;&lt;issue id="DisableBaselineAlignment" severity="ignore"/&gt; 18. Inefficient layout weight在使用layout weight属性的时候，应保持相应属性为0dp;或者是在copy代码的时候忘记删除layout_weight代码导致lint检测报错 19. Nested layout weights在布局进行嵌套使用时，父布局与子布局都使用了android:layout_weight，根据需求进行修改; 20. Useless parent layout警告有未使用的父布局，或者是无用的父布局。 根据实际需求进行忽略或者是删除相应布局 21. Unused namespace命名空间重复添加，或者是删除对应属性后，命名空间未删除，删除. 22. Hyphen can be replaced with dashReplace “-“ with an “en dash” character (–, –) 为了符合人性化的开发，建议直接添加规则忽略 23. H Ellipsis string can be replaced with ellipsis character处理同上 24. Duplicated icons under different names存在不同命名的同文件的icons 目前的处理是添加规则忽略 25. Missing accessibility label对EditTextView的使用，建议添加一个它的标签View 根据需要进行忽略 或者添加android:labelfor 26. Keyboard inaccessible widget一个控件（比如图片），如果没有定义focusable(可聚焦的)，却定义了是clickable（可点击的），那么是不能通过键盘访问的。所以，需要添加一个focusable=“true”;相当于指定可获取焦点. 27. Usage of showAsAction=always建议使用”ifRoom”替换”always” 根据需求进行修改或者忽略 28. Missing inputTypeThis text field does not specify an inputType 建议为EditText指定inputType属性 29. Overdraw: Painting regions more than oncePossible overdraw: Root element paints background @color/actionbar_color with a theme that also paints a background (inferred theme is @style/ActionTheme_NoTitle) 存在过度绘制的可能性 但是这个报警有点牵强，所以还是先添加规则给过滤吧 30. Hardware Id Usage获取设备相关信息，可以查看官方API,使用其替换方法 31. Incompatible Gradle Versions不兼容依赖版本库，可通过打依赖树，进行查找 贴出常见的lint issueid和秒速，以供对照123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330"ContentDescription": Image without contentDescription"AddJavascriptInterface": addJavascriptInterface Called"ShortAlarm": Short or Frequent Alarm"AllCaps": Combining textAllCaps and markup"AllowAllHostnameVerifier": Insecure HostnameVerifier"AlwaysShowAction": Usage of showAsAction=always"InvalidUsesTagAttribute": Invalid name attribute for uses element."MissingIntentFilterForMediaSearch": Missing intent-filter with action android.media.action.MEDIA_PLAY_FROM_SEARCH"MissingMediaBrowserServiceIntentFilter": Missing intent-filter with action android.media.browse.MediaBrowserService."MissingOnPlayFromSearch": Missing onPlayFromSearch."ImpliedTouchscreenHardware": Hardware feature touchscreen not explicitly marked as optional"MissingTvBanner": TV Missing Banner"MissingLeanbackLauncher": Missing Leanback Launcher Intent Filter."MissingLeanbackSupport": Missing Leanback Support."PermissionImpliesUnsupportedHardware": Permission Implies Unsupported Hardware"UnsupportedTvHardware": Unsupported TV Hardware Feature"SupportAnnotationUsage": Incorrect support annotation usage"ShiftFlags": Dangerous Flag Constant Declaration"LocalSuppress": @SuppressLint on invalid element"SwitchIntDef": Missing @IntDef in Switch"UniqueConstants": Overlapping Enumeration Constants"InlinedApi": Using inlined constants on older versions"Override": Method conflicts with new inherited method"ObsoleteSdkInt": Obsolete SDK_INT Version Check"NewApi": Calling new methods on older versions"UnusedAttribute": Attribute unused on older versions"AppCompatMethod": Using Wrong AppCompat Method"AppCompatCustomView": Appcompat Custom Widgets"AppCompatResource": Menu namespace"GoogleAppIndexingApiWarning": Missing support for Firebase App Indexing Api"GoogleAppIndexingWarning": Missing support for Firebase App Indexing"AppLinksAutoVerifyError": App Links Auto Verification Failure"AppLinksAutoVerifyWarning": Potential App Links Auto Verification Failure"AppLinkUrlError": URL not supported by app for Firebase App Indexing"TestAppLink": Unmatched URLs"InconsistentArrays": Inconsistencies in array element counts"Assert": Assertions"BadHostnameVerifier": Insecure HostnameVerifier"BatteryLife": Battery Life Issues"BackButton": Back button"ButtonCase": Cancel/OK dialog button capitalization"ButtonOrder": Button order"ButtonStyle": Button should be borderless"ByteOrderMark": Byte order mark inside files"MissingSuperCall": Missing Super Call"AdapterViewChildren": AdapterViews cannot have children in XML"ScrollViewCount": ScrollViews can have only one child"PermissionImpliesUnsupportedChromeOsHardware": Permission Implies Unsupported Chrome OS Hardware"UnsupportedChromeOsHardware": Unsupported Chrome OS Hardware Feature"GetInstance": Cipher.getInstance with ECB"CommitTransaction": Missing commit() calls"Recycle": Missing recycle() calls"CommitPrefEdits": Missing commit() on SharedPreference editor"ApplySharedPref": Use apply() on SharedPreferences"ClickableViewAccessibility": Accessibility in Custom Views"EasterEgg": Code contains easter egg"StopShip": Code contains STOPSHIP marker"MissingConstraints": Missing Constraints in ConstraintLayout"VulnerableCordovaVersion": Vulnerable Cordova Version"CustomViewStyleable": Mismatched Styleable/Custom View Name"CutPasteId": Likely cut &amp; paste mistakes"SimpleDateFormat": Implied locale in date format"SetTextI18n": TextView Internationalization"Deprecated": Using deprecated resources"MissingPrefix": Missing Android XML namespace"MangledCRLF": Mangled file line endings"DuplicateIncludedIds": Duplicate ids across layouts combined with include tags"DuplicateIds": Duplicate ids within a single layout"DuplicateDefinition": Duplicate definitions of resources"ReferenceType": Incorrect reference types"StringEscaping": Invalid string escapes"UnpackedNativeCode": Missing android:extractNativeLibs=false"UnsafeDynamicallyLoadedCode": load used to dynamically load code"UnsafeNativeCodeLocation": Native code outside library directory"EllipsizeMaxLines": Combining Ellipsize and Maxlines"ExifInterface": Using android.media.ExifInterface"ExtraText": Extraneous text in resource files"FieldGetter": Using getter instead of field"InvalidAnalyticsName": Invalid Analytics Name"MissingFirebaseInstanceTokenRefresh": Missing Firebase Instance ID Token Refresh"FontValidationError": Validation of font files"FontValidationWarning": Validation of font files"FullBackupContent": Valid Full Backup Content File"ValidFragment": Fragment not instantiatable"GetContentDescriptionOverride": Overriding getContentDescription() on a View"PackageManagerGetSignatures": Potential Multiple Certificate Exploit"AccidentalOctal": Accidental Octal"UseOfBundledGooglePlayServices": Use of bundled version of Google Play services"GradleCompatible": Incompatible Gradle Versions"GradleDependency": Obsolete Gradle Dependency"GradleDeprecated": Deprecated Gradle Construct"DevModeObsolete": Dev Mode Obsolete"DuplicatePlatformClasses": Duplicate Platform Classes"GradleGetter": Gradle Implicit Getter Call"GradlePluginVersion": Incompatible Android Gradle Plugin"HighAppVersionCode": VersionCode too high"GradleIdeError": Gradle IDE Support Issues"GradlePath": Gradle Path Issues"GradleDynamicVersion": Gradle Dynamic Version"NotInterpolated": Incorrect Interpolation"StringShouldBeInt": String should be int"NewerVersionAvailable": Newer Library Versions Available"MinSdkTooLow": API Version Too Low"GridLayout": GridLayout validation"HandlerLeak": Handler reference leaks"HardcodedDebugMode": Hardcoded value of android:debuggable in the manifest"HardcodedText": Hardcoded text"HardwareIds": Hardware Id Usage"IconDuplicatesConfig": Identical bitmaps across various configurations"IconDuplicates": Duplicated icons under different names"GifUsage": Using .gif format for bitmaps is discouraged"IconColors": Icon colors do not follow the recommended visual style"IconDensities": Icon densities validation"IconDipSize": Icon density-independent size validation"IconExpectedSize": Icon has incorrect size"IconExtension": Icon format does not match the file extension"IconLauncherShape": The launcher icon shape should use a distinct silhouette"IconLocation": Image defined in density-independent drawable folder"IconMissingDensityFolder": Missing density folder"IconMixedNinePatch": Clashing PNG and 9-PNG files"IconNoDpi": Icon appears in both -nodpi and dpi folders"IconXmlAndPng": Icon is specified both as .xml file and as a bitmap"ConvertToWebp": Convert to WebP"WebpUnsupported": WebP Unsupported"IncludeLayoutParam": Ignored layout params on include"DisableBaselineAlignment": Missing baselineAligned attribute"InefficientWeight": Inefficient layout weight"NestedWeights": Nested layout weights"Orientation": Missing explicit orientation"Suspicious0dp": Suspicious 0dp dimension"InstantApps": Instant App Issues"DuplicateDivider": Unnecessary Divider Copy"TrustAllX509TrustManager": Insecure TLS/SSL trust manager"InvalidImeActionId": Invalid imeActionId declaration"InvalidPackage": Package not included in Android"DrawAllocation": Memory allocations within drawing code"UseSparseArrays": HashMap can be replaced with SparseArray"UseValueOf": Should use valueOf instead of new"JavascriptInterface": Missing @JavascriptInterface on methods"JobSchedulerService": JobScheduler problems"KeyboardInaccessibleWidget": Keyboard inaccessible widget"LabelFor": Missing labelFor attribute"InconsistentLayout": Inconsistent Layouts"InflateParams": Layout Inflation without a Parent"StaticFieldLeak": Static Field Leaks"DefaultLocale": Implied default locale in case conversion"LocaleFolder": Wrong locale name"GetLocales": Locale crash"InvalidResourceFolder": Invalid Resource Folder"WrongRegion": Suspicious Language/Region Combination"UseAlpha2": Using 3-letter Codes"LogConditional": Unconditional Logging Calls"LongLogTag": Too Long Log Tags"LogTagMismatch": Mismatched Log Tags"AllowBackup": AllowBackup/FullBackupContent Problems"MissingApplicationIcon": Missing application icon"DeviceAdmin": Malformed Device Admin"DuplicateActivity": Activity registered more than once"DuplicateUsesFeature": Feature declared more than once"GradleOverrides": Value overridden by Gradle build script"IllegalResourceRef": Name and version must be integer or string, not resource"MipmapIcons": Use Mipmap Launcher Icons"MockLocation": Using mock location provider in production"MultipleUsesSdk": Multiple &lt;uses-sdk&gt; elements in the manifest"ManifestOrder": Incorrect order of elements in manifest"MissingVersion": Missing application name/version"OldTargetApi": Target SDK attribute is not targeting latest version"UniquePermission": Permission names are not unique"UsesMinSdkAttributes": Minimum SDK and target SDK attributes not defined"WearableBindListener": Usage of Android Wear BIND_LISTENER is deprecated"WrongManifestParent": Wrong manifest parent"InvalidPermission": Invalid Permission Attribute"ManifestResource": Manifest Resource References"ManifestTypo": Typos in manifest tags"FloatMath": Using FloatMath instead of Math"MergeMarker": Code contains merge marker"MergeRootFrame": FrameLayout can be replaced with &lt;merge&gt; tag"IncompatibleMediaBrowserServiceCompatVersion": Obsolete version of MediaBrowserServiceCompat"InnerclassSeparator": Inner classes should use $ rather than ."Instantiatable": Registered class is not instantiatable"MissingRegistered": Missing registered class"MissingId": Fragments should specify an id or tag"LibraryCustomView": Custom views in libraries should use res-auto-namespace"ResAuto": Hardcoded Package in Namespace"NamespaceTypo": Misspelled namespace declaration"UnusedNamespace": Unused namespace"NegativeMargin": Negative Margins"NestedScrolling": Nested scrolling widgets"NetworkSecurityConfig": Valid Network Security Config File"MissingBackupPin": Missing Backup Pin"PinSetExpiry": Validate &lt;pin-set&gt; expiration attribute"NfcTechWhitespace": Whitespace in NFC tech lists"UnlocalizedSms": SMS phone number missing country code"ObjectAnimatorBinding": Incorrect ObjectAnimator Property"AnimatorKeep": Missing @Keep for Animated Properties"ObsoleteLayoutParam": Obsolete layout params"OnClick": onClick method does not exist"Overdraw": Overdraw: Painting regions more than once"DalvikOverride": Method considered overridden by Dalvik"OverrideAbstract": Not overriding abstract methods on older platforms"ParcelCreator": Missing Parcelable CREATOR field"UnusedQuantity": Unused quantity translations"MissingQuantity": Missing quantity translation"ImpliedQuantity": Implied Quantities"ExportedPreferenceActivity": PreferenceActivity should not be exported"PrivateApi": Using Private APIs"PackagedPrivateKey": Packaged private key"PrivateResource": Using private resources"ProguardSplit": Proguard.cfg file contains generic Android rules"Proguard": Using obsolete ProGuard configuration"PropertyEscape": Incorrect property escapes"UsingHttp": Using HTTP instead of HTTPS"SpUsage": Using dp instead of sp for text sizes"InOrMmUsage": Using mm or in dimensions"PxUsage": Using 'px' dimension"SmallSp": Text size is too small"ParcelClassLoader": Default Parcel Class Loader"PendingBindings": Missing Pending Bindings"RecyclerView": RecyclerView Problems"Registered": Class is not registered in the manifest"RelativeOverlap": Overlapping items in RelativeLayout"RequiredSize": Missing layout_width or layout_height attributes"AaptCrash": Potential AAPT crash"ResourceCycle": Cycle in resource definitions"ResourceName": Resource with Wrong Prefix"ValidRestrictions": Invalid Restrictions Descriptor"RtlCompat": Right-to-left text compatibility issues"RtlEnabled": Using RTL attributes without enabling RTL support"RtlSymmetry": Padding and margin symmetry"RtlHardcoded": Using left/right instead of start/end attributes"ScrollViewSize": ScrollView size validation"SdCardPath": Hardcoded reference to /sdcard"SecureRandom": Using a fixed seed with SecureRandom"TrulyRandom": Weak RNG"ExportedContentProvider": Content provider does not require permission"ExportedReceiver": Receiver does not require permission"ExportedService": Exported service does not require permission"SetWorldReadable": File.setReadable() used to make file world-readable"SetWorldWritable": File.setWritable() used to make file world-writable"GrantAllUris": Content provider shares everything"WorldReadableFiles": openFileOutput() or similar call passing MODE_WORLD_READABLE"WorldWriteableFiles": openFileOutput() or similar call passing MODE_WORLD_WRITEABLE"ServiceCast": Wrong system service casts"WifiManagerLeak": WifiManager Leak"WifiManagerPotentialLeak": WifiManager Potential Leak"SetJavaScriptEnabled": Using setJavaScriptEnabled"SignatureOrSystemPermissions": signatureOrSystem permissions declared"SQLiteString": Using STRING instead of TEXT"SSLCertificateSocketFactoryCreateSocket": Insecure call to SSLCertificateSocketFactory.createSocket()"SSLCertificateSocketFactoryGetInsecure": Call to SSLCertificateSocketFactory.getInsecure()"StateListReachable": Unreachable state in a &lt;selector&gt;"AuthLeak": Code might contain an auth leak"StringFormatCount": Formatting argument types incomplete or inconsistent"StringFormatMatches": "String.format string doesn't match the XML format string""StringFormatInvalid": Invalid format string"PluralsCandidate": Potential Plurals"UseCheckPermission": Using the result of check permission calls"CheckResult": Ignoring results"ResourceAsColor": Should pass resolved color instead of resource id"MissingPermission": Missing Permissions"Range": Outside Range"ResourceType": Wrong Resource Type"RestrictedApi": Restricted API"WrongThread": Wrong Thread"WrongConstant": Incorrect constant"VisibleForTests": Visible Only For Tests"ProtectedPermissions": Using system app permission"TextFields": Missing inputType or hint"TextViewEdits": TextView should probably be an EditText instead"SelectableText": Dynamic text should probably be selectable"MenuTitle": Missing menu title"ShowToast": Toast created but not shown"TooDeepLayout": Layout hierarchy is too deep"TooManyViews": Layout has too many views"ExtraTranslation": Extra translation"MissingTranslation": Incomplete translation"Typos": Spelling error"TypographyDashes": Hyphen can be replaced with dash"TypographyEllipsis": Ellipsis string can be replaced with ellipsis character"TypographyFractions": Fraction string can be replaced with fraction character"TypographyOther": Other typographical problems"TypographyQuotes": Straight quotes can be replaced with curvy quotes"UnsafeProtectedBroadcastReceiver": Unsafe Protected BroadcastReceiver"UnprotectedSMSBroadcastReceiver": Unprotected SMS BroadcastReceiver"UnusedResources": Unused resources"UnusedIds": Unused id"UseCompoundDrawables": Node can be replaced by a TextView with compound drawables"UselessLeaf": Useless leaf layout"UselessParent": Useless parent layout"EnforceUTF8": Encoding used in resource files is not UTF-8"VectorRaster": Vector Image Generation"VectorDrawableCompat": Using VectorDrawableCompat"VectorPath": Long vector paths"InvalidVectorPath": Invalid vector paths"ViewConstructor": Missing View constructors for XML inflation"ViewHolder": View Holder Candidates"ViewTag": Tagged object leaks"WrongViewCast": Mismatched view type"FindViewByIdCast": Add Explicit Cast"Wakelock": Incorrect WakeLock usage"WakelockTimeout": Using wakeLock without timeout"InvalidWearFeatureAttribute": Invalid attribute for Wear uses-feature"WearStandaloneAppFlag": Invalid or missing Wear standalone app flag"WebViewLayout": WebViews in wrap_content parents"WrongCall": Using wrong draw/layout method"WrongCase": Wrong case for view tag"InvalidId": Invalid ID declaration"NotSibling": RelativeLayout Invalid Constraints"UnknownId": Reference to an unknown id"UnknownIdInLayout": Reference to an id that is not in the current layout"SuspiciousImport": import android.R statement"WrongFolder": Resource file in the wrong res folder"WrongThreadInterprocedural": Wrong Thread (Interprocedural) 总结还有遇到一些简单代码规范的问题，平时注意，就能规避，比如常见的宽高，写成了sp、xp；总之就是sp、xp、dp使用混乱等一些规范问题，或者是内存泄漏风险.]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>lint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正确的提问方式]]></title>
    <url>%2Fposts%2F6cc70a12.html</url>
    <content type="text"><![CDATA[提问之前 你是否在谷歌/百度/论坛上搜索过？ 你是否查过手册/文档？ 你是否阅读过源码？ 正确提问 你想做什么？遇到了什么问题？你做过什么？尝试过什么解决方案？结果是什么？ 附上log，代码等 Ps：提供越多有效信息，越能得到帮助 错误提问 有大佬在吗？有人在吗？有人会吗？有人懂吗？ 这个怎么解决？为什么会出现这个？这是怎麽回事？有没有人帮我解决这个问题？ Ps：大家都忙，请尊重彼此的时间]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Hexo添加CNZZ统计]]></title>
    <url>%2Fposts%2Ffb66bb1.html</url>
    <content type="text"><![CDATA[前言刚开始弄NexT主题的时候，一直都是用不蒜子的统计，但是不蒜子统计的内容太过简单了，不能够看到其他的一些数据，最近把友盟的统计给加上了。 友盟+ 传送门：https://passport.umeng.com/login?appId=cnzz 配置站点信息登录之后，选择右上角的添加站点，配置好你的站点信息 获取代码获取友盟提供给你的代码，友盟提供了很多的样式，随便复制一份就行。 在\themes\next\layout\_third-party\analytics\cnzz-analytics.swig中将原来的代码全部删除，复制下面的代码：ps：如果没有该文件，请自行创建然后复制修改下面的代码 123456789101112&#123;% if theme.cnzz_siteid %&#125;&lt;div&gt;&lt;!-- 填写你的友盟代码 --&gt;&lt;script type="text/javascript"&gt; var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://"); document.write(unescape("%3Cspan id='cnzz_stat_icon_12'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D12%2show%3Dpic' type='text/javascript'%3E%3C/script%3E"));&lt;/script&gt;&lt;!-- 你的友盟代码 end --&gt;&lt;/div&gt;&#123;% endif %&#125; 修改配置文件添加了代码之后，还需要修改next的配置文件才能够生效。注意是主题配置文件打开\themes\next目录下的_config.yml，按ctrl + F搜索CNZZ,找到之后将注释的内容打开，并设置成true，注意空格 12# CNZZ countcnzz_siteid: true 这样就可以成功的使用CNZZ进行统计了。建议使用hexo s在本地测试，看是否有问题再部署上去。]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Os，iphone，ipad绑定阿里云邮箱]]></title>
    <url>%2Fposts%2F94899ee0.html</url>
    <content type="text"><![CDATA[在 MacOS iPhone iPad 上面设置可能有差别，但是关键参数如下。 以Mac OS为例，打开设置，前往互联网账户，添加其他账户，邮件账户，按自己的阿里邮箱，或者你们公司给你的以你们公司名后缀结束的邮箱（其实还是阿里邮箱），填写邮箱密码。 接着选择账户类型：pop 收件服务器：pop3.aliyun.com 发件服务器：smtp.aliyun.com]]></content>
      <categories>
        <category>Mac</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android适配-9.0进阶指南]]></title>
    <url>%2Fposts%2Fe2baf374.html</url>
    <content type="text"><![CDATA[前言国内从去年开始就有消息说，应用上架或者更新要求TargetSdkVersion最低要为26以上，也就是最低也要适配到8.0。今年来也都逐步地开始落实。 小米应用商店公告 Google Play的要求 还包括从8月份开始在Google Play上发布的应用必须支持64位架构。可以看到适配工作真的不能像以前一样随心所欲了。 准备工作进入正题，首先将我们项目中的targetSdkVersion改为 28。接下来运行你的项目，看有没中枪。 网络Http请求失败在9.0中默认情况下启用网络传输层安全协议 (TLS)，默认情况下已停用明文支持。也就是不允许使用http请求，要求使用https。 比如我使用的是okhttp，会报错： 1java.net.UnknownServiceException: CLEARTEXT communication to xxxx not permitted by network security policy 解决方法是需要我们添加网络安全配置。首先在 res 目录下新建xml文件夹，添加network_security_config.xml文件: 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; AndroidManifest.xml中的application添加： 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest ... &gt; &lt;application android:networkSecurityConfig="@xml/network_security_config"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 以上这是一种简单粗暴的配置方法，要么支持http，要么不支持http。为了安全灵活，我们可以指定支持的http域名： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;!-- Android 9.0 上部分域名时使用 http --&gt; &lt;domain-config cleartextTrafficPermitted="true"&gt; &lt;domain includeSubdomains="true"&gt;secure.example.com&lt;/domain&gt; &lt;domain includeSubdomains="true"&gt;cdn.example1.com&lt;/domain&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 当然不止这些配置，还有抓包配置、设置自定义CA以及各种场景下灵活的配置，详细的方法可以查看官方文档。 Apache HTTP 客户端弃用在 Android 6.0 时，就已经取消了对 Apache HTTP 客户端的支持。 从 Android 9.0 开始，默认情况下该库已从 bootclasspath 中移除。但是耐不住有些SDK中还在使用，比如我见到的友盟QQ分享报错问题。 所以要想继续使用Apache HTTP，需要在应用的 AndroidManifest.xml 文件中添加： 1&lt;uses-library android:name="org.apache.http.legacy" android:required="false"/&gt; 前台服务可以试着搜索一下你的代码，看是否有调用startForegroundService 方法来启动一个前台服务。 startForegroundService 主要来源估计都是8.0适配时候加上的： 123456Intent intentService = new Intent(this, MyService.class);if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; startForegroundService(intentService);&#125; else &#123; startService(intentService);&#125; 9.0 要求创建一个前台服务需要请求 FOREGROUND_SERVICE 权限，否则系统会引发 SecurityException。 1234567891011java.lang.RuntimeException: Unable to start service com.weilu.test.MyService@81795be with Intent &#123; cmp=com.weilu.test/.MyService &#125;: java.lang.SecurityException: Permission Denial: startForeground from pid=28631, uid=10626 requires android.permission.FOREGROUND_SERVICE at android.app.ActivityThread.handleServiceArgs(ActivityThread.java:3723) at android.app.ActivityThread.access$1700(ActivityThread.java:201) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1705) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:207) at android.app.ActivityThread.main(ActivityThread.java:6820) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876) 解决方法就是AndroidManifest.xml中添加FOREGROUND_SERVICE权限： 1&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE" /&gt; 启动Activity在9.0 中，不能直接非 Activity 环境中（比如Service，Application）启动 Activity，否则会崩溃报错： 12345678910java.lang.RuntimeException: Unable to create service com.weilu.test.MyService: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? at android.app.ActivityThread.handleCreateService(ActivityThread.java:3578) at android.app.ActivityThread.access$1400(ActivityThread.java:201) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1690) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:207) at android.app.ActivityThread.main(ActivityThread.java:6820) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876) 这类问题一般会在点击推送消息跳转页面这类场景，解决方法就是 Intent 中添加标FLAG_ACTIVITY_NEW_TASK 123Intent intent = new Intent(this, TestActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 异形屏适配这类异形屏叫法很多，刘海屏、水滴屏、挖孔屏、美人尖。。 其实如果你的页面不需要全屏显示，那么不需要额外的适配工作。 如果页面是全屏显示（比如启动页）。为了防止你的内容被遮挡，大部分场景下都是可以使用获取状态栏高度来处理遮挡的适配问题。因为状态栏的高度都是大于等于刘海的高度。 当然，如果你想利用起来刘海区域，就需要获取刘海位置等信息进行适配。在Android 9.0中官方提供了DisplayCutout 类，可以确定刘海区域的位置，国内的部分厂商在8.0就有了自己的适配方案。 具体的我就不过多介绍了，推荐大家看以下文章： Android P 刘海屏适配全攻略 Android刘海屏、水滴屏全面屏适配方案 权限首先是权限组的变更： 上图可以看到，在9.0 中新增权限组CALL_LOG 并将 READ_CALL_LOG、WRITE_CALL_LOG 和 PROCESS_OUTGOING_CALLS 权限从PHONE中移入该组。 限制访问通话记录如果应用需要访问通话记录或者需要处理去电，则您必须向 CALL_LOG权限组明确请求这些权限。 否则会发生 SecurityException。 限制访问电话号码 要通过 PHONE_STATE Intent 操作读取电话号码，同时需要 READ_CALL_LOG 权限和 READ_PHONE_STATE 权限。 要从 PhoneStateListener的onCallStateChanged() 中读取电话号码，只需要 READ_CALL_LOG 权限。 不需要 READ_PHONE_STATE 权限。 其他 在 Android 9 中，调用Build.SERIAL 会始终返回 UNKNOWN 以保护用户的隐私。如果你的应用需要访问设备的硬件序列号，那么需要先请求 READ_PHONE_STATE 权限，然后调用 Build.getSerial()。 注意非 SDK 接口的限制。主要是一些热修复、插件化框架涉及比较多，注意及时升级新版本。 多进程使用WebView注意无法共用同一数据目录。 详细点击查看 总的来说，9.0的适配工作需要改动和注意的点相比较以前版本的适配来说并不多，从本篇的篇幅就可以看出来，详细的变化可以参看文末的链接。后面如果遇到什么坑，我也会及时补充进来。感谢你的阅读！！ 参考 Android 9.0 行为变更 targetSdkVersion升级28]]></content>
      <categories>
        <category>Android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android适配-8.0详解]]></title>
    <url>%2Fposts%2Fcd8b8392.html</url>
    <content type="text"><![CDATA[准备工作将我们项目中的targetSdkVersion改为 26（8.0） 或者 27（8.1），记住不要超过27，毕竟我还没有告诉你Android P怎么适配（滑稽）。 运行时权限首先引用官方的原文。 在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE 和WRITE_EXTERNAL_STORAGE。应用请求 READ_EXTERNAL_STORAGE，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 READ_EXTERNAL_STORAGE；不过，如果该应用后来又请求 WRITE_EXTERNAL_STORAGE，则系统会立即授予该权限，而不会提示用户。 所谓权限组如下： 所以总结下来，如果你之前是用什么权限就去申请什么权限，那么恭喜你，这个变化不会影响到你。如果你只申请了权限组中的某些权限，却用了同组的其他权限，那么你就需要去适配一下了。 那么怎么适配呢，如果你去检查之前每个申请权限的地方，未免太过麻烦。那么你可以根据你项目中的Manifest文件中需要的权限与权限组去对比，整理出你需要申请的各个权限组。比如你需要android.permission.CALL_PHONE(打电话)与android.permission.READ_PHONE_STATE(读取手机状态) 这两个权限。那么你就整理出了类似下面的类。 12345678910public class PermissionGroup &#123; //Phone权限 public static String[] PHONE = new String[] &#123; Manifest.permission.READ_PHONE_STATE, Manifest.permission.CALL_PHONE &#125;; ...&#125; 到时在申请权限时就可以直接获取它，一次将它们都申请了。这样就防止了遗漏某个权限，导致的异常。 注意：8.0中PHONE权限组新增两个权限： ``ANSWER_PHONE_CALLS：允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用acceptRingingCall() `函数。 READ_PHONE_NUMBERS ：权限允许您的应用读取设备中存储的电话号码。 通知适配其实8.0在通知这里变化还挺多的，比如通知渠道、通知标志、通知超时、背景颜色的等，详细的说明可以去看官方的Android 8.0 功能和 API。虽然变化很多，但是国内的机子貌似支持的不多。。。我在小米的文档中了解到，Android 已将通知渠道的逻辑纳入 Android Compatibility Definition Document (CDD) 中，意味着所有 Android 厂商都必须支持。所以我们可以放心的去适配。 通知渠道：Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。 我个人很喜欢这个新特性。也就是说，我们可以将我们给用户的通知进行分类，我用高德地图app来举例 小米(MIUI10) 华为(EMUI 8.1.0) 一加(氢OS 5.1) 可以看到高德地图分的很细致，分为四个组共13个类别(华为貌似对组不生效)。这样有个好处，我们可以控制我们想收到的通知，比如我不喜欢运营活动通知，那我就可以把它关闭。这样避免大量的不必要通知，否则使得用户觉得烦，一棒子打死。直接关闭你的允许通知。当然了，大量app都还没有适配，适配的也都分的不是很细致，比如下图的QQ。(没有对比就没有伤害) 小米(MIUI10) 一加(氢OS 5.1) 当然更重要的问题是，如果不去适配，可能通知都不会弹出来。那么适配的方法如下： 1234567891011121314151617181920212223242526272829303132333435363738private void createNotificationChannel() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); //分组（可选） //groupId要唯一 String groupId = "group_001"; NotificationChannelGroup group = new NotificationChannelGroup(groupId, "广告"); //创建group notificationManager.createNotificationChannelGroup(group); //channelId要唯一 String channelId = "channel_001"; NotificationChannel adChannel = new NotificationChannel(channelId, "推广信息", NotificationManager.IMPORTANCE_DEFAULT); //补充channel的含义（可选） adChannel.setDescription("推广信息"); //将渠道添加进组（先创建组才能添加） adChannel.setGroup(groupId); //创建channel notificationManager.createNotificationChannel(adChannel); //创建通知时，标记你的渠道id Notification notification = new Notification.Builder(MainActivity.this, channelId) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentTitle("一条新通知") .setContentText("这是一条测试消息") .setAutoCancel(true) .build(); notificationManager.notify(1, notification); &#125; &#125; 效果如下： 小米(MIUI10) 华为(EMUI 8.1.0) 一加(氢OS 5.1) 华为手机当只有一个渠道时，不会显示，会当做默认通知处理，除非一个以上。 注意：当Channel已经存在时，后面的createNotificationChannel方法仅能更新其name/description，以及对importance进行降级，其余配置均无法更新。所以如果有必要的修改只能创建新的渠道，删除旧渠道 删除渠道代码如下： 123456private void deleteNotificationChannel(String channelId)&#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; NotificationManager mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); mNotificationManager.deleteNotificationChannel(channelId); &#125;&#125; 悬浮窗适配使用 SYSTEM_ALERT_WINDOW 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口: TYPE_PHONE TYPE_PRIORITY_PHONE TYPE_SYSTEM_ALERT TYPE_SYSTEM_OVERLAY TYPE_SYSTEM_ERROR 相反，应用必须使用名为 TYPE_APPLICATION_OVERLAY 的新窗口类型。 也就是说需要在之前的基础上判断一下： 12345if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; mWindowParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#125;else &#123; mWindowParams.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#125; 当然记得需要有权限 12&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt;&lt;uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW" /&gt; 再进行判断 安装APKAndroid 8.0去除了“允许未知来源”选项，所以如果我们的App有安装App的功能（检查更新之类的），那么会无法正常安装。 首先在AndroidManifest文件中添加安装未知来源应用的权限 1&lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/&gt; 这样系统会自动询问用户完成授权。当然你也可以先使用 canRequestPackageInstalls()查询是否有此权限，如果没有的话使用Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES这个action将用户引导至安装未知应用权限界面去授权。 12345678910111213141516171819202122232425262728private static final int REQUEST_CODE_UNKNOWN_APP = 100; private void installAPK()&#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; boolean hasInstallPermission = getPackageManager().canRequestPackageInstalls(); if (hasInstallPermission) &#123; //安装应用 &#125; else &#123; //跳转至“安装未知应用”权限界面，引导用户开启权限 Uri selfPackageUri = Uri.parse("package:" + this.getPackageName()); Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri); startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP); &#125; &#125;else &#123; //安装应用 &#125; &#125; //接收“安装未知应用”权限的开启结果 @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123; installAPK(); &#125; &#125; 对于权限组、悬浮窗还有安装未知来源应用的权限适配，我们也可以使用AndPermission。这样更加便捷。 透明主题的Activity这个是在targetSdk=27，Android为8.0的手机时，出现的bug（因为官方已经在8.1修复）。问题的探究可以查看这里。 只有全屏不透明的activity才可以设置方向。否则报错如下： 1234567891011java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2957) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3032) at android.app.ActivityThread.-wrap11(Unknown Source:0) at adroid.app.ActivityThread$H.handleMessage(ActivityThread.java:1696) at android.os.Handler.dispatchMessage(Handler.java:105) at android.os.Looper.loop(Looper.java:164) at android.app.ActivityThread.main(ActivityThread.java:6944) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:327) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1374) 容易中枪的比如微信分享、支付的回调页面，我们习惯设为透明。 解决办法： 要么去掉对应activity中的 screenOrientation 属性，或者对应设置方向的代码。 要么舍弃透明效果，在它的Theme中添加： 1&lt;item name="android:windowIsTranslucent"&gt;false&lt;/item&gt; 集合的处理现在，AbstractCollection.removeAll(null)和AbstractCollection.retainAll(null)始终引发 NullPointerException；之前，当集合为空时不会引发 NullPointerException。所以我们需要做判空处理。 后台执行限制应用在两个方面受到限制： 后台服务限制：处于空闲状态时，应用可以使用的后台服务存在限制。 这些限制不适用于前台服务，因为前台服务更容易引起用户注意。 广播限制：除了有限的例外情况，应用无法使用清单注册隐式广播。 它们仍然可以在运行时注册这些广播，并且可以使用清单注册专门针对它们的显式广播。 在大多数情况下，应用都可以使用 JobScheduler 克服这些限制。 这种方式让应用安排为在未活跃运行时执行工作，不过仍能够使系统可以在不影响用户体验的情况下安排这些作业。关于的用法可以参考官方例子：android-JobScheduler。 后台任务google推荐方案使用 WorkManager，WorkManager可以自动维护后台任务，同时可适应不同的条件，同时满足后台Service和静态广播，内部维护着JobScheduler，而在6.0以下系统版本则可自动切换为AlarmManager！有兴趣的可以了解一下。 当然还有后台位置的限制需要去注意。 参考 1.MIUI 10 通知类别 / Channel 适配 2.Create and Manage Notification Channels 3.Presentation of Notifications 4.Android 实现应用更新适配 Android O]]></content>
      <categories>
        <category>Android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android适配-7.0的踩坑之路]]></title>
    <url>%2Fposts%2Fa6a9da5d.html</url>
    <content type="text"><![CDATA[安装时解析错误我们的App通常会有检查更新的功能。用户在收到提示更新并且下载完后，会自动打开安装页面让用户来去安装。这时就会出现安装错误的问题，这类的问题的可能性比较多。比如较低版本的App想要覆盖已有的较高版本App会提示安装未完成，或是签名不一致导致的。不过7.0上常见的有以下两种情况。 应用间共享文件在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 Android 7.0 行为变更 通过FileProvider在应用间共享文件 这篇文章。 APK signature scheme v2 Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。详细看安卓官方说明。 简单地说就是任何方式的篡改APK 文件，在利用了V2签名的apk上会失效。 可以看到默认是V1 和V2选中的。 1）只勾选v1签名就是传统方案签署，但是在7.0上不会使用V2安全的验证方式。2）只勾选V2签名7.0以下会显示未安装，7.0上则会使用了V2安全的验证方式。3）同时勾选V1和V2则所有版本都没问题。 PopupWindow位置不正确7.0系统的手机上，PopupWindow弹出位置不正确。有两种可能： 第一种： 我们使用了update方法，同时设置了Gravity（Gravity.NO_GRAVITY没事）。因为在update方法中有调用computeGravity方法去获取Gravity。（7.0以下没有获取Gravity进行更新判断） 12345678910111213public void update() &#123; // 省略部分代码 final int newGravity = computeGravity(); if (newGravity != p.gravity) &#123; p.gravity = newGravity; update = true; &#125; if (update) &#123; setLayoutDirectionFromAnchor(); mWindowManager.updateViewLayout(mDecorView, p); &#125; &#125; Android 7.1computeGravity方法 1234567private int computeGravity() &#123; int gravity = mGravity == Gravity.NO_GRAVITY ? Gravity.START | Gravity.TOP : mGravity; if (mIsDropdown &amp;&amp; (mClipToScreen || mClippingEnabled)) &#123; gravity |= Gravity.DISPLAY_CLIP_VERTICAL; &#125; return gravity;&#125; 很显然在7.0上我们设置的Gravity被覆盖了。解决就很简单了，不使用update方法。如果你真的要使用可以参考这篇文章的方法。 第二种： PopupWindow高度为MATCH_PARENT，在显示的时候调用showAsLocation方法时，PopupWindow并没有在指定控件的下方显示。如果使用showAsDropDown，会全屏显示。 解决方法： 1.最简单的解决方法就是指定 PopupWindow 的高度为 WRAP_CONTENT, 调用 showAsDropDown方法。 2.或者弹出时做一下判断处理（代码来自PopupWindowCompat） 12345678910111213if (Build.VERSION.SDK_INT &gt;= 24) &#123; // Android 7.x中,PopupWindow高度为match_parent时,会出现兼容性问题,需要处理兼容性 int[] location = new int[2]; // 记录anchor在屏幕中的位置 anchor.getLocationOnScreen(location); int offsetY = location[1] + anchor.getHeight(); if (Build.VERSION.SDK_INT &gt;= 25) &#123; // Android 7.1 ,8.0中，PopupWindow高度为 match_parent 时，会占据整个屏幕 // 故而需要在 Android 7.1上再做特殊处理 int screenHeight = ScreenUtils.getScreenHeight(context); // 获取屏幕高度 popupWindow.setHeight(screenHeight - offsetY); // 重新设置 PopupWindow 的高度 &#125; popupWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, 0, offsetY);&#125; else &#123; popupWindow.showAsDropDown(anchor);&#125; 后台优化小伙伴们都知道在Android中有一些隐式广播，使用这些隐式广播可以做一些特定的功能，如，当手机网络变成WiFi时自动下载更新包等。 但，这些隐式广播会在后台频繁启动已注册侦听这些广播的应用，从而带来很大的电量消耗，为缓解这一问题来提升设备性能和用户体验，在Android 7.0中删除了三项隐式广播，以帮助优化内存使用和电量消耗。 Android 7.0 应用了以下优化措施： 在 Android 7.0上 应用不会收到 CONNECTIVITY_ACTION 广播，即使你在manifest清单文件中设置了请求接受这些事件的通知。 但，在前台运行的应用如果使用BroadcastReceiver 请求接收通知，则仍可以在主线程中侦听 CONNECTIVITY_CHANGE。 在 Android 7.0上应用无法发送或接收 ACTION_NEW_PICTURE 或ACTION_NEW_VIDEO 类型的广播。 应对策略：Android 框架提供多个解决方案来缓解对这些隐式广播的需求。 例如，JobScheduler API提供了一个稳健可靠的机制来安排满足指定条件（例如连入无线流量网络）时所执行的网络操作。 您甚至可以使用 JobScheduler API 来适应内容提供程序变化。 另外，大家如果想了解更多关于后台的优化可查阅后台优化 移动设备会经历频繁的连接变更，例如在 Wi-Fi 和移动数据之间切换时。 目前，可以通过在应用清单中注册一个接收器来侦听隐式 CONNECTIVITY_ACTION 广播，让应用能够监控这些变更。 由于很多应用会注册接收此广播，因此单次网络切换即会导致所有应用被唤醒并同时处理此广播。以上内容来自这里 多语言特性首先是官方的API指南：语言和语言区域 变化对比： Android 7.0多语言支持开发浅析 实现功能： Android 实现应用内置语言切换 通知栏适配这里有一篇非常详细的通知栏介绍与适配，分享给大家：Android通知栏介绍与适配总结 WebView问题 Android 7.0 WebView 部分机型打不开 Android 7.0 WebView 二级跳转后界面空白 Toast导致的BadTokenException 同学，你的系统Toast可能需要修复一下]]></content>
      <categories>
        <category>Android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android适配-6.0的动态权限管理]]></title>
    <url>%2Fposts%2Feea8a783.html</url>
    <content type="text"><![CDATA[前言大家都知道Android 6.0的新特性之一就是应用权限的管理。也就是说凡是涉及用户隐私的权限，用户可以自己去设置管理了。然而在6.0以前，我们安装一款APP是默认同意此APP所需的所有权限（比如定位、访问通讯录），不同意就不能安装。当然，国内的一些手机厂商基于Android定制的系统中，可以实现在6.0以前关闭指定的权限。如下图： 危险权限列表(Dangerous Permission)Dangerous Permission一般都是涉及用户隐私的权限。 从上面的图片中可以看到，摄像头、电话、定位等等都是我们平常开发中常用的权限。 可以在6.0不适配权限管理吗？答案是可以，但是不推荐。 首先说怎么不适配，那就是设置targetSdkVersion小于23（Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果您APP设置的targetSdkVersion低于23，在运行时也不会崩溃。） 有人一看这不是挺好的嘛，解决问题。那么我想告诉你，首先这不是长久之计，早晚都要面对的。你不可能永远targetSdkVersion低于23。其次，它是有一个前提，那就是用户自己不去操作权限。要知道如果用户是6.0以上的手机或是国内部分6.0以前的手机，他可以自己在设置中关闭权限，那么到时APP因为没有权限获取数据异常，导致空指针的异常时，APP就会崩溃。 怎么适配首先Android Studio：在build.gradle中声明targetSdkVersion为23及以上。 Eclipse：在AndroidManifest.xml中声明targetSdkVersion为23及以上。 这里引用高德定位Demo的CheckPermissionsActivity类，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/** * 继承了Activity，实现Android6.0的运行时权限检测 * 需要进行运行时权限检测的Activity可以继承这个类 * * @创建时间：2016年5月27日 下午3:01:31 * @项目名称： AMapLocationDemo * @author hongming.wang * @文件名称：PermissionsChecker.java * @类型名称：PermissionsChecker * @since 2.5.0 */public class CheckPermissionsActivity extends Activity &#123; /** * 需要进行检测的权限数组 */ protected String[] needPermissions = &#123; Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.READ_PHONE_STATE &#125;; private static final int PERMISSON_REQUESTCODE = 0; /** * 判断是否需要检测，防止不停的弹框 */ private boolean isNeedCheck = true; @Override protected void onResume() &#123; super.onResume(); if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= 23) &#123; if (isNeedCheck) &#123; checkPermissions(needPermissions); &#125; &#125; &#125; /** * * @param permissions * @since 2.5.0 * requestPermissions方法是请求某一权限， */ private void checkPermissions(String... permissions) &#123; try &#123; if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= 23) &#123; List&lt;String&gt; needRequestPermissonList = findDeniedPermissions(permissions); if (null != needRequestPermissonList &amp;&amp; needRequestPermissonList.size() &gt; 0) &#123; String[] array = needRequestPermissonList.toArray(new String[needRequestPermissonList.size()]); Method method = getClass().getMethod("requestPermissions", new Class[]&#123;String[].class, int.class&#125;); method.invoke(this, array, PERMISSON_REQUESTCODE); &#125; &#125; &#125; catch (Throwable e) &#123; &#125; &#125; /** * 获取权限集中需要申请权限的列表 * * @param permissions * @return * @since 2.5.0 * checkSelfPermission方法是在用来判断是否app已经获取到某一个权限 * shouldShowRequestPermissionRationale方法用来判断是否 * 显示申请权限对话框，如果同意了或者不在询问则返回false */ private List&lt;String&gt; findDeniedPermissions(String[] permissions) &#123; List&lt;String&gt; needRequestPermissonList = new ArrayList&lt;String&gt;(); if (Build.VERSION.SDK_INT &gt;= 23 &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= 23)&#123; try &#123; for (String perm : permissions) &#123; Method checkSelfMethod = getClass().getMethod("checkSelfPermission", String.class); Method shouldShowRequestPermissionRationaleMethod = getClass().getMethod("shouldShowRequestPermissionRationale", String.class); if ((Integer)checkSelfMethod.invoke(this, perm) != PackageManager.PERMISSION_GRANTED || (Boolean)shouldShowRequestPermissionRationaleMethod.invoke(this, perm)) &#123; needRequestPermissonList.add(perm); &#125; &#125; &#125; catch (Throwable e) &#123; &#125; &#125; return needRequestPermissonList; &#125; /** * 检测是否所有的权限都已经授权 * @param grantResults * @return * @since 2.5.0 * */ private boolean verifyPermissions(int[] grantResults) &#123; for (int result : grantResults) &#123; if (result != PackageManager.PERMISSION_GRANTED) &#123; return false; &#125; &#125; return true; &#125; /** * 申请权限结果的回调方法 */ @TargetApi(23) public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] paramArrayOfInt) &#123; if (requestCode == PERMISSON_REQUESTCODE) &#123; if (!verifyPermissions(paramArrayOfInt)) &#123; showMissingPermissionDialog(); isNeedCheck = false; &#125; &#125; &#125; /** * 显示提示信息 * * @since 2.5.0 * */ private void showMissingPermissionDialog() &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(R.string.notifyTitle); builder.setMessage(R.string.notifyMsg); // 拒绝, 退出应用 builder.setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;); builder.setPositiveButton(R.string.setting, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; startAppSettings(); &#125; &#125;); builder.setCancelable(false); builder.show(); &#125; /** * 启动应用的设置 * * @since 2.5.0 * */ private void startAppSettings() &#123; Intent intent = new Intent( Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.parse("package:" + getPackageName())); startActivity(intent); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if(keyCode == KeyEvent.KEYCODE_BACK)&#123; this.finish(); return true; &#125; return super.onKeyDown(keyCode, event); &#125; &#125; 我在上面的类中，自己加入了一些注释，大家仔细看就可以明白了。 补充：小米手机在动态权限这里还需要一些兼容，我们需要注意一下。当然对于国内部分6.0以前手机，只能在需要权限去去捕获异常来处理了。 当然不止上面一种实现方法，github上有许多大神开源的封装库，可以很方便的实现权限适配。我推荐两个库，大家根据需求选择： PermissionsDispatcher 鸿洋大神的MPermissions 参考 Android M 新的运行时权限开发者需要知道的一切 高德地图定位API]]></content>
      <categories>
        <category>Android</category>
        <category>适配</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>适配</tag>
        <tag>动态权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开箱即用的自定义Banner]]></title>
    <url>%2Fposts%2F108df6b8.html</url>
    <content type="text"><![CDATA[自定义Banner用法明细支持XML自定义属性： bv_viewHeight：Banner视图区域的高度，小于等于0时为该布局的高度 bv_viewCornerRadius：视图区域圆角的半径 bv_itemViewWidthRatio：根据该布局宽度的百分比设置ItemView的宽度 bv_itemViewMargin：设置ItemView之间的间距 bv_intervalInMillis：Banner轮换时间（在SMOOTH模式下为Banner从右匀速到左的时间） bv_pageHoldInMillis：手指滑动后，页面停留的时长（只在SMOOTH模式下生效） bv_scrollMode：设置Banner滚动模式 INTERVAL：间隔切换模式 SMOOTH：匀速滚动模式 bv_itemViewAlign：ItemView与父WrapperView的对齐方式（决定了itemViewMargin的留白位置） CENTER_HORIZONTAL：水平居中 ALIGN_PARENT_LEFT：居左对齐 ALIGN_PARENT_RIGHT：居右对齐 暴露的API有： setBannerViewImpl(impl: IBannerView)：设置Banner必须的实现类 startAutoScroll()：开始自动滚动（页面数量小于1时不会滚动） stopAutoScroll()：停止自动滚动 123456789101112131415161718192021222324252627282930313233343536/** * 定义页面切换回调 */interface OnPageChangeListener &#123; fun onPageSelected(position: Int)&#125;interface IBannerViewBase &#123; fun getCount(): Int fun getItemView(context: Context): View fun onBindView(itemView: View, position: Int)&#125;/** * BannerView依赖的外部实现 */interface IBannerView : OnPageChangeListener, IBannerViewBase &#123; /** * 当count为0时的默认view */ fun getDefaultView(context: Context): View? &#123; return null &#125; /** * 默认关闭自动滚动 */ fun isDefaultAutoScroll(): Boolean &#123; return false &#125; override fun onPageSelected(position: Int) &#123;&#125;&#125; 源码地址： https://github.com/drawf/SourceSet/tree/master/app/src/main/java/me/erwa/sourceset/view/banner 思考分析NOTE：这篇文章我们专注于BannerView的封装与实现，关于更底层的PagerSnapHelper的原理部分不在范围内，但在文末我拜读的文章中贴出了一份链接，大家可自行食用。 前路漫漫，我们先梳理下需求： 要支持两种滚动模式，间隔切换、平滑滚动 要支持设置视图区域圆角 要支持设置条目视图圆角（ItemView）（该需求本次未做实现，下文会自动忽略该需求） 要支持无限循环滚动 要支持根据BannerView的宽的比值设置ItemView的宽 要支持设置ItemView之间的间距 要支持设置滚动间隔，匀速模式要支持设置滚动一页的时间 要支持设置匀速模式下，手指滑动后，页面停留的时长 要支持设置ItemView与父WrapperView的对齐方式（决定了itemViewMargin的留白位置） 要支持设置默认是否开启滚动 要支持设置数据源为空时的默认View 要支持数据源只有1张banner时，禁止滚动 要暴露API控制Banner的自动滚动与暂停 要支持设置指示器（Indicator），且能灵活控制指示器位置，且与BannerView解耦 🤩这么多需求，不要怕，我们根据需求来理一遍核心技术点： 平滑滚动模式可以使用RecyclerView+PagerSnapHelper实现，间隔滚动模式可以继续使用ViewPager实现，也可以使用前者方式实现。（本文统一使用RecyclerView+PagerSnapHelper方式，不过代码中也留出了接口，可用ViewPager做实现） 设置圆角还是采用Xfermode做裁剪合成即可。（该方式在之前的文章ShadowLayout中使用过，故本文不再赘述） 需求[4]将adpter中getItemCount()返回Int.MAX_VALUE，再在绑定View时候，用当前的position与真实count求余数，作为真实的position去绑定数据，即可实现。 需求[4]到[13]，都没有技术复杂度，但有业务复杂度，做常规实现即可。 需求[14]可定义Indicator涉及的接口做代码解耦，并将BannerView继承RelativeLayout，这样Indicator作为子View在xml中可灵活控制位置。 这样一来，实现我们想要的BannerView只是耐心+时间的问题了。以下，我会挑本次实现中重要的几点来做说明，如下： RecyclerView+PagerSnapHelper实现的PagerRecyclerView 生成PagerView实例的工厂PagerViewFactory Indicator的解耦实现 PagerRecyclerView看名字便知这是一个用RecyclerView实现ViewPager功能的类，所以继承自RecyclerView。 它作为BannerView的核心功能实现类，为了与上层解耦（也就是方便切换为其它实现，比如用ViewPager做实现）所以定义接口IPagerViewInstance。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * PagerView功能实例需实现的接口 */interface IPagerViewInstance &#123; /** * 设置自动滚动 * @param intervalInMillis: Int 在INTERVAL模式下为页面切换间隔 在SMOOTH模式下为滚动一页所需时间 */ fun startAutoScroll(intervalInMillis: Int) /** * 停止自动滚动 */ fun stopAutoScroll() /** * 获取当前Item的位置（List的索引） */ fun getCurrentPosition(): Int /** * 获取当前真实的Item的位置（List的索引） */ fun getRealCurrentPosition(realCount: Int): Int /** * 设置平滑模式是否开启，否则为间隔切换模式 */ fun setSmoothMode(enabled: Boolean) /** * 设置页面停留时长 */ fun setPageHoldInMillis(pageHoldInMillis: Int) /** * 设置页面切换回调 */ fun setOnPageChangeListener(listener: OnPageChangeListener) /** * 通知数据刷新 */ fun notifyDataSetChanged()&#125; 关于PagerSnapHelper的使用极其简单，只需创建出实例，attachToRecyclerView一下，即可让RecyclerView摇身一变成为ViewPager一样。（这里实在让人惊叹！！我们都应该追求这种API的极致设计） 123456789/** * 滑动到具体位置帮助器 */private var mSnapHelper: PagerSnapHelper = PagerSnapHelper()... 省略代码init &#123; mSnapHelper.attachToRecyclerView(this) ... 省略代码&#125; 关于间隔切换模式 匀速滚动模式的实现主要是在startTimer()方法中，两者的区别在于Timer的间隔时间不同、回调中执行的方法不同。其中匀速模式的Timer间隔时间需要使用外部设置的滚动一屏的时间、一屏的宽度、每次scrollBy的距离计算而来。 123456789101112131415161718192021222324252627282930313233343536/** * 开始定时器 */private fun startTimer() &#123; mTimer?.cancel() if (mWidth &gt; 0 &amp;&amp; mFlagStartTimer &amp;&amp; context != null &amp;&amp; context is Activity) &#123; mTimer = timer(initialDelay = mDelayedTime, period = mPeriodTime) &#123; if (mScrollState == SCROLL_STATE_IDLE) &#123; (context as Activity).runOnUiThread &#123; if (mSmoothMode) &#123; scrollBy(DEFAULT_PERIOD_SCROLL_PIXEL, 0) triggerOnPageSelected() &#125; else &#123; smoothScrollToPosition(++mOldPosition) mPageChangeListener?.onPageSelected(mOldPosition) &#125; &#125; &#125; &#125; &#125;&#125;override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) mWidth = (w - paddingLeft - paddingRight).toFloat() mHeight = (h - paddingTop - paddingBottom).toFloat() //计算匀速滚动的时间间隔 if (mSmoothMode) &#123; mPeriodTime = (mSmoothSpeed / (mWidth / DEFAULT_PERIOD_SCROLL_PIXEL)).toLong() &#125; if (mTimer == null) &#123; startTimer() &#125;&#125; 页面选中是根据PagerSnapHelper中提供的findSnapView方法，先找到Snap（就是当前的目标View），再找它的位置，当然还需用一个变量记录一下，防止多次触发回调。 123456789101112131415/** * 触发OnPageSelected回调 */private fun triggerOnPageSelected() &#123; val layoutManager = getLinearLayoutManager() val view = mSnapHelper.findSnapView(layoutManager) if (view != null) &#123; val position = layoutManager.getPosition(view) //防止同一位置多次触发 if (position != mOldPosition) &#123; mOldPosition = position mPageChangeListener?.onPageSelected(position) &#125; &#125;&#125; 还有一个值得说道的点是初始化时需要矫正Snap的位置，因为PagerSnapHelper手指滑动的时候才工作让RecyclerView滑动出ViewPager的感觉，所以初始化时不矫正会发现选中的页面不居中显示，还是一个RecyclerView的样子。那如何矫正呢？这里去看了PagerSnapHelper实现，搬过来，稍加修改即可。 123456789101112131415161718192021222324252627282930313233343536/** * 矫正首次初始化时SnapView的位置 */private fun correctSnapViewPosition() &#123; val layoutManager = getLinearLayoutManager() val snapView = mSnapHelper.findSnapView(layoutManager) if (snapView != null) &#123; val snapDistance = mSnapHelper.calculateDistanceToFinalSnap(layoutManager, snapView) if (snapDistance != null) &#123; if (snapDistance[0] != 0 || snapDistance[1] != 0) &#123; //我们把源码的smoothScrollBy改为scrollBy，这样视觉上觉察不出矫正过程 scrollBy(snapDistance[0], snapDistance[1]) &#125; //首次触发回调 triggerOnPageSelected() &#125; &#125;&#125;/** * 这是源码 */void snapToTargetExistingView() &#123; if (this.mRecyclerView != null) &#123; LayoutManager layoutManager = this.mRecyclerView.getLayoutManager(); if (layoutManager != null) &#123; View snapView = this.findSnapView(layoutManager); if (snapView != null) &#123; int[] snapDistance = this.calculateDistanceToFinalSnap(layoutManager, snapView); if (snapDistance[0] != 0 || snapDistance[1] != 0) &#123; this.mRecyclerView.smoothScrollBy(snapDistance[0], snapDistance[1]); &#125; &#125; &#125; &#125;&#125; 以上是我认为PagerRecyclerView较为关键的点，其它部分均为业务逻辑的处理与实现，大家可打开源码自行食用。 PagerViewFactory这里采用了工厂方法模式来创建Banner底层的核心实现。 首先定义了BannerView实例接口，它将作为工厂实例的构造方法参数，用于区分创建底层实现。 1234567891011121314151617181920212223interface IBannerViewBase &#123; fun getCount(): Int fun getItemView(context: Context): View fun onBindView(itemView: View, position: Int)&#125;/** * 定义BannerView实例接口 */interface IBannerViewInstance : IBannerViewBase &#123; fun getContext(): Context fun isSmoothMode(): Boolean fun getItemViewWidth(): Int fun getItemViewMargin(): Int fun getItemViewAlign(): Int&#125; 工厂有个getPagerView()的方法，来创建Banner核心实现 123456789101112131415/** * 工厂根据参数创建对应PagerView实例 */override fun getPagerView(): IPagerViewInstance &#123; return if (bannerView.isSmoothMode()) &#123; casePagerRecycler(true) &#125; else &#123; if (intervalUseViewPager) &#123; //这里可以根据需要用ViewPager做底层实现 throw IllegalStateException("这里未使用ViewPager做底层实现") &#125; else &#123; casePagerRecycler(false) &#125; &#125;&#125; 这里就是创建了之前写好的PagerRecyclerView，其实就是创建配置使用一个RecyclerView的过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 处理PagerRecyclerView */private fun casePagerRecycler(isSmoothMode: Boolean): IPagerViewInstance &#123; val recyclerView = PagerRecyclerView(bannerView.getContext()) recyclerView.layoutManager = LinearLayoutManager(bannerView.getContext(), LinearLayoutManager.HORIZONTAL, false) recyclerView.adapter = object : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123; override fun getItemCount(): Int &#123; return Int.MAX_VALUE &#125; override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) &#123; if (!isActivityDestroyed(holder.itemView.context)) &#123; val realPos = position % bannerView.getCount() bannerView.onBindView(holder.itemView.findViewById(R.id.id_real_item_view), realPos) &#125; &#125; override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder &#123; val itemWrapper = LayoutInflater.from(parent.context).inflate( R.layout.layout_banner_item_wrapper, parent, false ) as RelativeLayout //处理ItemViewWrapper的宽 itemWrapper.layoutParams.width = bannerView.getItemViewWidth() + bannerView.getItemViewMargin() //外部实际的ItemView val itemView = bannerView.getItemView(parent.context) itemView.id = R.id.id_real_item_view val ivParams = RelativeLayout.LayoutParams( bannerView.getItemViewWidth(), ViewGroup.LayoutParams.MATCH_PARENT ) ivParams.addRule(bannerView.getItemViewAlign()) //添加ItemView到Wrapper itemWrapper.addView(itemView, ivParams) return object : RecyclerView.ViewHolder(itemWrapper) &#123;&#125; &#125; &#125; //初始化位置 recyclerView.scrollToPosition(bannerView.getCount() * 100) recyclerView.setSmoothMode(isSmoothMode) return recyclerView&#125; Indicator的解耦实现解耦的惯用套路就是抽象方法定义接口。所以我们定义了两个接口，一个是指示器实例需实现的接口，一个是指示器依赖的外部实现。所以使用这两个接口，可以自定义实现想要的样式。 1234567891011121314151617181920212223242526272829303132333435363738/** * 指示器实例需实现的接口 */interface IIndicatorInstance &#123; /** * 设置外部实现 */ fun setIndicator(impl: IIndicator) /** * 重新布局 */ fun doRequestLayout() /** * 重新绘制 */ fun doInvalidate()&#125;/** * 指示器依赖的外部实现 */interface IIndicator &#123; /** * 获取adapter总数目 */ fun getCount(): Int /** * 获取当前选中页面的索引 */ fun getCurrentIndex(): Int&#125; 对于我们这次实现的CrossBarIndicator，它就是一个常规的自定义View，这里已没有什么好说的啦。重点要说的是需求中有一条且能灵活控制指示器位置，如何实现呢？需求分析时说了，我们的BannerView是一个RelativeLayout，Indicator作为其子View可以很方便的控制其位置。 然后，看下BannerView中的关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647override fun onFinishInflate() &#123; super.onFinishInflate() findIndicator()&#125;/** * 在子View中找到指示器 */private fun findIndicator() &#123; for (i in 0 until childCount) &#123; val child = getChildAt(i) if (child is IIndicatorInstance) &#123; //布局填充完毕时，找到子View中的Indicator，并保存下来 mIndicator = child return &#125; &#125;&#125;/** * 初始化view */private fun initView() &#123; if (mBannerViewImpl != null &amp;&amp; mWidth &gt; 0) &#123; val bvImpl = mBannerViewImpl!! removeAllViews() ... 省略代码 //初始化指示器 if (mIndicator != null) &#123; mIndicator?.setIndicator(object : IIndicator &#123; override fun getCount(): Int &#123; return bvImpl.getCount() &#125; override fun getCurrentIndex(): Int &#123; return mPagerViewInstance.getRealCurrentPosition(bvImpl.getCount()) &#125; &#125;) //把指示器再添加回去 addView(mIndicator as View) &#125; &#125;&#125; 文末到这里整体要说的就完结了，整个BannerView的实现细节、逻辑还是很多的，不过复杂度倒没那么高，建议食用源码~ O(∩_∩)O哈哈~ 个人能力有限，如有不正之处欢迎大家批评指出，我会虚心接受并第一时间修改，以不误导大家。 拜读的文章SnapHelper硬核讲解： https://juejin.im/post/5cbe78ae5188250a6b183872]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>Banner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Context细节解析]]></title>
    <url>%2Fposts%2Fb902250c.html</url>
    <content type="text"><![CDATA[Context到底是啥？Context 本身是一个抽象类，它的实现类为 ContextImpl。 另外有子类 ContextWrapper 和 ContextThemeWrapper，这两个子类都是 Context 的代理类，主要区别是 ContextThemeWrapper 有自己的主题资源。 一个 Context 意味着一个场景，一个场景就是我们和软件进行交互的一个过程。 从安卓程序的角度来看，其实一个 Activity 就是一个 Context ，一个 Service 也是一个 Context。 Context有啥作用？有啥用？要看它能做啥，看看主要提供了哪些接口了。 还挺多的，看起来管得挺多，四大组件都管着，像个 Application 大管家。 一个app里有多少个Context？前面说啦，一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。 ContextImpl和ContextWrapper有啥区别？看下ContextWrapper： 再看下ContextImpl： 比较下： 不同组件创建ContextImpl的方式： 总结 Context相当于Application的大管家； ContextWrapper、ContextThemWrapper都是Context的代理类，ContextImpl是Context的主要实现类，是个实力派！ 参考: https://juejin.im/post/5c1fab7d5188254eb05fbe48 https://juejin.im/post/5865bfa1128fe10057e57c63]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中东阿拉伯语适配]]></title>
    <url>%2Fposts%2Fc080be13.html</url>
    <content type="text"><![CDATA[RTL 语言由来RTL 是 Right-to-left(从右向左) 的缩写。其意为人们书写阅读习惯是从右向左，朝左继续的，常见的 RTL 语言有阿拉伯语，希伯来语等。 看一下对比： LTR RTL 那么对于这种从右到左的习惯，在 Android 布局中有没有支持呢？ 答案是有的：从 Android 4.2 即 SDK 17 开始，提供了全面的本地布局支持，允许镜像布局，可以同时支持 RTL 和 LTR。 接下来我将介绍如何一步一步适配阿拉伯语。 属性 name desc chinese android:layoutDirection attribute for setting the direction of a component’s layout 设置组件的布局排列方向 android:textDirection attribute for setting the direction of a component’s text 设置组件的文字排列方向 android:textAlignment attribute for setting the alignment of a component’s text 设置文字的对齐方式 getLayoutDirectionFromLocale() method for getting the Locale-specified direction 获取指定地区的惯用布局方式 前提条件在 AndroidManifest.xml 文件中 application 节点添加支持从右到左布局方式代码 12345 &lt;application ... android:supportsRtl="true" &gt; ...&lt;/application&gt; 切换语言相关链接：change-language-programmatically-in-android 对应国家语言代码: what-is-the-list-of-supported-languages-locales-on-android 下面切换语言方式 updateConfiguration 方法在 Api 25 已经过时, 新的切换方式实例 地址 12345678String languageToLoad = "ar"; // your languageResources res = getResources(); DisplayMetrics dm = res.getDisplayMetrics();Locale locale = new Locale(languageToLoad); Locale.setDefault(locale);Configuration config = new Configuration();config.locale = locale;res.updateConfiguration(conf, dm); AS 一键适配AS 支持一键适配 RTL，主要是在原来 Layout 中设置 Left 和 Right 属性的补充添加 Start 和 End 属性（你们在写布局的时候是不是很少用到 paddingStart、marginStart？接下来你们写布局的时候可不能再偷懒了，该加的还是得加上) Start 属性在 LTR 中对应 Left，在 RTL 中对应 Right，在API 17开始支持，为了兼容低版本，需要同时有 Left 和 Start。从市场来看，Android 4.2 系统以下的手机用户已经不多了，我的建议是可以不兼容，具体还得你们看自家产品在 4.2 系统以下用户数。 Refactor &gt; Add RTL Support Where Possible… 利用第三方插件 名称 描述 gradle-android-rtl 自动修复布局文件中未添加RTL支持的标签 与 AS 插件的比较： 性能更好。在处理大批量文件修改时，用AS工具会出现卡顿 支持padding标签的补齐 使用全局样式EditText发现 EditText 控件基本都需要设置下面两个属性 相关链接：set-a-consistent-style-to-all-edittext-for-e-g 12android:textAlignment="viewStart"android:gravity="start" 那我们就可以在 style.xml 样式中全部 EditText 都设置 1234567891011&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="editTextStyle"&gt;@style/EditTextStyle.Alignment&lt;/item&gt; ...&lt;/style&gt;&lt;style name="EditTextStyle.Alignment" parent="@android:style/Widget.EditText"&gt; &lt;item name="android:textAlignment"&gt;viewStart&lt;/item&gt; &lt;item name="android:gravity"&gt;start&lt;/item&gt; &lt;item name="android:textDirection"&gt;locale&lt;/item&gt;&lt;/style&gt; TextView全局给所有 TextView 添加一个 RTL 属性 相关链接:setting-global-styles-for-views-in-android 123456789&lt;style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; ... &lt;item name="android:textViewStyle"&gt;@style/TextViewStyle.TextDirection&lt;/item&gt; ...&lt;/style&gt;&lt;style name="TextViewStyle.TextDirection" parent="android:Widget.TextView"&gt; &lt;item name="android:textDirection"&gt;locale&lt;/item&gt;&lt;/style&gt; 判断是否是 RTL 布局1TextUtilsCompat.getLayoutDirectionFromLocale(Locale.getDefault()) == LayoutDirection.RTL 对集合进行倒序处理在某些场合下, 这个方法很有用 1Collections.reverse(List&lt;?&gt; list); 代码动态设置控件 setMargins1234FrameLayout.LayoutParams params = new FrameLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);params.setMargins(10, 0, 10, 0);params.setMarginEnd(10); ViewPager相关链接: tabs-swipe-direction-in-right-to-left-android-app Android 官方控件大多支持 RTL，ViewPager 除外，GitHub 上面有人对 ViewPager 进行修改支持 RTL, 地址 适配总结 横向布局 LinearLayout ，可以使用 FrameLayout，控件需要靠左或靠右可以使用 layout_gravity 设置对应属性 切换阿拉伯语时，网格布局 item 之间的距离会出现增大问题，处理方法是：网格分割线 ItemDecoration 需要加入语言来判断，调换原来设置左右的边距即可 禁止掉之前的侧滑返回，以免出现冲突 一些方向图标，重新做一个相对方向的放到 mipmap-ldrtl-xxxhdpi 包下 动画翻转, 放在 anim-ldrtl 将对应的动画进行反向处理 布局里如果设置了 paddingLeft、drawableLeft 等等这些属性更改为一个支持 RTL 的属性 paddingStart、drawableStart；但是有些地方可以不加的，例如：购物车上的数量徽章，加了之后感觉怪怪的，所以还是不加了 利用在 AS 右边的预览布局工具中的语言切换工具，切换成阿拉伯语，能实时看到布局的效果图 EditText 添加 android:layoutDirection=”locale” ，如果外面有 TextInputLayout 的需给它设置 android:textDirection=”locale” ，如果输入类型时密码时还需添加一个属性 android:textAlignment=”viewStart” TextView 需要加上 android:textAlignment=”viewStart 或 viewEnd” 以及 android:textDirection=”locale” RecyclerView 网络布局的可以考虑使用 StaggeredGridLayoutManager ，如果数量太多的网格布局，不太建议使用，可能会出现滑动混乱 阿拉伯语目录下的 String.xml 文件, 出现占位符 d% 需要注意改为 %d, 但又并不是所有都改成这样, 目前我发现当代码中使用了 Toast 和 SpannableString 属性的就需要更改为 %d 建议计划 从基础类开始入手，判断是否是阿拉伯语，如果是需要将界面设置为从右到左的显示方式 分模块进行适配 复杂的模块，可以放到 layout-ldrtl 包下，单独做一个布局来适配阿拉伯语，例如详情页 参考资料 https://android-developers.googleblog.com/2013/03/native-rtl-support-in-android-42.html https://medium.com/@zhangqichuan/rtl-support-in-android-898e11f31561 https://mobikul.com/just-few-steps-to-make-your-app-rtl-supportable/ https://blog.robustastudio.com/featured/android-rtl-support/ http://blog.csdn.net/figo0423/article/details/50241363 http://blog.csdn.net/wxx614817/article/details/50586388 http://jiajixin.cn/2016/10/08/android_adapt_rtl/ http://www.apkbus.com/blog-327085-57866.html http://droidyue.com/blog/2014/07/07/support-rtl-in-android/index.html http://chuansong.me/n/920084451521]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>阿拉伯语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻量级存储框架MMKV]]></title>
    <url>%2Fposts%2F4770b281.html</url>
    <content type="text"><![CDATA[一、前言APP 的性能优化之路是永无止境的, 这里学习一个腾讯开源用于提升本地存储效率的轻量级存储框架 MMKV 目前项目中在轻量级存储上使用的是 SharedPreferences, 虽然 SP 兼容性极好, 但 SP 的低性能一直被诟病, 线上也出现了一些因为 SP 导致的 ANR 网上有很多针对 SP 的优化方案, 这里笔者使用的是通过 Hook SP 在 Application 中的创建, 将其替换成自定义的 SP 的方式来增强性能, 但 SDK 28 以后禁止反射 QueuedWork.getHandler 接口, 这个方式就失效了 因此需要一种替代的轻量级存储方案, MMKV 便是这样的一个框架 二、集成与测试以下介绍简单的使用方式, 更多详情请查看 Wiki 2.1 依赖注入在 App 模块的 build.gradle 文件里添加: 1234dependencies &#123; implementation &apos;com.tencent:mmkv:1.0.22&apos; // replace &quot;1.0.22&quot; with any available version&#125; 2.2 初始化1234// 设置初始化的根目录String dir = getFilesDir().getAbsolutePath() + "/mmkv_2";String rootDir = MMKV.initialize(dir);Log.i("MMKV", "mmkv root: " + rootDir); 2.3 获取实例12345678// 获取默认的全局实例MMKV kv = MMKV.defaultMMKV();// 根据业务区别存储, 附带一个自己的 IDMMKV kv = MMKV.mmkvWithID("MyID");// 多进程同步支持MMKV kv = MMKV.mmkvWithID("MyID", MMKV.MULTI_PROCESS_MODE); 2.4 CURD12345678// 添加/更新数据kv.encode(key, value);// 获取数据int tmp = kv.decodeInt(key);// 删除数据kv.removeValueForKey(key); 2.5 SP 的迁移123456789private void testImportSharedPreferences() &#123; MMKV mmkv = MMKV.mmkvWithID("myData"); SharedPreferences old_man = getSharedPreferences("myData", MODE_PRIVATE); // 迁移旧数据 mmkv.importFromSharedPreferences(old_man); // 清空旧数据 old_man.edit().clear().commit(); ......&#125; 2.6 数据测试以下是 MMKV、SharedPreferences 和 SQLite 同步写入 1000 条数据的测试结果 1234567891011121314151617181920// MMKVMMKV: MMKV write int: loop[1000]: 12 msMMKV: MMKV read int: loop[1000]: 3 msMMKV: MMKV write String: loop[1000]: 7 msMMKV: MMKV read String: loop[1000]: 4 ms// SharedPreferencesMMKV: SharedPreferences write int: loop[1000]: 119 msMMKV: SharedPreferences read int: loop[1000]: 3 msMMKV: SharedPreferences write String: loop[1000]: 187MMKV: SharedPreferences read String: loop[1000]: 2 ms// SQLiteMMKV: sqlite write int: loop[1000]: 101 msMMKV: sqlite read int: loop[1000]: 136 msMMKV: sqlite write String: loop[1000]: 29 msMMKV: sqlite read String: loop[1000]: 93 ms 可以看到 MMKV 无论是对比 SP 还是 SQLite, 在性能上都有非常大的优势, 官方提供的数据测试结果如下 更详细的性能测试见 wiki 了解 MMKV 的使用方式和测试结果, 让我对其实现原理产生了很大的好奇心, 接下来便看看它是如何将性能做到这个地步的, 这里对主要对 MMKV 的基本操作进行剖析 初始化 实例化 encode decode 进程读写的同步 我们从初始化的流程开始分析 三、初始化12345678910111213141516171819202122public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123; // call on program start public static String initialize(Context context) &#123; String root = context.getFilesDir().getAbsolutePath() + "/mmkv"; return initialize(root, null); &#125; static private String rootDir = null; public static String initialize(String rootDir, LibLoader loader) &#123; ...... // 省略库文件加载器相关代码 // 保存根目录 MMKV.rootDir = rootDir; // Native 层初始化 jniInitialize(MMKV.rootDir); return rootDir; &#125; private static native void jniInitialize(String rootDir); &#125; MMKV 的初始化, 主要是将根目录通过 jniInitialize 传入了 Native 层, 接下来看看 Native 的初始化操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// native-bridge.cppnamespace mmkv &#123; MMKV_JNI void jniInitialize(JNIEnv *env, jobject obj, jstring rootDir) &#123; if (!rootDir) &#123; return; &#125; const char *kstr = env-&gt;GetStringUTFChars(rootDir, nullptr); if (kstr) &#123; MMKV::initializeMMKV(kstr); env-&gt;ReleaseStringUTFChars(rootDir, kstr); &#125;&#125; &#125;// MMKV.cppstatic unordered_map&lt;std::string, MMKV *&gt; *g_instanceDic;static ThreadLock g_instanceLock;static std::string g_rootDir;void initialize() &#123; // 1.1 获取一个 unordered_map, 类似于 Java 中的 HashMap g_instanceDic = new unordered_map&lt;std::string, MMKV *&gt;; // 1.2 初始化线程锁 g_instanceLock = ThreadLock(); ......&#125;void MMKV::initializeMMKV(const std::string &amp;rootDir) &#123; // 由 Linux Thread 互斥锁和条件变量保证 initialize 函数在一个进程内只会执行一次 // https://blog.csdn.net/zhangxiao93/article/details/51910043 static pthread_once_t once_control = PTHREAD_ONCE_INIT; // 1. 进行初始化操作 pthread_once(&amp;once_control, initialize); // 2. 将根目录保存到全局变量 g_rootDir = rootDir; // 拷贝字符串 char *path = strdup(g_rootDir.c_str()); if (path) &#123; // 3. 根据路径, 生成目标地址的目录 mkPath(path); // 释放内存 free(path); &#125;&#125; 可以看到 initializeMMKV 中主要任务是初始化数据, 以及创建根目录 pthread_once_t: 类似于 Java 的单例, 其 initialize 方法在进程内只会执行一次 创建 MMKV 对象的缓存散列表 g_instanceDic 创建一个线程锁 g_instanceLock mkPath: 根据字符串创建文件目录 接下来我们看看这个目录创建的过程 3.1 目录的创建123456789101112131415161718192021222324252627282930313233// MmapedFile.cppbool mkPath(char *path) &#123; // 定义 stat 结构体用于描述文件的属性 struct stat sb = &#123;&#125;; bool done = false; // 指向字符串起始地址 char *slash = path; while (!done) &#123; // 移动到第一个非 "/" 的下标处 slash += strspn(slash, "/"); // 移动到第一个 "/" 下标出处 slash += strcspn(slash, "/"); done = (*slash == '\0'); *slash = '\0'; if (stat(path, &amp;sb) != 0) &#123; // 执行创建文件夹的操作, C 中无 mkdirs 的操作, 需要一个一个文件夹的创建 if (errno != ENOENT || mkdir(path, 0777) != 0) &#123; MMKVWarning("%s : %s", path, strerror(errno)); return false; &#125; &#125; // 若非文件夹, 则说明为非法路径 else if (!S_ISDIR(sb.st_mode)) &#123; MMKVWarning("%s: %s", path, strerror(ENOTDIR)); return false; &#125; *slash = '/'; &#125; return true;&#125; 以上是 Native 层创建文件路径的通用代码, 逻辑很清晰 好的, 文件目录创建好了之后, Native 层的初始化操作便结束了, 接下来看看 MMKV 实例构建的过程 四、实例化123456789101112131415161718192021222324public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123; @Nullable public static MMKV mmkvWithID(String mmapID, int mode, String cryptKey, String relativePath) &#123; ...... // 执行 Native 初始化, 获取句柄值 long handle = getMMKVWithID(mmapID, mode, cryptKey, relativePath); if (handle == 0) &#123; return null; &#125; // 构建一个 Java 的壳对象 return new MMKV(handle); &#125; private native static long getMMKVWithID(String mmapID, int mode, String cryptKey, String relativePath); // jni private long nativeHandle; private MMKV(long handle) &#123; nativeHandle = handle; &#125;&#125; 可以看到 MMKV 实例构建的主要逻辑通过 getMMKVWithID 方法实现, 看它内部做了什么 12345678910111213141516171819202122232425262728293031323334// native-bridge.cppnamespace mmkv &#123;MMKV_JNI jlong getMMKVWithID( JNIEnv *env, jobject, jstring mmapID, jint mode, jstring cryptKey, jstring relativePath) &#123; MMKV *kv = nullptr; if (!mmapID) &#123; return (jlong) kv; &#125; // 获取独立存储 id string str = jstring2string(env, mmapID); bool done = false; if (cryptKey) &#123; // 获取秘钥 string crypt = jstring2string(env, cryptKey); if (crypt.length() &gt; 0) &#123; if (relativePath) &#123; // 获取相对路径 string path = jstring2string(env, relativePath); // 通过 mmkvWithID 函数获取一个 MMKV 的对象 kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, &amp;path); &#125; else &#123; kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, &amp;crypt, nullptr); &#125; done = true; &#125; &#125; ...... // 强转成句柄, 返回到 Java return (jlong) kv;&#125;&#125; 可以看到最终通过 MMKV::mmkvWithID 函数获取到 MMKV 的对象 1234567891011121314151617181920212223242526272829303132333435// MMKV.cppMMKV *MMKV::mmkvWithID( const std::string &amp;mmapID, int size, MMKVMode mode, string *cryptKey, string *relativePath) &#123; if (mmapID.empty()) &#123; return nullptr; &#125; SCOPEDLOCK(g_instanceLock); // 1. 通过 mmapID 和 relativePath, 组成最终的 mmap 文件路径的 key auto mmapKey = mmapedKVKey(mmapID, relativePath); // 2. 从全局缓存中查找 auto itr = g_instanceDic-&gt;find(mmapKey); if (itr != g_instanceDic-&gt;end()) &#123; MMKV *kv = itr-&gt;second; return kv; &#125; // 3. 创建缓存文件 if (relativePath) &#123; // 根据 mappedKVPathWithID 获取 mmap 的最终文件路径 // mmapID 使用 md5 加密 auto filePath = mappedKVPathWithID(mmapID, mode, relativePath); // 不存在则创建一个文件 if (!isFileExist(filePath)) &#123; if (!createFile(filePath)) &#123; return nullptr; &#125; &#125; ...... &#125; // 4. 创建实例对象 auto kv = new MMKV(mmapID, size, mode, cryptKey, relativePath); // 5. 缓存这个 mmapKey (*g_instanceDic)[mmapKey] = kv; return kv;&#125; mmkvWithID 函数的实现流程非常的清晰, 这里我们主要关注一下实例对象的创建流程 1234567891011121314151617181920212223242526272829303132333435// MMKV.cppMMKV::MMKV( const std::string &amp;mmapID, int size, MMKVMode mode, string *cryptKey, string *relativePath) : m_mmapID(mmapedKVKey(mmapID, relativePath)) // 拼装文件的路径 , m_path(mappedKVPathWithID(m_mmapID, mode, relativePath)) // 拼装 .crc 文件路径 , m_crcPath(crcPathWithID(m_mmapID, mode, relativePath)) // 1. 将文件映射到内存 , m_metaFile(m_crcPath, DEFAULT_MMAP_SIZE, (mode &amp; MMKV_ASHMEM) ? MMAP_ASHMEM : MMAP_FILE) ...... , m_sharedProcessLock(&amp;m_fileLock, SharedLockType) ...... , m_isAshmem((mode &amp; MMKV_ASHMEM) != 0) &#123; ...... // 判断是否为 Ashmem 跨进程匿名共享内存 if (m_isAshmem) &#123; // 创共享内存的文件 m_ashmemFile = new MmapedFile(m_mmapID, static_cast&lt;size_t&gt;(size), MMAP_ASHMEM); m_fd = m_ashmemFile-&gt;getFd(); &#125; else &#123; m_ashmemFile = nullptr; &#125; // 根据 cryptKey 创建 AES 加解密的引擎 if (cryptKey &amp;&amp; cryptKey-&gt;length() &gt; 0) &#123; m_crypter = new AESCrypt((const unsigned char *) cryptKey-&gt;data(), cryptKey-&gt;length()); &#125; ...... // sensitive zone &#123; SCOPEDLOCK(m_sharedProcessLock); // 2. 根据 m_mmapID 来加载文件中的数据 loadFromFile(); &#125;&#125; 可以从 MMKV 的构造函数中看到很多有趣的信息, MMKV 是支持 Ashmem 共享内存的, 这意味着即使是跨进程大数据的传输, 它也能够提供很好的性能支持 不过这里我们主要关注两个关键点 m_metaFile 文件的映射 loadFromFile 数据的载入 接下来我们先看看, 文件的映射 4.1 文件映射到内存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// MmapedFile.cppMmapedFile::MmapedFile(const std::string &amp;path, size_t size, bool fileType) : m_name(path), m_fd(-1), m_segmentPtr(nullptr), m_segmentSize(0), m_fileType(fileType) &#123; // 用于内存映射的文件 if (m_fileType == MMAP_FILE) &#123; // 1. 打开文件 m_fd = open(m_name.c_str(), O_RDWR | O_CREAT, S_IRWXU); if (m_fd &lt; 0) &#123; MMKVError("fail to open:%s, %s", m_name.c_str(), strerror(errno)); &#125; else &#123; // 2. 创建文件锁 FileLock fileLock(m_fd); InterProcessLock lock(&amp;fileLock, ExclusiveLockType); SCOPEDLOCK(lock); // 获取文件的信息 struct stat st = &#123;&#125;; if (fstat(m_fd, &amp;st) != -1) &#123; // 获取文件大小 m_segmentSize = static_cast&lt;size_t&gt;(st.st_size); &#125; // 3. 验证文件的大小是否小于一个内存页, 一般为 4kb if (m_segmentSize &lt; DEFAULT_MMAP_SIZE) &#123; m_segmentSize = static_cast&lt;size_t&gt;(DEFAULT_MMAP_SIZE); // 3.1 通过 ftruncate 将文件大小对其到内存页 // 3.2 通过 zeroFillFile 将文件对其后的空白部分用 0 填充 if (ftruncate(m_fd, m_segmentSize) != 0 || !zeroFillFile(m_fd, 0, m_segmentSize)) &#123; // 说明文件拓展失败了, 移除这个文件 close(m_fd); m_fd = -1; removeFile(m_name); return; &#125; &#125; // 4. 通过 mmap 将文件映射到内存, 获取内存首地址 m_segmentPtr = (char *) mmap(nullptr, m_segmentSize, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0); if (m_segmentPtr == MAP_FAILED) &#123; MMKVError("fail to mmap [%s], %s", m_name.c_str(), strerror(errno)); close(m_fd); m_fd = -1; m_segmentPtr = nullptr; &#125; &#125; &#125; // 用于共享内存的文件 else &#123; ...... &#125;&#125; MmapedFile 的构造函数处理的事务如下 打开指定的文件 创建这个文件锁 修正文件大小, 最小为 4kb 前 4kb 用于统计数据总大小 通过 mmap 将文件映射到内存 好的, 通过 MmapedFile 的构造函数, 我们便能够获取到映射后的内存首地址了, 操作这块内存时 Linux 内核会负责将内存中的数据同步到文件中 比起 SP 的数据同步, mmap 显然是要优雅的多, 即使进程意外死亡, 也能够通过 Linux 内核的保护机制, 将进行了文件映射的内存数据刷入到文件中, 提升了数据写入的可靠性 结下来看看数据的载入 4.2 数据的载入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// MMKV.cppvoid MMKV::loadFromFile() &#123; ......// 忽略匿名共享内存相关代码 // 若已经进行了文件映射 if (m_metaFile.isFileValid()) &#123; // 则获取相关数据 m_metaInfo.read(m_metaFile.getMemory()); &#125; // 获取文件描述符 m_fd = open(m_path.c_str(), O_RDWR | O_CREAT, S_IRWXU); if (m_fd &lt; 0) &#123; MMKVError(&quot;fail to open:%s, %s&quot;, m_path.c_str(), strerror(errno)); &#125; else &#123; // 1. 获取文件大小 m_size = 0; struct stat st = &#123;0&#125;; if (fstat(m_fd, &amp;st) != -1) &#123; m_size = static_cast&lt;size_t&gt;(st.st_size); &#125; // 1.1 将文件大小对其到内存页的整数倍 if (m_size &lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) &#123; ...... &#125; // 2. 获取文件映射后的内存地址 m_ptr = (char *) mmap(nullptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0); if (m_ptr == MAP_FAILED) &#123; ...... &#125; else &#123; // 3. 读取内存文件的前 32 位, 获取存储数据的真实大小 memcpy(&amp;m_actualSize, m_ptr, Fixed32Size); ...... bool loadFromFile = false, needFullWriteback = false; if (m_actualSize &gt; 0) &#123; // 4. 验证文件的长度 if (m_actualSize &lt; m_size &amp;&amp; m_actualSize + Fixed32Size &lt;= m_size) &#123; // 5. 验证文件 CRC 的正确性 if (checkFileCRCValid()) &#123; loadFromFile = true; &#125; else &#123; // 若不正确, 则回调异常 CRC 异常 auto strategic = mmkv::onMMKVCRCCheckFail(m_mmapID); if (strategic == OnErrorRecover) &#123; loadFromFile = true; needFullWriteback = true; &#125; &#125; &#125; else &#123; // 回调文件长度异常 auto strategic = mmkv::onMMKVFileLengthError(m_mmapID); if (strategic == OnErrorRecover) &#123; writeAcutalSize(m_size - Fixed32Size); loadFromFile = true; needFullWriteback = true; &#125; &#125; &#125; // 6. 需要从文件获取数据 if (loadFromFile) &#123; ...... // 构建输入缓存 MMBuffer inputBuffer(m_ptr + Fixed32Size, m_actualSize, MMBufferNoCopy); if (m_crypter) &#123; // 解密输入缓冲中的数据 decryptBuffer(*m_crypter, inputBuffer); &#125; // 从输入缓冲中将数据读入 m_dic m_dic.clear(); MiniPBCoder::decodeMap(m_dic, inputBuffer); // 构建输出数据 m_output = new CodedOutputData(m_ptr + Fixed32Size + m_actualSize, m_size - Fixed32Size - m_actualSize); // 进行重整回写, 剔除重复的数据 if (needFullWriteback) &#123; fullWriteback(); &#125; &#125; // 7. 说明文件中没有数据, 或者校验失败了 else &#123; SCOPEDLOCK(m_exclusiveProcessLock); // 清空文件中的数据 if (m_actualSize &gt; 0) &#123; writeAcutalSize(0); &#125; m_output = new CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size); // 重新计算 CRC recaculateCRCDigest(); &#125; ...... &#125; &#125; ...... m_needLoadFromFile = false;&#125; 好的, 可以看到 loadFromFile 中对于 CRC 验证通过的文件, 会将文件中的数据读入到 m_dic 中缓存, 否则则会清空文件 因此用户恶意修改文件之后, 会破坏 CRC 的值, 这个存储数据便会被作废, 这一点要尤为注意 从文件中读取数据到 m_dic 之后, 会将 mdic 回写到文件中 , 其重写的目的是为了剔除重复的数据 关于为什么会出现重复的数据, 在后面 encode 操作中再分析 4.3 回顾到这里 MMKV 实例的构建就完成了, 有了 m_dic 这个内存缓存, 我们进行数据查询的效率就大大提升了 从最终的结果来看它与 SP 是一致的, 都是初次加载时会将文件中所有的数据加载到散列表中, 不过 MMKV 多了一步数据回写的操作, 因此当数据量比较大时, 对实例构建的速度有一定的影响 123// 写入 1000 条数据之后, MMVK 和 SharedPreferences 实例化的时间对比E/TAG: create MMKV instance time is 4 msE/TAG: create SharedPreferences instance time is 1 ms 从结果上来看, MMVK 的确在实例构造速度上有一定的劣势, 不过得益于是将 m_dic 中的数据写入到 mmap 的内存, 其真正进行文件写入的时机由 Linux 内核决定, 再加上文件的页缓存机制, 所以速度上虽有劣势, 但不至于无法接受 五、encode关于 encode 即数据的添加与更新的流程, 这里以 encodeString 为例 123456789public class MMKV implements SharedPreferences, SharedPreferences.Editor &#123; public boolean encode(String key, String value) &#123; return encodeString(nativeHandle, key, value); &#125; private native boolean encodeString(long handle, String key, String value);&#125; 看看 native 层的实现 1234567891011121314151617181920212223// native-bridge.cppnamespace mmkv &#123;MMKV_JNI jboolean encodeString(JNIEnv *env, jobject, jlong handle, jstring oKey, jstring oValue) &#123; MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle); if (kv &amp;&amp; oKey) &#123; string key = jstring2string(env, oKey); // 若是 value 非 NULL if (oValue) &#123; // 通过 setStringForKey 函数, 将数据存入 string value = jstring2string(env, oValue); return (jboolean) kv-&gt;setStringForKey(value, key); &#125; // 若是 value 为 NULL, 则移除 key 对应的 value 值 else &#123; kv-&gt;removeValueForKey(key); return (jboolean) true; &#125; &#125; return (jboolean) false;&#125;&#125; 这里我们主要分析一下 setStringForKey 这个函数 12345678910// MMKV.cppbool MMKV::setStringForKey(const std::string &amp;value, const std::string &amp;key) &#123; if (key.empty()) &#123; return false; &#125; // 1. 将数据编码成 ProtocolBuffer auto data = MiniPBCoder::encodeDataWithObject(value); // 2. 更新键值对 return setDataForKey(std::move(data), key);&#125; 这里主要分为两步操作 数据编码 更新键值对 5.1 数据的编码MMKV 采用的是 ProtocolBuffer 编码方式, 这里就不做过多介绍了, 具体请查看 Google 官方文档 1234567891011121314151617181920212223242526272829303132333435363738// MiniPBCoder.cppMMBuffer MiniPBCoder::getEncodeData(const string &amp;str) &#123; // 1. 创建编码条目的集合 m_encodeItems = new vector&lt;PBEncodeItem&gt;(); // 2. 为集合填充数据 size_t index = prepareObjectForEncode(str); PBEncodeItem *oItem = (index &lt; m_encodeItems-&gt;size()) ? &amp;(*m_encodeItems)[index] : nullptr; if (oItem &amp;&amp; oItem-&gt;compiledSize &gt; 0) &#123; // 3. 开辟一个内存缓冲区, 用于存放编码后的数据 m_outputBuffer = new MMBuffer(oItem-&gt;compiledSize); // 4. 创建一个编码操作对象 m_outputData = new CodedOutputData(m_outputBuffer-&gt;getPtr(), m_outputBuffer-&gt;length()); // 执行 protocolbuffer 编码, 并输出到缓冲区 writeRootObject(); &#125; // 调用移动构造函数, 重新创建实例返回 return move(*m_outputBuffer);&#125;size_t MiniPBCoder::prepareObjectForEncode(const string &amp;str) &#123; // 2.1 创建 PBEncodeItem 对象用来描述待编码的条目, 并添加到 vector 集合 m_encodeItems-&gt;push_back(PBEncodeItem()); // 2.2 获取 PBEncodeItem 对象 PBEncodeItem *encodeItem = &amp;(m_encodeItems-&gt;back()); // 2.3 记录索引位置 size_t index = m_encodeItems-&gt;size() - 1; &#123; // 2.4 填充编码类型 encodeItem-&gt;type = PBEncodeItemType_String; // 2.5 填充要编码的数据 encodeItem-&gt;value.strValue = &amp;str; // 2.6 填充数据大小 encodeItem-&gt;valueSize = static_cast&lt;int32_t&gt;(str.size()); &#125; // 2.7 计算编码后的大小 encodeItem-&gt;compiledSize = pbRawVarint32Size(encodeItem-&gt;valueSize) + encodeItem-&gt;valueSize; return index;&#125; 可以看到, 再未进行编码操作之前, 编码后的数据大小就已经确定好了, 并且将它保存在了 encodeItem-&gt;compiledSize 中, 接下来我们看看执行数据编码并输出到缓冲区的操作流程 1234567891011121314151617181920212223242526// MiniPBCoder.cppvoid MiniPBCoder::writeRootObject() &#123; for (size_t index = 0, total = m_encodeItems-&gt;size(); index &lt; total; index++) &#123; PBEncodeItem *encodeItem = &amp;(*m_encodeItems)[index]; switch (encodeItem-&gt;type) &#123; // 主要关心编码 String case PBEncodeItemType_String: &#123; m_outputData-&gt;writeString(*(encodeItem-&gt;value.strValue)); break; &#125; ...... &#125; &#125;&#125;// CodedOutputData.cppvoid CodedOutputData::writeString(const string &amp;value) &#123; size_t numberOfBytes = value.size(); ...... // 1. 按照 varint 方式编码字符串长度, 会改变 m_position 的值 this-&gt;writeRawVarint32((int32_t) numberOfBytes); // 2. 将字符串的数据拷贝到编码好的长度后面 memcpy(m_ptr + m_position, ((uint8_t *) value.data()), numberOfBytes); // 更新 position 的值 m_position += numberOfBytes;&#125; 可以看到 CodedOutputData 的 writeString 中按照 protocol buffer 进行了字符串的编码操作 其中 m_ptr 是上面开辟的内存缓冲区的地址, 也就是说 writeString 执行结束之后, 数据就已经被写入缓冲区了 有了编码好的数据缓冲区, 接下来看看更新键值对的操作 5.2键值对的更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// MMKV.cppbool MMKV::setStringForKey(const std::string &amp;value, const std::string &amp;key) &#123; // 编码数据获取存放数据的缓冲区 auto data = MiniPBCoder::encodeDataWithObject(value); // 更新键值对 return setDataForKey(std::move(data), key);&#125;bool MMKV::setDataForKey(MMBuffer &amp;&amp;data, const std::string &amp;key) &#123; ...... // 将键值对写入 mmap 文件映射的内存中 auto ret = appendDataWithKey(data, key); // 写入成功, 更新散列数据 if (ret) &#123; m_dic[key] = std::move(data); m_hasFullWriteback = false; &#125; return ret;&#125;bool MMKV::appendDataWithKey(const MMBuffer &amp;data, const std::string &amp;key) &#123; // 1. 计算 key + value 的 ProtocolBuffer 编码后的长度 size_t keyLength = key.length(); size_t size = keyLength + pbRawVarint32Size((int32_t) keyLength); size += data.length() + pbRawVarint32Size((int32_t) data.length()); SCOPEDLOCK(m_exclusiveProcessLock); // 2. 验证是否有足够的空间, 不足则进行数据重整与扩容操作 bool hasEnoughSize = ensureMemorySize(size); if (!hasEnoughSize || !isFileValid()) &#123; return false; &#125; // 3. 更新文件头的数据总大小 writeAcutalSize(m_actualSize + size); // 4. 将 key 和编码后的 value 写入到文件映射的内存 m_output-&gt;writeString(key); m_output-&gt;writeData(data); // 5. 获取文件映射内存当前 &lt;key, value&gt; 的起始位置 auto ptr = (uint8_t *) m_ptr + Fixed32Size + m_actualSize - size; if (m_crypter) &#123; // 加密这块区域 m_crypter-&gt;encrypt(ptr, ptr, size); &#125; // 6. 更新 CRC updateCRCDigest(ptr, size, KeepSequence); return true;&#125; 好的, 可以看到更新键值对的操作还是比较复杂的, 首先将键值对数据写入到文件映射的内存中, 写入成功之后更新散列数据 关于写入到文件映射的过程, 上面代码中的注释也非常的清晰, 接下来我们 ensureMemorySize 是如何进行数据的重整与扩容的 5.2.1 数据的重整与扩容123456789101112131415161718192021222324252627282930313233343536373839404142// MMKV.cppbool MMKV::ensureMemorySize(size_t newSize) &#123; ...... // 计算新键值对的大小 constexpr size_t ItemSizeHolderSize = 4; if (m_dic.empty()) &#123; newSize += ItemSizeHolderSize; &#125; // 数据重写: // 1. 文件剩余空闲空间少于新的键值对 // 2. 散列为空 if (newSize &gt;= m_output-&gt;spaceLeft() || m_dic.empty()) &#123; // 计算所需的数据空间 static const int offset = pbFixed32Size(0); MMBuffer data = MiniPBCoder::encodeDataWithObject(m_dic); size_t lenNeeded = data.length() + offset + newSize; if (m_isAshmem) &#123; ...... &#125; else &#123; // // 计算每个键值对的平均大小 size_t avgItemSize = lenNeeded / std::max&lt;size_t&gt;(1, m_dic.size()); // 计算未来可能会使用的大小(类似于 1.5 倍) size_t futureUsage = avgItemSize * std::max&lt;size_t&gt;(8, (m_dic.size() + 1) / 2); // 1. 所需空间 &gt;= 当前文件总大小 // 2. 所需空间的 1.5 倍 &gt;= 当前文件总大小 if (lenNeeded &gt;= m_size || (lenNeeded + futureUsage) &gt;= m_size) &#123; // 扩容为 2 倍 size_t oldSize = m_size; do &#123; m_size *= 2; &#125; while (lenNeeded + futureUsage &gt;= m_size); ....... &#125; &#125; ...... // 进行数据的重写 writeAcutalSize(data.length()); ...... &#125; return true;&#125; 从上面的代码我们可以了解到 数据的重写时机 文件剩余空间少于新的键值对大小 散列为空 文件扩容时机 所需空间的 1.5 倍超过了当前文件的总大小时, 扩容为之前的两倍 5.3回顾至此 encode 的流程我们就走完了, 回顾一下整个 encode 的流程 使用 ProtocolBuffer 编码 value 将 key 和 编码后的 value 使用 ProtocolBuffer 的格式 append 到文件映射区内存的尾部 文件空间不足 判断是否需要扩容 进行数据的回写 即在文件后进行追加 对这个键值对区域进行统一的加密 更新 CRC 的值 将 key 和 value 对应的 ProtocolBuffer 编码内存区域, 更新到散列表 m_dic 中 通过 encode 的分析, 我们得知 MMKV 文件的存储方式如下 接下来看看 decode 的流程 六、decodedecode 的过程同样以 decodeString 为例 1234567891011121314151617181920212223242526272829303132333435363738394041// native-bridge.cppMMKV_JNI jstringdecodeString(JNIEnv *env, jobject obj, jlong handle, jstring oKey, jstring oDefaultValue) &#123; MMKV *kv = reinterpret_cast&lt;MMKV *&gt;(handle); if (kv &amp;&amp; oKey) &#123; string key = jstring2string(env, oKey); // 通过 getStringForKey, 将数据输出到传出参数中 value 中 string value; bool hasValue = kv-&gt;getStringForKey(key, value); if (hasValue) &#123; return string2jstring(env, value); &#125; &#125; return oDefaultValue;&#125;// MMKV.cppbool MMKV::getStringForKey(const std::string &amp;key, std::string &amp;result) &#123; if (key.empty()) &#123; return false; &#125; SCOPEDLOCK(m_lock); // 1. 从内存缓存中获取数据 auto &amp;data = getDataForKey(key); if (data.length() &gt; 0) &#123; // 2. 解析 data 对应的 ProtocolBuffer 数据 result = MiniPBCoder::decodeString(data); return true; &#125; return false;&#125;const MMBuffer &amp;MMKV::getDataForKey(const std::string &amp;key) &#123; // 从散列表中获取 key 对应的 value auto itr = m_dic.find(key); if (itr != m_dic.end()) &#123; return itr-&gt;second; &#125; static MMBuffer nan(0); return nan;&#125; 好的可以看到 decode 的流程比较简单, 先从内存缓存中获取 key 对应的 value 的 ProtocolBuffer 内存区域, 再解析这块内存区域, 从中获取真正的 value 值 6.1 思考看到这里可能会有一个疑问, 为什么 m_dic 不直接存储 key 和 value 原始数据呢, 这样查询效率不是更快吗? 如此一来查询效率的确会更快, 因为少了 ProtocolBuffer 解码的过程 从图上的结果可以看出, MMKV 的读取性能时略低于 SharedPreferences 的, 这里笔者给出自己的思考 m_dic 在数据重整中也起到了非常重要的作用, 需要依靠 m_dic 将数据写入到 mmap 的文件映射区, 这个过程是非常耗时的, 若是原始的 value, 则需要对所有的 value 再进行一次 ProtocolBuffer 编码操作, 尤其是当数据量比较庞大时, 其带来的性能损耗更是无法忽略的 既然 m_dic 还承担着方便数据复写的功能, 那能否再添加一个内存缓存专门用于存储原始的 value 呢? 当然可以, 这样 MMKV 的读取定是能够达到 SharedPreferences 的水平, 不过 value 的内存消耗则会加倍, MMKV 作为一个轻量级缓存的框架, 查询时时间的提升幅度还不足以用内存加倍的代价去换取, 我想这是 Tencent 在进行多方面权衡之后, 得到的一个比较合理的解决方案 七、进程读写的同步说起进程间读写同步, 我们很自然的想到 Linux 的共享内存配合信号量使用的案例, 但是这种方式有一个弊端, 那就是当持有锁的进程意外死亡的时候, 并不会释放其拥有的信号量, 若多进程之间存在竞争, 那么阻塞的进程将不会被唤醒, 这是非常危险的 MMKV 是采用 文件锁 的方式来进行进程间的同步操作 LOCK_SH(共享锁): 多个进程可以使用同一把锁, 常被用作读共享锁 LOCK_EX(排他锁): 同时只允许一个进程使用, 常被用作写锁 LOCK_UN: 释放锁 接下来我看看 MMKV 加解锁的操作 7.1 文件共享锁123456789101112131415161718192021222324MMKV::MMKV( const std::string &amp;mmapID, int size, MMKVMode mode, string *cryptKey, string *relativePath) : m_mmapID(mmapedKVKey(mmapID, relativePath)) // 创建文件锁的描述 , m_fileLock(m_metaFile.getFd()) // 描述共享锁 , m_sharedProcessLock(&amp;m_fileLock, SharedLockType) // 描述排它锁 , m_exclusiveProcessLock(&amp;m_fileLock, ExclusiveLockType) // 判读是否为进程间通信 , m_isInterProcess((mode &amp; MMKV_MULTI_PROCESS) != 0 || (mode &amp; CONTEXT_MODE_MULTI_PROCESS) != 0) , m_isAshmem((mode &amp; MMKV_ASHMEM) != 0) &#123; ...... // 根据是否跨进程操作判断共享锁和排它锁的开关 m_sharedProcessLock.m_enable = m_isInterProcess; m_exclusiveProcessLock.m_enable = m_isInterProcess; // sensitive zone &#123; // 文件读操作, 启用了文件共享锁 SCOPEDLOCK(m_sharedProcessLock); loadFromFile(); &#125;&#125; 可以看到在我们前面分析过的构造函数中, MMKV 对文件锁进行了初始化, 并且创建了共享锁和排它锁, 并在跨进程操作时开启, 当进行读操作时, 启动了共享锁 7.2 文件排它锁1234567891011121314151617181920212223242526bool MMKV::fullWriteback() &#123; ...... auto allData = MiniPBCoder::encodeDataWithObject(m_dic); // 启动了排它锁 SCOPEDLOCK(m_exclusiveProcessLock); if (allData.length() &gt; 0) &#123; if (allData.length() + Fixed32Size &lt;= m_size) &#123; if (m_crypter) &#123; m_crypter-&gt;reset(); auto ptr = (unsigned char *) allData.getPtr(); m_crypter-&gt;encrypt(ptr, ptr, allData.length()); &#125; writeAcutalSize(allData.length()); delete m_output; m_output = new CodedOutputData(m_ptr + Fixed32Size, m_size - Fixed32Size); m_output-&gt;writeRawData(allData); // note: don't write size of data recaculateCRCDigest(); m_hasFullWriteback = true; return true; &#125; else &#123; // ensureMemorySize will extend file &amp; full rewrite, no need to write back again return ensureMemorySize(allData.length() + Fixed32Size - m_size); &#125; &#125; return false;&#125; 在进行数据回写的函数中, 启动了排它锁 7.3 读写效率表现其进程同步读写的性能表现如下 可以看到进程同步读写的效率也是非常 nice 的 关于跨进程同步就介绍到这里, 当然 MMKV 的文件锁并没有表面上那么简单, 因为文件锁为状态锁, 无论加了多少次锁, 一个解锁操作就全解除, 显然无法应对子函数嵌套调用的问题, MMKV 内部通过了自行实现计数器来实现锁的可重入性, 更多的细节可以查看 wiki 总结通过上面的分析, 我们对 MMKV 有了一个整体上的把控, 其具体的表现如下所示 项目 评价 描述 正确性 优 支持多进程安全, 使用 mmap, 由操作系统保证数据回写的正确性 时间开销 优 使用 mmap 实现, 减少了用户空间数据到内核空间的拷贝 空间开销 中 使用 protocl buffer 存储数据, 同样的数据会比 xml 和 json 消耗空间小 使用的是数据追加到末尾的方式, 只有到达一定阈值之后才会触发键值合并, 不合并之前会导致同一个 key 存在多份 安全 中 使用 crc 校验, 甄别文件系统和操作系统不稳定导致的异常数据 开发成本 优 使用方式较为简单 兼容性 优 各个安卓版本都前后兼容 虽然 MMKV 一些场景下比 SP 稍慢(如: 首次实例化会进行数据的复写剔除重复数据, 比 SP 稍慢, 查询数据时存在 ProtocolBuffer 解码, 比 SP 稍慢), 但其逆天的数据写入速度、mmap Linux 内核保证数据的同步, 以及 ProtocolBuffer 编码带来的更小的本地存储空间占用等都是非常棒的闪光点 在分析 MMKV 的代码的过程中, 从中学习到了很多知识, 非常感谢 Tencent 为开源社区做出的贡献 八、参考文献 github.com/Tencent/MMK… developers.google.com/protocol-bu… time.geekbang.org/column/arti… www.cnblogs.com/kex1n/p/710…]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BannerViewPage]]></title>
    <url>%2Fposts%2F6831bdd1.html</url>
    <content type="text"><![CDATA[BannerViewPageBanner当前屏幕显示下一页内容的一部分，用ViewPager偏移来实现。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于OKR的解读]]></title>
    <url>%2Fposts%2F5b77eb6.html</url>
    <content type="text"><![CDATA[OKR是一套严密的思考框架和持续的纪律要求，旨在确保员工紧密协作，把精力聚焦在促进组织成长的、可衡量的贡献上。 具体拆解如下： 1、严密的思考框架：OKR意在提升绩效，但如果只是简单的每个季度跟踪一下的你的结果，你不会如偿所愿。 2、持续的纪律要求：OKR代表了一种时间和精力上的承诺。 以季度（或者其他预先规定的周期）为单位刷新OKR； 仔细确认结果达成情况； 如有必要，持续修正现行战略和商业模式； 结果导向。 3、确保员工紧密协作：由于OKR对每个人都充分共享，组织内从上至下都可以看到OKR及其达成情况。 4、精力聚焦：OKR不是，也不应被当成一张待完成的任务清单。OKR的主要目的是用来识别最关键的业务目标，并通过量化的关键结果去衡量目标达成情况。战略就是不做什么和做什么，两者都同等重要，不可偏废！OKR也是如此。你必须做出最终取舍，决定哪些内容才是你最终的关注点。 5、做出可衡量的贡献：任何时候，如有可能，我们都应该尽量避免主观描述KR，KR要能精确地指出它的达成对业务究竟有多大的促进作用。 6、促进组织成长：判断OKR成功与否的最终标准，还是要用结果说话，看你的目标所取得的实际成果如何。]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是灰度发布，灰度测试]]></title>
    <url>%2Fposts%2F5b196854.html</url>
    <content type="text"><![CDATA[什么是灰度发布？灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。 灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。 灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。 灰度发布的意义灰度发布能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。 灰度发布步骤 定义目标 选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等 筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等 部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调 发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表 产品完善 新一轮灰度发布或完整发布]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.lang.ClassNotFoundException:"org.apache.http.ProtocolVersion"]]></title>
    <url>%2Fposts%2Fc7a54c5f.html</url>
    <content type="text"><![CDATA[运行项目遇到以下问题： Caused by: java.lang.ClassNotFoundException: Didn’t find class “org.apache.http.ProtocolVersion” on path: DexPathList[[zip file “/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk”],nativeLibraryDirectories=[/data/user_de/0/com.google.android.gms/app_chimera/m/00000043/MapsDynamite.apk!/lib/arm64-v8a, /system/lib64, /product/lib64]] 解决方案：1.在清单文件增加代码: 12&lt;application android:usesCleartextTraffic="true"&gt; 2.在清单文件清单再加一句代码： 123456 &lt;application android:usesCleartextTraffic="true"&gt; &lt;uses-library android:name="org.apache.http.legacy" android:required="false" /&gt;&lt;/application&gt; 好了，重新运行解决了.最根本的做法是使用https进行接口访问，毕竟涉及数据的安全性。当然了，这需要服务器的支持。还有第三方sdk，也需要使用https。]]></content>
      <categories>
        <category>Android</category>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoogleMap使用介绍]]></title>
    <url>%2Fposts%2F50fe3b5b.html</url>
    <content type="text"><![CDATA[概述通过本文，你可以知道如何使用 GoogleMap 相关 API、定位当前位置、获取当前所在城市、获取当前位置附近的地点、导航、地点搜索等内容。大致内容，可以查看如下思维导图。 特别注意：demo 使用的 GoogleMap key 对应我自己电脑的 keystore，如果重新编译项目，生成的apk使用的是你的电脑的 keystore，和我的 keystore 是不一样的，所以要正常运行， 直接下载我编译好的 apk； 用我的项目包名，和你自己的 keystore 的 SHA-1 去申请新的 GoogleMap key。（方法在下面，往下看哈） 前期准备网络因为国内众所周知的网络问题，谷歌地图的页面加载和 API 的使用会出现无效的情况，如果你要使用或调试，首先要确保是可以科学上网的。 设备Android 设备，必须安装了 Google 服务。 谷歌账号作为用户，不需要拥有或者登录你的 Google 账号。网络和 Google 服务正常即可。 作为开发者，必须拥有一个 Google 账号。要知道，谷歌地图是不开源的，要使用他的 API ，必须用你的包名，和编译 Android app 的 keystore 的 SHA-1，去申请App 对应的 Google Map Key。获取 Key 的教程官网讲得很详细，请看这里 Google API Console 设置完成后，如下图所示： 设置好后，还要确保已经 Enable了对应的API，不然会出现数据访问不到的情况。 把这个 API key 填入 AndroidManifest.xml ： 123&lt;meta-data android:name="com.google.android.geo.API_KEY" android:value="your key" /&gt; Map 相关前提初始化 Google Map布局在你的布局文件里面，只需要如下方式声明一个 Fragment，这个 Fragment 是可以放在 LinearLayout 或 RelativeLayout 下面的。 12345678&lt;fragment android:id="@+id/map" android:layout_width="match_parent" android:layout_height="match_parent" map:uiZoomControls="true" map:uiCompass = "true" class="com.google.android.gms.maps.SupportMapFragment" android:layout_below="@id/layout_btn"/&gt; Activity在 onCreate 的时候，进行初始化操作。 12345678910private GoogleMap mMap;SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager() .findFragmentById(map);mapFragment.getMapAsync(new OnMapReadyCallback() &#123; @Override public void onMapReady(GoogleMap googleMap) &#123; //初始化完 GoogleMap mMap = googleMap; &#125;&#125;); 确保 GoogleMap 实例化在使用 GoogleMap 相关接口前，必须确保 GoogleMap 已经实例化，即已经在 onMapReady回调中获取了 GoogleMap实例。 开关类定位按钮定位功能必须获取用户的位置权限，判断是非获取了用户权限，没有获取则手动请求权限。 12345678910111213141516171819202122232425262728/** * * 检查定位权限，如果未授权则请求该权限 * @return true：已经授权； false：未授权 */private boolean checkLocationPermission() &#123; if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; // Permission to access the location is missing. PermissionUtils.requestPermission(this, LOCATION_PERMISSION_REQUEST_CODE, Manifest.permission.ACCESS_FINE_LOCATION, true); return false; &#125; return true;&#125;public static void requestPermission(FragmentActivity activity, int requestId, String permission, boolean finishActivity) &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)) &#123; // Display a dialog with rationale. PermissionUtils.RationaleDialog.newInstance(requestId, finishActivity) .show(activity.getSupportFragmentManager(), "dialog"); &#125; else &#123; // Location permission has not been granted yet, request it. ActivityCompat.requestPermissions(activity, new String[]&#123;permission&#125;, requestId); &#125;&#125; 要让地图上显示开关按钮，只需要设置mMap.setMyLocationEnabled(true); 点击此按钮，地图的摄像头就会开始移动，定位到当前设备所在位置，如果要获取点击此按钮的回调，可以设置监听器 mMap.setOnMyLocationButtonClickListener 放大／缩小按钮地图的放大缩小，就以摄像头焦点（地图中心）进行缩放。要出现这个开关，只需要 12UiSettings uiSettings = mMap.getUiSettings();uiSettings.setZoomControlsEnabled(true); 指南针按钮12UiSettings uiSettings = mMap.getUiSettings();uiSettings.setCompassEnabled(true); 手势 旋转 12UiSettings uiSettings = mMap.getUiSettings();uiSettings.setRotateGesturesEnabled(mRotateGesturesEnabled); 平移 12UiSettings uiSettings = mMap.getUiSettings();uiSettings.setScrollGesturesEnabled(mScrollGesturesEnabled); 自定义标注清除标注1mMap.clear(); 新增标注增加一个标注，只需要把当前的经纬度，图标，标题等信息传入 MarkerOptions ，之后在 addMarker 到 map对象即可。 1234567LatLng latLng = new LatLng(latitude, longitude);//标记当前坐标mMap.addMarker(new MarkerOptions() .position(latLng) .icon(BitmapDescriptorFactory.fromResource(R.drawable.icon_position_small)) .title(getString(R.string.map_camera_center_location))); 摄像头当前位置123//获取当前摄像头中心点的坐标double latitude = mMap.getCameraPosition().target.latitude;double longitude = mMap.getCameraPosition().target.longitude; 移动相关监听 开始监听 1234567891011121314151617//摄像头开始滑动监听mMap.setOnCameraMoveStartedListener(new GoogleMap.OnCameraMoveStartedListener() &#123; @Override public void onCameraMoveStarted(int reason) &#123; if (reason == GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE) &#123; //表示摄像头移动是为了响应用户在地图上做出的手势，如平移、倾斜、通过捏合手指进行缩放或旋转地图 &#125; else if (reason == GoogleMap.OnCameraMoveStartedListener .REASON_API_ANIMATION) &#123; //表示 API 移动摄像头是为了响应非手势用户操作，如点按 zoom 按钮、点按 My Location 按钮或点击标记 &#125; else if (reason == GoogleMap.OnCameraMoveStartedListener .REASON_DEVELOPER_ANIMATION) &#123; //表示您的应用已发起摄像头移动 &#125; &#125;&#125; ; 取消 1234567//摄像头移动停止状态的监听mMap.setOnCameraIdleListener(new GoogleMap.OnCameraIdleListener() &#123; @Override public void onCameraIdle() &#123; &#125;&#125;); 停止 1234567//摄像头移动中被取消时的监听mMap.setOnCameraMoveCanceledListener(new GoogleMap.OnCameraMoveCanceledListener() &#123; @Override public void onCameraMoveCanceled() &#123; &#125;&#125;); 点击监听点击123456789//点击地图上某个坐标mMap.setOnMapClickListener(new GoogleMap.OnMapClickListener() &#123; @Override public void onMapClick(LatLng latLng) &#123; Toast.makeText(MapActivity.this, getString(R.string.map_click_tip, latLng.latitude, latLng.longitude), Toast.LENGTH_SHORT).show(); &#125;&#125;); 长按123456789//长按地图上某个坐标mMap.setOnMapLongClickListener(new GoogleMap.OnMapLongClickListener() &#123; @Override public void onMapLongClick(LatLng latLng) &#123; Toast.makeText(MapActivity.this, getString(R.string.map_long_click_tip, latLng.latitude, latLng.longitude), Toast.LENGTH_SHORT).show(); &#125;&#125;); 点击景点123456789//点击地图上某个景点mMap.setOnPoiClickListener(new GoogleMap.OnPoiClickListener() &#123; @Override public void onPoiClick(PointOfInterest pointOfInterest) &#123; Toast.makeText(MapActivity.this, getString(R.string.map_place_click_tip, pointOfInterest.name, pointOfInterest.placeId, pointOfInterest.latLng.latitude, pointOfInterest.latLng.longitude), Toast.LENGTH_SHORT).show(); &#125;&#125;); 快照快照分两种，一种是直接不管地图有没有加载完，就把当前的地图截屏，如果此时地图未加载完，截取的图片会出现模糊的情况；另外一种是判断地图是否在加载中，如果是，则等加载完毕再截图，如果不是，就直接截图。 123456789101112131415161718192021222324252627//是否等待地图加载完毕if (mWaitForMapLoaded) &#123; //获取加载完的高清图片 mMap.setOnMapLoadedCallback(new GoogleMap.OnMapLoadedCallback() &#123; @Override public void onMapLoaded() &#123; if (null != mMap) &#123; mMap.snapshot(new GoogleMap.SnapshotReadyCallback() &#123; @Override public void onSnapshotReady(Bitmap bitmap) &#123; //获取bitmap &#125; &#125;); &#125; &#125; &#125;);&#125; else &#123; //未加载完，就执行快照功能，会导致截取模糊图片 mMap.snapshot(new GoogleMap.SnapshotReadyCallback() &#123; @Override public void onSnapshotReady(Bitmap bitmap) &#123; //获取bitmap &#125; &#125;);&#125; GoogleApiClient前提 初始化 GoogleApiClient 在 onCreate 的时候进行初始化操作 123456789101112131415161718192021222324252627282930313233343536373839/** * 初始化 google client 用于获取地点信息 */private void createGoogleApiClient() &#123; if (mGoogleApiClient == null) &#123; mGoogleApiClient = new GoogleApiClient .Builder(this) .addApi(Places.GEO_DATA_API) .addApi(Places.PLACE_DETECTION_API) .addApi(LocationServices.API) .addConnectionCallbacks(new GoogleApiClient.ConnectionCallbacks() &#123; @Override public void onConnected(@Nullable Bundle bundle) &#123; //连接成功 mConnected = true; &#125; @Override public void onConnectionSuspended(int i) &#123; //连接暂停 &#125; &#125;) .addOnConnectionFailedListener(new GoogleApiClient.OnConnectionFailedListener() &#123; @Override public void onConnectionFailed(@NonNull ConnectionResult connectionResult) &#123; //连接失败 mConnected = false; &#125; &#125;) .enableAutoManage(this, new GoogleApiClient.OnConnectionFailedListener() &#123; @Override public void onConnectionFailed(@NonNull ConnectionResult connectionResult) &#123; //连接失败 mConnected = false; &#125; &#125;) .build(); &#125;&#125; 在 onStart() 的时候连接，在 onStop() 的时候，断开连接。 123456789101112131415@Overrideprotected void onStart() &#123; super.onStart(); if (null != mGoogleApiClient) &#123; mGoogleApiClient.connect(); &#125;&#125;@Overrideprotected void onStop() &#123; super.onStop(); if (null != mGoogleApiClient) &#123; mGoogleApiClient.disconnect(); &#125;&#125; 使用位置相关 API 的前提，必须确保用户授予位置权限。方法同上的 checkLocationPermission() 获取当前定位的经纬度坐标科普 WGS-84 国际标准的坐标系，国际标准的 GPS 设备定位获取的就是这种坐标。简称 地球坐标系。 GCJ-02 在我们国家，据说是为了保密，我们不使用 WGS-84 坐标，而是使用经过加密的 GCJ-02，高德地图，谷歌地图（国内板块）都是使用这个坐标系。这个就是俗称的 火星坐标系。 其他坐标系 比如百度地图，他用的是他们家的 BD-09 坐标，这个只适用于百度相关产品。搜狗地图也有自己的坐标。 格式注意到谷歌地图的坐标是 latitude, longitude 格式，即 纬度，经度 格式。和国内的百度，高德坐标写法是反过来的。国内的一般是 经度，纬度 的方式。 API1234567Location lastLocation = LocationServices.FusedLocationApi.getLastLocation(mGoogleApiClient);if (null != lastLocation) &#123; double latitude = lastLocation.getLatitude(); double longitude = lastLocation.getLongitude();&#125; else &#123; &#125; 刚开始我也以为这么简单就可以了，在测试设备上确实可以获取到坐标，但是实际上，大多数情况，在第一次运行定位的时候，获取的 Location 对象是为null。所以还需要注册位置变化的监听。等监听到位置信息后，移除此监听，防止不断监听引起高耗电现象。这部分百度地图用得很方便，他封装好了，但是谷歌地图就要自己实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private long UPDATE_INTERVAL = 10 * 1000; /* 10 secs */private long FASTEST_INTERVAL = 1500; /* 1.5 sec */private final int MAX_TIME = 2; //最多定位次数private int time;if (null != lastLocation) &#123; //.....&#125; else &#123; //如果获取不到位置信息，注册位置变化监听 regLocationUpdates();&#125;private void regLocationUpdates() &#123; if (!checkLocationPermission()) &#123; showContentText(getString(R.string.cilent_permission_failed)); return; &#125; LocationRequest locationRequest = LocationRequest.create() .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY) .setInterval(UPDATE_INTERVAL) .setFastestInterval(FASTEST_INTERVAL); LocationServices.FusedLocationApi.requestLocationUpdates(mGoogleApiClient, locationRequest, new LocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; time++; //如果获取到位置信息，则移除位置变化监听 if (null != location) &#123; LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this); //获取定位的经纬度 double latitude = location.getLatitude(); double longitude = location.getLongitude(); return; &#125; //如果超过最大的定位次数则停止位置变化监听 if (time == MAX_TIME) &#123; //移除位置变化监听 LocationServices.FusedLocationApi.removeLocationUpdates(mGoogleApiClient, this); //获取当前位置失败 &#125; &#125; &#125;);&#125; 现在终于获取到定位坐标了，等等，好像不太对，这个坐标和我实际位置好像有不少的偏差…..我打开了 GoogleMap 这个官方的 APP，点击了他的定位。这下就懵逼了，怎么官方的这个是没问题了，误差很小…. 我明明用的是 GoogleMap 的 API，为什么定位会不一样？ 原因在刚才的坐标系里面，谷歌地图的国内板块是用 GCJ-02，但是定位 API 获取的坐标是国际标准坐标 WGS-84，所以需要把 WGS-84 转化 GCJ-02。 那谷歌地图 APP 上为什么可以呢？ 我猜测，谷歌地图在访问网络的时候，会进行位置判断，如果是国内坐标，就进行转换，国外坐标就不转换。 WGS-84 转化 GCJ-02 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static double a = 6378245.0;static double ee = 0.00669342162296594323;/** * 把 WGS-84 转换成 GCJ-02 * @param wgLoc * @return */public static LatLng transformFromWGSToGCJ(LatLng wgLoc) &#123; //如果在国外，则默认不进行转换 if (outOfChina(wgLoc.latitude, wgLoc.longitude)) &#123; //return new LatLng(wgLoc.latitude, wgLoc.longitude); return wgLoc; &#125; double dLat = transformLat(wgLoc.longitude - 105.0, wgLoc.latitude - 35.0); double dLon = transformLon(wgLoc.longitude - 105.0, wgLoc.latitude - 35.0); double radLat = wgLoc.latitude / 180.0 * Math.PI; double magic = Math.sin(radLat); magic = 1 - ee * magic * magic; double sqrtMagic = Math.sqrt(magic); dLat = (dLat * 180.0)/ ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI); dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI); return new LatLng(wgLoc.latitude + dLat, wgLoc.longitude + dLon);&#125;private static double transformLat(double x, double y) &#123; double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(x &gt; 0 ? x : -x); ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0; ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0; return ret;&#125;private static double transformLon(double x, double y) &#123; double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(x &gt; 0 ? x : -x); ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0; ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0; ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0; return ret;&#125;/** * 判断是否在中国以外 * @param lat * @param lon * @return */public static boolean outOfChina(double lat, double lon) &#123; if (lon &lt; 72.004 || lon &gt; 137.8347) return true; if (lat &lt; 0.8293 || lat &gt; 55.8271) return true; return false;&#125; 根据经纬度获取附近地点通过经纬度获取对应的地理位置信息，这个叫做反地理编码请求，以前百度地图有个 API mGeoCoder.reverseGeoCode(mReverseGeoCodeOption);可以直接使用，Google地图也有类似的，只不过在我使用过程中存在 bug。 心急想马上能用的，可以自己调到 Web API 中的 【根据经纬度获取附近地点】章节。 此处存在的问题：如果坐标切换为国外，就会造成获取数据为null。即使修改地区 mGeocoder = new Geocoder(this, Locale.JAPAN) 也无效。 初始化 Geocoder 123mGeocoder = new Geocoder(this, Locale.getDefault());//设置区域//mGeocoder = new Geocoder(this, Locale.JAPAN); 在子线程获取数据 1234567891011121314List&lt;Address&gt; addressList = mGeocoder.getFromLocation(latitude, longitude, maxResult);if (null != addressList &amp;&amp; addressList.size() &gt; 0) &#123; //遍历获取附近地点信息 for (Address address : addressList) &#123; //省 String adminArea = address.getAdminArea(); //市 String city = address.getLocality(); //地址 String feature = address.getFeatureName(); &#125; &#125; else &#123; //获取附近地点失败&#125; startActivity方式地点搜索 打开 Activity private static final int REQUEST_CODE_AUTOCOMPLETE = 2; 123456789101112131415161718/** * 打开搜索的 Activity */private void openAutocompleteActivity() &#123; try &#123; // MODE_FULLSCREEN 全屏方式启动一个 Activity // MODE_OVERLAY 启动浮在界面上的控件 Intent intent = new PlaceAutocomplete.IntentBuilder(PlaceAutocomplete.MODE_OVERLAY) .build(this); startActivityForResult(intent, REQUEST_CODE_AUTOCOMPLETE); &#125; catch (GooglePlayServicesRepairableException e) &#123; GoogleApiAvailability.getInstance().getErrorDialog(this, e.getConnectionStatusCode(), 0).show(); &#125; catch (GooglePlayServicesNotAvailableException e) &#123; String message = "Google Play Services is not available: " + GoogleApiAvailability.getInstance().getErrorString(e.errorCode); Toast.makeText(this, message, Toast.LENGTH_SHORT).show(); &#125;&#125; 在 onActivityResult 回调中获取搜索的地点信息 123456789101112131415161718192021222324252627@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_CODE_AUTOCOMPLETE) &#123; if (resultCode == RESULT_OK) &#123; Place place = PlaceAutocomplete.getPlace(this, data); String placeText = null; if (null != place) &#123; placeText = "place.getId() = " + place.getId() + "\nplace.getName() = " + place.getName() + "\nplace.getLatLng().latitude = " + place.getLatLng().latitude + "\nplace.getLatLng().longitude = " + place.getLatLng().longitude + "\nplace.getAddress() = " +place.getAddress() + "\nplace.getPhoneNumber() = " + place.getPhoneNumber() + "\nplace.getLocale() = " + place.getLocale() + "\n......."; &#125; Toast.makeText(this, getString(R.string.start_by_activity_btn_search_place_result, placeText), Toast.LENGTH_LONG).show(); &#125; else if (resultCode == PlaceAutocomplete.RESULT_ERROR) &#123; //错误码 Status status = PlaceAutocomplete.getStatus(this, data); &#125; else if (resultCode == RESULT_CANCELED) &#123; //取消 &#125; &#125; &#125; 导航123456789101112131415161718192021222324252627/** * 开启导航 * @param latitude * @param longitude */private void startNavigation(double latitude, double longitude) &#123; try &#123; Uri gmmIntentUri = Uri.parse("google.navigation:q="+latitude+","+longitude+"&amp;mode=d"); Intent mapIntent = new Intent(Intent.ACTION_VIEW, gmmIntentUri); mapIntent.setPackage("com.google.android.apps.maps"); startActivity(mapIntent); &#125; catch (Exception e) &#123; //提示未安装google map //开启google map下载界面 showGoogleMapDownloadView(); &#125;&#125;/** * 开启google map下载界面 */private void showGoogleMapDownloadView() &#123; Uri uri = Uri.parse("market://details?id=com.google.android.apps.maps"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); this.startActivity(intent);&#125; 附近地点 获取定位权限 获取方法和前面一样，使用 checkLocationPermission() 打开 Activity，开启附近地点选择 private static final int PLACE_PICKER_REQUEST = 3; 12345678PlacePicker.IntentBuilder builder = new PlacePicker.IntentBuilder();try &#123; startActivityForResult(builder.build(this), PLACE_PICKER_REQUEST);&#125; catch (GooglePlayServicesRepairableException e) &#123; e.printStackTrace();&#125; catch (GooglePlayServicesNotAvailableException e) &#123; e.printStackTrace();&#125; 在 onActivityResult 获取选择的地点信息 123456789@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == PLACE_PICKER_REQUEST) &#123; if (resultCode == RESULT_OK) &#123; Place place = PlacePicker.getPlace(this, data); //place.getName() .... &#125; &#125;&#125; Places当前位置及附近地点API12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private final int mMaxEntries = 5;/** * 获取当前位置及附近地点 */private void getCurrentPlaces()&#123; if (!mConnected) &#123; return; &#125; if (!checkLocationPermission()) &#123; //未授权定位 return; &#125; PendingResult&lt;PlaceLikelihoodBuffer&gt; result = Places.PlaceDetectionApi .getCurrentPlace(mGoogleApiClient, null); result.setResultCallback(new ResultCallback&lt;PlaceLikelihoodBuffer&gt;() &#123; @Override public void onResult(@NonNull PlaceLikelihoodBuffer likelyPlaces) &#123; int i = 0; String[] likelyPlaceNames = new String[mMaxEntries]; String[] likelyPlaceAddresses = new String[mMaxEntries]; String[] likelyPlaceAttributions = new String[mMaxEntries]; LatLng[] likelyPlaceLatLngs = new LatLng[mMaxEntries]; for (PlaceLikelihood placeLikelihood : likelyPlaces) &#123; // Build a list of likely places to show the user. Max 5. likelyPlaceNames[i] = (String) placeLikelihood.getPlace().getName(); likelyPlaceAddresses[i] = (String) placeLikelihood.getPlace().getAddress(); likelyPlaceAttributions[i] = (String) placeLikelihood.getPlace() .getAttributions(); likelyPlaceLatLngs[i] = placeLikelihood.getPlace().getLatLng(); i++; //String placeId = (String) placeLikelihood.getPlace().getId(); if (i &gt; (mMaxEntries - 1)) &#123; break; &#125; &#125; likelyPlaces.release(); StringBuilder builder = new StringBuilder(); for (String placeName : likelyPlaceNames) &#123; builder.append(placeName + "\n"); &#125; //显示地点列表 //builder.toString() &#125; &#125;);&#125; 根据 PlaceID 获取对应地点在 onResult 返回的 places 一般只有一个，所以取第一个元素，就是 id 对应的地点信息。 1234567891011121314151617181920212223/** * 通过placeId获取对应的位置信息 * @param placeId */private void getPlaceById(String placeId)&#123; if (TextUtils.isEmpty(placeId)) &#123; return; &#125; Places.GeoDataApi.getPlaceById(mGoogleApiClient, placeId) .setResultCallback(new ResultCallback&lt;PlaceBuffer&gt;() &#123; @Override public void onResult(PlaceBuffer places) &#123; if (places.getStatus().isSuccess() &amp;&amp; places.getCount() &gt; 0) &#123; Place myPlace = places.get(0); //获取id对应的Place &#125; else &#123; //没有获取到数据 &#125; places.release(); &#125; &#125;);&#125; Web API这里说的 Web API 是指：通过拼接 url 的方式，向 Google 服务器请求数据，服务器会返回一段 JSON，我们本地再用 fastjson 解析，获取对应的数据。 根据坐标获取所在城市这里的 URL 可以这样拼接 1private static final String GOOGLE_MAP_URL = "https://maps.google.com/maps/api/geocode/json?language=%1$s&amp;sensor=true&amp;latlng=%2$s,%3$s"; 其中 %1$s 对应的是语言，比如我要返回的是中文，那么对于的就是 zh-CN*，%2$s %3$s* 对应的就是纬度和经度。 12345678910private static final String DEFAULT_LANGUAGE = "zh-CN";/** * 拼接url(默认设置语言为中文) * * @param latitude * @param longitude */public static String getGoogleMapUrl(double latitude, double longitude) &#123; return String.format(GOOGLE_MAP_URL, DEFAULT_LANGUAGE, Double.valueOf(latitude), Double.valueOf(longitude));&#125; 这样，外面只需要直接调这个方法，参数传入纬度、经度，就会返回拼接好的 URL。 获取了 URL，我们就可以异步访问网络，去获取数据了。这里主要讲下思路，详细代码，可以自己查看 Demo。 以Demo为例，拼接的URL为： 1https://maps.google.com/maps/api/geocode/json?language=zh-CN&amp;sensor=true&amp;latlng=22.536817569098282,113.97451490163802 获取的 JSON 如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; "results": [ &#123; "address_components": [ &#123; "long_name": "9028", "short_name": "9028", "types": [ "street_number" ] &#125;, &#123; "long_name": "深南大道", "short_name": "深南大道", "types": [ "route" ] &#125;, &#123; "long_name": "华侨城", "short_name": "华侨城", "types": [ "neighborhood", "political" ] &#125;, &#123; "long_name": "南山区", "short_name": "南山区", "types": [ "political", "sublocality", "sublocality_level_1" ] &#125;, &#123; "long_name": "深圳市", "short_name": "深圳市", "types": [ "locality", "political" ] &#125;, &#123; "long_name": "广东省", "short_name": "广东省", "types": [ "administrative_area_level_1", "political" ] &#125;, /** * 篇幅原因，省略其余数据 */ "status": "OK"&#125; 其中 type 对应的值是 locality 的就是城市名字，political 代表政治实体。 关键代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 根据经纬度获取对应的城市 * @param latitude * @param longitude */private void getCityByLatlngWeb(double latitude, double longitude) &#123; String urlString = GoogleMapUrlUtil.getGoogleMapUrl(latitude, longitude); if (URLUtil.isNetworkUrl(urlString)) &#123; new GeocodeTask().execute(urlString); &#125;&#125;class GeocodeTask extends AsyncTask&lt;String, Void, JSONObject&gt; &#123; @Override protected void onPreExecute() &#123; &#125; @Override protected com.alibaba.fastjson.JSONObject doInBackground(String... params) &#123; //请求网络，并且转化为 JSONObject 对象 return GoogleMapUrlUtil.returnResult(HttpUtils.doGet(params[0])); &#125; @Override protected void onPostExecute(com.alibaba.fastjson.JSONObject result) &#123; if (null != result) &#123; JSONArray jsonArray = result.getJSONArray("results"); if (null != jsonArray) &#123; Object firstObj = jsonArray.get(0); if (null != firstObj) &#123; GeocodeBean bean = JSON.parseObject(firstObj.toString(), GeocodeBean.class); //获取所在城市 String city = getLocality(bean); &#125; &#125; &#125; &#125;&#125;public class GeocodeBean &#123; private List&lt;AddressComponent&gt; address_components; private String formatted_address; //geometry private String place_id; private List&lt;String&gt; types; //set, get 方法自己补充哈&#125;/** * 从数据集里面获取所在城市 * @param bean * @return */private String getLocality(GeocodeBean bean) &#123; boolean isFound = false; if (null != bean) &#123; List&lt;AddressComponent&gt; list = bean.getAddress_components(); if (null != list) &#123; for (AddressComponent address : list) &#123; List&lt;String&gt; types = address.getTypes(); for (String type : types) &#123; if ("locality".equals(type)) &#123; isFound = true; break; &#125; &#125; if (isFound) &#123; return address.getShort_name(); &#125; &#125; &#125; &#125; return null;&#125; 根据经纬度获取附近地点前面获取对应城市中用的 URL 很方便，基本上没有限制。但是获取附近地点的就没这么好了，在拼接 URL 的时候，需要加上谷歌授权给你的 Web API key。这个是官方推荐的做法，详情可以查看官网的介绍 特别注意这里有一点要特别注意的，这里说的 Web API key 必须要重新申请的。之前我们使用 GoogleMap 的时候已经申请了 KEY，但是选项选择的是【Android apps】，只是作用于 Android Map 相关 API，这个时候访问 Web API 必须重新申请多一个 KEY。申请方法和前面一样，只是选项为【None】即可。 设置完之后如果一般间隔几分钟就可以调用，如果不行，就要手动开启服务。点击此处开启,选择对应的项目，【启用】 Google Places API Web Service 服务。 1private static final String GOOGLE_MAP_PLACES_URL = "https://maps.googleapis.com/maps/api/place/nearbysearch/json?language=%1$s&amp;location=%2$s,%3$s&amp;radius=%4$s&amp;type=%5$s&amp;key=%6$s"; 这下参数有点多了哈，前面3个和之前一样，分别对应语言、纬度、经度。第四个参数是查询地点的半径多大，第五个是类型，这里我使用的是 point_of_interest 意思是已经命名的景点，其他类型可以查看官网，最后一个参数是你的 APP 申请的 Key值。 关键代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 获取经纬度对应的附近地点 * @param latitude * @param longitude */private void getPlacesByLatLngWeb(double latitude, double longitude) &#123; String url = GoogleMapUrlUtil.getGoogleMapPlacesUrl(latitude, longitude); if (URLUtil.isNetworkUrl(url)) &#123; new NearbyPlacesTask().execute(url); &#125;&#125;class NearbyPlacesTask extends AsyncTask&lt;String, Void, JSONObject&gt; &#123; @Override protected JSONObject doInBackground(String... params) &#123; return GoogleMapUrlUtil.returnResult(HttpUtils.doGet(params[0])); &#125; @Override protected void onPostExecute(JSONObject result) &#123; if (null != result) &#123; JSONArray jsonArray = result.getJSONArray("results"); if (null != jsonArray) &#123; List&lt;NearbyPlaceBean&gt; list = JSON.parseArray(jsonArray.toString(), NearbyPlaceBean.class); //遍历 list 可以获取对应的附近地点信息 //list的size能比较大，可以根据项目需求，指截取前面10个。 &#125; &#125; &#125;&#125;public class NearbyPlaceBean &#123; //geometry //icon private String id; //1f7541b5f729cdc8bc8bb546f205848c50315af7 private String name; //澎柏白金假日公寓 //photos private String place_id; //ChIJX9_kRAXsAzQRKmc97njB67c //reference //scope //types private String vicinity; //深圳市宝安区 private GeometryBean geometry; //set，get 自己补充哈&#125; 实战：附近地点推荐可以像上面那样使用 Activity 的方式，弹出 Google 自带的地点推荐／选取界面，但是这样的UI定制性低，不能按照项目需求显示界面。所以根据上面学习到的东西，我重新写了个类似的界面，实现地点推荐、搜索、选择和截图功能的功能。考虑到频繁调接口会损耗请求次数，所以我设置了个半径，超过半径的才重新请求数据。 限制／收费前面我把类型分为 Map，Places主要原因就是，他们的收费标准是不同的。详情可见 Android 标准方案 高级 Google Maps Android API 不受限制地免费使用。1 定价基于所需数量。如需了解详细信息，请参阅Premium Plan使用率和限制。 Google Places API for Android 默认每天 1,000 次免费请求，信用卡验证后可增至每天 150,000 次免费请求。符合要求的应用可免费提升。详情 —- Web 服务 标准 高级 Google Places API Web Service 每天 150,000 次免费请求（信用卡验证后）。 定价基于所需数量。如需了解详细信息，请参阅Premium Plan使用率和限制。 学习资料官方 Demo官方 Demo 要跑起来，必须像前面的方式一样，去申请对应的 Key。 android-samples-apiDemos介绍 Map 相关 API。 android-play-places介绍 Places 相关 API 。包括地点搜索，附近地点选择，地点补全等。 android-maps-utils点聚合 Clustering 可以通过这个 demo 学习，GoogleMap的点聚合和百度是一样的用法，外层代码基本上是一样的。 工具类网页 API Console （Key 管理控制台） Google Map API 查询 坐标反查 (通过经纬度查对应地点)GoogleMap(谷歌地图直接把经纬度输入输入框即可查询，例如输入：22.536817569098282,113.97451490163802 )高德地图百度地图 相关参考[1]官方 Map 教程 https://developers.google.com/maps/documentation/android-api/[2]官方 Places 教程 https://developers.google.com/places/android-api/[3]启动 GoogleMap https://developers.google.com/maps/documentation/android-api/intents[4]Android使用intent调取导航或者地图 https://blog.csdn.net/qwer4755552/article/details/51659833[5]关于地图和偏移的那些事 https://blog.csdn.net/sanjay_f/article/details/48493699[6]地图坐标转换大全 http://www.eoeandroid.com/forum.php?mod=viewthread&amp;tid=332419[7]Show Popup when Location access is disable by user (Andorid Google Maps) https://stackoverflow.com/questions/24160472/show-popup-when-location-access-is-disable-by-user-andorid-google-maps[8]How to show enable location dialog like Google maps? https://stackoverflow.com/questions/29801368/how-to-show-enable-location-dialog-like-google-maps]]></content>
      <categories>
        <category>Android</category>
        <category>Map</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最新Android框架排行榜，上百项资源汇总不容错过]]></title>
    <url>%2Fposts%2Fb0de6447.html</url>
    <content type="text"><![CDATA[Android框架排行榜1.Retrofit 一句话介绍：Retrofit是一款类型安全的网络框架，基于HTTP协议，服务于Android和java语言 上榜理由：Retrofit以21.8k的stars量雄踞github中android子标题榜首，第一当之无愧。 官网地址：http://square.github.io/retrofit/ github：https://github.com/square/retrofit 作者：square团队 使用：1compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos; 2.okhttp 一句话介绍：okhttp是一款基于HTTP和HTTP2.0协议的网络框架，服务于java和android客户端 上榜理由，okhttp以20.4k的stars量雄踞github中android子标题第二名。大型公司比如淘宝也封装的是okhttp。Retrofit2.0开始内置okhttp框架，Retrofit专注封装接口完成业务需求，okhttp专注网络请求的安全高效，笔者将两者区分开，是想让后来学习者知道，这是两套框架，学习框架原理时可以分开学习，以免理解混乱。 官网地址：http://square.github.io/okhttp/ github：https://github.com/square/okhttp 作者：square团队 使用：1compile &apos;com.squareup.okhttp3:okhttp:3.9.1&apos; 3.Butter Knife 一句话介绍：Butter Knife所提供了一种能力——使用注解生成模板代码，将view与方法和参数绑定。 上榜理由：github上16.5K个star，配合Androidstudio提供的Butter Knife插件，帮助开发者省却了频繁findviewbyid的烦恼，最新的Butter Knife还提供了onclick绑定以及字符串的初始化，初学者可以查阅Butter Knife以及Butter Knife插件进一步学习！ 官网地址：http://jakewharton.github.io/butterknife/ github：https://github.com/JakeWharton/butterknife 作者：JakeWharton ，也是square团队成员之一 使用：1234dependencies &#123; compile &apos;com.jakewharton:butterknife:8.8.1&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.8.1&apos;&#125; 4.MPAndroidChart 一句话介绍：MPAndroidChart是一款图表框架 上榜理由：github上16.1K个star，以快速、简洁。强大著称的图表框架 官网地址：https://github.com/PhilJay/MPAndroidChart github：https://github.com/PhilJay/MPAndroidChart 作者：PhilJay 使用：在AS中加入Gradle依赖 在根目录的 build.gradle上加入: 12345allprojects &#123; repositories &#123; maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 在app的build.gradle上加入： 123dependencies &#123; compile &apos;com.github.PhilJay:MPAndroidChart:v3.0.3&apos;&#125; 5.glide 一句话介绍：glide是一款专注于提供流畅划动能力的“图片加载和缓存框架” 上榜理由：15.9k个star，图片加载类框架排名第一的框架，google 在2014开发者大会上演示的camera app就是基于gilde框架开发的 github：https://github.com/bumptech/glide 作者：Bump Technologies团队 使用：12345678repositories &#123; mavenCentral()&#125;dependencies &#123; implementation &apos;com.github.bumptech.glide:glide:4.5.0&apos; annotationProcessor &apos;com.github.bumptech.glide:compiler:4.5.0&apos;&#125; 6.leakcanary 一句话介绍：一款内存检测框架，服务于java和android客户端 上榜理由：方便，简洁是leakcanary最大的特点，只需在应用的apllication中集成，就可以直接使用它；15.5k个star说明了它有多么受欢迎 github：https://github.com/square/leakcanary 作者：square团队 使用：12345dependencies &#123; debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos; releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos; testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos; &#125; 在 Application 中写入: 12345678910111213public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; &#125; LeakCanary.install(this); // Normal app init code... &#125;&#125; 7.Android-Universal-Image-Loader 一句话介绍：曾经的图片加载框架王者，android开发老手都用过它 上榜理由:android端图片加载框架的老大哥了，15.3k个star足以证明它的热门，UIL与gilde最大区别是可定制，UIL提供了大量配置方式，图片加载状态的回调（成功，失败，进行中），加载动画等；以及提供了移动端图片加载框架的缓存思路：三级缓存策略 sd卡-内存-网络；值得注意的是，UIL以及两年未更新了，但笔者仍推荐各位使用！ github：https://github.com/nostra13/Android-Universal-Image-Loader 作者：nostra13 使用： 下载地址 universal-image-loader-1.9.5.jar 8.EventBus 一句话介绍：EventBus是一款本地组件间通信框架 上榜理由：组件间通信框架star量第一：14.8k，在大型项目的Activities，fragments，Threads，Services都可以看到它的使用场景，尽管EventBus在向未创建的组件传递事件时有些局限，仅适合在“活着的”组件间传递消息，但仍不妨碍它活跃在各个大型项目各个场景里。 官网地址：http://greenrobot.org/eventbus/documentation/how-to-get-started/ github：https://github.com/greenrobot/EventBus 作者：greenrobot 使用：1compile &apos;org.greenrobot:eventbus:3.1.1&apos; 9.zxing 一句话介绍：条码图像处理库 上榜理由：如果你用过二维码，你肯定已经间接使用过大名鼎鼎的zxing了。13.9K的star量，让它排在本榜单第九，实至名归，如果你有了解二维码的需求，不妨从了解、修改它源码入手。 github：https://github.com/zxing/zxing 作者：Sean Owen 10.picasso 一句话介绍：强力的图片下载、缓存框架 上榜理由：本榜单出现的第三款图片类框架，不同的是picasso更强调图片下载，你可以将picasso集成进你的项目中，你也可以结合gilde和UIL与picasso，三者一齐封装至你的项目中，按需所用。 官网地址：http://square.github.io/picasso/ github：https://github.com/square/picasso 作者：square团队 使用：1compile &apos;com.squareup.picasso:picasso:2.5.2&apos; 或者下载jar包 11.lottie-android 一句话介绍：一款可以在Android端快速展示Adobe Afeter Effect（AE）工具所作动画的框架 上榜理由：动画类框架第一名，github上13.3k个star证明了他的优越性，利用json文件快速实现动画效果是它最大的便利，而这个json文件也是由Adobe提供的After Effects（AE）工具制作的，在AE中装一个Bodymovin的插件，使用这个插件最终将动画效果生成json文件，这个json文件即可由LottieAnimationView解析并生成绚丽的动画效果。而且它还支持跨平台哟。 github：https://github.com/airbnb/lottie-android 作者：Airbnb 团队 12.fresco 一句话介绍：一款可以管理图片内存的框架 上榜理由:github上12.8k个star，图片类排行榜第四名，facebook的出身证明了它并非是重复造的轮子，在管理图片内存领域上有着它的一片天地，渐进式加载、加载gif都是它与前三位相比独有的特性 官网地址：https://www.fresco-cn.org/ github：https://github.com/facebook/fresco 作者：facebook 使用：1234dependencies &#123; // 其他依赖 compile &apos;com.facebook.fresco:fresco:0.12.0&apos;&#125; 下面的依赖需要根据需求添加： 1234567891011121314dependencies &#123; // 在 API &lt; 14 上的机器支持 WebP 时，需要添加 compile &apos;com.facebook.fresco:animated-base-support:0.12.0&apos; // 支持 GIF 动图，需要添加 compile &apos;com.facebook.fresco:animated-gif:0.12.0&apos; // 支持 WebP （静态图+动图），需要添加 compile &apos;com.facebook.fresco:animated-webp:0.12.0&apos; compile &apos;com.facebook.fresco:webpsupport:0.12.0&apos; // 仅支持 WebP 静态图，需要添加 compile &apos;com.facebook.fresco:webpsupport:0.12.0&apos;&#125; 13.RxAndroid 一句话介绍：一款Android客户端组件间异步通信的框架 上榜理由：github上12.7k个star，位居组件通信框架的第二名，仅在EventBus之后，如果要问两者的区别，Eventbus是用来取代组件间繁琐的interface，RxAndroid是用来取代AnsyTask的，并不冲突；当然RxAndroid的优点并不仅限于此，更多优雅的实现，可以去官网查阅！ github：https://github.com/ReactiveX/RxAndroid 作者：JakeWharton 使用：12compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;compile &apos;io.reactivex.rxjava2:rxjava:2.1.0&apos; 14.SlidingMenu 一句话介绍：侧滑菜单栏框架 上榜理由：与Userval-Image-loader 齐名的上古神器框架——为你的app提供侧滑菜单栏的功能；github闪更有10.5k个star，证明了它的经久不衰，即使在Google推出了NavigationDrawer，仍然没有减少开发者对SildingMenu的拥簇，经典总是经得起考验的，这个上古神兽已经四年没有更新了；有太多太多的app使用过它，这些都可以在软件的开源许可上看到！ github：https://github.com/jfeinstein10/SlidingMenu 作者：Jeremy Feinstein 使用：在gihub上fork源码，集成进项目中 15.PhotoView 一句话介绍：一款ImageView展示框架，支持缩放，响应手势 上榜理由：10.3k的star数量，位于图片类框架排行榜第五位，PhotoView与前四位不同的是这次带来的是图片的展示能力，你一定好奇微信的头像点击放大是如何实现的，很多App的图片显示响应手势按压是如何实现的，了解PhotoView，你一定会开心的！（笔者也不会告诉你ImageView的点击放大效果在Android的sample也有） github：https://github.com/chrisbanes/PhotoView 作者：chrisbanes 使用：在app根目录的build.gradle中加入： 12345allprojects &#123; repositories &#123; maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125; 在app的module目录的build.gralde中加入： 123dependencies &#123; compile &apos;com.github.chrisbanes:PhotoView:latest.release.here&apos;&#125; 使用12345678&lt;com.github.chrisbanes.photoview.PhotoView android:id=&quot;@+id/photo_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;PhotoView photoView = (PhotoView) findViewById(R.id.photo_view);photoView.setImageResource(R.drawable.image); 16.material-dialogs 一句话介绍：一款自定义dialog框架 上榜理由：9.9k个star，也是继PhotoView，SlidingMenu之后第三款自定义View框架，也许你还是自定义View的新人，对Dialog使用的还有点生疏，你可以通过它提升你的Dilaog使用能力 github：https://github.com/afollestad/material-dialogs 作者：Aidan Follestad 使用：1234dependencies &#123; // ... other dependencies here compile &apos;com.afollestad.material-dialogs:core:0.9.4.5&apos;&#125; 17.droid-async-http 一句话介绍：一款基于Http协议的异步请求的网络框架， 上榜理由：虽然你有无数个使用retrofit+okhttp的理由，但9.8k个star，证明它仍然值得你深入学习。值得注意的是，它也已经有两年没更新了，你尽管拿去当你懒惰的理由！ github：https://github.com/loopj/android-async-http 作者：James Smith 使用：12345678repositories &#123; maven &#123; url &apos;https://oss.sonatype.org/content/repositories/snapshots/&apos; &#125;&#125;dependencies &#123; compile &apos;com.loopj.android:android-async-http:1.5.0-SNAPSHOT&apos;&#125; 18.androidannotations 一句话介绍：一款基于注解的快速开发框架 上榜理由：与Butterknife一样基于注解，利用注解快速完成view的初始化，不同的是androidannotations提供了更多的能力：简单的线程模型等；笔者只接触过Butterknife，无法更进一步叙述androidannotations的优势，如果你志在深入了解注解的妙用，可以尝试探索一下！ 官网地址：http://androidannotations.org/ github：https://github.com/androidannotations/androidannotations 作者：WonderCsabo 19.fastjson 一句话介绍:一款基于json解析、生成的框架 上榜理由：从它的名字不难看出，快速是它最大的特性，阿里巴巴的出身保证了代码的质量和优越，9.4k的star数量，也是榜单里第一个出现的中国开源框架，涉及网络的app都会用到json，fastjson值得作为你的首选！ github：https://github.com/alibaba/fastjson 作者：alibaba 使用：1compile &apos;com.alibaba:fastjson:1.1.58.android&apos; 20.Material-Animations 一句话介绍：一款提供场景转换过渡能力的动画框架 上榜理由：Android动画框架排行榜第二名，9.3k个star数量，与动画框架榜单第一名lottie-android不同的是，Material-Animations提供的是场景切换的动画效果。Android 官网sample中已经提供了部分Transition （转场动画）的展示，作为初学者很难快速拓展到自己项目中，Material-Animations的示例出现为开发者省去了此类麻烦，直接照搬应用到自己的App中吧。 github：https://github.com/lgvalle/Material-Animations 作者：Luis G. Valle 使用：down源码，修改学习 21.tinker 一句话介绍：它是微信官网的Android热补丁解决方案 上榜理由：9.1k个star，微信在用的热补丁方案，心动不如行动 官网地址：http://www.tinkerpatch.com/Docs/intro github：https://github.com/Tencent/tinker 作者：Tencent 22.ViewPagerIndicator 一句话介绍：一款基于ViewPager的页面指示器开源框架 上榜理由：上古神器，尽管已经五年未更新了，但你仍然可以在淘宝等app中看到它的使用场景，8.9K的star量让它不愠不火的在矗立在榜单里 官网地址：http://viewpagerindicator.com/ github：https://github.com/JakeWharton/ViewPagerIndicator 作者：JakeWharton 使用：下载地址：https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master 23.Android-CleanArchitecture 一句话介绍：一个讲解设计框架的demo 上榜理由：它不是框架，你可以把它当作一本书，它将教会你如何设计简洁的架构，工程里有一个sample app，配合图文讲解，你将对Android客户端的架构有更深一层的认识。8.8k的star数量，证明了它是一本“好书”哟。 github：https://github.com/android10/Android-CleanArchitecture 作者：Fernando Cejas 24.Android-PullToRefresh 一句话介绍：一款为普通视图提供刷新UI的视图框架 上榜理由：8.2K的star数量使它位居刷新类UI框架榜首，强大的兼容能力，该框架支持ListView，GrdiView，WebViewScrollView，ViewPager等众多View增加刷新的能力，如果你有增加上拉加载，下拉加载的需求，你应该考虑它了！ github：https://github.com/chrisbanes/Android-PullToRefresh 作者：Chris Banes 使用：github fork源码，集成到项目中 25.flexbox-layout 一句话介绍：一款弹性伸缩布局 上榜理由：8.1k个star，前端H5开发者转Android开发的福音，FlexboxLayout作为LinearLayout和RelativeLayout的替代者，值得各位一试，与其一同推出的还有ConstraintLayout。 github：https://github.com/google/flexbox-layout 作者：Google 使用：123dependencies &#123; compile &apos;com.google.android:flexbox:0.3.0-alpha3&apos;&#125; 26.AndroidSwipeLayout 一句话介绍：非常强大滑动式布局 上榜理由:滑动删除是国产app常见需求，商品详情的上下滑动需求作为开发者的我们也经常遇到，AndroidSwipeLayout在github上拥有8K个star，证明它经受住了检验，各位值得一试 github：https://github.com/daimajia/AndroidSwipeLayout 作者：daimajia 使用：12345dependencies &#123; compile &apos;com.android.support:recyclerview-v7:21.0.0&apos; compile &apos;com.android.support:support-v4:20.+&apos; compile &quot;com.daimajia.swipelayout:library:1.2.0@aar&quot;&#125; 或下载AndroidSwipeLayout-v1.1.8.jar 27.realm-java 一句话介绍：Realm是一款移动端数据库框架 上榜理由：核心数据引擎C++打造，比普通的Sqlite型数据库快的多。笔者猜测正是如此，realm以7892个star数让它位于大名鼎鼎的数据库框架GreenDao（7877）之前 官网地址：https://realm.io/cn/ github：https://github.com/realm/realm-java 作者：Realm团队 使用：https://realm.io/docs/java/latest/ 28.greenDAO 一句话介绍：greenDAO是一款高效、快速的SQLite型数据库 上榜理由：greenDAO的star数量与Realm不相上下，且与EventBus师出同门，也是由greenrobot团队开发维护的，质量有所保证，但若拷问笔者Realm与greenDao两者的优劣性，只能具体到实际使用当中，模拟线上的使用情形，进行高强度测试后才能下判断，故在此不能一言两语说完，深表遗憾 官网地址：http://greenrobot.org/greendao/ github：https://github.com/greenrobot/greenDAO 使用：12345678910111213141516171819buildscript &#123; repositories &#123; jcenter() mavenCentral() // add repository &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.1&apos; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin &#125;&#125; -----apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library&#125; 29.stetho 一句话介绍：一款提供在Chrome开发者工具上调试Android app能力的开源框架 上榜理由：上古时期Android程序员要调试本地数据库，需要进入Android Device Monitor找到/data/data/com.xxx.xxx/databases里面的db文件，导出到PC端，用PC的数据工具查看，现在使用stetho省却了如此的麻烦；如今的Android程序员如果想调试网络请求响应过程中的报文段，需要在请求中加入Log语句，一个信息一个信息打印出来，相当繁琐，现在请使用stetho，省却诸如此类的麻烦把！7.8K个star数，广大Android开发者调试的福音，你值得拥有！ 官网地址：http://facebook.github.io/stetho/ github：https://github.com/facebook/stetho 作者：FaceBook 使用：1compile ‘com.facebook.stetho:stetho:1.5.0’ 30.BaseRecyclerViewAdapterHelper 一句话介绍：强大、流畅的Recyvlerview通用适配器 上榜理由：如果你是RecyclerView的拥簇者，你一定要体验这款专门服务该view的适配器，7.7K个star，让这个家伙位于github上Android 适配器排行榜第一，还有很多惊喜等你去探寻！ 官网地址：http://www.recyclerview.org/ 使用： 1234567891011allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot;&#125; &#125;&#125;dependencies &#123; compile &apos;com.github.CymChad:BaseRecyclerViewAdapterHelper:VERSION_CODE&apos;&#125; 31.AndroidViewAnimations 一句话介绍：一款提供可爱动画集合的框架 上榜理由：正如作者所说，它囊括了开发需求过程中所有的动画效果，集成进了这个简洁可爱的动画框架。7.6K的star数，证明了它在动画框架领域的战斗力，让它仅仅位列lottie-android和Material-Animations两个动画框架霸主之后，屈居第三名 github：https://github.com/daimajia/AndroidViewAnimations 作者：daimajia 使用：1234567891011dependencies &#123; compile &apos;com.android.support:support-compat:25.1.1&apos; compile &apos;com.daimajia.easing:library:2.0@aar&apos; compile &apos;com.daimajia.androidanimations:library:2.2@aar&apos;&#125;sample：YoYo.with(Techniques.Tada) .duration(700) .repeat(5) .playOn(findViewById(R.id.edit_area)); 32.MaterialDrawer 一句话介绍：强大的塑料风格的抽屉框架 上榜理由：7.6K的star数量，作者的持续更新状态，如果你还在犹豫上手SlidingMenu遇到bug没人管的困境，那么你可以入手它作为你的抽屉布局 github：https://github.com/mikepenz/MaterialDrawer 作者：Mike Penz 使用:12345compile(&apos;com.mikepenz:materialdrawer:5.9.2@aar&apos;) &#123; transitive = true&#125;new DrawerBuilder().withActivity(this).build(); 33.Android-ObservableScrollView 一句话介绍：一款让视图滑动更具有视觉效果的滑动式框架 上榜理由：7.5K的star数量，证明了它曾经的价值，github上提供了12种滑动效果，你可以用它弥补其他框架的不足，提升你的App体验！ github：https://github.com/ksoichiro/Android-ObservableScrollView 作者：Soichiro Kashima 使用：1compile com.github.ksoichiro:android-observablescrollview 34.CircleImageView 一句话介绍：圆角ImageView 上榜理由：也许你已经听说过无数种展示圆角图片的方法，但如果你不尝试尝试CircleImageView，那么你的知识库会因为少了它黯然失色，有的时候完成需求是开发者优先考虑的，不同实现方法牵扯到的性能差异更值得让人深思，如果你有心在图片性能上有所涉猎，那么CircleImageView绝对不会让你败兴而归。最后别忘了记得去看Romain Guy的建议哟。 github：https://github.com/hdodenhof/CircleImageView 作者：Henning Dodenhof 使用：12345678910111213dependencies &#123; ... compile &apos;de.hdodenhof:circleimageview:2.1.0&apos;&#125;&lt;de.hdodenhof.circleimageview.CircleImageView xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/profile_image&quot; android:layout_width=&quot;96dp&quot; android:layout_height=&quot;96dp&quot; android:src=&quot;@drawable/profile&quot; app:civ_border_width=&quot;2dp&quot; app:civ_border_color=&quot;#FF000000&quot;/&gt; 35.logger 一句话介绍：一款让log日志优雅显示的框架 上榜理由：logger作为调试框架，并未给出很强大的能力，它最大的亮点是优雅的输出log信息，并且支持多种格式：线程、Json、Xml、List、Map等，如果你整日沉迷于汪洋大海般的log信息不能自拔，logger就是你的指路明灯！6.6k个star让他位列调试框架第二名，屈居facebook的stetho之后 github：https://github.com/orhanobut/logger 作者：Orhan Obut 使用： 12345678compile &apos;com.orhanobut:logger:2.1.1&apos;Logger.d(MAP);Logger.d(SET);Logger.d(LIST);Logger.d(ARRAY);Logger.json(JSON_CONTENT);Logger.xml(XML_CONTENT); 36.agera 一句话介绍:一款服务于Android平台的响应式编程框架 上榜理由：google专门推出一套响应式编程框架服务于Android开发者，相比于之响应式编程框架榜首的 RxJava RxAndroid，它更轻量，两者最大的不同点在于agera基于push event、pull data （VS Rx系列 push data）。 github：https://github.com/google/agera 作者：Google 使用：1compile &apos;com.google.android.agera:agera:1.3.0&apos; 扩展能力12345compile &apos;com.google.android.agera:content:1.3.0&apos; compile &apos;com.google.android.agera:database:1.3.0&apos; compile &apos;com.google.android.agera:net:1.3.0&apos; compile &apos;com.google.android.agera:rvadapter:1.3.0&apos; compile &apos;com.google.android.agera:rvdatabinding:1.3.0&apos; 37.BottmBar 一句话介绍：一款底部导航栏视图框架 上榜理由：底部栏里的王者框架，6.3K的star数量，证明了它的优秀，完全遵循材料设计规范，上手非常方便。如果说缺点，无法设置icon与titile的间距，无法自定义视图的大小等，但这些都可以通过修改源代码解决，笔者献丑也修改了一套符合国内开发者的底部导航框架，即将开源。 github：https://github.com/roughike/BottomBar 作者：Iiro Krankka 使用：1compile &apos;com.roughike:bottom-bar:2.3.1&apos; 38.Calligraphy 一句话介绍：一款自定义字体框架 上榜理由：如果你还在为一键修改App内所有字体样式而烦恼，6.3K个star的Calligraphy就值得你拥有，它可以同时修改整个整个项目的Textview字体，也可以单独 设置某个Textview的字体，还在等什么，快来试试吧！ github：https://github.com/chrisjenx/Calligraphy 作者：Christopher Jenkins 使用：123dependencies &#123; compile &apos;uk.co.chrisjenx:calligraphy:2.3.0&apos;&#125; 39.AndroidSlidingUpPanel 一句话介绍：可拖动的滑动面板视图框架 上榜理由：如果你的项目需要一个可拖拽的滑动式面板（展示某些详情信息，播放音乐，地图信息等），那么推荐你使用它，6.3k个star，来自创业公司umano的作品，证明它是用心推出的杰作 github：https://github.com/umano/AndroidSlidingUpPanel 作者：umano 使用：12345678dependencies &#123; repositories &#123; mavenCentral() &#125; compile &apos;com.sothree.slidinguppanel:library:3.3.1&apos;&#125; 40.AppIntro 一句话介绍：一款提供快速制作欢迎页的框架 上榜理由：笔者从未把打算把欢迎页框架纳入排行榜当中，作为国内开发者，ViewPager开发App的欢迎页已经是手到擒来的需求，为何一个开源的欢迎页框架会在github上拥有6.3k个star？也许你会不屑一顾，是的，往往就在不屑一顾的瞬间，机遇就悄悄溜走了。 github：https://github.com/apl-devs/AppIntro 作者：Paolo Rotolo 12345678910allprojects &#123; repositories &#123; ... maven &#123; url &apos;https://jitpack.io&apos;&#125; &#125; &#125; dependencies &#123; compile &apos;com.github.apl-devs:appintro:v4.2.0&apos; &#125; 41.recyclerview-animators 一句话介绍：一款为Recyclerview提供扩展动画能力的框架 上榜理由：有一句老话：如果有天你失去对新事物的兴趣，那就说明你老了。recyclerview已经推出快三年了，还在用listview的人们，是否已经发掘自己渐渐变老；不要灰心，快为你的项目加入recyclerview-animators框架吧，为“自己”加入新鲜的血液和能量！（笔者备注：6.2K个star） github：https://github.com/wasabeef/recyclerview-animators 作者：https://github.com/wasabeef 使用：1234dependencies &#123; // jCenter compile &apos;jp.wasabeef:recyclerview-animators:2.2.6&apos;&#125; 42.dagger 一句话介绍：一款通过依赖注入降低程序间耦合的开发框架 上榜理由：github 上dagger1版本 有6.2k个star ， dagger2版本有7.3k个；由square完成的dagger1版本，到如今google团队接手的dagger2版本，强力开发团队保证了代码在设计上的优越性；如果你想探究Android 领域的设计模式，这也是不错的选择。 官网地址：https://google.github.io/dagger/ github：https://github.com/google/dagger 作者：google 使用：123456789dependencies &#123; compile &apos;com.google.dagger:dagger:2.x&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:2.x&apos;&#125;If you&apos;re using classes in dagger.android you&apos;ll also want to include:compile &apos;com.google.dagger:dagger-android:2.x&apos;compile &apos;com.google.dagger:dagger-android-support:2.x&apos; annotationProcessor &apos;com.google.dagger:dagger-android-processor:2.x&apos; 43.Android-Bootstarp 一句话介绍：一款提供在Android应用上实现Bootstrap（web框架）所作出效果的框架 上榜理由：榜单上第二款响应web技术的Android 端框架，还记得第一名是谁吗——flexbox-layout，作为Android开发者，你有必要去了解Web技术了。5.9k个star，证明它不容小觑 github：https://github.com/Bearded-Hen/Android-Bootstrap 作者：Bearded-Hen团队 使用：123dependencies &#123; compile &apos;com.beardedhen:androidbootstrap:&#123;X.X.X&#125;&apos;&#125; 44.RxBinding一句话介绍：一款提供UI组件事件响应能力的框架 上榜理由：如果你还未开始RxAndroid 之旅，RxBinding可以作为你的第一站，通过RXBinding，你将理解响应式编程的快乐，让项目里的事件流程更清晰。5.6K个star，RxAndroid作者亲自操刀，快来试用吧！ github：https://github.com/JakeWharton/RxBinding 作者：JakeWharton Platform bindings:12345678910111213141516compile &apos;com.jakewharton.rxbinding2:rxbinding:2.0.0&apos;&apos;support-v4&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-support-v4:2.0.0&apos;&apos;appcompat-v7&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-appcompat-v7:2.0.0&apos;&apos;design&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-design:2.0.0&apos;&apos;recyclerview-v7&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:2.0.0&apos;&apos;leanback-v17&apos; library bindings:compile &apos;com.jakewharton.rxbinding2:rxbinding-leanback-v17:2.0.0&apos; 45.ListViewAnimations 一句话介绍：一款为ListView提供动展示画效果能力的框架 上榜理由：如果有一天我承认自己老了，我还会排排我的兄弟——ListView，证明我和它一起战斗过。ListViewAnimations的存在就是证明我们这些“老年人”仍有用武之地，也许你有说不出口的难处，无法体会到RecyclerView里动画的快乐，拥有ListViewAnimations，你一样可以骄傲的说，我的孩子（每个item）也有自己的动效啦。（笔者备注 5.6K个star） github：https://github.com/nhaarman/ListViewAnimations 作者：nhaarman 使用：123456789repositories &#123; mavenCentral()&#125;dependencies &#123; compile &apos;com.nhaarman.listviewanimations:lib-core:3.1.0@aar&apos; compile &apos;com.nhaarman.listviewanimations:lib-manipulation:3.1.0@aar&apos; compile &apos;com.nhaarman.listviewanimations:lib-core-slh:3.1.0@aar&apos;&#125; 46.UItimateRecyclerView 一句话介绍：一款提供刷新、加载更多、动画特效等额外能力的RecyclerView框架 上榜理由：榜单上第三次出现RecyclerView的身影，足以证明RecyclerView的优异性，5.5K个star，框架里所提供众多的能力，如果你是个功利开发者，那么此框架会为你节省很多学习时间，它可以完成多item式布局的大多数需求，值得注意的是，这个项目也是在其他项目的思路上二次开发的。 github：https://github.com/cymcsg/UltimateRecyclerView 作者：MarshalChen 使用：1234567repositories &#123; jcenter() &#125;dependencies &#123; ... compile &apos;com.marshalchen.ultimaterecyclerview:library:0.7.2&apos;&#125; 47.uCrop 一句话介绍：一款优雅的图片裁剪框架 上榜理由：5.3K个star，图片编辑模块单独拎出来也是一款优雅的App。 github：https://github.com/Yalantis/uCrop 作者：Yalantis 使用：12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125;&#125;compile &apos;com.github.yalantis:ucrop:2.2.1&apos; 48.RxJava-Android-Samples 一句话介绍：一款介绍RxJava使用场景的app 上榜理由：榜单出现的第一个“仅仅为告诉你如何使用另一个项目”的开源项目，它可以说是RxJava的用例，你想得到的想不到的RxJava用法这里都有，这就是为什么它以5.2k个star矗立在这份榜单里的原因。遗憾自己没有创作这么一个受人追捧的demo？赶快动手写个其他的“XX项目用例吧” github：https://github.com/kaushikgopal/RxJava-Android-Samples 作者：kaushikgopal 使用：clone到本地慢慢探索吧 49.AndroidAutoLayout 一句话介绍：一个提供适配能力的框架 上榜理由：5.2K个star，鸿洋老弟的作品，适合小项目的开发团队，拿到设计MM的px像素设计稿是不是很头疼捏？这个框架一键式搞定你的问题，它有很多的不足，但在追求完美适配的路上，你值得探索和了解它！笔者并不推荐把它应用到已经成熟运行的项目中，毕竟市面上已经有太多的适配解决方案了，适配问题就像是个大杂烩，想炒一盘好菜，就得备好各种佐料（适配小方案），当你把各种小佐料用的炉火纯青的时候，你离美食大厨就不远了。 github：https://github.com/hongyangAndroid/AndroidAutoLayout 作者：张鸿洋 使用：123dependencies &#123; compile &apos;com.zhy:autolayout:1.4.5&apos;&#125; 50.EffectiveAndroidUI 一句话介绍：一款讲解高效展示UI的教学型App 上榜理由：编程新手很难对MVC MVP,MVVM等模式有深刻的理解，如果有一个示例型app，那对初学者会有很大裨益，笔者在遇到它时也是相见恨晚。4.8K个star，证明了它经受了广大开发者的考验与审视，其中Effective UI的编程思想更是与Android官方课程里的Effective UI课程不谋而合，并且，此项目还包含了fragment、dagger、主题样式、Butterknife等众多小知识点，作为编程初学者的学习用例再适合不过了 github：https://github.com/pedrovgs/EffectiveAndroidUI 作者：Pedro Vicente 使用：clone项目到本地 51.Luban 一句话介绍：最接近微信的图片压缩框架 上榜理由：好的思路总是可以让你大放异彩，Luban仅以图片压缩单一功能，俘获了4.8K个star，证明了它在图片压缩上的造诣，它可能不是最优秀的，但它是让你我最接近伟大的项目 github：https://github.com/Curzibn/Luban 作者：Curzibn 使用：1compile &apos;top.zibin:Luban:1.1.1&apos; 52.DroidPlugin 一句话介绍：一款热门的插件化开发框架 上榜理由：4.8K个star，插件化框架榜单第一名，，360团队出品，框架质量有保证，有成功案例——360手机助手，并且持续维护着 github：https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md 作者：Andy Zhang 使用:clone项目到本地 53.otto 一句话介绍:一款老旧且强大的事件总线框架 上榜理由：4.8K个star，是square团队早先推出的事件响应型框架，淘宝app的事件驱动也是基于此框架封装的，如今square已经建议开发者采用RxJava RxAndroid来代替otto了。但otto仍有与EventBus横向对比的价值，纵向来说，otto与square自家开发的Rx系列框架的差异同样值得开发者们去探究。 github https://github.com/square/otto 作者：square 使用：123456repositories &#123; mavenCentral() maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;&#125;compile &apos;com.michaelpardo:activeandroid:3.1.0-SNAPSHOT&apos; 54.u2020 一句话介绍：一款提供Dagger的高级教学示例的app（额，名字是有点绕） 上榜理由：4.7K个star，JakeWharton牵头开发的教学类app，教你使用Dagger在其他高级框架的用法，它展示了Dagger与ButterKnife、Retrofit、Moshi、Picasso、Okhttp、RxJava、Timber、Madge、LeakCanar等众多优秀框架结合起来的高级用法，你也可以借鉴到自己的项目当中 github：https://github.com/JakeWharton/u2020 作者：JakeWharton 55.buck 一句话介绍：buck是一个快速构建系统 上榜理由：facebook+google出身的作者，对构建代码的出色理解，加上大型团队的维护，以及增量更新时的快速高效，让buck成为了微信Android团队构建项目的首选，构建大型项目时，它比gradle更快，然而中小公司并不适合此框架，但作为立志在框架设计领域有一番作为的人们，欢迎来一探究竟 官网地址：https://buckbuild.com/ github：https://github.com/facebook/buck 作者：facebook 使用：linux or mac system +docs 56.PermissionsDispatcher 一句话介绍：一款基于注解的提供解决运行时危险权限方案的框架 上榜理由：自Android6.0 Google提出危险权限一词起，用户安全性被提到一定的高度，一些运行时对用户较为危险的权限将不再自动被开发者获取，需要经过用户批准，开发者才可以继续使用该权限，如果你曾经被权限问题搞的抓耳挠腮，建议你试试这个框架，它足够解决你的问题 官网地址：https://hotchemi.github.io/PermissionsDispatcher/ github：https://github.com/hotchemi/PermissionsDispatcher 作者：Shintaro Katafuchi 使用：123456789101112dependencies &#123; compile(&apos;com.github.hotchemi:permissionsdispatcher:$&#123;latest.version&#125;&apos;) &#123; exclude module: &quot;support-v13&quot; &#125; annotationProcessor &apos;com.github.hotchemi:permissionsdispatcher-processor:$&#123;latest.version&#125;&apos;&#125;repositories &#123; jcenter() maven &#123; url &apos;http://oss.jfrog.org/artifactory/oss-snapshot-local/&apos; &#125;&#125; 57.android-gif-drawable 一句话介绍:一款提供展示GIF动画能力的视图框架 上榜理由：据我所查国内著名App——知乎使用了android-gif-drawable，因此证明了它的存在价值，尽管在榜单第十一位介绍了lottie-android直接应用AE动画的示例，但AE设计师不是每个公司都配备的，GIF的存在，就必然存在了展示GIF的需要，它值得你拥有！ github：https://github.com/koral--/android-gif-drawable 作者：Karol Wrótniak 使用：1234567repositories &#123; mavenCentral() maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; &#125;&#125;dependencies &#123; compile &apos;pl.droidsonroids.gif:android-gif-drawable:1.2.+&apos;&#125; 58.Apktool 一句话介绍：一款反编译apk的工具 上榜理由：开源的反编译工具，对于志在了解apk逆向破解的诸位，值得拥有，4.5k个star，逆向破解apk神器！ github：https://github.com/iBotPeaches/Apktool 官网地址：https://ibotpeaches.github.io/Apktool/ 作者：Connor Tumbleson 59.dynamic-load-apk 一句话介绍：插件化开发框架 上榜理由：4.5k个star，位于插件化开发框架第二名（第一名来自360团队），全面的文档介绍让你很快就能上手插件化开发，如果你喜欢大段文字讲解，那么这个项目一定适合你 github：https://github.com/singwhatiwanna/dynamic-load-apk 作者：singwhatiwanna 使用：github上的文档配合作者博客更配哟 60.atlas 一句话介绍：淘宝推出的组件化开发框架 上榜理由：淘宝团队所出的精品，atlas框架提供了解耦、组件、动态的开发能力，4.5k个star让他位列组件化开发框架第一名 github：https://github.com/alibaba/atlas 作者：alibaba 61.volley 一句话介绍：google推荐使用的Android端网络请求框架 上榜理由：4.4k个star，并不是他不够优秀，而是使用volley已经渐渐成为广大开发者的习惯 github：https://github.com/google/volley（新版volley地址） 作者：google 使用：clone源码到本地 62.androidmvp 一句话介绍：一款展示Android端Mvp设计的demo 上榜理由：榜单里为数不多、仅凭展示某种设计模式就获得4.2K个star的项目，如果你有尝试mvp的打算，androidmvp可以作为你的前哨站 github：https://github.com/antoniolg/androidmvp 作者：Antonio Leiva 使用：clone到本地 63.SwipeBackLayout 一句话介绍:一款可以让你通过滑动手势关闭页面的的框架 上榜理由：仿微信滑动退出当前聊天界面的效果，提供了activity的滑动关闭能力，通过这种思路，实现fragment的滑动关闭轻而易举;笔者坚持建议诸位clone源码到本地探索一番；4.2k个star证明很多人都喜爱它 github：https://github.com/ikew0ng/SwipeBackLayout 作者：ike_w0ng 使用:1compile &apos;me.imid.swipebacklayout.lib:library:1.0.0&apos; 64.FlycoTabLayout 一句话介绍：一款可以让作出多种多样指示器效果的框架 上榜理由：尽管我们没有理由为了给app加入页面指示器功能就集成2.5M的依赖库，但是作为了解viewpager或swip views的指示器设计原理的优秀框架，你值得打开它试试，笔者建议单独拆分所需源码，加入到自己的项目中去。4.1K个star，二次开发的作品，仍然推荐！ github：https://github.com/H07000223/FlycoTabLayout 作者：Flyco 65.android-testing 一句话介绍：一款展示四大自动化测试框架用例的demo（Espresso，UiAutomator，AndroidJunitRunner，JUnit4） 上榜理由：学习者经常会陷入似懂非懂的境地，如果你有幸学习过Android Testing Support Library site的课程，那么你一定对android的四大测试框架迫不及待，这款demo非常适合你，快来学习这个4.1k个star的明星项目吧 github：https://github.com/googlesamples/android-testing 作者：googlesampes团队 66.FileDownloader 一句话介绍：一款高效、稳定、灵活、易用的文件下载引擎 上榜理由：4.1k证明了它有多受人喜爱，文件下载看似简单的背后暗藏了多少的坑坑点点，我知道你有能力自己实现文件下载功能，但优秀的框架可以提升你的设计编码能力，这款框架可以提升你的实力！ github：https://github.com/lingochamp/FileDownloader 作者：LingoChamp团队 使用：123dependencies &#123; compile &apos;com.liulishuo.filedownloader:library:1.5.5&apos;&#125; 67.JieCaoVideoPlayer 一句话介绍：基于MediaPlayer api——VideoView 的多媒体播放框架 上榜理由：榜单里第三款多媒体播放框架，它以灵巧的身姿挤入本榜单，精巧是它最大的优点，不到100k，拥有它，你就可以快速开发类似今日头条那样的视频播放效果，4k个star，证明它值得一试 github：https://github.com/lipangit/JieCaoVideoPlayer 作者：Nathen 使用：1compile &apos;fm.jiecao:jiecaovideoplayer:5.5.4&apos; 68.glide-transformations 一句话介绍：为众多著名图片加载框架提供图片形状变幻能力的框架 上榜理由：在榜单靠前的部分已经介绍过glide，Picasso，Fresco等图片加载框架，glide-transformations就是一款为他们提供图片变形能力的框架，使用起来非常简单，因此受到了大家的喜爱，github上有3.8K个star github：https://github.com/wasabeef/glide-transformations 作者：Daichi Furiya 使用：123456789repositories &#123; jcenter()&#125;dependencies &#123; compile &apos;jp.wasabeef:glide-transformations:2.0.2&apos; // If you want to use the GPU Filters compile &apos;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&apos;&#125; 在Glide里设置变幻效果 12345Set Glide Transform.Glide.with(this).load(R.drawable.demo) .bitmapTransform(new BlurTransformation(context)) .into((ImageView) findViewById(R.id.image)); 69.android-gpuimage 一句话介绍：一款基于OpenGL的图片渲染引擎 上榜理由：放下GpuImage在IOS平台的荣誉不谈，Android版的android-gpuimage就提供多达70多种图片渲染效果，你还在好奇美图秀秀是如何实现图片变幻的？有了它，一切都不是问题。如果你是美图工具类的工程师，此框架的建设思路也会对你大有裨益。笔者也是通过android-gpuimage仿造了美图App并俘获女友芳心的，再次为它的实力点赞。ios版+android版一共19k个star，已经证明了它的实力，还在等什么呢？ github：https://github.com/CyberAgent/android-gpuimage 作者：CyberAgent 团队 使用：1234567repositories &#123; jcenter()&#125;dependencies &#123; compile &apos;jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1&apos;&#125; 更多的改造方法，还需要阅读Ios的编程文档，对于有毅力的小伙伴强力推荐！ 70.RxPermissions 一句话介绍：一款基于RxJava完成权限申请的框架 上榜理由：榜单里第二款提供权服务的框架，基于RxJava的设计，让你可以专心写业务，3.7K个star已经证明了它的实用价值 github：https://github.com/tbruyelle/RxPermissions 作者：Thomas Bruyelle 使用：1234567repositories &#123; jcenter() // If not already there&#125;dependencies &#123; compile &apos;com.tbruyelle.rxpermissions:rxpermissions:0.9.4@aar&apos;&#125; 优雅的使用： 12345678910RxPermissions rxPermissions = new RxPermissions(this); rxPermissions .request(Manifest.permission.CAMERA) .subscribe(granted -&gt; &#123; if (granted) &#123; // I can control the camera now &#125; else &#123; // Oups permission denied &#125; &#125;); 71.freeline 一句话介绍：一款动态替换的编译构建框架 上榜理由：继Facebook的Buck，Androdi官方的InstRun之后，蚂蚁金服推出了Freeline编译框架，官网宣称Freeline与业内主流构建方式相比仍然有数倍的速度领先;排行有先后，编译速度并不在本榜单排序的考据因素中，因此freeline以3.7个star，暂列编译框架第二名 官网地址：https://www.freelinebuild.com/ github：https://github.com/alibaba/freeline 作者：alibaba 使用：1234567891011121314buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.antfortune.freeline:gradle:0.8.7&apos; &#125;&#125;apply plugin: &apos;com.antfortune.freeline&apos;android &#123; ...&#125; File → Settings… → Plugins → Browse repositories →freeline. 72.RxLifecycle 一句话介绍：一款提供在使用RxJava过程中管理Activity和Fragment生命周期能力的框架 上榜理由：在榜单靠前的部分，你已经了解RxJava和RxAndroid的强大之处，但部分粗心的开发者因为没有及时取消订阅而产生严重的内存泄漏，不要担心，RxLifecycle可以为你解决难题，在gtihub上拥有3.7K个star，国内知名软件——知乎和淘宝也都在使用它 github：https://github.com/trello/RxLifecycle 作者：trello团队 使用：clone源码到本地 73.classyshark 一句话介绍：一款可执行文件浏览器 上榜理由：榜单里继Apktool之后第二款apk逆向工具，如果你喜欢优雅的图形数据展示，那么你一定不能错过他，classyshark可以将破解的结果以图形化展示用户，方便分析，3.7K个star，让它暂列apk逆向工具第二位！ github：https://github.com/google/android-classyshark 作者：google 使用：下载 JAR 74.acra 一句话介绍：一款提供记录APP崩溃日志能力的框架 上榜理由：如果你面临着收集APP崩溃日志的需求，那么acra是个不错的选择。3.7K个star，让acra位列崩溃日志框架排行榜第一名，acra有足够的能力记录线上APP，并且发回服务端，acra也提供了相当棒的崩溃日志统计服务端框架Acralyzer，cralyzer工作在Apache CouchDB之上，所以除了CouchDB之外，没有必要安装任何额外的软件，移动端开发者也可以借此学习服务端的建设，一举两得！ github：https://github.com/ACRA/acra 服务端github：https://github.com/ACRA/acralyzer 作者：acra团队 使用：没有什么方法比clone源码到本地更方便了 75.DiskLruCache 一句话介绍：一款提供磁盘文件缓存管理能力的框架 上榜理由：3.7k个star并不足以说明DiskLruCache的优秀，仅仅以管理磁盘文件能力单独拎出来成为一个框架，作者需要很大的勇气，很幸运，作者做到了，并且也成为Google官网提倡的缓存 ；如还记得上次做“一键清除缓存”、“查看缓存文件大小”功能是什么时候吗？DiskLruCache一句话就可以搞定！ github：https://github.com/JakeWharton/DiskLruCache 作者：JakeWharton 使用：1compile &apos;com.jakewharton:disklrucache:2.0.2&apos; 或者下载 latest .jar 76.dexposed 一句话介绍：一款支撑阿里大部分App客户端热修复、线上调试能力的框架 上榜理由：榜单上再次出现热修复框架的身影，证明App热修复技术的火热，dexposed提供图形化的性能监控、在线热修复bug漏洞、支持AOP编程思想等，不论你是企业热修复技术的设计者还是打算在热修复领域一探究竟的新人，这款框架很适合你。3.5k个star，证明它作为一门技术框架的存在，是多么令人喜爱！ github：https://github.com/alibaba/dexposed 作者：alibaba 使用：123dependencies &#123; compile &apos;com.taobao.android:dexposed:0.1.1@aar&apos; &#125; 77.Litho 一句话介绍：一款提供高效构建UI能力的框架 上榜理由：作为一款专门构建UI的框架，Litho高效的地方在于：单独开辟了用于渲染和布局的线程，然后将创建好的组件传递给UI线程去完成最终的渲染，使用更少的视图层级，来提升界面的滚动速度，值得注意的是，它仅支持开发者作出不可改变的UI组件 ,3.5K个star，证明了它在构建UI领域的价值，更多的妙处，期待你亲自去发掘！ github：https://github.com/facebook/litho 作者：facebook 使用：123456789101112131415161718192021dependencies &#123; // ... // Litho compile &apos;com.facebook.litho:litho-core:0.3.1&apos; compile &apos;com.facebook.litho:litho-widget:0.3.1&apos; provided &apos;com.facebook.litho:litho-annotations:0.3.1&apos; annotationProcessor &apos;com.facebook.litho:litho-processor:0.3.1&apos; // SoLoader compile &apos;com.facebook.soloader:soloader:0.2.0&apos; // Optional // For debugging debugCompile &apos;com.facebook.litho:litho-stetho:0.3.1&apos; // For integration with Fresco compile &apos;com.facebook.litho:litho-fresco:0.3.1&apos; // For testing testCompile &apos;com.facebook.litho:litho-testing:0.3.1&apos;&#125; 78.mosby 一句话介绍：一款提供构建MVP项目能力的框架 上榜理由：榜单靠前的部分已经介绍了MVC,MVVM,MVP的框架项目，想必此时你在构建企业项目架构上，选择或者开发一款合适的MVP框架迫在眉睫，mosby可以作为你的第一步参考，你可以封装它，也可以照抄它，无论如何，3.4K个star，证明了它在框架设计上有多受开发者的喜爱 github：https://github.com/sockeqwe/mosby 作者：Hannes Dorfmann 使用：1234567891011121314dependencies &#123; compile &apos;com.hannesdorfmann.mosby3:mvi:3.0.4&apos; // Model-View-Intent // or compile &apos;com.hannesdorfmann.mosby3:mvp:3.0.4&apos; // Plain MVP // or compile &apos;com.hannesdorfmann.mosby3:viewstate:3.0.4&apos; // MVP + ViewState support&#125;allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots/&quot; &#125;&#125; 79.AndResGuard 一句话介绍：一款提供资源文件路径混淆 的工具 上榜理由：如果你是个对APK大小很敏感的人，那么AndResGuard一定适合你，它的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a，3.4K个star，证明了在优化APK道路上，你不是一个人在战斗！ github：https://github.com/shwenzhang/AndResGuard 作者：wechat team 使用：clone项目到本地，其实也就是个三两句话的文档 80.StatusBarUtil 一句话介绍：一款提供设置沉浸式状态栏样式能力的框架 上榜理由：设计师MM总是抱怨系统状态栏不优雅？那就给她一个完美的沉浸式状态栏。StatusBarUtil可以随心所欲的设置状态栏样式，3.3K个star，足以说明它有多受设计MM的喜爱 github：https://github.com/laobie/StatusBarUtil 作者：Jaeger 使用：1compile &apos;com.jaeger.statusbarutil:library:1.4.0&apos; 81.robolectric 一句话介绍：一款不依赖于Android设备的单元测试框架， 上榜理由：sample中列举了如何对Android四大组件和常见功能测试的用例，3.2K个star，值得充满好奇心的人尝试 官网地址：http://robolectric.org/ github：https://github.com/robolectric/robolectric 作者：robolectric 使用：1testCompile &quot;org.robolectric:robolectric:3.3.2&quot; 82.Fragmentation 一句话介绍:一款提供管理Fragmen嵌套t能力的框架 上榜理由：对于Activity和Fragment使用，你一定得心应手，但如果要做一套通用的Activity&amp;Fragment嵌套设计，想必你有点手足无措了，Fragmentation可以作为你设计Fragment管理上的第一步，3.2K个star，笔者认为有点名副其实了，项目介绍里说的是Fragment的管理能力，但并未提供Fragment&amp;Activity生命周期、任务栈的管理能力，因此很难直接应用到企业项目当中，但源码当中的设计思路，值得笔者与诸位借鉴，拾人牙慧留有余香！ github：https://github.com/YoKeyword/Fragmentation 作者：YoKey 使用：1// appcompat v7包是必须的compile ‘me.yokeyword:fragmentation:0.10.7’// 如果想使用SwipeBack 滑动边缘退出Fragment/Activity功能，请再添加下面的库// compile ‘me.yokeyword:fragmentation-swipeback:0.10.4’ 83.Small 一句话介绍：轻巧的插件化框架 上榜理由：作为插件框架榜单的新成员，Small的优点是轻巧，适合作为小团队的插件开发方案，3.1K个star，让它获得了酷狗音乐等著名开发团队的青睐，如果你们的团队想逐步实施插件化开发，Small是个不错的选择！ 官网地址：http://code.wequick.net/Small/cn/cases github：https://github.com/wequick/Small 作者：wequick 团队 使用：123456789buildscript &#123; dependencies &#123; classpath &apos;net.wequick.tools.build:gradle-small:1.2.0-alpha6&apos; &#125;&#125;apply plugin: &apos;net.wequick.small&apos;small &#123; aarVersion = &apos;1.2.0-alpha6&apos;&#125; 84.JsBridge 一句话介绍：一款提供WebView和Javascript通信能力的框架 上榜理由：该框架提供给了允许H5页面调用通过JS调用App方法的能力；3.1K个star，简洁的通讯方式，值得每一个WebHybrid App开发者尝试 gtihub：https://github.com/lzyzsd/JsBridge 作者：hi大头鬼hi 使用：12345678repositories &#123; // ... maven &#123; url &quot;https://jitpack.io&quot; &#125;&#125;dependencies &#123; compile &apos;com.github.lzyzsd:jsbridge:1.0.4&apos;&#125; 85.richeditor-android 一句话介绍：一款强大的富文本编辑框架 上榜理由：2.8k个star，榜单里第一个为TextView提供扩展能力的框架，你暂时不需要它，但不能不知道它 github：https://github.com/wasabeef/richeditor-android 作者：Daichi Furiya 使用：1234567repositories &#123; jcenter()&#125;dependencies &#123; compile &apos;jp.wasabeef:richeditor-android:1.2.2&apos;&#125; 86.Transitions-Everywhere 一句话介绍：一款教你正确使用Transitions API（Android 转场动画API）的教学型项目 上榜理由：你可能还未尝试过Android API的Transitions 框架，可能听过，但却无法做出优雅奇妙的动效——别担心，Transitions-Everywhere正如它的名字一样，它将带你全面体验Transitions 的强大之处 github：https://github.com/andkulikov/Transitions-Everywhere 作者：Andrey Kulikov 使用：123dependencies &#123; compile &quot;com.andkulikov:transitionseverywhere:1.7.4&quot;&#125; 87.android-viewbadger 一句话介绍：能够快速的为Android 视图加入“勋章”能力的框架 上榜理由：如果说勋章一词听起来陌生，那么显示已读未读个数、小红点标记信息这一类词语你一定不太陌生，笔者相信在诸位实际开发中经常遇到为某些item加入小红点标记的需求，聪明的各位一定有着各种实现方案，为什么不能快速优雅的完成呢？android-viewbadger可以帮你实现，当然，在某些情况下，你需要具备修改源码的能力，以符合设计MM的需求！值得注意的是，这宽项目已经五年没有更新了！ github：https://github.com/jgilfelt/android-viewbadger 作者：Jeff Gilfelt 使用：clone源码到本地 1234View target = findViewById(R.id.target_view);BadgeView badge = new BadgeView(this, target);badge.setText(&quot;1&quot;);badge.show(); 88.AndroidWiFiADB 一句话介绍：一款不用数据线也可以让你调试手机设备APP的插件项目 上榜理由：你是否还在担心测试过程中高强度的拔插数据线对手机电池和USB端口造成终生难以弥补的损害？别担心，有wifi有AndroidWiFiADB，无须数据线也可以调试应用了，更有趣的是，在测试工程师一边拿着手机一边找你聊bug的时候，你已经偷偷在它的手机上修复了bug，深藏功与名！ github：https://github.com/pedrovgs/AndroidWiFiADB 作者：Pedro Vicente Gómez Sánchez 使用： Preferences/Settings-&gt;Plugins-&gt;Browse Repositories-&gt;serch AndroidWiFiADB 89.emojicon 一句话介绍：一款提供在TextView、EdiText展示表情包能力的框架 上榜理由：2.7k个star，,榜单第二款增强TextView显示能力的框架，这款专为表情包设计，如果你曾经好奇微信、QQ的表情显示是如何做到的？这款框架一定能满足你的求知欲。 90.packer-ng-plugin 一句话介绍：一款打爆工具插件 上榜利用：笔者尽力维护榜单涉及范围的全面性，因此引入此插件项目——项目号称完成100个渠道包只需要10秒钟，在市面上各种各样多渠道打包方案的今天，选择一款适合自己团队的，才是上上选择 github：https://github.com/mcxiaoke/packer-ng-plugin 作者：Xiaoke Zhang 使用：1234567891011121314151617181920buildscript &#123; ...... dependencies&#123; // add packer-ng classpath &apos;com.mcxiaoke.gradle:packer-ng:1.0.9&apos; &#125;&#125; apply plugin: &apos;packer&apos; dependencies &#123; compile &apos;com.mcxiaoke.gradle:packer-helper:1.0.9&apos;&#125; android &#123; //... signingConfigs &#123; release &#123; // 满足下面两个条件时需要此配置 // 1. Gradle版本 &gt;= 2.14.1 // 2. Android Gradle Plugin 版本 &gt;= 2.2.0 // 作用是只使用旧版签名，禁用V2版签名模式 v2SigningEnabled false &#125; &#125; &#125; 91.android-priority-jobqueue 一句话介绍：一款提供后台任务管理能力的框架 上榜理由：如果你是个志在深入研究多线程操作的开发者，这个项目一定不要错过，不论是Activity重新加载、Service使用线程池时的任务优先级和并发问题，都不要担心，Job Manage会照顾优先级，持久性，负载平衡，延迟，网络控制，分组，2.4K个star，优秀的多线程管理能力，况且它依赖的第三方框架很少，值得你一试 github：https://github.com/yigit/android-priority-jobqueue 作者：Yigit Boyar]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试总结]]></title>
    <url>%2Fposts%2F27a6e4df.html</url>
    <content type="text"><![CDATA[面试大纲 java基础、面向对象、集合、线程使用； Android 机型适配、SDK适配、内存优化、内存溢出、内存泄漏； MVC/MVP/MVVM的使用场景； 了解并能使用最新流行开源库RXjava+Retrofit+OKHttp、Glide、EventBus等； JNI及NDK的使用、熟悉Framework。 频繁面试题 1.面向对象（OOP） 2.数据类型 3.equal和==的区别 4.字符串运行速度：StringBuilder、StringBuffer、 String 5.Queue 队列、Stack 栈 6.ListView机制 7.Fragment生命周期 8.四大引用类型 9.线程、进程及其通信方式 10.PackageManagerService 11.binder机制 12.launcher的实现 13.Android 版本特性 14.BroadcastReceiver广播 15.RecycleView 16.各种集合比较SparseArray、HashMap、ArrayMap、LinkedList、ArrayList 17.SQLite升级 18.Bitmap 19.Handler机制 20.性能优化技巧 21.ANR 22.自定义View 23.MVC、MVP、MVVM三种架构设计 24.APP 启动流程 25.插件化 26.Kotlin 多平台应用的静态编程语言 27.Framework 工作原理 28.Android 屏幕适配 29.事件分发机制 30.Android 动画分类：视图，属性，帧，gif 31.Android 进程 32.Android 五大存储方式 33.屏幕旋转Activity生命周期 34.Activity 四大启动模式 35.CPU、GPU工作原理 36.UI卡顿原因 37.Application的生命周期 38.如何避免因引入的开源库导致的安全性和稳定性？ 39.简单的音频/视频格式 40.线程同步的方法 41.线程安全的单例 42.Serializable、Parcelelable 43.Service启动方式和生命周期 44.Android 常见布局 45.Http、Https、Volley、OkHttp、RxJava + Retrofit + OkHttp、TCP、UDP 46.如何节省内存使用，主动回收内存？ 47.Activity如何生成View？ 48.为什么要使用多线程？ 49.现场保护 50.内存溢出、内存泄漏 51.JNI和NDK 52.常用的设计模式及其实现思想和作用 53.HashMap、 HashTable、HashSet的异同 54.Android 中内存泄漏原因及优化方案 55.LeakCanary 内存泄漏检查的开源工具 56.多线程、线程池 57.腾讯 Bugly 58.Glide 59.Fresco 60.React 面试题解析1.面向对象（OOP）针对业务处理过程的实体及其属性和行为进行抽象封装以获得高效清晰的逻辑单元划分。 三大特性：①封装（隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变量隔离便于使用，提高代码的服用小和安全性）；②继承（提高代码的复用性，继承是多态的前提）；③多态（父类或接口定义的引用变量可以指向子类或具体实现类的形象，提高了程序的拓展性）。 五大原则：单一职责、开放封闭、里氏替换、依赖倒置、接口分离。 2.数据类型byte 1个字符，short 、char2 个字符，int 、float 4个字符，long 、double 8个字符。** volatile是一个类型修饰符（type specifier）volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。（from百度） volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。 在JDK1.7之前，switch语句仅支持byte、short、char、int，在JDK1.7之后，枚举、字符串类型都可以，通过String.hashcode转成int进行判断。 String不可变原因：字符串常量池的需要；运行String对象缓存HashCode，提高效率；多线程安全。 String 转integer的方法和原理 ①Integer.parseInt（String str）调用Integer内部的； ②Integer.parseInt（String s, int radix）parseInt内部首先判断字符串是否包含符号（-或者+），则对相应的negative和limit进行赋值，然后再循环字符串，对单个char进行数值计算 ③Character.digit(char ch, int radix) 返回指定基数中字符表示的数值。函数肯定进入到0-9字符的判断（相对于string转换到int），否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值。 限定参数类型的上界：参数类型必须是T或T的子类型 &lt;? super T&gt; 限定参数类型的下界：参数类型必须是T或T的超类型 3.equal和==的区别：equal 比较对象，==比较原生类型equal：存储空间的值是否相同，字符串内容比较，值是否相同 ==：是否为同一内存空间，内存空间是否相同，引用是否相同 如果一个类重写了equals()方法，则一定也要重写hashCode()方法，原因是：虽然equals()方法重写可以保证正确判断两个对象在逻辑是否相同，但是hashCode()方法映射的物理地址是不相同的，依然会将逻辑上相同的两个元素存入集合，但是第二个对象的内容会是Null. 参考文章：关于java中Object类中的equals()和hashCode()方法的使用个人总结 - 张森（ZhangSen） - 博客园 4.字符串运行速度：StringBuilder &gt; StringBuffer （线程安全）&gt; String ，String为常量，其它为变量，所以运行慢。5.Queue 队列：先进先出，Stack 栈：后进先出。Collect –&gt;List/Set/Map6.ListView机制：用到的适配器有ArrayAdapter、SimpleAdapter、BaseAdapterBaseAdapter 重写的方法getCount()、getItem()、getItemId()、getView()，每绘制一次就调用一次getView()，在getView()中将事先定好的layout布局确定显示的效果并返回一个view对象作为一个item 显示出来，getItem()、getItemId()在调用LIstView响应方法时调用。 7.Fragment生命周期参考文章：Fragment各种情况的生命周期 - 猫吻鱼的博客 - CSDN博客 onAttach()： 完成Fragment和Activity的绑定，参数中的Activity即为要绑定的Activity，可以进行赋值等操作。 onCreate() : 完成Fragment的初始化 onCreateView() : 加载Fragment布局，绑定布局文件 onActivityCreated() : 表名与Fragment绑定的Activity已经执行完成了onCreate，可以与Activity进行交互操作。 onStart() : Fragment变为可见状态 onResume() : Fragment变为可交互状态 onPause()： Fragment变为不可交互状态(不代表不可见) onSaveInstanceState()：保存当前Fragment的状态。记录一些数据，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本。 onStop(): Fragment变为不可见状态 onDestroyView() : 销毁Fragment的有关视图，但并未和Activity解绑，可以通过onCreateView()重新创建视图。Fragment销毁时或者ViewPager+Fragment情况下会调用 onDestroy() : 销毁Fragment时调用 onDetach() : 解除和Activity的绑定。Fragmen销毁最后一步。 8.四大引用类型强引用： 是指创建一个对象并把这个对象赋给一个引用变量。 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。 软引用（SoftReference）：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。 弱引用（WeakReference）：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。 虚引用（PhantomReference）：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。 9.线程是进程的子集，一个进程可有多个线程。线程间通讯方式：①共享变量；②管道；③handler；④runOnUiThread(Runnable)；⑤view.post(Runnable)。 进程间通讯方式：①管道；②FIFO；③消息队列；④信号量；⑤共享内存区；⑥套接字socket信号。 Activity间的通信方式：①Intent；②借助类的静态变量；③借助全局变量/Application；④借助外部工具（SharedPreference、SQLite、File、剪贴板）；⑤借助Service。 10.PackageManagerService APP安装有关的service，WindowManagerService APP调用窗口相关的service，ActivityManagerService 系统的引导服务，支持应用进程的启动、切换、调度、四大组件的启动和管理。自定义系统服务：在ServiceManager注册，在Framework/base增加JNI，C++ 文件，在build 配置mk文件，全部编译，才可调用。 11.binder机制Binder是Android系统中进程间通讯（IPC）的一种方式，也是Android系统中最重要的特性之一。Android中的四大组件Activity，Service，Broadcast，ContentProvider，不同的App等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。 12.launcher的实现Manifest 配置launcher，PackageManager、ActivityManager对应包的管理和应用进程的管理。 13.Android 版本特性6.0需要代码请求权限checkPermissions，7.0应用间文件共享限制，系统广播删除，8.0通知渠道、悬浮窗、透明窗口不允许屏幕旋转，9.0明文流量的网络请求（Https加密） Android SDK兼容：minSdkVersion必须，targetSdkVersion针对某版本，maxSdkVersion非必需。 详细特性可见转载文档：Android 各版本新特性介绍 - 落叶Ex的博客 - CSDN博客 14.BroadcastReceiver广播 BroadcastReceiver比较 特别注意：动态广播最好在Activity 的 onResume()注册、onPause()注销。 原因：对于动态广播，有注册就必然得有注销，否则会导致内存泄露，重复注册、重复注销也不允许 广播的类型主要分为5类： 普通广播（Normal Broadcast）：开发者自身定义 intent的广播（最常用），sendBroadcast(intent); 系统广播（System Broadcast）：涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播，每个广播都有特定的Intent - Filter（包括具体的action） 有序广播（Ordered Broadcast）：发送出去的广播被广播接收者按照先后顺序接收，按照Priority属性值从大-小排序；Priority属性相同者，动态注册的广播优先； sendOrderedBroadcast(intent); 特点 接收广播按顺序接收 先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不再接收到此广播； 先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播 App应用内广播（Local Broadcast）：Android高效安全的本地广播LocalBroadcast完全解析 - 简书 粘性广播（Sticky Broadcast）：由于在Android5.0 &amp; API 21中已经失效，所以不建议使用 15.RecycleView方法：onCreateViewHolder() 、onBinderViewHolder()、getItemCount() 三种布局：垂直or水平、网格、瀑布流 需要自定义分割线、易于回收、View复用、便于实现添加和删除item动画。 16.各种集合比较SparseArray稀疏数组与HashMap相比，正序插入快，逆序插入慢，查找慢占用内存少于HashMap； HashMap和ArrayMap的区别 ①查找效率 HashMap依据HashCode查找，效率增加；ArrayMap使用二分法查找，效率下降。数量大时用HashMap ②扩展数量 HashMap初始值16个长度，每次扩容申请双倍的数组空间；A扩容申请空间更少 ③扩容效率 ArrayMap更好 ④内存消耗 数据量小时，ArrayMap更节省内存 总结：数据量小时，并需要频繁使用map存储时，用ArrayMap，数据量大时，用HashMap。 HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。 HashMap 的实例有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。在Java编程语言中，加载因子默认值为0.75，默认哈希表元为101 hashMap的默认加载因子为0.75，加载因子表示Hsah表中元素的填满的程度。加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。冲突的机会越大,则查找的成本越高。反之,查找的成本越小。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。 参考文章：为什么java Hashmap 中的加载因子是默认为0.75 - 简书 LinkedList 链表结构，查找慢，插入快； ArrayList 数组结构，查找快，插入慢。 17.SQLite升级而不影响现有数据，DBHelper单例，在OnUpgrade()方法中判断oldVersion对数据库进行增删改查以实现数据库升级。18.Bitmap参考文章：Android Bitmap详解 - 小爷宋 - 博客园 位图包括图片的像素、长宽、颜色等描述，可通过这些信息计算出图像占用内存的大小。作为花架，可对图片做一些处理，位图文件显示效果好，但是非压缩格式，需要占用较大存储空间。 ①Config：表示图片像素类型 ②三种压缩格式：Bitmap.CompressFormat.JPEG、Bitmap.CompressFormat.PNG、Bitmap.CompressFormat.WEBP ③BitmapFactory提供了四类加载方法：decodeFile、decodeResource、decodeStream、decodeByteArray。巨图加载：BitmapRegionDecoder，可以按照区域进行加载。高效加载：核心其实也很简单，主要是采样压缩、缓存策略、异步加载等 ④内存优化：缓存LRU、缩放、Config、Compress选择、内存管理、缓存方式等等方面入手。、内存管理、内存优化、缩放、config、compress 开源框架：ImageLoader、Glide（google）、Fresco（FaceBook）、Picasso（Square） 图片优化：异步加载，压缩处理bitmapFactory.options，设置内存大小，缓存于内存、SD卡，没有内存再从网络取。 Picasso包体积小、清晰，但功能有局限不能加载gif、只能缓存全尺寸； Glide功能全面，擅长大型图片流，体积较大； Fresco内存优化，减少oom，体积更大。 如何处理大图：BitmapFactory.Options，把inJustDecodeBounds这个属性设为true，计算inSampleSize。参考文章：官方推荐方法，如何有效率的加载大图Bitmap - 月毛毛的专栏 - CSDN博客 19.Handler机制主线程不能进行耗时操作，子线程不能更新UI，Handler实现线程间通信，将要发送的消息保存到Message中，Handler调用sendMessage()方法将message发送到MessageQueue，Looper对象不断调用loop()方法，不断从MessageQueue中取出message交给handler处理，从而实现线程间的通信。 主线程handler不需要调用Looper.prepare()，Looper.loop()，通过sendMessage将message添加到messagequeue。 子线程可以new Handler。 总结：当创建Handler时将通过ThreadLocal在当前线程绑定一个Looper对象，而Looper持有MessageQueue对象。执行Handler.sendMessage(Message)方法将一个待处理的Message插入到MessageQueue中，这时候通过Looper.loop()方法获取到队列中Message，然后再交由Handler.handleMessage(Message)来处理。 20.性能优化技巧启动速度优化，布局优化，内存、电量、APP大小优化、列表滑动优化等等。 性能优化工具：TraceView、Hierarchy Viewer。 21.ANR（Application Not Responding）扩展文链接：深入理解ANR - 简书 Android应用程序有一段时间响应不够灵敏，系统会向用户显示应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现ANR，而让用户每次都要处理这个对话框。因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。默认情况下，在android中Activity的最长执行时间是5秒，BroadcastReceiver的最长执行时间则是10秒。 原因：主线程做耗时操作；主线程被其他线程锁；CPU被其他进程占用，该进程没有分配CPU资源；OnReceiver过多操作，IO操作，如数据库、文件、网络。 22.自定义View扩展文链接：Android自定义View全解 - 简书 自定义组合控件 多个控件组合成为一个新的控件，方便多处复用 继承系统View控件 继承自TextView等系统控件，在系统控件的基础功能上进行扩展 继承View 不复用系统控件逻辑，继承View进行功能定义 继承系统ViewGroup 继承自LinearLayout等系统控件，在系统控件的基础功能上进行扩展 继承ViewViewGroup 不复用系统控件逻辑，继承ViewGroup进行功能定义 View绘制流程基本由measure()、layout()、draw()这个三个函数完成 函数作用相关方法 measure()测量View的宽高measure(),setMeasuredDimension(),onMeasure() layout()计算当前View以及子View的位置layout(),onLayout(),setFrame() draw()视图的绘制工作draw(),onDraw() 自定义View的注意事项 参考文章：Android自定义View注意事项 - 简书 ①需要在onMeasure方法中处理wrap_content的方法，让View支持wrap_content； ②避免padding和子元素的margin失效，让View支持padding； ③尽量不要在View中使用Handler，View中已提供了post系列方法，可替代Handler作用； ④避免造成内存泄漏，View中如果有线程或者动画，需要及时停止。 23.MVC、MVP、MVVM三种架构设计扩展文链接：Android高精战争（MVC、MVP、MVVM） - lihaoxiang123的博客 - CSDN博客 MVC全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。 MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。 MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）： View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity) Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合) Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。 View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试 MVC 与MVP的区别 （最主要区别）View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。 在MVP中，Activity的代码不臃肿； 在MVP中，Model(IUserModel的实现类)的改动不会影响Activity(View)，两者也互不干涉，而在MVC中会； 在MVP中，IUserView这个接口可以实现方便地对Presenter的测试； 在MVP中，UserPresenter可以用于多个视图，但是在MVC中的Activity就不行。 MVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。 24.APP 启动流程点击桌面图标，launcher进程启动主Activity以Binder方式发送给AMS服务，交付给ActivityManagerService处理Intent和flag信息，通过prepareMainLooper()方法loop处理消息 25.插件化解除代码耦合，插件支持热插拔，静默升级，从根本上解决65k属性和方法的bug，进行自定义classLoader。 插件化和热修复都是动态加载技术，使用场景不同，热修复为解决线上问题或者小功能更新，插件化解决应用上的大问题。 组件化：为了解耦，把复杂系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。 26.Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。Kotlin已正式成为Android官方支持开发语言。 React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和安卓两大平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。 flutter。 27.Framework 工作原理Android 系统对Linux、kernel、lib库等封装，提供WMS、AMS、binder机制，handler-message机制等方式，供APP使用。Framework 就是提供APP生存环境。 28.Android 屏幕适配各种dp文件，使用各种尺寸屏幕 布局文件中view设置高宽时不限定大小，尽量使用wrap_content，match_parent；代码中设置高宽前可获取屏幕大小，如果是线性布局可设置view在LinearLayout的weight；单位dp适配屏幕，单位sp适用字体，多图片，多布局。 29.事件分发机制dispatchTouchEvent() 负责事件分发。当点击事件产生后，事件首先传递给当前Activity，调用Activity的dispatchTouchEvent()方法，返回值为true则表示View或子View消费了此事件，如果返回true，则表示没有消费事件，并调用父View的onTouchEvent方法。 onTouchEvent()用于处理事件，返回值决定当前控件是否消费了这个事件，也就是说在当前控件在调用父View的onTouchEvent方法完Touch事件后，是否还允许Touch事件继续向上（父控件）传递，一但返回True，则父控件不用操心自己来处理Touch事件。返回true，则向上传递给父控件。 onInterceptTouchEvent() ViewGroup的一个方法，用于处理事件（类似于预处理，当然也可以不处理）并改变事件的传递方向，也就是决定是否允许Touch事件继续向下（子控件）传递，一但返回True（代表事件在当前的viewGroup中会被处理），则向下传递之路被截断（所有子控件将没有机会参与Touch事件），同时把事件传递给当前的控件的onTouchEvent()处理；返回false，则把事件交给子控件的onInterceptTouchEvent()。 事件分发机制原理图 当一个Touch事件(触摸事件为例)到达根节点，即Acitivty的ViewGroup时，它会依次下发，下发的过程是调用子View(ViewGroup)的dispatchTouchEvent方法实现的。简单来说，就是ViewGroup遍历它包含着的子View，调用每个View的dispatchTouchEvent方法，而当子View为ViewGroup时，又会通过调用ViwGroup的dispatchTouchEvent方法继续调用其内部的View的dispatchTouchEvent方法。上述例子中的消息下发顺序是这样的：①-②-⑤-⑥-⑦-③-④。dispatchTouchEvent方法只负责事件的分发，它拥有boolean类型的返回值，当返回为true时，顺序下发会中断。 小结：onInterceptTouchEvent()默认返回false，不做截获。返回true之后，事件流的后端控件就没有机会处理touch事件。view的onTouchEvent()返回了false，那么该事件将被传递至其上一层次的view的onTouchEvent()处理，如果onTouchEvent()返回了true，那么后续事件将可以继续传递给该view的onTouchEvent()处理。 30.Android 动画分类：视图，属性，帧，gif。31.Android 进程一般大体分为前台进程，后台进程，可见进程，服务进程，空进程这五大进程。其中空进程优先级最低，调用startService()让service所在进程成为前台进程，service的onDestory()里重新启动自己可避免后台进程被杀死。 一个应用允许多个进程，在清单文件配置的service为一个进程，Android:process就可以配置； 多进程会引起的异常：静态成员和单例模式会失效，线程同步机制完全失效，SharedPreferences可靠性下降，Application会多次创建。 32.Android 五大存储方式使用SharedPreferences存储数据； 文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据。 当APP没有获取文件存储权限时，当需要存储大文件时，可以保存在APP-data-cache目录里。 ContentProvider：抽象类，为不同应用数据提供数据共享，提供统一接口，通过uri标识要访问的数据。 33.屏幕旋转Activity生命周期参考文章链接：Activity横竖屏切换生命周期变化 - 简书 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行1次，切竖屏时会执行1次 2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 3、设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 4、设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，切屏切记要加上screenSize,否则4.0版本以上生命周期不生效 34.Activity 四大启动模式standard 启动模式 Activity 默认的启动模式，每次 startActivity 都会在栈顶创建一个新的实例，在同一个任务中可以存在多个Activity 的实例。 singleTop 启动模式 栈顶复用，也就是说，要启动 singleTop 模式的 Activity，如果它恰好在当前栈顶，那么直接复用，执行其 onNewIntent 方法。否则，就重新创建一个实例入栈。 singleTask 启动模式 在系统中只有一个实例，当再次启动该 Activity 时，会重用已存在的任务和实例，并且会调用这个实例的 onNewIntent()方法，将 Intent 实例传递到该实例中。 singleInstance 启动模式 总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他 Activity 会自动运行于另一个任务中。当再次启动该 Activity 的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将 Intent 实例传递到该实例中。 总结：①standard每一次都会创建新的实例；②singleTop栈顶复用。和standard相似，但是如果栈顶已有实例，复用该实例，回调onNewIntent()方法；③singleTask栈内复用。查找栈内有没有该实例，有则复用回调onNewIntent()方法，如果没有，新建Activity，并入栈；④singleInstance单例模式，全局唯一。具备singleTask所有特性，独占一个任务栈。 35.CPU是一个有多功能的优秀领导者，它的优点在于调度、管理、协调能力强，计算能力则位于其次，而GPU相当于一个能接受CPU调度的“拥有强大计算能力”的员工，GPU提供了多核并行计算的基础结构，且核心数非常多，可支撑大量数据的并行操作，拥有更高的访存速度，更高的浮点运算能力。36.UI卡顿原因每16ms绘制一次Activity，如果由于一些原因导致了我们的逻辑、CPU耗时、GPU耗时大于16ms(应用卡顿的根源就在于16ms内不能完成绘制渲染合成过程,16ms需要完成视图树的所有测量、布局、绘制渲染及合成)，UI就无法完成一次绘制，那么就会造成卡顿。①内存抖动问题，②方法耗时，③view本身卡顿。 解决办法：修改方法，使其不耗时，放到子线程中，如网络访问，大文件操作等，防止ANR，避免GPU过度绘制。 37.Application的生命周期参考文章：Android中Application的用途及生命周期_YY小爬虫_新浪博客 ①onCreate0 在创建应用程序时创建； ②onTerminate() 在模拟环境下执行。当终止应用程序对象时调用，不保证一定被调用，当程序是被内核终止以便为其他应用程序释放资源，那么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程； ③onLowMemory() 低内存时执行。好的应用程序一般会在这个方法里面释放一些不必要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况； ④onConfigurationChanged(Configuration newConfig) 配置改变时触发这个方法。 ⑤onTrimMemory(int level) 程序在进行内存清理时执行。 38.如何避免因引入的开源库导致的安全性和稳定性？由于项目引入了太多第三方开源库，Android APP有65536方法数的问题，可使用multidex解决。Android Methods Count插件可以高效统计Android开源库的方法数。 39.简单的音频/视频格式PCM：脉冲编码调制，由二进制数字信号对光源进行通断调制产生，没有压缩的编码方式。 WAV：无损音频文件格式，PCM是无损WAV文件中音频数据的一种编码方式，但是WAV还可以用其它编码。 AVI：音视频交错，调用方便，图像质量好，压缩标准可选。 WMV：可扩充的媒体类型，本地或网络回放，流优先级化。 3GP：3G流媒体，配合3G网络高速传输而开发。 FLV：文件小，加载速度快，用于网络观看视频。 MP4：音视频压缩编码标准。 40.线程同步的方法转载文章：多线程同步的五种方法 - 平凡希 - 博客园 ①synchronized 即有synchronized关键字修饰的方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态； ②同步代码块 即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步； ③使用特殊变量Volatile （1）volatile关键字为域变量的访问提供了一种免锁机制； （2）使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新； （3）因此每次使用该域就要重新计算，而不是使用寄存器中的值； （4）volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。 ④使用重入锁 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力； ⑤使用局部变量； ⑥使用阻塞队列。 线程sleep()和wait()的区别 sleep()不释放同步锁，自动唤醒，需要try-catch，线程方法。 wait()释放同步锁，需要notify唤醒，是object方法。 线程的生命周期？如何中断？ 生命周期：文章转载：多线程——线程的生命周期 - 积_跬步 - 博客园 ① 新建状态(New Thread)：在Java语言中使用new 操作符创建一个线程后，该线程仅仅是一个空对象，它具备类线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。 线程处于创建状态时，可通过Thread类的方法来设置各种属性，如线程的优先级(setPriority)、线程名(setName)和线程的类型(setDaemon)等。 ② 就绪状态(Runnable)：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个线程执行了yield()方法，那么该线程会被暂时剥夺CPU资源，重新进入就绪状态。 ③ 运行状态(Running)：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。 a) 可以通过Thread类的isAlive方法来判断线程是否处于就绪/运行状态：当线程处于就绪/运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于阻塞状态，也可能处于停止状态。 ④ 阻塞和唤醒线程 阻塞状态(Blocked)：一个正在运行的线程因某些原因不能继续运行时，就进入阻塞 状态。这些原因包括： ​ a)当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程对象会被置入一个阻塞集内，等待超时而自动苏醒。 ​ b)当多个线程试图进入某个同步区域时，没能进入该同步区域的线程会被置入锁定集，直到获得该同步区域的锁，进入就绪状态。 ​ c)当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集中，知道执行了该对象的notify()方法wait()/notify()方法的执行要求线程首先获得该对象的锁。 ⑤ 死亡状态(Dead)：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。 终止线程的三种方法 ① 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。 ② 使用stop方法强制终止线程(这个方法不推荐使用，因为stop和suppend、resume一样，也可能发生不可预料的结果)。 ③ 使用interrupt方法中断线程。 41.线程安全的单例1234567891011121314 private static SingleInstance instance; public static SingleInstance getInstance(SingleInstance instance)&#123; if (instance == null) &#123; synchronized (SingleInstance.class) &#123; if (instance == null) &#123; instance = new SingleInstance(); &#125; &#125; &#125; return instance; &#125;&#125; 42.Serializable 序列化接口，开销大，建议使用，java方法； Parcelelable 使用麻烦，效率高，多用于内存，Android方法。 43.Service启动方式和生命周期 ①startService()：开启，调用者退出后Service仍在； 生命周期：onCreate()–onStartCommand()–onDestory() 通过startService启动后，service会一直无限期运行下去，只有外部调用了stopService()或stopSelf()方法时，该Service才会停止运行并销毁。 ②bindService()：开启，调用者退出后Service随即退出。 生命周期：onCreate()–onBind()–onUnBind()–onDestory() ①+② 的生命周期：onCreate()–onStartCommand()–onBind()–onUnBind()–onDestory() 44.Android 常见布局 FrameLayout （框架布局）、LinearLayout（线性布局）、AbsoluteLayout（绝对布局）、RelativeLayout（相对布局）、TableLayout（表格布局） 45.Http是服务层，借助HttpClient和HttpUrlConnection建立短连接，请求一次后断开，需要重连时才连。 ①HttpClient：开源框架，无封装，原始，使用方便，开发快，实现比较稳定，Android废弃，Android 6.0删除； ②HttpUrlConnection：对网络请求没有HttpClient封装彻底，Android2.2之前存在bug，所以2.2之前用HttpClient，之后用容易优化的HttpUrlConnection，开源框架，封装了请求头、参数、内容体、响应在I/O流，接口中统一封成了HttpGet/HttpPost，减少了操作的繁琐性，访问速度快。 Https是以安全为目标的Http通道，简单讲就是Http的安全版，即Http下加入SSL层，安全基础是SSL，加密的详细内容是SSL，作用：建立一个信息安全通道，来保证数据传输的安全、确认网站的安全性。 Volley：适合处理数据量小，通信频繁的网络操作，内部封装了异步操作，可直接在线程执行并处理结果，同时可以取消，容易扩展，但是不适合大数据请求，比如下载表现糟糕，不支持https，android2.2及以下用HttpClient，android2.3及以上用HttpUrlConnection。 OkHttp：专注于提升网络连接效率的Http客户端，能够实现IP和端口的请求重用一个socket，大大降低了连接时间，也降低了服务器的压力，对Http和https都有良好的支持，不用担心app版本更换的困扰，但是okHttp请求是在线程里执行，不能直接刷新UI，需要手动处理。 总结：在项目实际运用中，视情况选择网络请求方式，也可以Volley+OkHttp搭配使用。异步回调用Volley，网络请求底层用OkHttp RxJava + Retrofit3 + OkHttp3 ①RxJava 主要用来实现线程切换，我们制定订阅在哪一个线程，观察在哪个线程，通过操作符进行数据变换，整个过程是键式的，简化逻辑。 ②Retrofit 是网络请求的一个架子，用它设置一些参数和请求Url。 ③OkHttp是网络请求的内核，实际的网络请求是它发出来的。 TCP 是网络层，滑动窗口协议，拥塞控制，可靠连接借助socket长连接，需要3次握手，第四次取消连接，画面优先。 UDP：不关心数据是否到达，是否阻塞，不可靠连接，流畅优先。 46.如何节省内存使用，主动回收内存？ 答：尽量多使用内部类，提高程序效率，回收已使用的资源，合理使用缓存，合理设置变量的作用范围。 47.Activity如何生成View？ 答：Activity执行在attch()方法的时候，会创建一个PhoneWindow（Window的子类），在onCreate()方法的setContentView()方法中，创建DecorView，DecorView的addView()方法，把layout布局加载出来。通过onDraw()画出来，画View之前调用onMeasure()方法计算显示的大小。 48.为什么要使用多线程？ ①更好地利用CPU资源；②进程间数据不能数据共享，线程可以；③系统创建进程需要为该进程重新分配系统资源，创建线程代价较小；④Java语言内置了多线程功能支持，简化了java多线程编程。 线程池是一种多线程处理形式，处理过程中将任务添加到队列，在创建线程后自动启动这些任务，线程池线程是后台线程，每个线程都使用默认的堆栈大小，以优先级执行。 49.现场保护123456789@Overrideprotected void onSaveInstanceState(Bundle savedInstanceState) &#123; super.onSaveInstanceState(savedInstanceState);&#125;@Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState);&#125; 使用场景：①进程被异常杀死；②系统配置发生变化（比如横竖屏切花换）。 当Activity处于onPause() ，onStop() ，onDestroy() 三种状态时程序可能会被Android系统回收掉，这时可能会造成用户在程序当中的数据或者修改丢失。于是我们需要”现场保护”，当下次重启程序或activity时恢复上一次的数据。 因此Android提供了onSaveInstanceState(Bundlout State)方法会在程序被回收前进行调用，但需要注意的是onSaveInstanceState()方法只适合保存瞬态数据, 比如UI控件的状态, 成员变量的值等，而不应该用来保存持久化数据。onRestoreInstanceState方法，需要注意的是onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。 50.内存溢出，内存泄漏 内存溢出（OOM）：程序在申请内存时，没有足够的内存空间使用。 原因：加载对象过大，相对资源较多，来不及加载。 解决办法：内存引用上做处理，比如用软引用；图片加载时处理（压缩等）；动态回收内存；优化内存分配，自定义堆内存大小，避免使用Enum，减少BitMap的内存占用，内存对象重复使用，避免对象的内存泄漏。 内存泄漏（memory leak）： 程序在申请内存后，无法释放已申请的内存空间，一次泄漏危害可忽略，但推积严重最终会导致OOM； handler泄露：消息引用了handler对象，该对象又隐性地持有了Activity对象，当发生GC时以为message-handler-activity的引用链导致Activity无法被回收，即发生泄漏，简单来说就是handler对activity强引用导致的GC，无法及时回收Activity。（PS：GC垃圾回收，当堆内存里的对象没有引用指向时，GC回收。） 解决办法：方法一：通过程序逻辑来进行保护。 1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。 方法二：将Handler声明为静态类。 PS:在Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。 静态类不持有外部类的对象，所以你的Activity可以随意被回收。由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）。 WebView泄漏：创建的对象没有在合适的时间销毁，则一直存在内存里耗费内存空间，WebView不建议在xml文件中指明，因为一直存在不能对其销毁，应该在代码中创建WebView，通过addView()的方式加入layout，在Activity 的onDestory()方法中需要销毁，先将加载的内容置为null，webView.destroy(); 12345678910111213141516171819202122WebView mWebView = new WebView(getApplicationContext()); @Override protected void onDestroy() &#123; if( mWebView!=null) &#123; ViewParent parent = mWebView.getParent(); if (parent != null) &#123; ((ViewGroup) parent).removeView(mWebView); &#125; mWebView.stopLoading(); // 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错 mWebView.getSettings().setJavaScriptEnabled(false); mWebView.clearHistory(); mWebView.clearView(); mWebView.removeAllViews(); mWebView.destroy(); &#125; super.onDestroy(); &#125; 51.JNI和NDK​ JNI是Java调用Native 语言的一种特性，属于Java，Java本地接口，使Java与本地其他类型语言交互（C++） ​ 实现步骤：在Java中声明Native方法，编译该文件得到.class文件，通过javah命令导出JNI头文件（.h文件），使用Java需要交互的本地代码实现子啊Java中声明的Native方法，编译so文件，通过Java执行Java程序，最终实现Java调用本地代码 ​ NDK（Native Develop Kit）：Android开发工具包，属于Android。 ​ 作用：快速开发C、C++动态库，并自动将so文件和应用打包成APK，即可通过NDK在Android中使用JNI与本地代码（C、C++）交互（Android开发需要本地代码C、C++实现） ​ 特点：运行效率高，代码安全性高，功能拓展性好，易于代码复用和移植。 ​ 使用步骤：①配置NDK环境；②创建Android项目，并于NDK进行关联；③在Android项目中声明所需调用的Native方法；④使用该Native方法；⑤通过NDK build命令编译产生so文件；⑥编译AS工程，实现调用本地代码。 ​ JNI和NDK的关系：JNI实现目的，NDK是Android实现JNI的手段，即在AS开发环境中通过NDK从而实现JNI功能。 52.常用的设计模式及其实现思想和作用转载文章：23种设计模式全解析 - codeTao - 博客园 ①单例模式：单例对象能保证在一个JVM中，该对象只有一个实例存在。 ②工厂模式 一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。 抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。 ③适配器模式 将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 ④装饰模式（Decorator） 顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能。 装饰器模式的应用场景： 1、需要扩展一个类的功能。 2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点：产生过多相似的对象，不易排错！ ⑤代理模式（Proxy）：多一个代理类出来，替原对象进行一些操作。 ⑥桥接模式（Bridge）：桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化。 ⑦观察者模式：一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。 ⑧访问者模式：一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。 53.HashMap、 HashTable、HashSet的异同转载文章：HashSet HashTable HashMap的区别 及其Java集合介绍 - ywl925 - 博客园 ①HashSet是Set的一个实现类，HashMap是Map的一个实现类，同时HashMap是HashTable的替代品 ②HashSet以对象作为元素，而HashMap以(key-value)的一组对象作为元素，且HashSet拒绝接受重复的对象。HashMap可以看作三个视图：key的Set，value的Collection，Entry的Set。 这里HashSet就是其实就是HashMap的一个视图。 HashSet内部就是使用HashMap实现的，和HashMap不同的是它不需要Key和Value两个值。 HashMap是一个数组和链表的结合体，新加入的放在链头，重复的key不同的alue被新value替代 ③继承不同 public class Hashtable extends Dictionary&lt;&gt; implements Map&lt;&gt; public class HashMap extends AbstractMap&lt;&gt; implements Map&lt;&gt; ④HashTable 方法同步，而HashMap需要自己增加同步处理。 ⑤HashTable中，key和value都不允许出现null值。 在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。用containsKey()方法来判断是否存在某个键。 ⑥两个遍历方式的内部实现上不同。 HashTable、HashMap都使用了 Iterator。而由于历史原因，HashTable还使用了Enumeration的方式 。 ⑦哈希值的使用不同 HashTable直接使用对象的hashCode，HashTable中hash数组默认大小是11，增加的方式是 old*2+1。 而HashMap重新计算hash值，HashMap中hash数组的默认大小是16，而且一定是2的指数。 如何实现HashMap线程同步？ ①使用 java.util.Hashtable 类，此类是线程安全的。 ②使用 java.util.concurrent.ConcurrentHashMap，此类是线程安全的。 ③使用 java.util.Collections.synchronizedMap() 方法包装 HashMap object，得到线程安全的Map，并在此Map上进行操作。 54.Android 中内存泄漏原因及优化方案？文章转载：Android 中内存泄漏的原因和解决方案 - 简书 ①非静态内部类造成的内存泄漏 非静态类会持有外部类的引用，如果这个内部类比外部类的生命周期长，在外部类被销毁时，内部类无法回收，即造成内存泄漏； ②外部类中持有非静态内部类的静态对象 保持一致的生命周期，将内部类对象改成非静态； ③Handler 或 Runnable 作为非静态内部类 Handler 和 Runnable 作为匿名内部类，都会持有 Activity 的引用，由于 Handler 和 Runnable 的生命周期比 Activity 长，导致Activity 无法被回收，从而造成内存泄漏。 解决办法：将Handler 和 Runnable 定义为静态内部类，在Activity 的onDestory()方法中调用Handler 的 removeCallbacks 方法来移除 Message。 还有一种特殊情况，如果 Handler 或者 Runnable 中持有 Context 对象，那么即使使用静态内部类，还是会发生内存泄漏。解决办法：使用弱引用 ④其他内存泄漏情况：比如BraodcastReceiver 未注销，InputStream 未关闭，再代码中多注意注销或关闭。 55.LeakCanary内存优化参考文章：LeakCanary原理解析 - 简书 ①项目如何使用LeakCanary LeakCanary.enableDisplayLeakActivity(context);内存溢出图标，图标以通知的形式显示内存溢出 ②工作机制 LeakCanary.install() 会返回一个预定义的 RefWatcher，同时也会启用一个 ActivityRefWatcher，用于自动监控调用Activity.onDestroy() 之后泄露的 activity。 1.RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。 2.然后在后台线程检查引用是否被清除，如果没有，调用GC。 3.如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。 4.在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。 5.得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。 6.HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。 7.引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。 56.多线程、线程池参考文章：Java中的多线程你只要看这一篇就够了 - Givefine - 博客园 线程的并行和并发 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全：多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，实现线程同步的方法有很多，临界区对象就是其中一种。 Java通过Executors提供四种线程池（from 百度） newCachedThreadPool——创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool——创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool——创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor——创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 参考文章：Java并发编程：线程池的使用 - Matrix海子 - 博客园 ①线程池中的线程初始化 创建线程池后，线程池中没有线程，需要提交任务才会创建线程。 prestartCoreThread()：初始化一个核心线程； prestartAllCoreThreads()：初始化所有核心线程 ②workQueue，任务缓存队列，用来存放等待执行的任务 workQueue的类型为BlockingQueue，通常可以取下面三种类型： 1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小； 2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE； 3）SynchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。 ③任务拒绝策略 当线程池的任务缓存队列已满或线程数目达到maximumPoolSize，还有任务来时会采用任务拒绝策略 1）ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 2）ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 3）ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） 4）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 ④线程池的关闭 1）shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 2）shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 ⑤线程池容量的动态调整 1）setCorePoolSize：设置核心池大小 2）setMaximumPoolSize：设置线程池最大能创建的线程数目大小 参考文章：由浅入深理解Java线程池及线程池的如何使用 - Janti - 博客园 corePoolSize :线程池的核心池大小，在创建线程池之后，线程池默认没有任何线程。 当有任务过来的时候才会去创建创建线程执行任务。换个说法，线程池创建之后，线程池中的线程数为0，当任务过来就会创建一个线程去执行，直到线程数达到corePoolSize之后，就会被到达的任务放在队列中。（注意是到达的任务）。换句更精炼的话：corePoolSize表示允许线程池中允许同时运行的最大线程数。 如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize :线程池允许的最大线程数，他表示最大能创建多少个线程。maximumPoolSize肯定是大于等于corePoolSize。 keepAliveTime :表示线程没有任务时最多保持多久然后停止。默认情况下，只有线程池中线程数大于corePoolSize时，keepAliveTime才会起作用。换句话说，当线程池中的线程数大于corePoolSize，并且一个线程空闲时间达到了keepAliveTime，那么就是shutdown。 Unit:keepAliveTime的单位。 workQueue：一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能 threadFactory：线程工厂，用来创建线程。 handler :表示当拒绝处理任务时的策略。 在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池： Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE Executors.newSingleThreadExecutor(); //创建容量为1的缓冲池 Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池 57.腾讯 Bugly腾讯公司为移动开发者开放的服务之一，面向移动开发者提供专业的 Crash 监控、崩溃分析等质量跟踪服务。Bugly 能帮助移动互联网开发者更及时地发现掌控异常，更全面的了解定位异常，更高效的修复解决异常。 针对移动应用，腾讯 Bugly 提供了专业的 Crash、Android ANR ( application not response)、iOS 卡顿监控和解决方案。移动开发者 ( Android / iOS ) 可以通过监控，快速发现用户在使用过程中出现的 Crash (崩溃)、Android ANR 和 iOS 卡顿，并根据上报的信息快速定位和解决问题。 58.Glidegithub 地址 项目依赖Glide，在app build.gradle 中配置 compile’com.github.bumptech.glide:glide:3.7.0’ 使用glide3.7版本，更高版本或出现异常：Error:Failed to resolve: com.android.support:support-annotations:27.0.2 Glide缓存机制 内存存缓存的 读存都在Engine类中完成。内存缓存使用弱引用和LruCache结合完成的,弱引用来缓存的是正在使用中的图片。图片封装类Resources内部有个计数器判断是该图片否正在使用。 Glide内存缓存的流程 读：是先从lruCache取，取不到再从弱引用中取； 存：内存缓存取不到，从网络拉取回来先放在弱引用里，渲染图片，图片对象Resources使用计数加一； 渲染完图片，图片对象Resources使用计数减一，如果计数为0，图片缓存从弱引用中删除，放入lruCache缓存。 参考文章： Google推荐——Glide使用详解 - 简书 Glide 系列(四) Glide缓存机制 - 野生的安卓兽 - 简书 59.Frescogithub 地址 项目依赖Glide，在app build.gradle 中配置：implementation’com.facebook.fresco:fresco:1.9.0’ https://github.com/desmond1121/Fresco-Source-Analysis 参考文章：Fresco的使用小结 - 简书 https://blog.csdn.net/yw59792649/article/details/78921025 60.React Native混合开发技术移动开发-混合App介绍 - Primise7的博客 - CSDN博客]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试题集]]></title>
    <url>%2Fposts%2F4a3cde30.html</url>
    <content type="text"><![CDATA[Java部分Android部分数据结构与算法部分常用的开源库部分计算机网络认识 1.Java部分1.1 操作系统相关 1.什么是操作系统？ 2.什么是线程，什么是进程？ 1.2 JDK&amp;JVM&amp;JRE 1.JDK &amp; JVM &amp; JRE分别是什么以及它们的区别？ 2.解释一下为什么Java可以跨平台？ 1.3 面向过程 &amp; 面向对象 1.什么是面向过程 &amp; 什么是面向对象 &amp; 区别？ 2.给我说说Java面向对象的特征以及讲讲你代码中凸显这些特征的经验。 3.什么是重载 &amp; 什么是重写 &amp; 区别。 4.谈谈你对this和super的认识。 5.接口和抽象类的区别。 6.静态属性和静态方法能被继承吗？静态方法又是否能被重写呢？ 7.给我说说权限修饰符特性。 8.给我谈谈Java中的内部类。 9.闭包和内部类的区别？ 10.Java多态的实现机制是什么？ 11.谈谈你对对象生命周期的认识？ 12.static关键字的作用？ 13.final关键字的作用。 1.4 八大基本数据类型&amp;引用类型 1.说说Java中的8大基本类型 &amp; 内存中占有的字节 &amp; 什么是引用类型？ 2.什么是拆箱 &amp; 装箱，能给我举栗子吗？ 1.5 数组 1.能说说多维数组在内存上是怎么存储的吗？ 2.你对数组二次封装过吗？说说封装了什么 1.6 Java异常 1.说说Java异常体系主要用来干什么的 &amp; 异常体系？ 2.Error和Exception的区别？ 3.说说运行时异常和非运行时异常的区别？ 4.如何自定义一个异常？ 5.throw和throws 的区别？ 6.try{}catch{}finally{}可以没有finally吗？ 7.finally语块有什么特点？ 8.return在try{}catch{}finally{}中执行具有哪些规则？ 9.给我例举至少5个常见的运行时异常。 1.7 NIO/BIO/AIO 1.NIO是什么 &amp; BIO是什么 &amp; AIO是什么 &amp; 它们之间的区别？ 2.IO按照方向和数据类型划分能划分为哪些数据流？ 3.能给我说说NIO有什么特点？平常开发中使用过吗？ 1.8 集合(容器) 1.说说Java中集合的框架？ 2.Collection &amp; Map区别 3.谈谈你常用的集合 &amp; 它们底层的实现方式 &amp; 优缺点 &amp; 使用场景。 4.Map的遍历方式有哪些？ 5.给我说说ArrayList的扩容机制. 6.什么是深拷贝 &amp; 浅拷贝 &amp; 如何深拷贝一个List集合. 7.Set是如何确保它的唯一性的。 8.你觉得HashMap的元素顺序和什么有关？ 9.Java中HashMap如何解决哈希碰撞的？ 10.ConcurrentHashMap如何实现并发访问的？ 11.谈谈Java集合中那些线程安全的集合 &amp; 实现原理。 12.说说有哪些集合能加入null,哪些不能加入null,为什么？ 13.说说LinkedHashMap原理。 14.Collection 和 Collections的区别？ 15.比较一下ArrayMap和HashMap。 16.说说HashMap的原理。 1.9 线程 1.什么是线程？能解决什么问题。 2.Java中创建线程的2种方式 &amp; 区别？ 3.给我说说线程的生命周期。 4.线程死锁的原因 &amp; 举个栗子 &amp; 如何避免死锁。 5.Synchronized放在静态方法和非静态方法上的锁对象分别是什么？ 6.如何停止掉一个线程？ 7.给我说说线程池的种类 &amp; 特点 &amp; 内部原理 &amp; 平时当中使用案例。 8.给我谈谈你是如何保证线程数据安全问题的？ 9.wait()和sleep()的区别？ 10.什么是公平锁&amp;非公平锁&amp;区别？ 11.给我讲讲线程间通信 12.volatile关键字是如何使用的？原理是什么 13.说说使用5个线程去计算一个数组之和的思路。 14.谈谈线程阻塞的原因有哪些？ 15.谈谈你对notify的理解？ 16.你觉得Lock和Synchronized的区别是什么？ 17.谈谈你对ReentrantLock的认识。 18.调用run()和start()的区别？ 19.transient关键字的用法 &amp; 作用 &amp; 原理。 20.线程池的种类 &amp; 工作原理 &amp; ThreadPoolExecutor的工作策略有哪些？ 21.ThreadLocal了解吗？说说原理。 22.权衡多线程的性能。 23.如何理解同步和异步，阻塞和非阻塞。 1.10 泛型 1.什么是泛型？能解决什么问题？ 2.说说Java中泛型的工作机制？ 3.在泛型种extends和super关键字的区别是什么？ 1.11 反射 1.什么是反射？ 2.如何获取一个类的成员变量 &amp; 成员方法 &amp; 注解信息 &amp; …。 3.通常在项目当中用到反射多吗？都是用来干嘛？ 1.12 注解 1.什么是注解 &amp; 它和注释的区别？ 2.注解的工作机制是什么？ 1.13 Socket编程 1.什么是Socket编程？ 2.什么是TCP,什么是UDP,二者之间区别如何？ 1.14 设计模式 1.说说设计模式的六大原则。 2.请讲讲你会使用的一些设计模式？ 3.请说说单例模式 &amp; 你项目中常用的单例模式。 4.懒汉单例模式为什么要加volaitle？ 5.能否给我说说Android中至少3个用到设计模式的栗子？ 1.15 JVM相关 1.什么是class文件？ 2.Java代码执行流程？ 3.Java内存结构 &amp; 内存模型。 4.GC回收机制。 5.Java虚拟机是如何加载一个类的？ 6.给我谈谈类加载器。 7.谈谈static编译运行时的流程，在虚拟机中如何保存的？ 8.说说Java种的4种引用以及用法？ 9.如何判断一个对象是死亡的？ 10.代码中直接调用System.gc()会发生什么？ 11.一个强引用直接被null赋值，那么这个对象会被立刻回收吗？ 12.String a = “a”+”b”+”c”;在内存中创建了几个对象？ 13.谈谈你对字符集的理解。 14.常见的编码格式有哪些？ 15.utf-8中的中文占几个字节？int型占几个字节？ 16.谈谈你对逻辑地址和物理地址的理解？ 17.你知道对象什么时候会回调finalize方法吗？ 1.16 其它Java部分有关面试题 1.为什么局部内部类访问局部变量需要final? 2.String、StringBuffer、StringBuilder、CharSequence的区别。 3.equals和==的区别？ 4.关于字符串的拼接你在项目中常常怎么操作的？为什么不能用“+”的方式进行拼接呢？ 5.什么是Callback,讲讲你项目中使用的一些有关Callback的栗子。 6.retrun &amp; break &amp; continue 区别？ 7.如何判断一个字符串是回文字符串？ 8.final,finally,finalize的区别？ 9.什么是动态代理 &amp; 什么是静态代理？ 10.String为什么会加final？ 11.OOM可以try{}catch{}吗？ 12.给我谈谈正则表达式。 13.如何将String转成int? 14.谈谈你对String的理解。 15.你如何理解序列化？有哪些方式序列化？ 16.谈谈你对依赖注入的理解。 17.给我谈谈你对分派的理解。 2.Android 部分 四大组件是哪四个？ABCS(Activity,Braodcast,ContentProvider,Service) 2.1 Activity 1.Activity是什么？ 2.典型情况下的Activity生命周期？ 3.异常情况下的Activity的生命周期 &amp; 数据如何保存和恢复？ 4.从Activity A跳转到Activity B之后，然后再点击back建之后，它们的生命周期调用流程是什么？ 5.如何统计Activity的工作时间？ 6.给我说说Activity的启动模式 &amp; 使用场景。 7.如何在任意位置关掉应用所有Activity &amp; 如何在任意位置关掉指定的Activity？ 8.Activity的启动流程(从源码角度解析)？ 9.启动一个其它应用的Activity的生命周期分析。 10.Activity任务栈是什么？在项目中有用到它吗？说给我听听 11.什么情况下Activity不走onDestory? 12.什么情况下Activity会单独执行onPause? 13.a-&gt;b-&gt;c界面，其中b是SingleInstance的，那么c界面点back返回a界面，为什么？ 14.如果一个Activity弹出一个Dialog,那么这个Acitvity会回调哪些生命周期函数呢？ 15.Activity之间如何通信 &amp; Activity和Fragment之间通信 &amp; Activity和Service之间通信？ 16.说说Activity横竖屏切换的生命周期。 17.前台切换到后台，然后在回到前台时Activity的生命周期。 18.下拉状态栏时Activity的生命周期？ 19.Activity与Fragment的生命周期比较？ 20.了解哪些Activity常用的标记位Flags？ 21.谈谈隐式启动和显示启动Activity的方式？ 22.Activity用Intent传递数据和Bundle传递数据的区别？为什么不用HashMap呢？ 23.在隐式启动中Intent可以设置多个action,多个category吗 &amp; 顺便讲讲它们的匹配规则？ 24.Activity可以设置为对话框的形式吗？ 25.如何给Activity设置进入和退出的动画？ 26.Activity使用Intent传递数据是否有限制 &amp; 如果传递一个复杂的对象，例如一个复杂的控件对象应该怎么做？ 2.2 BroadcastReceiver 1.广播是什么？ 2.广播的注册方式有哪些？ 3.广播的分类 &amp; 特性 &amp; 使用场景？ 4.说说系统广播和本地广播的原理 &amp; 区别 &amp; 使用场景。 5.有两个应用注册了一样的广播，一个是静态，一个是动态，连优先级也一样，那么当广播从系统发出来后，哪个应用先接收到广播？ 2.3 ContentProvider 1.什么是内容提供者？ 2.说说如何创建自己应用的内容提供者 &amp; 使用场景。 3.说说ContentProvider的原理。 4.ContentProvider,ContentResolver,ContentObserver之间的关系？ 5.说说ContentProvider的权限管理。 2.4 Service 1.什么是Service? 2.说说Service的生命周期。 3.Service和Thread的区别？ 4.Android 5.0以上的隐式启动问题及其解决方案。 5.给我说说Service保活方案 6.IntentService是什么 &amp; 原理 &amp; 使用场景 &amp; 和Service的区别。 7.创建一个独立进程的Service应该怎样做？ 8.Service和Activity之间如何通信？ 9.说说你了解的系统Service。 10.谈谈你对ActivityManagerService的理解。 11.在Activtiy中创建一个Thread和在一个Service中创建一个Thread的区别？ 2.5 Handler 1.子线程一定不能更新UI吗？ 2.给我说说Handler的原理 3.Handler导致的内存泄露你是如何解决的？ 4.如何使用Handler让子线程和子线程通信？ 5.你能给我说说Handler的设计原理？ 6.HandlerThread是什么 &amp; 原理 &amp; 使用场景？ 7.IdleHandler是什么？ 8.一个线程能否创建多个Handler,Handler和Looper之间的对应关系？ 9.为什么Android系统不建议子线程访问UI？ 10.Looper死循环为什么不会导致应用卡死？ 11.使用Handler的postDealy后消息队列有什么变化？ 12.可以在子线程直接new一个Handler出来吗？ 13.Message对象创建的方式有哪些 &amp; 区别？ 2.6 AsyncTask 1.AsyncTask是什么？能解决什么问题 2.给我谈谈AsyncTask的三个泛型参数作用 &amp; 它的一些方法作用。 3.给我说说AsyncTask的原理。 4.你觉得AsyncTask有不足之处吗？ 2.7 Fragment 1.Android中v4包下Fragment和app包下Fragment的区别是什么？ 2.Fragment的生命周期 &amp; 请结合Activity的生命周期再一起说说。 3.说说Fragment如何进行懒加载。 4.ViewPager + Fragment结合使用会出现内存泄漏吗 &amp; 如何解决？ 5.Fragment如何和Activity进行通信 &amp; Fragment之间如何进行通信？ 6.给我谈谈Fragment3种切换的方式以及区别 &amp; 使用场景。 7.getFragmentManager,getSupportFragmentManager,getChildFragmentManager之间的区别？ 8.FragmentPagerAdapter和FragmentStatePagerAdapter区别？ 9.Fragment如何实现类似Activity栈的压栈和出栈效果的？ 2.8 序列化 1.什么是序列化 &amp; 能用来干什么？ 2.Android中序列化方式有几种？说说它们的区别。 3.如果想要序列化的类中某些字段不序列化，那么应该怎么做？ 2.9 IPC 1.说说你对Android多进程开发的认识？ 2.Android中进程间通信的方式有哪些？ 3.什么是AIDL?如何创建一个AIDL。 2.10 文件存储 1.说说Android中数据持久化的方式 &amp; 使用场景。 2.接触过MMKV吗？说说SharedPreference和它的区别。 3.第三方数据库框架用过哪些？有没有自己封装过一个SQLite的库？ 4.SQLite是线程安全的吗 &amp; SharedPreference是线程安全的吗？ 5.请简单的给我说说什么是三级缓存？ 6.SharedPreference的apply和commit的区别。 7.谈谈你对SQLite事务的认识。 8.千奇百怪的SQL语句考察。 9.SharePreference跨进程使用会怎么样？如何保证跨进程使用安全？ 10.谈谈SQLite升级要注意哪些地方？ 2.11 ListView &amp; RecyclerView 1.ListView是什么？如何使用？ 2.RecyclerView是什么？如何使用？如何返回不一样的Item。 3.ListView和RecycyclerView的区别是什么？ 4.分别讲讲你对ListView &amp; RecyclerView的优化经验。 5.给我说说RecyclerView的回收复用机制 6.说说你是如何给ListView &amp; RecyclerView加上拉刷新 &amp; 下拉加载更多机制。 7.谈谈你是如何对ListView &amp; RecycleView进行局部刷新的？ 8.谈谈如何进行分页加载？ 9.ScrollView下嵌套一个ListView通常会出现什么问题？ 10.一个ListView或者一个RecyclerView在显示新闻数据的时候，出现图片错位，可能的原因有哪些 &amp; 如何解决？ 2.12 图片编程 1.你对Bitmap了解吗？它在内存中如何存在？ 2.有关Bitmap导致OOM的原因知道吗？如何优化？ 3.给我谈谈图片压缩。 4.LruCache &amp; DiskLruCache原理。 5.说说你平常会使用的一些第三方图片加载库,最好给我谈谈它的原理。 6.如果让你设计一个图片加载库，你会如何设计？ 7.有一张非常大的图片,你如何去加载这张大图片？ 8.你知道Android中处理图片的一些库吗(OpenCv &amp; GPUImage …)？ 9.如何计算一张图片在内存中占用的大小？ 2.13 WebView 1.WebView是什么？ 2.WebView会导致内存泄露吗？原因是什么？解决方式有哪些？ 3.你知道Hybrid开发吗？说说你的相关经验。 4.说说WebSettings &amp; WebViewClient &amp; WebChromeClient这三个类的作用 &amp; 用法。 5.说说你了解的Hybrid框架。 2.14 ViewPager 1.什么是ViewPager?说说它的那些适配器。 2.你了解ViewPager2吗？和ViewPager 1有哪些区别？ 3.ViewPager + Fragment结合使用存在的内存泄漏的原因是什么？如何解决？ 2.15 View事件分发机制 1.什么是事件分发机制？主要用来解决什么问题？ 2.给我说说事件分发的流程 &amp; 你项目解决事件冲突的一些案例。 3.多点触摸事件平时接触过吗？如何监听用户第二个手指，第三个…？ 4.OnTouchListener &amp; OnTouchEvent &amp; onClickListener三者之间的关系？ 5.谈谈你对MotionEvent的认识？Cancel事件是什么情况下触发的？ 6.能给我谈谈Android中坐标体系吗？ 2.16 View绘制机制 1.说说View绘制流程。 2.说说Activity View树结构。 3.自定义View的方式有哪些?给我说说你之前项目中的案例。 4.invalidate和postvalidate的区别？ 5.说说你在自定义View时常常重写的一些方法？ 6.说说自定义View中如何自定义属性？ 7.requestLayout(),onLayout(),onDraw(),drawChild()区别和联系？ 8.如何计算出一个View的嵌套层级？ 9.自定义View如何考虑机型适配？ 2.17 布局 1.说说Android中有哪些布局 &amp; 特点。 2.你知道布局文件到控件对象的过程吗？ 3.有这么一个布局需求，一个文本控件放在屏幕一半的一半的中间位置，你如何进行布局？ 4.LinearLayout,FrameLayout,RelativeLayout性能对比，为什么？ 2.18 Binder 1.什么是Binder？用来干什么？ 2.给我具体讲讲Binder机制。 2.19 动画机制 1.Android中的动画分为哪些种类 &amp; 特点 &amp; 缺点。 2.知道SVG &amp; 矢量动画吗？ 3.给我说说转场动画。 4.给我谈谈插值器 &amp; 估值器 的作用。 5.说说Android动画框架实现的原理。 2.20 JNI 1.什么是JNI?它主要用来干什么。 2.Java Native方法如何和Native函数进行绑定的？ 3.JNI如何实现数据传递？ 4.如何全局捕获Native发生的异常？ 5.只有C/C++能编写Native库吗？ 2.21 Window &amp; Appliction &amp; Context 1.说说你对Android中Window的理解。 2.说说你对Application的理解 &amp; 生命周期。 3.Android中有哪些上下文 &amp; 区别 &amp; 作用。 4.谈谈你对Android中Context的理解。 2.22 通知 1.Android 8.0如何适配通知？ 2.自定义通知流程？ 2.23 对话框(Dialog &amp; DialogFragment &amp; PopWindow) 1.说说Android中对话框可以用哪些方式完成？ 2.24 蓝牙 1.说说最新的蓝牙版本？新版本的特性是什么？ 2.25 冷启动&amp;热启动 1.什么是冷启动 &amp; 什么是热启动 &amp; 它们的流程？ 2.如何优化冷启动？ 3.启动页白屏，黑屏，太慢如何解决？ 2.26 悬浮窗 1.在做悬浮窗的时候你遇到了什么困难(主要指悬浮窗权限适配)？ 2.如何制作一个悬浮窗？ 2.27 Android版本 1.最新的Android版本多少知道吗？有哪些特性 2.说说更新较大的Android版本。 2.28 Android Studio 1.你现在比较常用Android Studio那个版本 &amp; 用的Gradle版本是多少？ 2.如何理解gradle? 3.说说Android Studio中大致项目结构？ 4.混淆是什么 &amp; 为什么需要进行混淆 &amp; 混淆的原理 &amp; 为什么Java反射常常会和混淆冲突？ 2.29 UI卡顿优化 1.ANR是什么？导致原因有哪些？ 2.谈谈你项目中避免ANR的一些经验。 3.分别说说Activity &amp; BroadcastReceiver &amp; Serice最长可耗时时间为多少？ 2.30 内存优化 1.什么是OOM &amp; 什么是内存泄漏 &amp; 什么是内存抖动？ 2.谈谈你项目中内存优化的一些经验。 2.31 屏幕适配 1.说说Android中一些屏幕单位。 2.谈谈你项目中的一些屏幕适配的经验。 3.今日头条的轻量级适配方案了解吗 &amp; 给我说说原理。 2.32 多渠道打包 &amp; apk签名 1.apk为什么需要签名？ 2.多渠道打包是什么 &amp; 有类似经验吗？ 3.简述多渠道打包及原理和常用操作？ 2.33 项目架构 1.说说你用过的项目架构？ 2.分别给我说说MVC,MVP,MVVM特点和区别。 3.以登陆界面为例子,设计MVP架构。 4.谈谈AndroidManifest.xml文件的理解。 2.34 Android前沿知识 1.谷歌新出的Flutter知道吗？ 2.谷歌新出的官方开发语言Kotlin了解吗 &amp; 和Java相比它有哪些特点。 3.谈谈Kotlin中协程的认识？ 2.35 音视频开发(高薪) 1.之前有过音视频开发经验吗 &amp; 说说用哪些开源架子开发的。 2.FFmpeng了解过吗？ 3.Android中播放视频音频的方式有哪些？ 4.Android中播放网络地址视频有哪些出色的开源库？ 5.流媒体服务器了解吗？ 6.谈谈你对编码格式的理解。 7.MediaPlayer和SoundPool的区别？ 8.视频硬解码和软解码的区别？ 2.36 其它Android部分有关面试题 1.说说一个app的启动流程(从源码角度讲解)。 2.你知道无论是Kotlin或者是Java,程序运行的主要入口都是main()方法，那么Android的main方法在哪里？ 3.Android Hock技术了解吗？ 4.简述Android中的加固和使用平台？ 5.谈谈你对Apk瘦身的经验？ 6.为什么子线程不能更新UI？ 7.你知道如何定位内存泄漏吗？ 8.说说System.exit(0),onDestory(),Activity.finish()的区别？ 9.在OnResume或者之前获取View的宽高为多少 &amp; 为什么？ 10.Art &amp; Dvm 区别，特别是谈谈GC的区别。 11.说说你用的二维码框架 &amp; 有过优化经验吗？ 12.谈谈App多进程的好处 &amp; 缺点。 13.说说AMS是怎么找到启动指定的Activity？ 14.View的getWidth和getMeasureWidth有啥区别？ 15.有插件化或者热修复经验吗？说说它的原理。 16.断点续传了解吗？谈谈你是如何通过多线程实现断点续传的。 17.给我谈谈你对SurfaceView的认识。 18.什么情况下你会使用到ScrollView。 19.低版本SDK如何使用高版本API？ 20.AlertDialog,PopWindow,Activity之间的区别？ 21.Application和Activity,Context的区别？ 22.谈谈Android中多线程通信方式？ 23.说说Android大体的架构图，试着画出来。 24.知道SpareArray吗？ 25.Activity除了setContentView可以设置布局，还有其它方式吗？ 26.Android为每个应用程序分配的内存大小为多少？ 27.Android进程保活方案？ 28.谈谈Android系统安装apk的过程？ 29.Activity,Window,View三者的关系？ 30.ActivityThread,ActivityManagerService,WindowManagerService的工作原理？ 31.PackageManagerService的工作原理？ 32.PowerManagerService的工作原理？ 33.在桌面点击一个未启动的App的流程 &amp; 点击一个已启动的App的流程？ 34.Android中进程分为哪些种类？ 35.什么是埋点，懂点它的原理吗？ 36.进程和Application生命周期之间的关系？ 37.App相互唤醒的有哪些方式？ 38.Android中如何开启多进程？应用是否可以开启N个进程？ 39.谈谈消息推送的方式有哪些？ 40.谈谈你对Root权限的理解。 41.谈谈项目如何进行国际化？ 42.谈谈你对Intent和IntentFilter的理解。 43.一条最长的短信息约占多少byte？ 3.算法与数据结构部分3.1 复杂度分析 1.什么是时间复杂度 &amp; 什么是空间复杂度？ 2.时间复杂度和空间复杂度之间存在什么联系？ 3.2 数组 1.谈谈你对数组的理解。 3.3 链表 1.什么是单链表 &amp; 双向链表 &amp; 循环链表 &amp; 双向循环链表 &amp; 静态链表。 2.反转一个链表有哪些方式？ 3.如何判断链表有环？ 4.用Java语言设计一个LinkedList。 3.4 堆 1.如何理解堆？ 3.5 栈 1.什么是栈 &amp; 栈的特点是什么？ 2.什么是顺序栈 &amp; 链式栈？ 3.你有没有基于栈封装的业务类？ 4.你能用栈实现队列吗？ 5.如何实现浏览器前进和后退功能？ 3.6 队列 1.什么是队列 &amp; 队列的特点是什么？ 2.什么是优先队列？ 3.什么是双端队列 &amp; 阻塞队列? 4.你能用队列实现栈吗？ 3.7 散列表 1.什么是散列函数？ 2.什么是散列冲突？解决的方式有哪些？Java中的HashMap解决方式采用的哪一种？ 3.什么是散列表的动态扩容？ 4.什么是位图？ 3.8 树 1.什么是二叉树？ 2.什么是先序遍历 &amp; 中序遍历 &amp; 后序遍历。 3.什么是多路查找树？ 4.什么是红黑树？ 3.9 排序 1.给我说说你会的排序 &amp; 复杂度如何？ 2.现在有10万条数据需要进行排序，你会选择什么排序？ 3.10 查找 1.说说你知道的查找算法 &amp; 复杂度如何？ 3.11 递归&amp;回溯算法 1.什么是递归 &amp; 什么是回溯？ 3.12 贪心算法 1.什么是贪心算法？ 3.13 其它有关算法与数据结构的面试题 1.什么是图？可以解决一些什么问题？ 2.时针走一圈，时针分针重合几次？ 3.有一个不均匀的绳子烧完要1个小时，如何算出1小时15分钟？ 4.求1000以内的水仙花数以及40亿以内的水仙花数？ 5.数据怎么压缩，数据的安全。 6.谈谈你对对称加密 &amp; 非对称加密的理解。 4.常用的开源库部分4.1 异步通信 1.RxJava用法 &amp; RxJava2用法 &amp; 原理 &amp;用到的设计模式？ 2.EventBus用法 &amp; 原理。 4.2 网络 1.OkHttp用法 &amp; 源码分析。 2.Retrofit用法 &amp; 源码分析。 3.Volley用法 &amp; 缺点。 4.3 依赖注入 1.ButterKnife用法 &amp; 原理。 2.Dagger2用法 &amp; 原理。 4.4 图片加载 1.Glide用法 &amp; 原理。 2.Picasso用法 &amp; 原理。 3.Fresco用法 &amp; 原理。 4.5 数据库 1.GreenDao。 2.LitePal。 3.OrmLite。 4.DBFlow。 5.Realm。 4.6 其它 1.分享你觉得比较好用的开源库。 2.自己有封装库吗？给我说说你是如何设计的？ 3.你是如何设计一个网络请求框架的？ 5.计算机网络部分 1.给我介绍5层网络模型。 2.Http/Https协议工作在哪一层？ 3.TCP/UDP协议工作在哪一层？ 4.给我说说三次握手和四次挥手。 5.什么是请求头 &amp; 响应头 ? 说说请求头中一些重要的字段。 6.什么是Cookie &amp; Session。 7.知道什么是心跳检测吗？ 8.Http和Https的区别？ 9.加密协议TLS/SSL加密过程是怎样的？ 10.什么是DNS &amp; 作用是什么 &amp;工作机制？ 11.浏览器访问一个url网址所经历的过程是什么？ 12.Socket是协议吗？WebSocket是协议吗？它们的区别是什么？ 13.Json解析方式有哪些？比较它们的优劣势。 14.XML解析方式有哪些？比较它们的优劣势。 15.http1.x &amp; http 2.0区别是什么？ 16.说说HTTP缓存的原理。 17.如果有个100M大的文件，需要上传至服务器中，而服务器form表单最大只能上传2M,可以使用什么方法？ 18.说说你项目中即时通讯的方案有哪些？]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识间记，快速回顾各种知识]]></title>
    <url>%2Fposts%2F97843d21.html</url>
    <content type="text"><![CDATA[目录： 网络 Java 基础&amp;容器&amp;同步&amp;设计模式 Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理 Android 基础&amp;性能优化&amp;Framwork Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩 音视频&amp;FFmpeg&amp;播放器 网络网络协议模型应用层：负责处理特定的应用程序细节 HTTP、FTP、DNS 传输层：为两台主机提供端到端的基础通信TCP、UDP 网络层：控制分组传输、路由选择等IP 链路层：操作系统设备驱动程序、网卡相关接口 #### TCP 和 UDP 区别TCP 连接；可靠；有序；面向字节流；速度慢；较重量；全双工；适用于文件传输、浏览器等 全双工：A 给 B 发消息的同时，B 也能给 A 发 半双工：A 给 B 发消息的同时，B 不能给 A 发 UDP 无连接；不可靠；无序；面向报文；速度快；轻量；适用于即时通讯、视频通话等 TCP 三次握手 A：你能听到吗？ B：我能听到，你能听到吗？ A：我能听到，开始吧 A 和 B 两方都要能确保：我说的话，你能听到；你说的话，我能听到。所以需要三次握手 TCP 四次挥手 A：我说完了 B：我知道了，等一下，我可能还没说完 B：我也说完了 A：我知道了，结束吧 B 收到 A 结束的消息后 B 可能还没说完，没法立即回复结束标示，只能等说完后再告诉 A ：我说完了。 POST 和 GET 区别Get 参数放在 url 中；Post 参数放在 request Body 中 Get 可能不安全，因为参数放在 url 中 HTTPS HTTP 是超文本传输协议，明文传输；HTTPS 使用 SSL 协议对 HTTP 传输数据进行了加密 HTTP 默认 80 端口；HTTPS 默认 443 端口 优点：安全 缺点：费时、SSL 证书收费，加密能力还是有限的，但是比 HTTP 强多了 Java 基础&amp;容器&amp;同步&amp;设计模式StringBuilder、StringBuffer、+、String.concat 链接字符串： StringBuffer 线程安全，StringBuilder 线程不安全 +实际上是用 StringBuilder 来实现的，所以非循环体可以直接用 +，循环体不行，因为会频繁创建 StringBuilder String.concat 实质是 new String ，效率也低，耗时排序：StringBuilder &lt; StringBuffer &lt; concat &lt; + Java 泛型擦除 修饰成员变量等类结构相关的泛型不会被擦除 容器类泛型会被擦除 ArrayList、LinkedListArrayList 基于数组实现，查找快：o(1)，增删慢：o(n) 初始容量为10，扩容通过 System.arrayCopy 方法 LinkedList 基于双向链表实现，查找慢：o(n)，增删快：o(1) 封装了队列和栈的调用 HashMap 、HashTableHashMap 基于数组和链表实现，数组是 HashMap 的主体；链表是为解决哈希冲突而存在的 当发生哈希冲突且链表 size 大于阈值时会扩容，JAVA 8 会将链表转为红黑树提高性能允许 key/value 为 null HashTable 数据结构和 HashMap 一样 不允许 value 为 null 线程安全 ArrayMap、SparseArrayArrayMap 基于两个数组实现，一个存放 hash；一个存放键值对。扩容的时候只需要数组拷贝，不需要重建哈希表 内存利用率高 不适合存大量数据，因为会对 key 进行二分法查找（1000以下） SparseArray 基于两个数组实现，int 做 key 内存利用率高 不适合存大量数据，因为会对 key 进行二分法查找（1000以下） volatile 关键字 只能用来修饰变量，适用修饰可能被多线程同时访问的变量 相当于轻量级的 synchronized，volatitle 能保证有序性（禁用指令重排序）、可见性；后者还能保证原子性 变量位于主内存中，每个线程还有自己的工作内存，变量在自己线程的工作内存中有份拷贝，线程直接操作的是这个拷贝 被 volatile 修饰的变量改变后会立即同步到主内存，保持变量的可见性. 双重检查单例，为什么要加 volatile？ volatile想要解决的问题是，在另一个线程中想要使用instance，发现instance!=null，但是实际上instance还未初始化完毕这个问题 将instance =newInstance();拆分为3句话是。1.分配内存2.初始化3.将instance指向分配的内存空 volatile可以禁止指令重排序，确保先执行2，后执行3 wait 和 sleep sleep 是 Thread 的静态方法，可以在任何地方调用 wait 是 Object 的成员方法，只能在 synchronized 代码块中调用，否则会报 IllegalMonitorStateException 非法监控状态异常 sleep 不会释放共享资源锁，wait 会释放共享资源锁 lock 和 synchronized synchronized 是 Java 关键字，内置特性；Lock 是一个接口 synchronized 会自动释放锁；lock 需要手动释放，所以需要写到 try catch 块中并在 finally 中释放锁 synchronized 无法中断等待锁；lock 可以中断 Lock 可以提高多个线程进行读/写操作的效率 竞争资源激烈时，lock 的性能会明显的优于 synchronized 可重入锁 定义：已经获取到锁后，再次调用同步代码块/尝试获取锁时不必重新去申请锁，可以直接执行相关代码 ReentrantLock 和 synchronized 都是可重入锁 公平锁 定义：等待时间最久的线程会优先获得锁 非公平锁无法保证哪个线程获取到锁，synchronized 就是非公平锁 ReentrantLock 默认时非公平锁，可以设置为公平锁 乐观锁和悲观锁 悲观锁：线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁 乐观锁：假设没有冲突，不加锁，更新数据时判断该数据是否过期，过期的话则不进行数据更新，适用于读取操作频繁的场景 乐观锁 CAS：Compare And Swap，更新数据时先比较原值是否相等，不相等则表示数据过去，不进行数据更新 乐观锁实现：AtomicInteger、AtomicLong、AtomicBoolean 死锁 4 个必要条件 互斥 占有且等待 不可抢占 循环等待 synchronized 原理 每个对象都有一个监视器锁：monitor，同步代码块会执行 monitorenter 开始，motnitorexit 结束 wait/notify 就依赖 monitor 监视器，所以在非同步代码块中执行会报 IllegalMonitorStateException 异常 Java 虚拟机&amp;内存结构&amp;GC&amp;类加载&amp;四种引用&amp;动态代理JVM 定义：可以理解成一个虚构的计算机，解释自己的字节码指令集映射到本地 CPU 或 OS 的指令集，上层只需关注 Class 文件，与操作系统无关，实现跨平台 Kotlin 就是能解释成 Class 文件，所以可以跑在 JVM 上 JVM 内存模型 Java 多线程之间是通过共享内存来通信的，每个线程都有自己的本地内存 共享变量存放于主内存中，线程会拷贝一份共享变量到本地内存 volatile 关键字就是给内存模型服务的，用来保证内存可见性和顺序性 JVM 内存结构线程私有： 程序计数器：记录正在执行的字节码指令地址，若正在执行 Native 方法则为空 虚拟机栈：执行方法时把方法所需数据存为一个栈帧入栈，执行完后出栈 本地方法栈：同虚拟机栈，但是针对的是 Native 方法 线程共享： 堆：存储 Java 实例，GC 主要区域，分代收集 GC 方法会吧堆划分为新生代、老年代 方法区：存储类信息，常量池，静态变量等数据 GC回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收回收类型：1.堆中的对象 分代收集 GC 方法会吧堆划分为新生代、老年代 新生代：新建小对象会进入新生代；通过复制算法回收对象 老年代：新建大对象及老对象会进入老年代；通过标记-清除算法回收对象 2.方法区中的类信息、常量池 判断一个对象是否可被回收： 1.引用计数法缺点：循环引用 2.可达性分析法定义：从 GC ROOT 开始搜索，不可达的对象都是可以被回收的 GC ROOT 1.虚拟机栈/本地方法栈中引用的对象2.方法区中常量/静态变量引用的对象 四种引用 强引用：不会被回收 软引用：内存不足时会被回收 弱引用：gc 时会被回收 虚引用：无法通过虚引用得到对象，可以监听对象的回收 ClassLoader类的生命周期：1.加载；2.验证；3.准备；4.解析；5.初始化；6.使用；7.卸载 类加载过程： 1.加载：获取类的二进制字节流；生成方法区的运行时存储结构；在内存中生成 Class 对象2.验证：确保该 Class 字节流符合虚拟机要求3.准备：初始化静态变量4.解析：将常量池的符号引用替换为直接引用5.初始化：执行静态块代码、类变量赋值 类加载时机： 1.实例化对象2.调用类的静态方法3.调用类的静态变量（放入常量池的常量除外） 类加载器：负责加载 class 文件 分类： 1.引导类加载器 - 没有父类加载器2.拓展类加载器 - 继承自引导类加载器3.系统类加载器 - 继承自拓展类加载器 双亲委托模型： 当要加载一个 class 时，会先逐层向上让父加载器先加载，加载失败才会自己加载 为什么叫双亲？不考虑自定义加载器，系统类加载器需要网上询问两层，所以叫双亲 判断是否是同一个类时，除了类信息，还必须时同一个类加载器 优点： 防止重复加载，父加载器加载过了就没必要加载了 安全，防止篡改核心库类 动态代理原理及实现 InvocationHandler 接口，动态代理类需要实现这个接口 Proxy.newProxyInstance，用于动态创建代理对象 Retrofit 应用： Retrofit 通过动态代理，为我们定义的请求接口都生成一个动态代理对象，实现请求 Android 基础&amp;性能优化&amp;FramworkActivity 启动模式 standard 标准模式 singleTop 栈顶复用模式，* 推送点击消息界面 singleTask 栈内复用模式，* 首页 singleInstance 单例模式，单独位于一个任务栈中* 拨打电话界面细节：* taskAffinity：任务相关性，用于指定任务栈名称，默认为应用包名* allowTaskReparenting：允许转移任务栈 View 工作原理12345* DecorView (FrameLayout) * LinearLayout * titlebar * Content * 调用 setContentView 设置的 View ViewRoot 的 performTraversals 方法调用触发开始 View 的绘制，然后会依次调用: performMeasure：遍历 View 的 measure 测量尺寸 performLayout：遍历 View 的 layout 确定位置 performDraw：遍历 View 的 draw 绘制 #### 事件分发机制 一个 MotionEvent 产生后，按 Activity -&gt; Window -&gt; decorView -&gt; View 顺序传递，View 传递过程就是事件分发，主要依赖三个方法: dispatchTouchEvent：用于分发事件，只要接受到点击事件就会被调用，返回结果表示是否消耗了当前事件 onInterceptTouchEvent：用于判断是否拦截事件，当 ViewGroup 确定要拦截事件后，该事件序列都不会再触发调用此 ViewGroup 的 onIntercept onTouchEvent：用于处理事件，返回结果表示是否处理了当前事件，未处理则传递给父容器处理 细节： 一个事件序列只能被一个 View 拦截且消耗 View 没有 onIntercept 方法，直接调用 onTouchEvent 处理 OnTouchListener 优先级比 OnTouchEvent 高，onClickListener 优先级最低 requestDisallowInterceptTouchEvent 可以屏蔽父容器 onIntercet 方法的调用 Window 、 WindowManager、WMS、SurfaceFlinger Window：抽象概念不是实际存在的，而是以 View 的形式存在，通过 PhoneWindow 实现 WindowManager：外界访问 Window 的入口，内部与 WMS 交互是个 IPC 过程 WMS：管理窗口 Surface 的布局和次序，作为系统级服务单独运行在一个进程 SurfaceFlinger：将 WMS 维护的窗口按一定次序混合后显示到屏幕上 View 动画、帧动画及属性动画View 动画： * 作用对象是 View，可用 xml 定义，建议 xml 实现比较易读* 支持四种效果：平移、缩放、旋转、透明度 帧动画： * 通过 AnimationDrawable 实现，容易 OOM 属性动画： 可作用于任何对象，可用 xml 定义，Android 3 引入，建议代码实现比较灵活 包括 ObjectAnimator、ValuetAnimator、AnimatorSet 时间插值器：根据时间流逝的百分比计算当前属性改变的百分比 系统预置匀速、加速、减速等插值器 类型估值器：根据当前属性改变的百分比计算改变后的属性值 系统预置整型、浮点、色值等类型估值器 使用注意事项： 避免使用帧动画，容易OOM 界面销毁时停止动画，避免内存泄漏 开启硬件加速，提高动画流畅性 ，硬件加速： 将 cpu 一部分工作分担给 gpu ，使用 gpu 完成绘制工作 从工作分摊和绘制机制两个方面优化了绘制速度 Handler、MessageQueue、Looper Handler：开发直接接触的类，内部持有 MessageQueue 和 Looper MessageQueue：消息队列，内部通过单链表存储消息 Looper：内部持有 MessageQueue，循环查看是否有新消息，有就处理，没就阻塞 如何实现阻塞：通过 nativePollOnce 方法，基于 Linux epoll 事件管理机制 为什么主线程不会因为 Looper 阻塞：系统每 16ms 会发送一个刷新 UI 消息唤醒 MVC、MVP、MVVM MVP：Model：处理数据；View：控制视图；Presenter：分离 Activity 和 Model MVVM：Model：处理获取保存数据；View：控制视图；ViewModel：数据容器* 使用 Jetpack 组件架构的 LiveData、ViewModel 便捷实现 MVVM Serializable、Parcelable Serializable ：Java 序列化方式，适用于存储和网络传输，serialVersionUID 用于确定反序列化和类版本是否一致，不一致时反序列化回失败 Parcelable ：Android 序列化方式，适用于组件通信数据传递，性能高，因为不像 Serializable 一样有大量反射操作，频繁 GC Binder Android 进程间通信的中流砥柱，基于客户端-服务端通信方式 使用 mmap 一次数据拷贝实现 IPC，传统 IPC：用户A空间-&gt;内核-&gt;用户B空间；mmap 将内核与用户B空间映射，实现直接从用户A空间-&gt;用户B空间 BinderPool 可避免创建多 Service IPC 方式 Intent extras、Bundle：要求传递数据能被序列化，实现 Parcelable、Serializable ，适用于四大组件通信 文件共享：适用于交换简单的数据实时性不高的场景 AIDL：AIDL 接口实质上是系统提供给我们可以方便实现 BInder 的工具 Android Interface Definition Language，可实现跨进程调用方法 服务端：将暴漏给客户端的接口声明在 AIDL 文件中，创建 Service 实现 AIDL 接口并监听客户端连接请求 客户端：绑定服务端 Service ，绑定成功后拿到服务端 Binder 对象转为 AIDL 接口调用 RemoteCallbackList 实现跨进程接口监听，同个 Binder 对象做 key 存储客户端注册的 listener 监听 Binder 断开：1.Binder.linkToDeath 设置死亡代理；2. onServiceDisconnected 回调 Messenger：基于 AIDL 实现，服务端串行处理，主要用于传递消息，适用于低并发一对多通信 ContentProvider：基于 Binder 实现，适用于一对多进程间数据共享 Socket：TCP、UDP，适用于网络数据交换 Android 系统启动流程 按电源键 -&gt; 加载引导程序 BootLoader 到 RAM -&gt; 执行 BootLoader 程序启动内核 -&gt; 启动 init 进程 -&gt; 启动 Zygote 和各种守护进程 -&gt; 启动 System Server 服务进程开启 AMS、WMS 等 -&gt; 启动 Launcher 应用进程 #### App 启动流程 Launcher 中点击一个应用图标 -&gt; 通过 AMS 查找应用进程，若不存在就通过 Zygote 进程 fork 进程保活 进程优先级：1.前台进程 ；2.可见进程；3.服务进程；4.后台进程；5.空进程 进程被 kill 场景：1.切到后台内存不足时被杀；2.切到后台厂商省电机制杀死；3.用户主动清理 保活方式： 1.Activity 提权：挂一个 1像素 Activity 将进程优先级提高到前台进程 2.Service 提权：启动一个前台服务（API&gt;18会有正在运行通知栏） 3.广播拉活 4.Service 拉活 5.JobScheduler 定时任务拉活 6.双进程拉活 网络优化及检测 速度：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；4.IP 直连省去 DNS 解析时间 成功率：1.失败重试策略； 流量：1.GZIP 压缩（okhttp 自动支持）；2.Protocol Buffer 替代 json；3.优化图片/文件流量；5.文件下载断点续传 ；6.缓存 协议层的优化，比如更优的 http 版本等 监控：Charles 抓包、Network Monitor 监控流量 UI卡顿优化 减少布局层级及控件复杂度，避免过度绘制 使用 include、merge、viewstub 优化绘制过程，避免在 Draw 中频繁创建对象、做耗时操作 内存泄漏场景及规避 1.静态变量、单例强引跟生命周期相关的数据或资源，包括 EventBus 2.游标、IO 流等资源忘记主动释放 3.界面相关动画在界面销毁时及时暂停 4.内部类持有外部类引用导致的内存泄漏* handler 内部类内存泄漏规避：1.使用静态内部类+弱引用 2.界面销毁时清空消息队列* 检测：Android Studio Profiler LeakCanary 原理 通过弱引用和引用队列监控对象是否被回收 比如 Activity 销毁时开始监控此对象，检测到未被回收则主动 gc ，然后继续监控 OOM 场景及规避 加载大图：减小图片 内存泄漏：规避内存泄漏 Android 模块化&amp;热修复&amp;热更新&amp;打包&amp;混淆&amp;压缩Dalvik 和 ART Dalvik* 谷歌设计专用于 Android 平台的 Java 虚拟机，可直接运行 .dex 文件，适合内存和处理速度有限的系统* JVM 指令集是基于栈的；Dalvik 指令集是基于寄存器的，代码执行效率更优 ART* Dalvik 每次运行都要将字节码转换成机器码；ART 在应用安装时就会转换成机器码，执行速度更快* ART 存储机器码占用空间更大，空间换时间 APK 打包流程 1.aapt 打包资源文件生成 R.java 文件；aidl 生成 java 文件 2.将 java 文件编译为 class 文件 3.将工程及第三方的 class 文件转换成 dex 文件 4.将 dex 文件、so、编译过的资源、原始资源等打包成 apk 文件 5.签名 6.资源文件对齐，减少运行时内存 App 安装过程 首先要解压 APK，资源、so等放到应用目录 Dalvik 会将 dex 处理成 ODEX ；ART 会将 dex 处理成 OAT； OAT 包含 dex 和安装时编译的机器码 #### 组件化路由实现 ARoute：通过 APT 解析 @Route 等注解，结合 JavaPoet 生成路由表，即路由与 Activity 的映射关系 音视频&amp;FFmpeg&amp;播放器FFmpeg基于命令方式实现了一个音视频编辑 App： https://github.com/yhaolpz/FFmpegCmd 集成编译了 AAC、MP3、H264 编码器 播放器原理 视频播放原理：（mp4、flv）-&gt; 解封装 -&gt; （mp3/aac、h264/h265）-&gt; 解码 -&gt; （pcm、yuv）-&gt; 音视频同步 -&gt; 渲染播放 音视频同步：* 选择参考时钟源：音频时间戳、视频时间戳和外部时间三者选择一个作为参考时钟源（一般选择音频，因为人对音频更敏感，ijk 默认也是音频）* 通过等待或丢帧将视频流与参考时钟源对齐，实现同步 IjkPlayer 原理 集成了 MediaPlayer、ExoPlayer 和 IjkPlayer 三种实现，其中 IjkPlayer 基于 FFmpeg 的 ffplay 音频输出方式：AudioTrack、OpenSL ES；视频输出方式：NativeWindow、OpenGL ES]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart语法学习]]></title>
    <url>%2Fposts%2Fab669d34.html</url>
    <content type="text"><![CDATA[目录 参考资料 语言特性 关键字 变量与常量 数据类型 运算符 operators 控制流程语句 异常 Exceptions 函数 Function 类 Class 类-方法 类-抽象类 类-隐式接口 类-扩展一个类（重写） 库和可见性 异步支持 参考资料 https://www.dartlang.org/guides/language/language-tour 【官方文档】 http://wiki.jikexueyuan.com/project/dart-language-tour/classes.html 【极客学院】 https://www.jianshu.com/p/3d927a7bf020 【author：AWeiLoveAndroid】 https://www.jianshu.com/p/a7cc623132b0 【author：soojade】 https://www.jianshu.com/p/78d317b2ea79 【author：优腾爱乐】 语言特性 Dart所有的东西都是对象， 即使是数字numbers、函数function、null也都是对象，所有的对象都继承自Object类。 Dart动态类型语言, 尽量给变量定义一个类型，会更安全，没有显示定义类型的变量在 debug 模式下会类型会是 dynamic(动态的)。 Dart 在 running 之前解析你的所有代码，指定数据类型和编译时的常量，可以提高运行速度。 Dart中的类和接口是统一的，类即接口，你可以继承一个类，也可以实现一个类（接口），自然也包含了良好的面向对象和并发编程的支持。 Dart 提供了顶级函数(如：main())。 Dart 没有 public、private、protected 这些关键字，变量名以”_”开头意味着对它的 lib 是私有的。 没有初始化的变量都会被赋予默认值 null。 final的值只能被设定一次。const 是一个编译时的常量，可以通过 const 来创建常量值，var c=const[];，这里 c 还是一个变量，只是被赋值了一个常量值，它还是可以赋其它值。实例变量可以是 final，但不能是 const。 编程语言并不是孤立存在的，Dart也是这样，他由语言规范、虚拟机、类库和工具等组成： SDK：SDK 包含 Dart VM、dart2js、Pub、库和工具。 Dartium：内嵌 Dart VM 的 Chromium ，可以在浏览器中直接执行 dart 代码。 Dart2js：将 Dart 代码编译为 JavaScript 的工具。 Dart Editor：基于 Eclipse 的全功能 IDE，并包含以上所有工具。支持代码补全、代码导航、快速修正、重构、调试等功能。 关键字（56个） 关键字 - - - abstract do import super as dynamic in switch assert else interface sync* enum implements is this async* export library throw await external mixin true break extends new try case factory null typedef catch false operator var class final part void const finally rethrow while continue for return with covariant get set yield* default if static deferred 变量与常量 变量声明与初始化 调用的变量name包含对String值为“张三” 的对象的引用，name推断变量的类型是String，但可以通过指定它来更改该类型，如果对象不限于单一类型（没有明确的类型），请使用Object或dynamic关键字。 1234567// 没有明确类型，编译的时候根据值明确类型var name = ‘Bob’; Object name = '张三';dynamic name = '李四';// 显示声明将被推断类型, 可以使用String显示声明字符串类型String name = 'Bob' ; 默认值 未初始化的变量的初始值为null（包括数字），因此数字、字符串都可以调用各种方法 12345//测试 数字类型的初始值是什么?int lineCount;// 为false的时候抛出异常assert(lineCount == null);print(lineCount); //打印结果为null，证明数字类型初始化值是null final and const 如果您从未打算更改一个变量，那么使用 final 或 const，不是var，也不是一个类型。 一个 final 变量只能被初始化一次; const变量是一个编译时常量，(Const变量是隐式的final) final的顶级或类变量在第一次使用时被初始化。 被final修饰的顶级变量或类变量在第一次声明的时候就需要初始化。 12// The final variable 'outSideFinalName' must be initialized.final String outSideFinalName 被final或者const修饰的变量，变量类型可以省略，建议指定数据类型。 123456//可以省略String这个类型声明final name = "Bob";final String name1 = "张三";const name2 = "alex";const String name3 = "李四"; 被 final 或 const 修饰的变量无法再去修改其值。 123456789final String outSideFinalName = "Alex";// outSideFinalName', a final variable, can only be set once// 一个final变量，只能被设置一次。outSideFinalName = "Bill";const String outSideName = 'Bill';// 这样写，编译器提示：Constant variables can't be assigned a value// const常量不能赋值// outSideName = "小白"; flnal 或者 const 不能和 var 同时使用 12345// Members can't be declared to be both 'const' and 'var'const var String outSideName = 'Bill';// Members can't be declared to be both 'final' and 'var'final var String name = 'Lili'; 常量如果是类级别的，请使用 static const 1234567// 常量如果是类级别的，请使用 static conststatic const String name3 = 'Tom';// 这样写保存// Only static fields can be declared as const// 只有静态字段可以声明为const//const String name3 = 'Tom'; 常量的运算 12345const speed = 100; //速度（km/h）const double distance = 2.5 * speed; // 距离 = 时间 * 速度 final speed2 = 100; //速度（km/h）final double distance2 = 2.5 * speed2; // 距离 = 时间 * 速度 const关键字不只是声明常数变量，您也可以使用它来创建常量值，以及声明创建常量值的构造函数，任何变量都可以有一个常量值。 123456789101112131415// 注意: [] 创建的是一个空的list集合// const []创建一个空的、不可变的列表（EIL）。var varList = const []; // varList 当前是一个EILfinal finalList = const []; // finalList一直是EILconst constList = const []; // constList 是一个编译时常量的EIL // 可以更改非final,非const变量的值// 即使它曾经具有const值varList = ["haha"]; // 不能更改final变量或const变量的值// 这样写，编译器提示：a final variable, can only be set once// finalList = ["haha"];// 这样写，编译器提示：Constant variables can't be assigned a value // constList = ["haha"]; 在常量表达式中，该运算符的操作数必须为’bool’、’num’、’String’或’null’, const常量必须用conat类型的值初始化。 12345678910111213141516171819202122const String outSideName = 'Bill';final String outSideFinalName = 'Alex';const String outSideName2 = 'Tom';const aConstList = const ['1', '2', '3'];// In constant expressions, operands of this operator must be of type 'bool', 'num', 'String' or 'null'// 在常量表达式中，该运算符的操作数必须为'bool'、'num'、'String'或'null'。const validConstString = '$outSideName $outSideName2 $aConstList';// Const variables must be initialized with a constant value// const常量必须用conat类型的值初始化const validConstString = '$outSideName $outSideName2 $outSideFinalName';var outSideVarName='Cathy';// Const variables must be initialized with a constant value.// const常量必须用conat类型的值初始化const validConstString = '$outSideName $outSideName2 $outSideVarName';// 正确写法const String outSideConstName = 'Joy';const validConstString = '$outSideName $outSideName2 $outSideConstName'; 数据类型 num num 是数字类型的父类，有两个子类 int 和 double。 int 根据平台的不同，整数值不大于64位。在Dart VM上，值可以从-263到263 - 1，编译成JavaScript的Dart使用JavaScript代码，允许值从-253到253 - 1。 double 64位（双精度）浮点数，如IEEE 754标准所规定。 123456789101112131415161718192021222324252627282930313233int a = 1;print(a);double b = 1.12;print(b);// String -&gt; intint one = int.parse('1');// 输出3print(one + 2);// String -&gt; doublevar onePointOne = double.parse('1.1');// 输出3.1print(onePointOne + 2); // int -&gt; StringString oneAsString = 1.toString();// The argument type 'int' can't be assigned to the parameter type 'String'//print(oneAsString + 2);// 输出 1 + 2print('$oneAsString + 2');// 输出 1 2print('$oneAsString 2'); // double -&gt; String 注意括号中要有小数点位数，否则报错String piAsString = 3.14159.toStringAsFixed(2);// 截取两位小数, 输出3.14print(piAsString);String aString = 1.12618.toStringAsFixed(2);// 检查是否四舍五入，输出1.13，发现会做四舍五入print(aString); String Dart里面的String是一系列 UTF-16 代码单元。 您可以使用单引号或双引号来创建一个字符串。 单引号或者双引号里面嵌套使用引号。 用 或{} 来计算字符串中变量的值，需要注意的是如果是表达式需要${表达式} 123456789101112131415161718192021String singleString = 'abcdddd';String doubleString = "abcsdfafd";String sdString = '$singleString a "bcsd" $&#123;singleString&#125;';String dsString = "abc 'aaa' $sdString";print(sdString);print(dsString); String singleString = 'aaa';String doubleString = "bbb";// 单引号嵌套双引号String sdString = '$singleString a "bbb" $&#123;doubleString&#125;';// 输出 aaa a "bbb" bbbprint(sdString);// 双引号嵌套单引号String dsString = "$&#123;singleString.toUpperCase()&#125; abc 'aaa' $doubleString.toUpperCase()";// 输出 AAA abc 'aaa' bbb.toUpperCase(), 可以看出 ”$doubleString.toUpperCase()“ 没有加“&#123;&#125;“，导致输出结果是”bbb.toUpperCase()“print(dsString); bool Dart 是强 bool 类型检查，只有bool 类型的值是true 才被认为是true。 只有两个对象具有bool类型：true和false，它们都是编译时常量。 Dart的类型安全意味着您不能使用 if（nonbooleanValue） 或 assert（nonbooleanValue） 等代码, 相反Dart使用的是显式的检查值。 assert 是语言内置的断言函数，仅在检查模式下有效 在开发过程中， 除非条件为真，否则会引发异常。(断言失败则程序立刻终止)。 123456789101112131415// 检查是否为空字符串var fullName = '';assert(fullName.isEmpty);// 检查0var hitPoints = 0;assert(hitPoints &lt;= 0);// 检查是否为nullvar unicorn;assert(unicorn == null);// 检查是否为NaNvar iMeantToDoThis = 0 / 0;assert(iMeantToDoThis.isNaN); List集合 在Dart中，数组是List对象，因此大多数人只是将它们称为List。 Dart list文字看起来像JavaScript数组文字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//创建一个int类型的listList list = [10, 7, 23];// 输出[10, 7, 23]print(list);// 使用List的构造函数，也可以添加int参数，表示List固定长度，不能进行添加 删除操作var fruits = new List();// 添加元素fruits.add('apples');// 添加多个元素fruits.addAll(['oranges', 'bananas']);List subFruits = ['apples', 'oranges', 'banans'];// 添加多个元素fruits.addAll(subFruits);// 输出： [apples, oranges, bananas, apples, oranges, banans]print(fruits);// 获取List的长度print(fruits.length);// 获取第一个元素print(fruits.first);// 获取元素最后一个元素print(fruits.last);// 利用索引获取元素print(fruits[0]);// 查找某个元素的索引号print(fruits.indexOf('apples'));// 删除指定位置的元素，返回删除的元素print(fruits.removeAt(0));// 删除指定元素,成功返回true，失败返回false// 如果集合里面有多个“apples”, 只会删除集合中第一个改元素fruits.remove('apples');// 删除最后一个元素，返回删除的元素fruits.removeLast();// 删除指定范围(索引)元素，含头不含尾fruits.removeRange(start,end);// 删除指定条件的元素(这里是元素长度大于6)fruits.removeWhere((item) =&gt; item.length &gt;6)；// 删除所有的元素fruits.clear(); 注意事项： 可以直接打印list包括list的元素，list也是一个对象。但是java必须遍历才能打印list，直接打印是地址值。 和java一样list里面的元素必须保持类型一致，不一致就会报错。 和java一样list的角标从0开始。 如果集合里面有多个相同的元素“X”, 只会删除集合中第一个改元素 Map集合 一般来说，map是将键和值相关联的对象。键和值都可以是任何类型的对象。 每个键只出现一次，但您可以多次使用相同的值。Dart支持map由map文字和map类型提供。 初始化Map方式一： 直接声明，用{}表示，里面写key和value，每组键值对中间用逗号隔开。 123456// Two keys in a map literal can't be equal.// Map companys = &#123;'Alibaba': '阿里巴巴', 'Tencent': '腾讯', 'baidu': '百度', 'Alibaba': '钉钉', 'Tenect': 'qq-music'&#125;;Map companys = &#123;'Alibaba': '阿里巴巴', 'Tencent': '腾讯', 'baidu': '百度'&#125;;// 输出：&#123;Alibaba: 阿里巴巴, Tencent: 腾讯, baidu: 百度&#125;print(companys); 创建Map方式二：先声明，再去赋值。 12345678910111213Map schoolsMap = new Map();schoolsMap['first'] = '清华';schoolsMap['second'] = '北大';schoolsMap['third'] = '复旦';// 打印结果 &#123;first: 清华, second: 北大, third: 复旦&#125;print(schoolsMap);var fruits = new Map();fruits["first"] = "apple";fruits["second"] = "banana";fruits["fifth"] = "orange";//换成双引号,换成var 打印结果 &#123;first: apple, second: banana, fifth: orange&#125;print(fruits); Map API 12345678910111213141516171819202122232425262728// 指定键值对的参数类型var aMap = new Map&lt;int, String&gt;();// Map的赋值，中括号中是Key，这里可不是数组aMap[1] = '小米';//Map中的键值对是唯一的//同Set不同，第二次输入的Key如果存在，Value会覆盖之前的数据aMap[1] = 'alibaba';// map里面的value可以相同aMap[2] = 'alibaba';// map里面value可以为空字符串aMap[3] = '';// map里面的value可以为nullaMap[4] = null;print(aMap);// 检索Map是否含有某Keyassert(aMap.containsKey(1));//删除某个键值对aMap.remove(1); print(aMap); 注意事项 map的key类型不一致也不会报错。 添加元素的时候，会按照你添加元素的顺序逐个加入到map里面，哪怕你的key，比如分别是 1,2,4，看起来有间隔，事实上添加到map的时候是{1:value,2:value,4:value} 这种形式。 map里面的key不能相同。但是value可以相同,value可以为空字符串或者为null。 运算符 描述 操作符 一元后置操作符 expr++ expr-- () [] . ?. 一元前置操作符 expr !expr ~expr ++expr --expr 乘除 * / % ~/ 加减 + - 位移 &lt;&lt; &gt;&gt; 按位与 &amp; 按位或 按位异或 ^ 逻辑与 &amp;&amp; 逻辑或 关系和类型判断 &gt;= &gt; &lt;= &lt; as is is! 等 == != 如果为空 ?? 条件表达式 expr1 ? expr2 : expr3 赋值 = *= /= ~/= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= = ??= 级联 .. 流程控制语句（Control flow statements） if…else for while do-whild break continue switch…case assert（仅在checked模式有效） 异常（Exceptions） throw 抛出固定类型的异常 1throw new FormatException('Expected at least 1 section'); 抛出任意类型的异常 1throw 'Out of llamas!'; 因为抛出异常属于表达式，可以将throw语句放在=&gt;语句中，或者其它可以出现表达式的地方 12distanceTo(Point other) =&gt; throw new UnimplementedError(); catch 将可能出现异常的代码放置到try语句中，可以通过 on语句来指定需要捕获的异常类型，使用catch来处理异常。 123456789101112try &#123; breedMoreLlamas();&#125; on OutOfLlamasException &#123; // A specific exception buyMoreLlamas();&#125; on Exception catch (e) &#123; // Anything else that is an exception print('Unknown exception: $e');&#125; catch (e, s) &#123; print('Exception details:\n $e'); print('Stack trace:\n $s');&#125; rethrow rethrow语句用来处理一个异常，同时希望这个异常能够被其它调用的部分使用。 123456789101112131415161718final foo = '';void misbehave() &#123; try &#123; foo = "1"; &#125; catch (e) &#123; print('2'); rethrow;// 如果不重新抛出异常，main函数中的catch语句执行不到 &#125;&#125;void main() &#123; try &#123; misbehave(); &#125; catch (e) &#123; print('3'); &#125;&#125; finally Dart的finally用来执行那些无论异常是否发生都执行的操作。 12345678910111213141516171819final foo = ''; void misbehave() &#123; try &#123; foo = "1"; &#125; catch (e) &#123; print('2'); &#125;&#125; void main() &#123; try &#123; misbehave(); &#125; catch (e) &#123; print('3'); &#125; finally &#123; print('4'); // 即使没有rethrow最终都会执行到 &#125;&#125; 函数 Function 以下是一个实现函数的例子： 123bool isNoble(int atomicNumber) &#123; return _nobleGases[atomicNumber] != null;&#125; main()函数 每个应用程序都必须有一个顶层main()函数，它可以作为应用程序的入口点。该main()函数返回void并具有List参数的可选参数。 12345void main() &#123; querySelector('#sample_text_id') ..text = 'Click me!' ..onClick.listen(reverseText);&#125; 级联符号..允许您在同一个对象上进行一系列操作。除了函数调用之外，还可以访问同一对象上的字段。这通常会为您节省创建临时变量的步骤，并允许您编写更流畅的代码。 1234querySelector('#confirm') // Get an object. ..text = 'Confirm' // Use its members. ..classes.add('important') ..onClick.listen((e) =&gt; window.alert('Confirmed!')); 上述例子相对于： 1234var button = querySelector('#confirm');button.text = 'Confirm';button.classes.add('important');button.onClick.listen((e) =&gt; window.alert('Confirmed!')); 级联符号也可以嵌套使用。 例如： 12345678final addressBook = (AddressBookBuilder() ..name = 'jenny' ..email = 'jenny@example.com' ..phone = (PhoneNumberBuilder() ..number = '415-555-0100' ..label = 'home') .build()) .build(); 当返回值是void时不能构建级联。 例如，以下代码失败： 123var sb = StringBuffer();sb.write('foo') // 返回void ..write('bar'); // 这里会报错 注意： 严格地说，级联的..符号不是操作符。它只是Dart语法的一部分。 可选参数 可选的命名参数, 定义函数时，使用{param1, param2, …}，用于指定命名参数。例如： 123456//设置[bold]和[hidden]标志void enableFlags(&#123;bool bold, bool hidden&#125;) &#123; // ... &#125; enableFlags(bold: true, hidden: false); 可选的位置参数，用[]它们标记为可选的位置参数： 1234567String say(String from, String msg, [String device]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; return result;&#125; 下面是一个不带可选参数调用这个函数的例子： 1say('Bob', 'Howdy'); //结果是： Bob says Howdy 下面是用第三个参数调用这个函数的例子： 1say('Bob', 'Howdy', 'smoke signal'); //结果是：Bob says Howdy with a smoke signal 默认参数 函数可以使用=为命名参数和位置参数定义默认值。默认值必须是编译时常量。如果没有提供默认值，则默认值为null。 下面是为命名参数设置默认值的示例: 1234567// 设置 bold 和 hidden 标记的默认值都为falsevoid enableFlags2(&#123;bool bold = false, bool hidden = false&#125;) &#123; // ...&#125; // 调用的时候：bold will be true; hidden will be false.enableFlags2(bold: true); 下一个示例显示如何为位置参数设置默认值： 1234567891011121314String say(String from, String msg, [String device = 'carrier pigeon', String mood]) &#123; var result = '$from says $msg'; if (device != null) &#123; result = '$result with a $device'; &#125; if (mood != null) &#123; result = '$result (in a $mood mood)'; &#125; return result;&#125; //调用方式：say('Bob', 'Howdy'); //结果为：Bob says Howdy with a carrier pigeon; 您还可以将list或map作为默认值传递。下面的示例定义一个函数doStuff()，该函数指定列表参数的默认list和gifts参数的默认map。 123456789// 使用list 或者map设置默认值void doStuff( &#123;List&lt;int&gt; list = const [1, 2, 3], Map&lt;String, String&gt; gifts = const &#123;'first': 'paper', 'second': 'cotton', 'third': 'leather' &#125;&#125;) &#123; print('list: $list'); print('gifts: $gifts');&#125; 作为一个类对象的功能 您可以将一个函数作为参数传递给另一个函数。 12345678void printElement(int element) &#123; print(element);&#125;var list = [1, 2, 3];// 把 printElement函数作为一个参数传递进来list.forEach(printElement); 您也可以将一个函数分配给一个变量。 12var loudify = (msg) =&gt; '!!! $&#123;msg.toUpperCase()&#125; !!!';assert(loudify('hello') == '!!! HELLO !!!'); 匿名函数 大多数函数都能被命名为匿名函数，如 main() 或 printElement()。您还可以创建一个名为匿名函数的无名函数，有时也可以创建lambda或闭包。您可以为变量分配一个匿名函数，例如，您可以从集合中添加或删除它。 一个匿名函数看起来类似于一个命名函数 - 0或更多的参数，在括号之间用逗号和可选类型标注分隔。 下面的代码块包含函数的主体: 123([[Type] param1[, …]]) &#123; codeBlock; &#125;; 下面的示例定义了一个具有无类型参数的匿名函数item，该函数被list中的每个item调用，输出一个字符串，该字符串包含指定索引处的值。 1234var list = ['apples', 'bananas', 'oranges'];list.forEach((item) &#123; print('$&#123;list.indexOf(item)&#125;: $item');&#125;); 如果函数只包含一条语句，可以使用箭头符号=&gt;来缩短它, 比如上面的例2可以简写成： 1list.forEach((item) =&gt; print('$&#123;list.indexOf(item)&#125;: $item')); 返回值 所有函数都返回一个值，如果没有指定返回值，则语句return null，隐式地附加到函数体。 12foo() &#123;&#125;assert(foo() == null); 类（Classes） 对象 Dart 是一种面向对象的语言，并且支持基于mixin的继承方式。 Dart 语言中所有的对象都是某一个类的实例,所有的类有同一个基类–Object。 基于mixin的继承方式具体是指：一个类可以继承自多个父类。 使用new语句来构造一个类，构造函数的名字可能是ClassName，也可以是ClassName.identifier， 例如： 1234567var jsonData = JSON.decode('&#123;"x":1, "y":2&#125;');// Create a Point using Point().var p1 = new Point(2, 2);// Create a Point using Point.fromJson().var p2 = new Point.fromJson(jsonData); 使用.（dot）来调用实例的变量或者方法。 12345678910var p = new Point(2, 2);// Set the value of the instance variable y.p.y = 3;// Get the value of y.assert(p.y == 3);// Invoke distanceTo() on p.num distance = p.distanceTo(new Point(4, 4)); 使用?.来确认前操作数不为空, 常用来替代. , 避免左边操作数为null引发异常。 123456``` // If p is non-null, set its y value to 4. p?.y = 4;``` 使用const替代new来创建编译时的常量构造函数。 12345``` var p = const ImmutablePoint(2, 2);``` 使用runtimeType方法，在运行中获取对象的类型。该方法将返回Type 类型的变量。 12345``` print('The type of a is $&#123;a.runtimeType&#125;');``` 实例化变量(Instance variables) 在类定义中，所有没有初始化的变量都会被初始化为null。 12345class Point &#123; num x; // Declare instance variable x, initially null. num y; // Declare y, initially null. num z = 0; // Declare z, initially 0.&#125; 类定义中所有的变量, Dart语言都会隐式的定义 setter 方法，针对非空的变量会额外增加 getter 方法。 1234567891011class Point &#123; num x; num y;&#125;main() &#123; var point = new Point(); point.x = 4; // Use the setter method for x. assert(point.x == 4); // Use the getter method for x. assert(point.y == null); // Values default to null.&#125; 构造函数(Constructors) 声明一个和类名相同的函数，来作为类的构造函数。 12345678910class Point &#123; num x; num y; Point(num x, num y) &#123; // There's a better way to do this, stay tuned. this.x = x; this.y = y; &#125;&#125; this关键字指向了当前类的实例, 上面的代码可以简化为： 12345678class Point &#123; num x; num y; // Syntactic sugar for setting x and y // before the constructor body runs. Point(this.x, this.y);&#125; 构造函数不能继承(Constructors aren’t inherited) Dart 语言中，子类不会继承父类的命名构造函数。如果不显式提供子类的构造函数，系统就提供默认的构造函数。 命名的构造函数(Named constructors) 使用命名构造函数从另一类或现有的数据中快速实现构造函数。 123456789101112class Point &#123; num x; num y; Point(this.x, this.y); // 命名构造函数Named constructor Point.fromJson(Map json) &#123; x = json['x']; y = json['y']; &#125;&#125; 构造函数不能被继承，父类中的命名构造函数不能被子类继承。如果想要子类也拥有一个父类一样名字的构造函数，必须在子类是实现这个构造函数。 调用父类的非默认构造函数 默认情况下，子类只能调用父类的无名，无参数的构造函数; 父类的无名构造函数会在子类的构造函数前调用; 如果initializer list 也同时定义了，则会先执行initializer list 中的内容，然后在执行父类的无名无参数构造函数，最后调用子类自己的无名无参数构造函数。即下面的顺序： initializer list（初始化列表） super class’s no-arg constructor（父类无参数构造函数） main class’s no-arg constructor （主类无参数构造函数） 如果父类不显示提供无名无参数构造函数的构造函数，在子类中必须手打调用父类的一个构造函数。这种情况下，调用父类的构造函数的代码放在子类构造函数名后，子类构造函数体前，中间使用:(colon) 分割。 12345678910111213141516171819202122232425262728class Person &#123; String firstName; Person.fromJson(Map data) &#123; print('in Person'); &#125;&#125;class Employee extends Person &#123; // 父类没有无参数的非命名构造函数，必须手动调用一个构造函数 super.fromJson(data) Employee.fromJson(Map data) : super.fromJson(data) &#123; print('in Employee'); &#125;&#125;main() &#123; var emp = new Employee.fromJson(&#123;&#125;); // Prints: // in Person // in Employee if (emp is Person) &#123; // Type check emp.firstName = 'Bob'; &#125; (emp as Person).firstName = 'Bob';&#125; 初始化列表 除了调用父类的构造函数，也可以通过初始化列表在子类的构造函数体前（大括号前）来初始化实例的变量值，使用逗号,分隔。如下所示： 12345678910111213class Point &#123; num x; num y; Point(this.x, this.y); // 初始化列表在构造函数运行前设置实例变量。 Point.fromJson(Map jsonMap) : x = jsonMap['x'], y = jsonMap['y'] &#123; print('In Point.fromJson(): ($x, $y)'); &#125; &#125; 注意：上述代码，初始化程序无法访问 this 关键字。 静态构造函数 如果你的类产生的对象永远不会改变，你可以让这些对象成为编译时常量。为此，需要定义一个 const 构造函数并确保所有的实例变量都是 final 的。 123456class ImmutablePoint &#123; final num x; final num y; const ImmutablePoint(this.x, this.y); static final ImmutablePoint origin = const ImmutablePoint(0, 0);&#125; 重定向构造函数 有时候构造函数的目的只是重定向到该类的另一个构造函数。重定向构造函数没有函数体，使用冒号:分隔。 1234567891011121314151617class Point &#123; num x; num y; // 主构造函数 Point(this.x, this.y) &#123; print("Point($x, $y)"); &#125; // 重定向构造函数，指向主构造函数，函数体为空 Point.alongXAxis(num x) : this(x, 0);&#125;void main() &#123; var p1 = new Point(1, 2); var p2 = new Point.alongXAxis(4);&#125; 常量构造函数 如果类的对象不会发生变化，可以构造一个编译时的常量构造函数。定义格式如下： 定义所有的实例变量是final。 使用const声明构造函数。 123456class ImmutablePoint &#123; final num x; final num y; const ImmutablePoint(this.x, this.y); static final ImmutablePoint origin = const ImmutablePoint(0, 0);&#125; 工厂构造函数 当实现一个使用 factory 关键词修饰的构造函数时，这个构造函数不必创建类的新实例。例如，工厂构造函数可能从缓存返回实例，或者它可能返回子类型的实例。 下面的示例演示一个工厂构造函数从缓存返回的对象： 1234567891011121314151617181920212223242526class Logger &#123; final String name; bool mute = false; // _cache 是一个私有库,幸好名字前有个 _ 。 static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;&#123;&#125;; factory Logger(String name) &#123; if (_cache.containsKey(name)) &#123; return _cache[name]; &#125; else &#123; final logger = new Logger._internal(name); _cache[name] = logger; return logger; &#125; &#125; Logger._internal(this.name); void log(String msg) &#123; if (!mute) &#123; print(msg); &#125; &#125; &#125; 注意：工厂构造函数不能用 this。 方法 方法就是为对象提供行为的函数。 实例方法 对象的实例方法可以访问实例变量和 this 。以下示例中的 distanceTo() 方法是实例方法的一个例子： 12345678910111213import 'dart:math';class Point &#123; num x; num y; Point(this.x, this.y); num distanceTo(Point other) &#123; var dx = x - other.x; var dy = y - other.y; return sqrt(dx * dx + dy * dy); &#125; &#125; setters 和 Getters 是一种提供对方法属性读和写的特殊方法。每个实例变量都有一个隐式的 getter 方法，合适的话可能还会有 setter 方法。你可以通过实现 getters 和 setters 来创建附加属性，也就是直接使用 get 和 set 关键词： 123456789101112131415161718192021class Rectangle &#123; num left; num top; num width; num height; Rectangle(this.left, this.top, this.width, this.height); // 定义两个计算属性: right and bottom. num get right =&gt; left + width; set right(num value) =&gt; left = value - width; num get bottom =&gt; top + height; set bottom(num value) =&gt; top = value - height;&#125;main() &#123; var rect = new Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 12; assert(rect.left == -8);&#125; 借助于 getter 和 setter ，你可以直接使用实例变量，并且在不改变客户代码的情况下把他们包装成方法。 注： 不论是否显式地定义了一个 getter，类似增量（++）的操作符，都能以预期的方式工作。为了避免产生任何向着不期望的方向的影响，操作符一旦调用 getter ，就会把他的值存在临时变量里。 抽象方法 Instance ， getter 和 setter 方法可以是抽象的，也就是定义一个接口，但是把实现交给其他的类。要创建一个抽象方法，使用分号（；）代替方法体： 12345678910abstract class Doer &#123; // ...定义实例变量和方法... void doSomething(); // 定义一个抽象方法。&#125; class EffectiveDoer extends Doer &#123; void doSomething() &#123; // ...提供一个实现，所以这里的方法不是抽象的... &#125;&#125; 枚举类型 枚举类型，通常被称为 enumerations 或 enums ，是一种用来代表一个固定数量的常量的特殊类。 声明一个枚举类型需要使用关键字 enum ： 12345enum Color &#123; red, green, blue&#125; 在枚举中每个值都有一个 index getter 方法，它返回一个在枚举声明中从 0 开始的位置。例如，第一个值索引值为 0 ，第二个值索引值为 1 。 123assert(Color.red.index == 0);assert(Color.green.index == 1);assert(Color.blue.index == 2); 要得到枚举列表的所有值，可使用枚举的 values 常量。 12345678910111213141516171819202122232425262728293031323334``` List&lt;Color&gt; colors = Color.values; assert(colors[2] == Color.blue); ```* 你可以在 switch 语句 中使用枚举。如果 e 在 switch (e) 是显式类型的枚举，那么如果你不处理所有的枚举值将会弹出警告： ``` enum Color &#123; red, green, blue &#125; // ... Color aColor = Color.blue; switch (aColor) &#123; case Color.red: print('Red as roses!'); break; case Color.green: print('Green as grass!'); break; default: // Without this, you see a WARNING. print(aColor); // 'Color.blue' &#125; ```***枚举类型有以下限制*** * 你不能在子类中混合或实现一个枚举。 * 你不能显式实例化一个枚举。 为类添加特征：mixins mixins 是一种多类层次结构的类的代码重用。 要使用 mixins ，在 with 关键字后面跟一个或多个 mixin 的名字。下面的例子显示了两个使用mixins的类： 123456789101112 class Musician extends Performer with Musical &#123; // ... &#125;class Maestro extends Person with Musical, Aggressive, Demented &#123; Maestro(String maestroName) &#123; name = maestroName; canConduct = true; &#125; &#125; 要实现 mixin ，就创建一个继承 Object 类的子类，不声明任何构造函数，不调用 super 。例如： 123456789101112131415abstract class Musical &#123; bool canPlayPiano = false; bool canCompose = false; bool canConduct = false; void entertainMe() &#123; if (canPlayPiano) &#123; print('Playing piano'); &#125; else if (canConduct) &#123; print('Waving hands'); &#125; else &#123; print('Humming to self'); &#125; &#125;&#125; 类的变量和方法 使用 static 关键字来实现类变量和类方法。 只有当静态变量被使用时才被初始化。 静态变量, 静态变量（类变量）对于类状态和常数是有用的： 123456789class Color &#123; static const red = const Color('red'); // 一个恒定的静态变量 final String name; // 一个实例变量。 const Color(this.name); // 一个恒定的构造函数。&#125; main() &#123; assert(Color.red.name == 'red');&#125; 静态方法, 静态方法（类方法）不在一个实例上进行操作，因而不必访问 this 。例如： 1234567891011121314151617181920import 'dart:math'; class Point &#123; num x; num y; Point(this.x, this.y); static num distanceBetween(Point a, Point b) &#123; var dx = a.x - b.x; var dy = a.y - b.y; return sqrt(dx * dx + dy * dy); &#125;&#125; main() &#123; var a = new Point(2, 2); var b = new Point(4, 4); var distance = Point.distanceBetween(a, b); assert(distance &lt; 2.9 &amp;&amp; distance &gt; 2.8);&#125; 注：考虑到使用高阶层的方法而不是静态方法，是为了常用或者广泛使用的工具和功能。 你可以将静态方法作为编译时常量。例如，你可以把静态方法作为一个参数传递给静态构造函数。 抽象类 使用 abstract 修饰符来定义一个抽象类，该类不能被实例化。抽象类在定义接口的时候非常有用，实际上抽象中也包含一些实现。如果你想让你的抽象类被实例化，请定义一个 工厂构造函数 。 抽象类通常包含 抽象方法。下面是声明一个含有抽象方法的抽象类的例子： 123456// 这个类是抽象类，因此不能被实例化。abstract class AbstractContainer &#123; // ...定义构造函数，域，方法... void updateChildren(); // 抽象方法。&#125; 下面的类不是抽象类，因此它可以被实例化，即使定义了一个抽象方法： 12345678910class SpecializedContainer extends AbstractContainer &#123; // ...定义更多构造函数，域，方法... void updateChildren() &#123; // ...实现 updateChildren()... &#125; // 抽象方法造成一个警告，但是不会阻止实例化。 void doSomething();&#125; 类-隐式接口 每个类隐式的定义了一个接口，含有类的所有实例和它实现的所有接口。如果你想创建一个支持类 B 的 API 的类 A，但又不想继承类 B ，那么，类 A 应该实现类 B 的接口。 一个类实现一个或更多接口通过用 implements 子句声明，然后提供 API 接口要求。例如： 1234567891011121314151617181920212223242526// 一个 person ，包含 greet() 的隐式接口。class Person &#123; // 在这个接口中，只有库中可见。 final _name; // 不在接口中，因为这是个构造函数。 Person(this._name); // 在这个接口中。 String greet(who) =&gt; 'Hello, $who. I am $_name.';&#125; // Person 接口的一个实现。class Imposter implements Person &#123; // 我们不得不定义它，但不用它。 final _name = ""; String greet(who) =&gt; 'Hi $who. Do you know who I am?';&#125; greetBob(Person person) =&gt; person.greet('bob'); main() &#123; print(greetBob(new Person('kathy'))); print(greetBob(new Imposter()));&#125; 这里是具体说明一个类实现多个接口的例子： 123class Point implements Comparable, Location &#123; // ...&#125; 类-扩展一个类 使用 extends 创建一个子类，同时 supper 将指向父类： 123456789101112131415161718class Television &#123; void turnOn() &#123; _illuminateDisplay(); _activateIrSensor(); &#125; // ...&#125; class SmartTelevision extends Television &#123; void turnOn() &#123; super.turnOn(); _bootNetworkInterface(); _initializeMemory(); _upgradeApps(); &#125; // ...&#125; 子类可以重载实例方法， getters 方法， setters 方法。下面是个关于重写 Object 类的方法 noSuchMethod() 的例子,当代码企图用不存在的方法或实例变量时，这个方法会被调用。 1234567class A &#123; // 如果你不重写 noSuchMethod 方法, 就用一个不存在的成员，会导致NoSuchMethodError 错误。 void noSuchMethod(Invocation mirror) &#123; print('You tried to use a non-existent member:' + '$&#123;mirror.memberName&#125;'); &#125;&#125; 你可以使用 @override 注释来表明你重写了一个成员。 123456class A &#123; @override void noSuchMethod(Invocation mirror) &#123; // ... &#125;&#125; 如果你用 noSuchMethod() 实现每一个可能的 getter 方法，setter 方法和类的方法，那么你可以使用 @proxy 标注来避免警告。 123456@proxyclass A &#123; void noSuchMethod(Invocation mirror) &#123; // ... &#125;&#125; 库和可见性 import,part,library指令可以帮助创建一个模块化的，可共享的代码库。库不仅提供了API，还提供隐私单元：以下划线（_）开头的标识符只对内部库可见。每个Dartapp就是一个库，即使它不使用库指令。 库可以分布式使用包。见 Pub Package and Asset Manager 中有关pub(SDK中的一个包管理器）。 使用库 使用 import 来指定如何从一个库命名空间用于其他库的范围。 例如，Dart Web应用一般采用这个库 dart:html，可以这样导入： 1import 'dart:html'; 唯一需要 import 的参数是一个指向库的 URI。对于内置库，URI中具有特殊dart:scheme。对于其他库，你可以使用文件系统路径或package:scheme。包 package：scheme specifies libraries ，如pub工具提供的软件包管理器库。例如： 123import 'dart:io';import 'package:mylib/mylib.dart';import 'package:utils/utils.dart'; 指定库前缀 如果导入两个库是有冲突的标识符，那么你可以指定一个或两个库的前缀。例如，如果 library1 和 library2 都有一个元素类，那么你可能有这样的代码： 123456789``` import 'package:lib1/lib1.dart'; import 'package:lib2/lib2.dart' as lib2; // ... var element1 = new Element(); // 使用lib1里的元素 var element2 = new lib2.Element(); // 使用lib2里的元素``` 导入部分库 如果想使用的库一部分，你可以选择性导入库。例如： 12345// 只导入foo库import 'package:lib1/lib1.dart' show foo; //导入所有除了fooimport 'package:lib2/lib2.dart' hide foo; 延迟加载库 延迟(deferred)加载（也称为延迟(lazy)加载）允许应用程序按需加载库。下面是当你可能会使用延迟加载某些情况： 为了减少应用程序的初始启动时间； 执行A / B测试-尝试的算法的替代实施方式中； 加载很少使用的功能，例如可选的屏幕和对话框。 为了延迟加载一个库，你必须使用 deferred as 先导入它。 1import 'package:deferred/hello.dart' deferred as hello; 当需要库时，使用该库的调用标识符调用 LoadLibrary（）。 1234greet() async &#123; await hello.loadLibrary(); hello.printGreeting();&#125; 在前面的代码，在库加载好之前，await关键字都是暂停执行的。有关 async 和 await 见 asynchrony support 的更多信息。 您可以在一个库调用 LoadLibrary（） 多次都没有问题。该库也只被加载一次。 当您使用延迟加载，请记住以下内容： 延迟库的常量在其作为导入文件时不是常量。记住，这些常量不存在，直到迟库被加载完成。 你不能在导入文件中使用延迟库常量的类型。相反，考虑将接口类型移到同时由延迟库和导入文件导入的库。 Dart隐含调用LoadLibrary（）插入到定义deferred as namespace。在调用LoadLibrary（）函数返回一个Future。 库的实现 用 library 来来命名库，用part来指定库中的其他文件。 注意：不必在应用程序中（具有顶级main（）函数的文件）使用library，但这样做可以让你在多个文件中执行应用程序。 声明库 利用library identifier（库标识符）指定当前库的名称： 1234567// 声明库，名ballgamelibrary ballgame; // 导入html库import 'dart:html'; // ...代码从这里开始... 关联文件与库 添加实现文件，把part fileUri放在有库的文件，其中fileURI是实现文件的路径。然后在实现文件中，添加部分标识符（part of identifier），其中标识符是库的名称。下面的示例使用的一部分，在三个文件来实现部分库。 第一个文件，ballgame.dart，声明球赛库，导入其他需要的库，并指定ball.dart和util.dart是此库的部分： 123456789library ballgame; import 'dart:html';// ...其他导入在这里... part 'ball.dart';part 'util.dart'; // ...代码从这里开始... 第二个文件ball.dart，实现了球赛库的一部分： 123part of ballgame; // ...代码从这里开始... 第三个文件，util.dart，实现了球赛库的其余部分： 123part of ballgame; // ...Code goes here... 重新导出库(Re-exporting libraries) 123456789101112131415161718192021222324* 可以通过重新导出部分库或者全部库来组合或重新打包库。例如，你可能有实现为一组较小的库集成为一个较大库。或者你可以创建一个库，提供了从另一个库方法的子集。 ``` // In french.dart: library french; hello() =&gt; print('Bonjour!'); goodbye() =&gt; print('Au Revoir!'); // In togo.dart: library togo; import 'french.dart'; export 'french.dart' show hello; // In another .dart file: import 'togo.dart'; void main() &#123; hello(); //print bonjour goodbye(); //FAIL &#125; ``` 异步的支持 Dart 添加了一些新的语言特性用于支持异步编程。最通常使用的特性是 async 方法和 await 表达式。Dart 库大多方法返回 Future 和 Stream 对象。这些方法是异步的：它们在设置一个可能的耗时操作（比如 I/O 操作）之后返回，而无需等待操作完成 当你需要使用 Future 来表示一个值时，你有两个选择。 使用 async 和 await 使用 Future API 同样的，当你需要从 Stream 获取值的时候，你有两个选择。 使用 async 和一个异步的 for 循环 (await for) 使用 Stream API 使用 async 和 await 的代码是异步的，不过它看起来很像同步的代码。比如这里有一段使用 await 等待一个异步函数结果的代码： 1await lookUpVersion() 要使用 await，代码必须用 await 标记 12345678checkVersion() async &#123; var version = await lookUpVersion(); if (version == expectedVersion) &#123; // Do something. &#125; else &#123; // Do something else. &#125;&#125; 你可以使用 try, catch, 和 finally 来处理错误并精简使用了 await 的代码。 12345try &#123; server = await HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 4044);&#125; catch (e) &#123; // React to inability to bind to the port...&#125; 声明异步函数 一个异步函数是一个由 async 修饰符标记的函数。虽然一个异步函数可能在操作上比较耗时，但是它可以立即返回-在任何方法体执行之前。 12345checkVersion() async &#123; // ...&#125; lookUpVersion() async =&gt; /* ... */; 在函数中添加关键字 async 使得它返回一个 Future，比如，考虑一下这个同步函数，它将返回一个字符串。 String lookUpVersionSync() =&gt; ‘1.0.0’; 如果你想更改它成为异步方法-因为在以后的实现中将会非常耗时-它的返回值是一个 Future 。 Future lookUpVersion() async =&gt; ‘1.0.0’; 请注意函数体不需要使用 Future API，如果必要的话 Dart 将会自己创建 Future 对象 使用带 future 的 await 表达式 一个 await表达式具有以下形式 await expression 在异步方法中你可以使用 await 多次。比如，下列代码为了得到函数的结果一共等待了三次。 123var entrypoint = await findEntrypoint();var exitCode = await runExecutable(entrypoint, args);await flushThenExit(exitCode); 在 await 表达式中， 表达式 的值通常是一个 Future 对象；如果不是，那么这个值会自动转为 Future。这个 Future 对象表明了表达式应该返回一个对象。await 表达式 的值就是返回的一个对象。在对象可用之前，await 表达式将会一直处于暂停状态。 如果 await 没有起作用，请确认它是一个异步方法。比如，在你的 main() 函数里面使用await，main() 的函数体必须被 async 标记： 1234567``` main() async &#123; checkVersion(); print('In main: version is $&#123;await lookUpVersion()&#125;'); &#125;``` 结合 streams 使用异步循环 一个异步循环具有以下形式： 123await for (variable declaration in expression) &#123; // Executes each time the stream emits a value.&#125; 表达式 的值必须有Stream 类型（流类型）。执行过程如下： 在 stream 发出一个值之前等待 执行 for 循环的主体，把变量设置为发出的值。 重复 1 和 2，直到 Stream 关闭 如果要停止监听 stream ，你可以使用 break 或者 return 语句，跳出循环并取消来自 stream 的订阅 。 如果一个异步 for 循环没有正常运行，请确认它是一个异步方法。 比如，在应用的 main() 方法中使用异步的 for 循环时，main() 的方法体必须被 async 标记。 123456789main() async &#123; ... await for (var request in requestServer) &#123; handleRequest(request); &#125; ...&#125; 更多关于异步编程的信息，请看 dart:async 库部分的介绍。你也可以看文章 [Dart Language Asynchrony Support: Phase 1 ] (https://www.dartlang.org/articles/await-async/) 和 Dart Language Asynchrony Support: Phase 2 和 the Dart language specification]]></content>
      <categories>
        <category>Android</category>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从setContentView入口，全方位分析LayoutInflater]]></title>
    <url>%2Fposts%2F61266016.html</url>
    <content type="text"><![CDATA[LayoutInflater 介绍在 Android 中 LayoutInflater 是扮演着很重要的角色，很多时候我们忽略了它的重要性，因为它的重要性完 全被隐藏起来了，可以说是直接隐藏在了Activity , Fragment 等组件的光环之下了。 from(mContext) 源码解析在 Android 系统中，我们经常以 Context 获取系统级别的服务，比如 AMS, WMS, LayoutInfoater 等，这些服务会在合适的时候注册在系统中，在我们需要的时候 getSS(String name) 通过系统的名字来获取。我们先来看一段代码： 这里我就拿 Activity setContentView() 举例 1234@Overridepublic void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID);&#125; 继续跟下去： 1234/** * Should be called instead of &#123;@link Activity#setContentView(int)&#125;&#125; */public abstract void setContentView(@LayoutRes int resId); 跟下去发现是一个抽象类，我们找它的实现类： 123456789@Overridepublic void setContentView(int resId) &#123; ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); //通过 LayoutInflater 加载 XML id LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged();&#125; 我们在 AppCompatDelegateImpl 类找到了实现类，眼神好的是不是发现了上面的 LayoutInflater ，没错我们 Activity 最后也是通过 LayoutInflater 解析 XML 加载布局的，继续跟 from 函数： 12345678910111213/** * Obtains the LayoutInflater from the given context. */public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) //通过 Context 获取服务 context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError("LayoutInflater not found."); &#125; return LayoutInflater;&#125; 通过上面代码可以知道，LayoutInflater 是通过 Context 的 getSystemService(String name) 来获取到的。context 的 getSS 函数怎么获取到的勒，下面我们就来介绍下 Context 的源码。 Context其实在 Application，Activity，Service 中都会存在一个 Context 对象，我们叫其上下文，可以通过这个上下文，启动 Activity,Service, 注册一个广播，获取系统服务等等操作，那么 Context 是怎么创建出来的勒，先来看一段代码： 1public abstract class Context &#123;...&#125; Context 是一个抽象类，我们找下它的实现类，我们知道在启动 Activity 的时候有一个 Context 上下文，启动 Activity 的入口在 ActivityThread main 函数，我们就从这里开始找 1234567891011121314//通过反射调用执行的public static void main(String[] args) &#123; ... //主线程消息循环 Looper.prepareMainLooper(); //创建 ActivityThread 对象 ActivityThread thread = new ActivityThread(); //Application,Activity 入口 thread.attach(false); Looper.loop(); ... throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 1234567891011121314151617181920212223242526private void attach(boolean system) &#123; sCurrentActivityThread = this; mSystemThread = system; //不是系统级别的应用 if (!system) &#123; ViewRootImpl.addFirstDrawHandler(new Runnable() &#123; @Override public void run() &#123; ensureJitEnabled(); &#125; &#125;); android.ddm.DdmHandleAppName.setAppName("&lt;pre-initialized&gt;", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try &#123; //通过 IActivityManager。aidl 文件 底层通过 Binder 通信，关联 Application mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; ... &#125; else &#123; 代码省略 ....&#125; 在 main 方法中，我们创建了 ActivityThread 对象后，调用了其 attach 函数，并且参数为 false。在 attach 函数中，参数为 false 的情况下是属于非系统应用，会通过 Binder 机制与 AMS 通信，并且最终调用 H 类的 LAUNCH_ACTIVITY - &gt; handleLaunchActivity 函数，我们看下该函数的实现: 123456789101112/** * *启动 Activity * @param r * @param customIntent * @param reason */ private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; //实施 启动 Activity 的实例 Activity a = performLaunchActivity(r, customIntent); &#125; 继续跟： 1234567891011121314151617181920212223242526272829303132/***启动 Activity 代码*/ private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; .... //1. 创建 Context 对象 ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null;..... try &#123; // 2. 制作 Application 对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; //3. 获取 Context 对象 CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); appContext.setOuterContext(activity); //4. 将 appContext 等对象依附在 Activity 的 attach 函数中 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); //是否是持久化 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; //5. 调用 Activity 的 onCreate 方法 mInstrumentation.callActivityOnCreate(activity, r.state); &#125; .... return activity; &#125; 123456789/***Context 的实现类 ContextImp*/ private ContextImpl createBaseContextForActivity(ActivityClientRecord r) &#123; //1.创建 Activity 的 Context 对象, 到这里点击 ContextImpl 是 Context 实现类 ContextImpl appContext = ContextImpl.createActivityContext( this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig); .... return appContext; &#125; 1234567/** * Common implementation of Context API, which provides the base * context object for Activity and other application components. */class ContextImpl extends Context &#123; ...&#125; 通过上面代码 1- 5 的注释分析可知，Context 的实现类是 ContextImpl, 这里我们相当于又带着大家复习了一遍 Application , Activity 启动源码了。 getSystemService通过上面我们得知 ContextImpl 是 Context 的实现类，我们继续看源码 123456789101112public class ContextImpl extends Context&#123; ... /** * 通过服务名称代号 Context.XXX 拿到系统各种服务 */ @Override public Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name); &#125; ...&#125; 这里我们发现返回的是 SystemServiceRegistry 类里面的 getSystemService 函数，继续跟： 1234567/** * Gets a system service from a given context. */public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; 1234567/** * 交给子类来实现获取服务 * */static abstract interface ServiceFetcher&lt;T&gt; &#123; T getService(ContextImpl ctx);&#125; 1234/*** 装服务的容器*/private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); 到了这里我们知道了通过容器缓存拿到了 LayInflater 服务，那么什么时候注册的？下面我们继续看该类源码 registerService1234567891011121314151617181920final class SystemServiceRegistry &#123; /***装系统各种服务的容器，这里相当于容器单例类*/ private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS = new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); // Not instantiable. private SystemServiceRegistry() &#123; &#125; static &#123; ..... //注册 LayoutInflater 服务 registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;); ..... &#125;&#125; 1234567891011121314151617181920212223242526272829static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; &#123; private final int mCacheIndex; public CachedServiceFetcher() &#123; mCacheIndex = sServiceCacheSize++; &#125; @Override @SuppressWarnings("unchecked") public final T getService(ContextImpl ctx) &#123; final Object[] cache = ctx.mServiceCache; synchronized (cache) &#123; // Fetch or create the service. Object service = cache[mCacheIndex]; if (service == null) &#123; try &#123; service = createService(ctx); cache[mCacheIndex] = service; &#125; catch (ServiceNotFoundException e) &#123; onServiceNotFound(e); &#125; &#125; return (T)service; &#125; &#125; //交给抽象实现去创建服务 public abstract T createService(ContextImpl ctx) throws ServiceNotFoundException;&#125; 通过上面的代码可以知道抽象实现返回的是 new PhoneLayoutInflater(ctx.getOuterContext()); 那么这个 Phone… 到底什么了？ 我们继续跟 123public class PhoneLayoutInflater extends LayoutInflater &#123; &#125; 真相大白啊，PhoneLayoutInflater 就是继承的 LayoutInflater。 总结： 通过上面的代码可知，在虚拟机第一次加载该类时，通过 静态代码块 会注册各种 ServiceFatcher, 这其中就包含了 LayoutInflater Service, 将这些服务以键值对的形式存储在 Map 中, 用户使用时只需要根据 key 来获取对应的 ServiceFetcher, 然后通过 ServiceFetcher 对象的 getService 来获取具体服务对象。当第一次获取时，会调用 ServiceFetcher 的 createService 函数创建服务，然后缓存到一个列表中，下次再取直接从缓存中获取，从而避免了重复创建对象，从而达到了单例的效果，这不就是我之前介绍的单例模式-容器单例模式嘛，通过容器的单例模式实现方式，系统核心服务以单例形式存在，减少了资源消耗。 inflate 源码解析12345678@Overridepublic void setContentView(int resId) &#123; ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged();&#125; 跟 inflate 1234public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123; // root 不为 null , 则会从resourec 布局解析到 View ,并添加到 root 中 return inflate(resource, root, root != null);&#125; 1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")"); &#125; //获取 XMl 解析器 final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /** * * @param parser xml 解析器 * @param root 解析布局的父视图 * @param attachToRoot 是否将要解析的视图添加到父视图中 * @return */public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate"); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; //Context 对象 mConstructorArgs[0] = inflaterContext; //存储父视图 View result = root; try &#123; // Look for the root node. int type; //找到 root 元素 while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; final String name = parser.getName(); //1. 解析 Merge 布局标签 if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // 根据 Tag 来解析layout 跟视图 final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; // 生成布局参数 params = root.generateLayoutParams(attrs); //如果 attachRoot 为 false,那么将给 temp 设置布局参数 if (!attachToRoot) &#123; temp.setLayoutParams(params); &#125; &#125; // 解析 temp 下所有子 View rInflateChildren(parser, temp, attrs, true); // 如果 Root 不为空，且 attachToroot 为 true ,那么将 temp 添加到父布局中 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; //如果 root == null 且 attachToRoot 为 false 那么直接返回 temp if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; ... return result; &#125; &#125; 上述 inflate 方法中，主要有下面几步: 解析 xml 中的根标签 如果根标签是 merge ，那么调用 rInflate 进行解析，rInflate 会将所有的子 View 添加到跟标签中 如果标签是普通元素，那么调用 createViewFromTag 对元素进行解析； 调动 rInflateChildren 解析 temp 根元素下的所有子 View, 并且将这些子 View 都添加到 temp 下 返回解析到的根视图； 我们在看一段代码，先从简单的理解： 12345678910111213141516171819202122232425262728293031323334353637383940View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals("view")) &#123; name = attrs.getAttributeValue(null, "class"); &#125; try &#123; //1. 用户可以通过设置 LayoutInflater 的 factory 来自行解析 View,默认这些 Factory 都为空，可以忽略这段 View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; //2. 没有 Factory 的情况下通过 onCreateView 或者 createView 创建 View if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; // 3. 内置 View 控件的解析 if (-1 == name.indexOf('.')) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; //4 自定义 View 的解析 view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view;...&#125; 本段代码重点就在注释 2 处，当这个 tag 的名字包含 “.” 时，认为这是一个内置 View, 也就是 12345&lt;TextView android:id="@+id/list_item" android:layout_width="match_parent" android:layout_height="wrap_content" tools:ignore="MissingConstraints" /&gt; 这里的 TextView 就是 XMl 标签的名字，因此，在执行 infate 时就会调用注释 3 处的 onCreateView 来解析 TextView 标签。那么，当我们自定义 View 时，就会执行注释 4 12345&lt;com.t01.TextView android:id="@+id/list_item" android:layout_width="match_parent" android:layout_height="wrap_content" tools:ignore="MissingConstraints" /&gt; 在上面的 PhoneLayoutInflater 重写了 onCreateView 方法，该方法就是在 View 标签名的前面设置了一个 “android.widget” 前缀，然后传递给 createView 解析。 那么我们来看下 createView 源码具体实现吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//根据完整的路径的类名通过反射机制构造 View 对象public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; //1. 通过缓存获取构造函数 Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); //2. 没有缓存构造函数 if (constructor == null) &#123; // 如果 prefix 不为空，那么构造函数的 View 路径，并且加载该类 clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) &#123; boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; //3. 从 Class 对象中获取构造函数 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); //4. 将构造函数存入缓存中 sConstructorMap.put(name, constructor); &#125; else &#123; ... &#125; Object lastContext = mConstructorArgs[0]; if (mConstructorArgs[0] == null) &#123; // Fill in the context if not already within inflation. mConstructorArgs[0] = mContext; &#125; Object[] args = mConstructorArgs; args[1] = attrs; //5. 通过反射构造 View final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123; // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; mConstructorArgs[0] = lastContext; return view; &#125; createView 相当来说还比较理解，如果有前缀，那么就构造 View 的完整路径，并且将该类加载到虚拟机中，然后获取该类的构造函数并且缓存下来，在通过构造函数来创建该 View 的对象，最后将对象返回，这就是解析单个 View 的过程。而我们的窗口中时一个视图树， LayoutInflater 需要解析完这棵树，这个功能就交给 rInflateChildren 方法，看下面代码 1234567891011121314151617181920212223242526272829303132333435363738394041 void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; //1. 获取树的深度，优先遍历 final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; //2. 挨个元素解析 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; pendingRequestFocus = true; consumeChildElements(parser); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; // 解析 include 标签 if (parser.getDepth() == 0) &#123; throw new InflateException("&lt;include /&gt; cannot be the root element"); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; //解析到 merge 标签，抛出异常，因为 merge 标签必须是根视图 throw new InflateException("&lt;merge /&gt; must be the root element"); &#125; else &#123; //3. 根据元素名进行解析，又回去了 final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); //递归调用进行解析 rInflateChildren(parser, view, attrs, true); //将解析到的 View 添加进 ViewGroup 中，也就是它的 parent viewGroup.addView(view, params); &#125; &#125;... &#125; rInflateChildren 通过深度优先遍历来构造视图树，每解析到一个 View 元素就会递归调用 rInflateChildren ，直到这条路径的最后一个元素，然后在回溯过来将每一个 View 元素添加进 parent 中，通过 rInflateChildren 解析之后，整棵树就构建完毕了。当回调了 onResume 之后，setContentView 设置的内容就会出现在屏幕中了。 总结LayoutInflater 涉及的知识源码还是挺多的，有 Application , Activity 的启动，还有深度广度遍历，XML 节点解析，容器单例模式。这里也相当于带着大家温习了一遍 Activity 启动流程吧。 好了，到了这里相信大家对 setContentView 之后干了些什么事儿，已经有一定了解了。 感谢你的阅读，谢谢！]]></content>
      <categories>
        <category>Android</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>单列模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter “保姆”级项目 Demo合集]]></title>
    <url>%2Fposts%2F60004316.html</url>
    <content type="text"><![CDATA[为啥叫“保姆”级项目，因为是真的贴心… flutter go https://github.com/alibaba/flutter-go GSY的 flutter 合集GSYFlutterDemo 作为简单示例和解决方案 Demo ，它可以给你学习和工作中提供一些便捷的帮助，比如 如何自定义布局，如何滚动控件到指定 child position ，如何调整 Text 控件的 Line Space ，如何监听键盘的弹出和收起 等等，所以例子方案都独立实现，方便阅读 CV 。 已有例子 Controller 例子 圆角 例子 滑动监听 例子 滑动到指定位置 例子 滑动到指定位置2 例子 Transform 例子 文本行间距 例子 多种下拉刷新 例子 绝对定位 例子 气泡提示框 例子 标签Wrap 例子 共享元素动画 例子 修改状态栏颜色 例子 系统键盘相关 例子 动画相关 例子 悬浮触摸控件 例子 全局字体大小 例子 富文本 例子 ViewPager 例子 滑动停靠 例子 验证码输入框 例子 自定义布局 例子 自定义布局云词图 例子 https://github.com/CarGuo/GSYFlutterDemo 除此之外，GSY 也对外输出了，实战系列博客： https://juejin.im/user/582aca2ba22b9d006b59ae68/posts 实战项目： https://github.com/CarGuo/GSYGithubAppFlutter Flutter NoteBookflutetr_note_book有许多flutter相关功能demo的集合，它能够帮助您快速学习一些零碎的知识，本项目将会不定期更新。 https://github.com/OpenFlutter/Flutter-Notebook 看介绍上写，原本作者计划是日更的，但是日更的压力太大了。 我曾经尝试过做这样的事情，后来还是觉得不需要给自己太大压力才好，比如：wanandroid 上面的每日一问，现在变成了每周 3 问。 想要坚持做一件事情，而且是没有明显收益的事情，还是保持一个合理的周期，不要影响到自己才行。 就像谈恋爱，天天觉得有压力，烦那就不长久了~ 好在作者并没有断更，希望作者能坚持更久，感谢。 flutter_app本项目包括各种基本控件使用（Text、TextField、Icon、Image、Listview、Gridview、Picker、Stepper、Dialog、Slider、Row、Appbar、Sizebox、BottomSheet、Chip、Dismissible、FlutterLogo、Check、Switch、TabBar、BottomNavigationBar、Sliver等）、豆瓣电影、每日一文、和天气、百姓生活、随机诗词、联系人、句子迷、好奇心日报等板块 这个项目比较大的特色，就是汇集了非常多的实战 app，那么你看到哪个页面效果就能去看看它的实现。 当然了，现在做具体 app 类似开源项目，最麻烦的就是开放 api 了，很多抓取的一方面不确定是否违规，另一方面极度不稳定，我以前经常推荐完整项目，但是经常过了一段时间就不能访问了。 所以，你们真要练手，不妨使用 wanandroid.com 的开放 API，网站多数接口和开放 API 是使用的相同的接口，除非这个网站挂了，否则 API 一直很稳定，数据也同步更新，也算我对外的一些付出啦。 https://github.com/shichunlei/flutter_app awesome-flutter类似于收集不错的 Flutter 库，工具，文章，实例等。 因为是国外开发者做的，所以关注的更多是国外的内容，所以和以上项目做互补还是非常不错的。 这个资源合集，分类非常细致，有入门，进阶；视频教程等等。 https://github.com/Solido/awesome-flutter 另外有一个小技巧，就是你想看什么方向技术的时候，果断用 awesome + 关键词 搜索。 awesome kotlin awesome android 学到了吧。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CEO、CFO、CTO、CIO、COO、CHO、CMO、COO等你都知道是什么吗？]]></title>
    <url>%2Fposts%2F45ddb687.html</url>
    <content type="text"><![CDATA[CAOChief Administrative Officer 首席行政官(Chief Art Officer 首席艺术官)释义：顾名思义，首席行政官是在一个企业中负责日常事务的最高行政官员，也是企业里的行政部门长官。÷首席艺术官多数出现在文化娱乐企业中。 CBOChief Brand Officer 首席品牌官释义：它是现代组织（包括企业、政府或其他组织）中设置的专门负责品牌战略管理与运营的高级官员，代表CEO就企业形象、品牌以及文化进行内外部沟通。CBO不仅是一种专业人才，更是一种特殊人才。因为他不再仅仅是一个传播者，更是一个企业价值设计的参与者和企业品牌资产经营的责任者。首席品牌官按照国际惯例是由企业副总裁级领导担任，因此在国外，首席品牌官的薪酬少则数十万美元，多则上百万、甚至数百万美元。 CCOChief Cultural Officer 首席文化（知识）官释义：企业文化也是生产力，这点在中国目前的企业估计很少有人反对，而首席文化官当仁不让的主要职能就是架构最有效率的企业文化。国内已经出现了首批企业首席文化官，而根据中国企业文化促进会会长张光照的定义，CCO在企业中的主要职能就是统筹全局制定企业文化建设的规划，帮助员工树立起企业的核心价值观念。 CDOChief Development Officer 首席开发官释义：一个月前，思科公司一份新闻声明中宣布，任命查尔斯-詹卡洛担任公司的首席开发官，而此前，詹卡洛曾担任思科公司的首席技术官。首席开发官和首席技术官有一定的联系，首席开发官并不是所有企业都存在这个职位，多数出现于技术含量高的企业，手下也是积极性高、充满智慧的工程师等研究开发人员。 CEOChief Executive Officer 首席执行官释义：在某种意义上代表着将原来董事会手中的一些决策权过渡到经营层手中。CEO与总经理，形式上都是企业的“一把手”，CEO既是行政一把手，又是股东权益代言人，大多数情况下，CEO是作为董事会成员出现的，总经理则不一定是董事会成员。从这个意义上讲，CEO代表着企业，并对企业经营负责。 CFOChief Finance Officer 首席财务官释义：首席财务官是企业财务总监的“增长版”。当然，从本质上讲，CFO在现代治理结构中的真正含义，不是其名称的改变、官位的授予，而是其职责权限的取得，在管理中作用的真正发挥。 CGOChief Gonverment Officer 首席政府关系官释义：首席政府关系官，企业中用以协调企业与政府与社会之间的关系。他也是企业与外部环境建立联系的桥梁，但是与公关总监不同的是，他更专注于政府公共关系的处理。如果鹿鼎记里的韦小宝也来经营企业的话，那么建宁公主将是CGO的不二人选。 CHOChief HumanResource Officer 首席人事官释义：“二十一世纪最贵的是什么？人才！”这句话从《天下无贼》里作为贼头的葛优嘴里说出来很搞笑，然而却是不折不扣的真理，没有人才的国家就没有未来。但对于一个集体来讲，没有比人才更重要的东西。而CHO就是经常“贩卖”各种人才的“人贩子”。CHO平常的工作就是招聘、培训员工；考核员工业绩；协调员工关系；为员工提供职业规划———这个很重要，不同的人有不同的能力和需求，不是每个技术人员都想当经理，也不是每个管理人员都能搞技术。 ###CIOChief Information Officer 首席信息官 释义：早在上个世纪80年代末，世界500强企业就有30%以上配备的CIO，首席信息官的职责是负责制订公司信息化的政策与标准，并确定实施程序与方法，统一领导企业内部信息系统建设，制定总体规划，并协调各部门之间的关系，保证信息流通畅通。随着首席信息官内涵的丰富，现在他们的另一项任务还包括利用现代化的技术捕捉收集信息，以实现信息资源的合理配置。 CJOChief Jet Officer 首席“火箭推动”官释义：关于CJO，目前企业尚未出现类似的职位，但如果考虑Jet这个词，那么CJO就是公司里那种把营运指标都加一个或多个零，使公司市值像火箭般上升的人。 CKOChief Knowledge Officer 首席知识官释义：20世纪90年代初，知识管理还是一个令人兴奋的新概念。某些企业还设置了“首席知识官”（CKO）这一新的行政职位来主持这方面的工作。某种意义上说，CKO是知识经济的产物，一般要做如下的工作：结合企业的业务发展战略，率领企业找到知识管理的愿景和目标；正确定义好企业的知识体系并进行系统地表达；推动建立合适的IT系统工具以保障“知识之轮”的运转；将知识管理的流程与业务流程紧密融合为一体；建立合适的知识管理考核与激励机制；营造适合知识管理的信任、共享、创新的文化氛围。 CLOChief Law Officer 首席法律官释义：随着社会的法制化日益增强，企业对高级法律人才的渴求会越来越大，首席法律官顾名思义，就是为了公司对外对内的法律事务的管理而设置的行政职务，一般来说，首席法律官最好具备律师方面的比较长的从业经验，同时掌握一定的企业管理知识。 CMOChief Marketing Officer 首席市场官释义：CMO是指企业中负责市场运营工作的高级管理人员，也可称市场总监、主营市场的副总经理或副总裁等。主要负责在企业中对营销思想进行定位；把握市场机会，制定市场营销战略和实施计划，完成企业的营销目标；协调企业内外部关系，对企业市场营销战略计划的执行进行监督和控制；负责企业营销组织建设与激励工作。 CNOChief Negotiation Officer 首席谈判官释义：现代企业和商务活动成功与否，极大程度上取决于谈判技巧与能力。毋庸置疑，首席谈判官必须炼就卓越的谈判策划和实战能力，才能成为商界的赢家，才能在掌控自己命运时得心应手。首席谈判官负责架构公司谈判团队，介绍最有效的谈判技能，阐释最新颖独到的谈判理念。 COOChief Operation Officer 首席营运官释义：COO是负责公司企业的日常运作并向CEO报告的二把手。如果说CEO是部长、市长的话，COO这个名称可以很容易地联想到中文里现有的名词如常务副部长、常务副市长等。 CPOChief Public Relation Officer 首席公关官释义：一份良好的信誉是企业最有价值的资产之一。首席公关官是建造并保护这份资产的企业管理者，CPO需要建立和保护自身及公司的信誉，搭设品牌组织及个人信誉的公司经理和公共关系顾问。CPO还需要熟悉信誉策略的发展、信誉的衡量、危机和项目管理、网上信誉管理、媒体关系和内部沟通等。 CQOChief Quality Officer 首席质量官释义：作为企业中的第一质量人，CQO是企业战略小组的关键一员，负责创建以品质为核心的企业文化，塑造企业质量竞争力。CQO不仅懂业务、有方法，而且脚踏实地、思想鲜活；无论是朱兰、克劳士比，还是费根堡姆、哈灵顿，不仅是质量大师，更是商界领袖人物。 CROChief Research Officer 研究总监释义：企业不断前进和发展的动力源头，CRO的任务是领导企业组织中最具有突破钻研精神的人为企业不断开发出新的经济增长点。 CSOChief Solution Officer 首席问题官释义：在这个职位名称中，之所以用Solution（解决方案）而不用Problem（问题）来表示问题，有两方面的原因：一方面是因为Problem可能会让人理解为首席问题官是制造问题的，而不是解决问题的。另一方面是Solution一词近年来正在流行，许多软件公司和咨询公司都说他们能提供的不只是产品，而且是一整套解决问题的方案（Solutions）。顾名思义，CSO是负责挖掘问题、协调缓解问题和解决问题的高级管理人员。CSO的职责是挖掘企业管理中的问题，分析问题的性质和可能造成的影响，搞清问题的轻重缓急，制定解决问题的方案，提请总裁或董事会决策实施。 CTOChief Technology Officer 首席技术官释义：CTO（首席技术官）即企业内负责技术的最高负责人。这个名称在1980年代从美国开始时兴。起于做很多研究的大公司，如General Electric，AT&amp;T，ALCOA，主要责任是将科学研究成果成为盈利产品。1990年代，因计算机和软件公司热门，很多公司把CTO的名称给予管理计算机系统和软件的负责人。有时CTO和CIO（Chief Information Officer信息管理最高负责人）是同一个人（尤其在软件公司），有时CTO归于比较精通科学技术的CIO手下。在不同领域的公司，CTO工作性质不同；即使在同一领域，工作性质也可能大不相同。一般CTO会有以下责任：长期技术方向（战略性）、短期技术方向（战术性）、管理研究对公司经营活动和营利的影响、公司中使用的软件等等。 CUOChief User Officer 客户总监释义：CUO为客户制定媒体关系策略和公关活动策划，达成客户的市场或传播目标；督促客户服务团队执行媒体及公关活动，有效分配资源，并保证服务团队的工作质量；负责监督公关项目的计划和实施，使公关项目能在预算的时间和费用内完成；积极拓展客源及开发公司业务；与客户进行紧密的业务联络和沟通。 CVOChief VCReception Officer 风险投资商接待专员释义：首席财务官的重要助理。 CWOChief Writer Officer 首席网络写手释义：首席网络写手，负责将小事扩大化。 CXOChinese XO 中国洋酒释义：在企业取得阶段性成功时，一般都会拿出CXO来以资庆祝。 CYOChief Yearly Officer 首席元老释义：公司元老，这是一个荣誉称号，这个职位通常空缺。 CZOChief Zero Officer 最后离开者释义：最后离开公司的一个人，负责关好门窗，将公司大门钥匙交给物业管理处。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlutterPlugin开发流程]]></title>
    <url>%2Fposts%2Fb7213cdb.html</url>
    <content type="text"><![CDATA[这篇文章主要介绍了Flutter Plugin开发流程，包括如何利用Android Studio开发以及发布等。 今天这篇文章，给大家介绍如何开发Flutter Plugin中Android的部分。有关Flutter以及Flutter Plugin的概念，感兴趣的可以从官网查看相关资料。 简介笔者的环境是Mac下Android Studio进行的开发，AS也是谷歌官推的，安装flutter插件后，开发起来相对于其他IDE来说，方便很多，自带了三种模板： Flutter Application： Flutter应用 Flutter Plugin：Flutter插件 Flutter Package：纯Dart组件 Plugin其实就是一个特殊的Package。Flutter Plugin提供Android或者iOS的底层封装，在Flutter层提供组件功能，使Flutter可以较方便的调取Native的模块。很多平台相关性或者对于Flutter实现起来比较复杂的部分，都可以封装成Plugin。其原理如下 消息在client和host之间通过平台通道（platform channels）来进行的，之间的通讯都是异步的。 创建组件直接在Android Studio中新建一个Flutter Plugin的工程，当然也可以使用命令行来进行，例如创建一个flutter_text_plugin。 flutter create –org com.example –plugin flutter_text_plugin 如果想支持swift或者kotlin，可以用如下命令进行创建: flutter create –org com.example –plugin -i swift -a kotlin flutter_text_plugin 更多的参数选项，大家可以 查看帮助文档，当然还是比较推荐直接用AS进行创建，简单直观。用AS打开项目，可以看到项目的组织结构 123456root android example ios lib ... android以及ios文件夹是我们将要编写插件的native层的地方，lib文件夹是编写与native层映射的地方，native与flutter之间不能直接通信，必须通过MethodChannel来间接调用。example文件夹则是例子工程，编写的插件可以直接在这个项目中进行验证。在本文中，我们主要在android目录下进行，也就是android部分。 编写Android部分用AS打开flutter_text_plugin/android项目，这样子开发起来比较方便。但是打开过后，会发现出现了很多错误，提示找不到flutter相关的东西，我们仔细看这个项目，会发现跟我们平时用AS建的Android项目有所不同，少了很多部分，目录也有所不同。这是因为这个android项目不需要能够直接去运行，因此减少了很多东西。但是对于初次接触的人来说，可能是一头懵逼，例如该如何添加第三方库，如何添加proguard rule等等。 引入flutter库android插件工程是没有引入flutter库的，所以才会出现错误提示，我们在项目根目录建立一个libs文件夹，用来存放flutter库。 flutter库就在我们的flutter sdk中，路径如下 /bin/cache/artifacts/engine engine下面包含了各种平台的flutter库，我们随便拷贝一个Android平台的库到libs文件夹下，右键flutter.jar，弹出菜单选择Add As Library...。 经过这一步，项目中不会再报错了，但是，由于整个flutter plugin包含了flutter库，因此不能只是简单的添加就了事了，点击菜单Project Structure...，找到flutter_text_plugin的Dependencies中，将flutter库的Scope从Implementation改成Compile Only。至此，引入flutter库的工作完成了，可以进行插件的编写操作了。 添加第三方库添加第三方库有两种，一种是jar包引入，另一种通过gradle的方式进行。由于进行了第一步flutter库的引入，这一步就简单多了。查看build.gradle文件，可以看到最下面出现了如下的信息。 123dependencies &#123; compileOnly files('libs/flutter.jar')&#125; 看到这个，是不是就明朗多了，添加静态库以及添加在线库都可以在这个地方进行。例如我添加一个bugly静态库以及okhttp3库： 12345dependencies &#123; compileOnly files('libs/flutter.jar') implementation 'com.squareup.okhttp3:okhttp:3.10.0' implementation files('libs/bugly_crash_release.jar')&#125; 添加proguard rule由于了bugly以及okhttp3库，因此需要添加progurad rule。我们发现项目中没有proguard-rules.pro文件，因此这一步也需要我们自己去创建，在根目录下，建立proguard-rules.pro文件，将混淆规则添加进去，然后修改build.gradle文件，添加如下信息，跟普通Android项目差不多： 12345678910buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; debug &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; Android权限添加了bugly以及okhttp3库，需要对应的权限申明，才能正常运行。直接在manifest文件下，添加对应的权限 12345&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.READ_LOGS"/&gt; 插件开发至此，准备工作都已就绪，你可以把这个项目当做一个独立的Android项目，在上面进行各种封装操作，然后在FlutterTestPlugin文件下，将接口暴露出来。通过platform channels与flutter层关联起来。 发布当插件开发完毕，可以将插件发布让其他人使用，在发布之前，确保pubspec.yaml,、README.md以及CHANGELOG.md文件的内容都正确填写完毕。可以通过dry-run命令来看准备是否就绪。 flutter packages pub publish –dry-run 检查无误后，可以执行下面的命令，发布到Pub上。 flutter packages pub publish 如何引用对插件的引用有两种，已经发布的和未发布的。 引用发布的库flutter项目的很多资源管理都在根目录的pubspec.yaml下面，类似于js中的一些包管理一样，在dependencies加上我们需要引入的库，例如引入url_launcher库： 12dependencies: url_launcher: ^0.4.2 如果这个库包含了一些平台相关的东西，例如需要在native层进行使用的话，则需要在对应的native项目单独做引用。 Android修改android/build.gradle的dependencies处做引用： 123dependencies &#123; provided rootProject.findProject(":url_launcher") &#125; iOS修改ios/hello.podspec文件 123Pod::Spec.new do |s| # lines skipped s.dependency &apos;url_launcher&apos; 引用冲突引用不同的库可能会导致一些冲突，例如A和B两个插件，都包含了C插件，但是所需的版本不同。因此我们可以采取以下措施避免这种问题： 尽量使用范围版本而不是指定一个特定的版本。 强制统一冲突的插件版本 对于native层，android可以通过force命令强制指定版本，而iOS这边，Cocoapods则不支持引用的override功能。 引用未发布的库引用未发布的库有两种方式，通过本地路径和git地址的方式： 基于Path的引用方式：这种方式主要针对本地的未发布的库，引用的路径可以是相对或者绝对路径。 123dependencies: plugin1: path: ../plugin1/ 基于Git的引用方式：这种方式针对存放在git上的库，其中path是可选的，可以定位到某个子目录 12345dependencies: package1: git: url: git://github.com/flutter/packages.git path: packages/package1 后话笔者新建了一个flutter学习相关的项目，github地址，里面包含了笔者写的关于flutter学习相关的一些文章，后期也会定期更新，也会上传一些学习demo，欢迎大家关注。 参考 Flutter进阶—平台插件 Flutter - Creating a Plugin Flutter for Android Developers Writing custom platform-specific code with platform channels Developing Packages &amp; Plugins Using Packages]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter与Android的交互]]></title>
    <url>%2Fposts%2F5ae94dfd.html</url>
    <content type="text"><![CDATA[Flutter 说到底只是一个 UI 框架，很多功能都需要通过原生的 Api 来实现，那么就会涉及到 Flutter 和 Native 的交互，因为本人不懂 iOS 开发，所以只能讲下 Flutter 同 Android 的交互。 Android 项目配置 Flutter 依赖既然是互相交互，那么需要准备一个 Android 项目。接着就需要创建 flutter module，让 Android 项目依赖，创建的方法可以参考官网 Flutter Wiki，虽然是官网提供的方法，但是完全按照这个步骤来，还是会有坑的，这边就慢慢一步步解决坑。 如果你用的是 Android Studio 进行开发的话，直接打开底部的 Terminal，直接创建 flutter module 依赖 flutter create -t module flutter_native_contact 至于 module 名可以随意填写，module 创建完后结构大概是这样的 接着切换到 module 下的 .android 文件夹，接着有坑来了，官网提供的方法是 ./gradlew flutter:assembleDebug 可能会提示命令不存在，那么直接通过 gradlew flutter:assembleDebug 来运行，等它自动跑完后，打开根目录下的 settings.gradle 文件，加入官网提供的 gradle 代码 12345setBinding(new Binding([gradle: this])) // newevaluate(new File( // new settingsDir.parentFile, // new 'flutter_native_contact/.android/include_flutter.groovy' // new)) // new 你以为这里没坑，真是图样图森破，没坑是不可能的，编译器大爷可能会给你甩这么个错误 很明显可以看出是找不到我们的文件，所以把文件名路径给补全 1234evaluate(new File( // new settingsDir.parentFile, // new 'FlutterNativeContactDemo/flutter_native_contact/.android/include_flutter.groovy' // 这里补全路径)) 接着打开原有项目下，原有项目下，原有项目下的 app 中的 build.gradle 文件，在 android 下加上如下代码 1234compileOptions &#123; sourceCompatibility 1.8 targetCompatibility 1.8&#125; 这个必须要加，不要问为什么，我也不知道为什么，最后在项目下添加 flutter module 的依赖就完成了。这个过程告诉我们一个什么道理呢？*不要以为官网的都对，官网讲的也不是完全可信的，时不时给你来个坑就能卡你老半天。 原生界面加载 Flutter 页面那么如何在原生界面显示 Flutter 界面呢，这个就需要通过 FlutterView 来实现了，Flutter 这个类提供了 createView 和 createFragment 两个方法，分别用于返回 FlutterView 和 FlutterFragment 实例，FlutterFragment 的实现原理也是通过 FlutterView 来实现的，可以简单看下 FlutterFragment 的源码 1234567891011121314151617181920212223242526/** * A &#123;@link Fragment&#125; managing a &#123;@link FlutterView&#125;. * * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; This file is auto-generated by Flutter tooling. * DO NOT EDIT.&lt;/p&gt; */public class FlutterFragment extends Fragment &#123; public static final String ARG_ROUTE = "route"; private String mRoute = "/"; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 获取传入的路由值，默认为 '/' if (getArguments() != null) &#123; mRoute = getArguments().getString(ARG_ROUTE); &#125; &#125; @Override public FlutterView onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // 最后还是挺过 createView 方法来生成页面，只不过直接放在 fragment， // 放在 fragment 会比直接 使用 FlutterView 更方便管理，例如实现 ViewPager 等 return Flutter.createView(getActivity(), getLifecycle(), mRoute); &#125;&#125; createFragment 方式加载在原生页面显示 Flutter 界面的第一种方式就是加载 FlutterFragment，看个比较简单的例子吧 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity"&gt; &lt;!-- 这个布局用于加载 fragment --&gt; &lt;FrameLayout android:id="@+id/fragment_container" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/flutter_fragment" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginEnd="20dp" android:layout_marginBottom="50dp" android:src="@drawable/ic_add_white_36dp" app:fabSize="auto" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 在 Activity 可以直接通过返回 FlutterFragment 加载到 FrameLayout 即可 1234567891011class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) supportFragmentManager.beginTransaction() .add(R.id.fragment_container, Flutter.createFragment("route_flutter")) .commit() &#125;&#125; 这样就把 Flutter 页面加载到原生界面了，会通过传递的路由值在 dart 层进行查找，所以接着就需要编写 Flutter 界面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/// runApp 内部值也可以直接传入 _buildWidgetForNativeRoute 方法/// 这边在外层嵌套一层 MaterialApp 主要是防止一些不必要的麻烦，/// 例如 MediaQuery 这方面的使用等void main() =&gt; runApp(FlutterApp());class FlutterApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( home: _buildWidgetForNativeRoute(window.defaultRouteName), debugShowCheckedModeBanner: false, theme: ThemeData( primaryColor: Color(0XFF008577), accentColor: Color(0xFFD81B60), primaryColorDark: Color(0xFF00574B), iconTheme: IconThemeData(color: Color(0xFFD81B60)), ), ); &#125;&#125;/// 该方法用于判断原生界面传递过来的路由值，加载不同的页面Widget _buildWidgetForNativeRoute(String route) &#123; switch (route) &#123; case 'route_flutter': return GreetFlutterPage(); // 默认的路由值为 '/'，所以在 default 情况也需要返回页面，否则 dart 会报错，这里默认返回空页面 default: return Scaffold(); &#125;&#125;class GreetFlutterPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('NativeMessageContactPage'), ), body: Center( child: Text( 'This is a flutter fragment page', style: TextStyle(fontSize: 20.0, color: Colors.black), ), ), ); &#125;&#125; 运行后可以看到页面加载出来了，不过会有一段时间的空白，这个在正式打包后就不会出现，所以不必担心。最后的页面应该是这样的 createView 方式加载接着看下 createView 方法，说白了，第一种方法最后还是会通过该方式实现 1234567891011121314151617181920212223242526272829303132333435@NonNullpublic static FlutterView createView(@NonNull final Activity activity, @NonNull final Lifecycle lifecycle, final String initialRoute) &#123; // 交互前的一些初始化工作，需要完成才可以继续下一步，同时需要保证当前线程为主线程 // Looper.myLooper() == Looper.getMainLooper()，否则会甩你一脸的 IllegalStateException FlutterMain.startInitialization(activity.getApplicationContext()); FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), null); final FlutterNativeView nativeView = new FlutterNativeView(activity); // 将 flutter 页面绑定到相应的 activity final FlutterView flutterView = new FlutterView(activity, null, nativeView) &#123; // ...... &#125;; // 将路由值传到 flutter 层，并加载相应的页面， if (initialRoute != null) &#123; flutterView.setInitialRoute(initialRoute); &#125; // 绑定 lifecycle，方便生命周期管理，同 activity 绑定 // 不熟悉 LifeCycle 的同学可以自行网上查找资料 lifecycle.addObserver(new LifecycleObserver() &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) public void onCreate() &#123; // 配置一些参数，传递到 flutter 层 final FlutterRunArguments arguments = new FlutterRunArguments(); arguments.bundlePath = FlutterMain.findAppBundlePath(activity.getApplicationContext()); arguments.entrypoint = "main"; // 最终会调用方法 nativeRunBundleAndSnapshotFromLibrary，这是一个 native 方法，进行交互 flutterView.runFromBundle(arguments); // 进行注册 GeneratedPluginRegistrant.registerWith(flutterView.getPluginRegistry()); &#125; // ...... &#125;); return flutterView;&#125; 通过 createView 方法返回的 FlutterView，通过设置 Layoutparams 参数就可以添加到相应的布局上，还有一种直接通过 addContentView 方式进行加载，这里直接修改原有代码， 1234567override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // setContentView(R.layout.activity_main) 不需要这一步了 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_flutter") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) // 直接加载到 activity 页面 &#125; 但是通过这样加载的话，那么整个页面都是 flutter 的页面。那么之前的效果的 FAB 则不会被加载出来了，即使没有省略 setContentView(R.layout.activity_main) 方法，这个页面的 xml 布局也会被覆盖。 PlantformChannel那么能够在原生界面显示 flutter 页面了，如何互相交互呢，这就需要通过 PlantformChannel 来执行了，PlantformChannel 主要有三种类型，BasicMessageChannel，MethodChannel，EventChannel。通过查看源码可以发现，三个 Channel 的实现机制类似，都是通过 BinaryMessenger 进行信息交流，每个 Channel 通过传入的 channel name 进行区分，所以在注册 Channel 的时候必须要保证 channel name 是唯一的，同时需要传入一个 BinaryMessageHandler 实例，用于传递信息的处理，当 Handler 处理完信息后，会返回一个 result，然后通过 BinaryMessenger 将 result 返回到 Flutter 层。如果需要深入理解这边推荐一篇文章深入理解Flutter PlatformChannel 接下来直接看例子吧，在创建 PlatformChannel 的时候需要传入一个 BinaryMessenger 实例，通过查看 FlutterView 的源码可以发现，FlutterView 就是一个 BinaryMessenger 在 Android 端的实现，所以呢，可以直接通过前面介绍的 Flutter.createView 方法获取注册 Channel 时的 BinaryMessenger 实例了，真是得来全部费工夫~因为通信的方法可能在多个界面会使用，所以还是封装一个通用类来处理会比较合理 BasicMessageChannel BasicMessageChannel 用于传递字符串和半结构化的信息。 123456789101112131415161718192021222324class FlutterPlugin(private val flutterView: FlutterView) :BasicMessageChannel.MessageHandler&lt;Any&gt;&#123; companion object &#123; private const val TAG = "FlutterPlugin" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; // channel name 需要保持两侧一致 val messageChannel = BasicMessageChannel(flutterView, Constant.MESSAGE_CHANNEL_NAME, StandardMessageCodec.INSTANCE) // MessageCodec 有多种实现方式，可以参考推荐的文章 val instance = FlutterPlugin(flutterView) messageChannel.setMessageHandler(instance) // 注册处理的 Hnadler return instance &#125; &#125; override fun onMessage(`object`: Any?, reply: BasicMessageChannel.Reply&lt;Any&gt;?) &#123; // 简单的将从 Flutter 传过来的消息进行吐司，同时返回自己的交互信息 // `object` 中包含的就是 Flutter 层传递过来的信息，reply 实例用于传递信息到 Flutter 层 Toast.makeText(flutterView.context, `object`.toString(), Toast.LENGTH_LONG).show() reply?.reply("\"Hello Flutter\"--- an message from Android") &#125;&#125; 接着就需要有个 FlutterView 用来注册，新建一个 Activity，用于加载 Flutter 页面 123456789101112131415161718class ContactActivity : AppCompatActivity() &#123; private lateinit var plugin: FlutterPlugin override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) // 传入路由值，需要在 flutter 层生成相应的界面 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_contact") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) plugin = FlutterPlugin.registerPlugin(flutterView) &#125; override fun onDestroy() &#123; super.onDestroy() &#125;&#125; 那么我们就要在 Flutter 界面的 _buildWidgetForNativeRoute 方法加入新路由值对应的界面 12345678910111213141516171819202122232425262728293031323334353637Widget _buildWidgetForNativeRoute(String route) &#123; switch (route) &#123; // ... case 'route_contact': return FlutterContactPage(); default: return Scaffold(); &#125;&#125;class FlutterContactPage extends StatelessWidget &#123; // 注册对应的 channel，要保证 channel name 和原生层是一致的 final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Flutter Page'), ), // 简单放一个按钮，通过 channel 传输消息过去，同时将原生层返回的消息打印出来 body: RaisedButton( onPressed: () &#123; _messageChannel .send('"Hello Native" --- an message from flutter') .then((str) &#123; print('Receive message: $str'); &#125;); &#125;, child: Text('Send Message to Native'), ), ); &#125;&#125; 最后的效果小伙伴可以自行执行，点击按钮后会弹出吐司，吐司内容就是 Flutter 传递的信息，同时在控制台可以看到从原生层返回的信息。 MethodChannel MethodChannel 用于传递方法调用（method invocation） 直接在上述例子中进行修改，例如在 Flutter 页面中实现 Activity 的 finish 方法，并传递参数到前一个界面，先做 Flutter 页面的修改，在 AppBar 上增加一个返回按钮，用于返回上层页面 1234567891011121314151617181920212223242526272829303132class FlutterContactPage extends StatelessWidget &#123; // 注册对应的 channel，要保证 channel name 和原生层是一致的 final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); final MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME); @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( leading: InkWell( child: Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Icon(Icons.arrow_back), ), onTap: () &#123; _methodChannel // invokeMethod 第一个值用于传递方法名，第二个值用于传递参数， // 这边简单的传递一个字符串，当然也可以传递别的类型，map，list 等等 .invokeMethod&lt;bool&gt;('finishActivity', 'Finish Activity') .then((result) &#123; // 这边会返回一个结果值，通过判断是否成功来打印不同的信息 print('$&#123;result ? 'has finish' : 'not finish'&#125;'); &#125;); &#125;, ), title: Text('Flutter Page'), ), body: // ... ); &#125;&#125; 同时，我们需要在 FlutterPlugin 这个类中，做些必要的修改，首先需要实现 MethodCallHandler 接口，该接口中需要实现 onMethodCall 方法，通过获取调用的方法名和参数值，进行相应的处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344class FlutterPlugin(private val flutterView: FlutterView) : MethodChannel.MethodCallHandler, BasicMessageChannel.MessageHandler&lt;Any&gt; &#123; companion object &#123; private const val TAG = "FlutterPlugin" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; val instance = FlutterPlugin(flutterView) val methodChannel = MethodChannel(flutterView, Constant.METHOD_CHANNEL_NAME) // ... messageChannel.setMessageHandler(instance) return instance &#125; &#125; // .... // call 中携带了 Flutter 层传递过来的方法名和参数信息 // 可以分别通过 call.method 和 call.arguments 来获取 override fun onMethodCall(call: MethodCall?, result: MethodChannel.Result?) &#123; when (call?.method) &#123; "finishActivity" -&gt; &#123; val activity = flutterView.context as Activity val info = call.arguments.toString() val intent = Intent().apply &#123; putExtra("info", info) &#125; activity.setResult(Activity.RESULT_OK, intent) activity.finish() // 成功时候通过 result.success 返回值， // 如果发生异常，通过 result.error 返回异常信息 // Flutter 通过 invokeMethod().then() 来处理正常结束的逻辑 // 通过 catchError 来处理发生异常的逻辑 result?.success(true) &#125; // 如果未找到对应的方法名，则通过 result.notImplemented 来返回异常 else -&gt; result?.notImplemented() &#125; &#125; 最终的效果，当点击返回按钮的时候，会将 Flutter 层通过 invokeMethod 传递的 arguments 属性吐司出来，同时，控制台会打印出 “has finish” 的信息 EventChannel EventChannel 用于数据流（event streams）的通信 EventChannel 的实现方式也类似，EventChannel 可以持续返回多个信息到 Flutter 层，在 Flutter 层的表现就是一个 stream，原生层通过 sink 不断的添加数据，Flutter 层接收到数据的变化就会作出新相应的处理。在 Android 端实现状态的监听可以通过广播来实现。直接看例子，还是修改上述代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class FlutterPlugin(private val flutterView: FlutterView) : MethodChannel.MethodCallHandler, EventChannel.StreamHandler, BasicMessageChannel.MessageHandler&lt;Any&gt; &#123; private var mStateChangeReceiver: BroadcastReceiver? = null companion object &#123; private const val TAG = "FlutterPlugin" const val STATE_CHANGE_ACTION = "com.demo.plugins.action.StateChangeAction" const val STATE_VALUE = "com.demo.plugins.value.StateValue" @JvmStatic fun registerPlugin(flutterView: FlutterView): FlutterPlugin &#123; // ... val streamChannel = EventChannel(flutterView, Constant.STREAM_CHANNEL_NAME) val instance = FlutterPlugin(flutterView) methodChannel.setMethodCallHandler(instance) streamChannel.setStreamHandler(instance) messageChannel.setMessageHandler(instance) return instance &#125; &#125; // 实现 StreamHandler 需要重写 onListen 和 onCancel 方法 // onListen 不会每次数据改变就会调用，只在 Flutter 层，eventChannel 订阅广播 // 的时候调用，当取消订阅的时候则会调用 onCancel， // 所以当开始订阅数据的时候，注册接收数据变化的关闭， // 在取消订阅的时候，将注册的广播注销，防止内存泄漏 override fun onListen(argument: Any?, sink: EventChannel.EventSink?) &#123; mStateChangeReceiver = createEventListener(sink) flutterView.context.registerReceiver(mStateChangeReceiver, IntentFilter(STATE_CHANGE_ACTION)) &#125; override fun onCancel(argument: Any?) &#123; unregisterListener() &#125; // 在 activity 被销毁的时候，FlutterView 不一定会调用销毁生命周期，或者会延时调用 // 这就需要手动去注销一开始注册的广播了 fun unregisterListener() &#123; if (mStateChangeReceiver != null) &#123; flutterView.context.unregisterReceiver(mStateChangeReceiver) mStateChangeReceiver = null &#125; &#125; private fun createEventListener(sink: EventChannel.EventSink?): BroadcastReceiver = object : BroadcastReceiver() &#123; override fun onReceive(context: Context?, intent: Intent?) &#123; if (TextUtils.equals(intent?.action, STATE_CHANGE_ACTION)) &#123; // 这边广播只做简单的接收一个整数，然后通过 sink 传递到 Flutter 层 // 当然，sink 还有 error 方法，用于传递发生的错误信息， // 以及 endOfStream 方法，用于结束接收 // 在 Flutter 层分别有 onData 对应 success 方法，onError 对应 error 方法 // onDone 对应 endOfStream 方法，根据不同的回调处理不同的逻辑 sink?.success(intent?.getIntExtra(STATE_VALUE, -1)) &#125; &#125; &#125;&#125; 在 Flutter 层，通过对 stream 的监听，对返回的数据进行处理，为了体现出变化，这边修改成 SatefulWidget 来存储状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class FlutterContactPage extends StatefulWidget &#123; @override _FlutterContactPageState createState() =&gt; _FlutterContactPageState();&#125;class _FlutterContactPageState extends State&lt;FlutterContactPage&gt; &#123; final MethodChannel _methodChannel = MethodChannel(METHOD_CHANNEL_NAME); final EventChannel _eventChannel = EventChannel(STREAM_CHANNEL_NAME); final BasicMessageChannel _messageChannel = BasicMessageChannel(MESSAGE_CHANNEL_NAME, StandardMessageCodec()); StreamSubscription _subscription; var _receiverMessage = 'Start receive state'; // 初始的状态值 @override void initState() &#123; super.initState(); // 当页面生成的时候就开始监听数据的变化 _subscription = _eventChannel.receiveBroadcastStream().listen((data) &#123; setState(() &#123; _receiverMessage = 'receive state value: $data'; // 数据变化了，则修改数据 &#125;); &#125;, onError: (e) &#123; _receiverMessage = 'process error: $e'; // 发生错误则显示错误信息 &#125;, onDone: () &#123; _receiverMessage = 'receive data done'; // 发送完毕则直接显示完毕 &#125;, cancelOnError: true); &#125; @override void dispose() &#123; super.dispose(); _subscription.cancel(); // 当页面销毁的时候需要将订阅取消，防止内存泄漏 &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( leading: InkWell( child: Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Icon(Icons.arrow_back), ), onTap: () &#123; // MethodChannel demo _methodChannel .invokeMethod&lt;bool&gt;('finishActivity', _receiverMessage) .then((result) &#123; print('$&#123;result ? 'has finish' : 'not finish'&#125;'); &#125;).catchError((e) &#123; print('error happend: $e'); &#125;); &#125;, ), title: Text('Flutter Page'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(8.0), // EventChannel demo，页面直接显示信息的变化 child: Text( _receiverMessage, style: TextStyle(fontSize: 20.0, color: Colors.black), ), ), // BasicMessageChannel demo RaisedButton( onPressed: () &#123; _messageChannel .send('"Hello Native" --- an message from flutter') .then((str) &#123; print('Receive message: $str'); &#125;); &#125;, child: Text('Send Message to Native'), ), ], ), ), ); &#125;&#125; 同时，需要在 Activity 层调用一个定时任务不断的发送广播 12345678910111213141516171819202122232425262728293031323334353637383940class ContactActivity : AppCompatActivity() &#123; private var timer: Timer? = null private var task: TimerTask? = null private lateinit var random: Random private lateinit var plugin: FlutterPlugin override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) random = Random() // 生成随机整数 val flutterView = Flutter.createView(this@ContactActivity, lifecycle, "route_contact") val lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) addContentView(flutterView, lp) plugin = FlutterPlugin.registerPlugin(flutterView) timer = Timer() // 定时器 task = timerTask &#123; // 定时任务 sendBroadcast(Intent(FlutterPlugin.STATE_CHANGE_ACTION).apply &#123; putExtra(FlutterPlugin.STATE_VALUE, random.nextInt(1000)) &#125;) &#125; timer?.schedule(task, 3000, 2000) // 延时 3s 开启定时器，并 2s 发送一次广播 &#125; override fun onDestroy() &#123; super.onDestroy() // 页面销毁的时候需要将定时器，定时任务销毁 // 同时注销 Plugin 中注册的广播，防止内存泄漏 timer?.cancel() timer = null task?.cancel() task = null plugin.unregisterListener() &#125;&#125; 最后的实现效果大概是这样的 Flutter 同 Android 端的交互到这讲的差不多了，和 iOS 的交互其实也类似，只不过在 Android 端通过 FlutterNativeView 来作为 Binarymessenger 的实现，在 iOS 端通过 FlutterBinaryMessenger 协议实现，原理是一致的。至于 Flutter 插件，其实现也是通过以上三种交互方式来实现的，可能我们目前通过 FlutterView 来作为 BinaryMessenger 实例，插件会通过 PluginRegistry.Registrar 实例的 messenger() 方法来获取 BinaryMessenger 实例。 最后贴上 demo 的地址：ContactDemo 需要了解插件的写法也可以直接查看官方提供的检测电量插件：Flutter Battery Plugin]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十四)之实战]]></title>
    <url>%2Fposts%2Fb447830c.html</url>
    <content type="text"><![CDATA[讲完了常用的部件和网络请求后，差不多该进入整体实战了，这里我们将写一个比较熟悉的项目，郭神的 cool weather。项目将使用 fluro 实现路由管理，dio 实现网络请求，rxdart 实现 BLoC 进行状态管理和逻辑分离，使用文件，shared_preferences，sqflite 实现本地的数据持久化。这边先给出项目的地址：flutter_weather，以及最后实现的效果图： One Two Three 除了 fluro 别的基本上前面都讲了，所以在开始正式的实战前，先讲下 fluro Flurofluro 是对 Navigator 的一个封装，方便更好的管理路由跳转，当然还存在一些缺陷，例如目前只支持传递字符串，不能传递中文等，但是这些问题都算不上是大问题。 fluro 的使用很简单，大概分如下的步骤： 在全局定义一个 Router 实例 1final router = Router(); 使用 Router 实例定义路径和其对应的 Handler 对象 123456789101112// 例如定义一个 CityPage 的路径和 HandlerHandler cityHandler = Handler(handlerFunc: (_, params) &#123; // 传递的参数都在 params 中，params 是一个 Map&lt;String, List&lt;String&gt;&gt; 类型参数 String cityId = params['city_id']?.first; return BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());&#125;);// 定义路由的路径和参数// 需要注意的是，第一个页面的路径必须为 "/"，别的可为 "/" + 任意拼接router.define('/city', handler: cityHandler);// 或者官方提供的另一种方式router.define('/city/:city_id', handler: cityHandler); 将 router 注册到 MaterialApp 的 onGenerateRoute 中 1MaterialApp(onGenerateRoute: router); 最后通过 Router 实例进行跳转，如果有参数传递则会在新的页面收到 123router.navigateTo(context, '/city?city_id=CN13579');// 或者官方的方式router.navigateTo(context, '/city/CN13579'); 在 fluro 中提供了多种路由动画，包括 fadeIn，inFromRight 等。讲完了使用，就进入实战了。 flutter_weather 实战导入插件在开始的时候，已经提到了整体功能的实现需求，所以这边需要导入的插件以及存放图片的文件夹如下： 12345678910111213141516171819202122dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.2 fluro: ^1.4.0 dio: ^2.1.0 shared_preferences: ^0.5.1+2 sqflite: ^1.1.3 fluttertoast: ^3.0.3 rxdart: ^0.21.0 path_provider: 0.5.0+1dev_dependencies: flutter_test: sdk: flutter flutter: uses-material-design: true assets: - images/ 顶层静态实例的实现有许多实例需要在顶层注册，然后在全局使用，包括但不限于 fluro 的 router，http，database 等等。在这个项目中，需要用到的就是这三个实例，会在全局调用，所以在开始前进行初始化，当然 http 和 database 在使用的时候创建也可以，完全看个人习惯，但是 fluro 的管理类必须在一开始就注册完成。首先需要定义一个 Application 类用来存放这些静态实例 12345class Application &#123; static HttpUtils http; // 全局网络 static Router router; // 全局路由 static DatabaseUtils db; // 全局数据库&#125; 接着就是对相应方法类的编写，其中 HttpUtil 和 DatabaseUtils 在前面有讲过，这边不重复讲，会讲下数据库如何建立。 Fluro 路由管理类首先，需要知道，该项目的界面大概分如下的界面(当然可先只定义首页，剩下用到了再定义，该项目相对简单，所以先列出来)：省选择页，市选择页，区选择页，天气展示页，设置页。所以 fluro 的管理类可按如下定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 查看 `routers/routers.dart` 文件class Routers &#123; /// 各个页面对应的路径 static const root = '/'; static const weather = '/weather'; static const provinces = '/provinces'; static const cities = '/cities'; static const districts = '/districts'; static const settings = '/settings'; /// 该方法用于放到 `main` 方法中定义所有的路由， /// 对应的 handler 可放同一个文件，也可放另一个文件，看个人喜好 static configureRouters(Router router) &#123; router.notFoundHandler = notFoundHandler; router.define(root, handler: rootHandler); // 首页 router.define(weather, handler: weatherHandler); // 天气展示页 router.define(provinces, handler: provincesHandler); // 省列表页 router.define(cities, handler: citiesHandler); // 省下市列表页 router.define(districts, handler: districtsHandler); // 市下区列表页 router.define(settings, handler: settingsHandler); // 设置页 &#125; /// 生成天气显示页面路径，需要用到城市 id static generateWeatherRouterPath(String cityId) =&gt; '$weather?city_id=$cityId'; /// 生成省下的市列表页相应路径 需要用到省 id 及省名 static generateProvinceRouterPath(int provinceId, String name) =&gt; '$cities?province_id=$provinceId&amp;name=$name'; /// 生成市下的区列表页相应路径，需用到市 id 及市名 static generateCityRouterPath(int provinceId, int cityId, String name) =&gt; '$districts?province_id=$provinceId&amp;city_id=$cityId&amp;name=$name';&#125;/// 查看 `routers/handler.dart` 文件Handler notFoundHandler = Handler(handlerFunc: (_, params) &#123; Logger('RouterHandler:').log('Not Found Router'); // 当找不到相应的路由时，打印信息处理&#125;);Handler rootHandler = Handler(handlerFunc: (_, params) =&gt; SplashPage());Handler weatherHandler = Handler(handlerFunc: (_, params) &#123; String cityId = params['city_id']?.first; // 获取相应的参数 return WeatherPage(city: cityId);&#125;);Handler provincesHandler = Handler(handlerFunc: (_, params) =&gt; ProvinceListPage());Handler citiesHandler = Handler(handlerFunc: (_, params) &#123; String provinceId = params['province_id']?.first; String name = params['name']?.first; return CityListPage(provinceId: provinceId, name: FluroConvertUtils.fluroCnParamsDecode(name));&#125;);Handler districtsHandler = Handler(handlerFunc: (_, params) &#123; String provinceId = params['province_id']?.first; String cityId = params['city_id']?.first; String name = params['name']?.first; return DistrictListPage(provinceId: provinceId, cityId: cityId, name: FluroConvertUtils.fluroCnParamsDecode(name));&#125;);Handler settingsHandler = Handler(handlerFunc: (_, params) =&gt; SettingsPage()); 那么界面的路由到这就编写好了，但是前面提到了 fluro 目前不支持中文的传递，所以在传递中文时候，需要先进行转码，这边提供一个自己写的方法，小伙伴有更好的方法也可以直接在项目提 issue 123456789101112131415161718/// 查看 `utils/fluro_convert_util.dart` 文件class FluroConvertUtils &#123; /// fluro 传递中文参数前，先转换，fluro 不支持中文传递 static String fluroCnParamsEncode(String originalCn) &#123; StringBuffer sb = StringBuffer(); var encoded = Utf8Encoder().convert(originalCn); // utf8 编码，会生成一个 int 列表 encoded.forEach((val) =&gt; sb.write('$val,')); // 将 int 列表重新转换成字符串 return sb.toString().substring(0, sb.length - 1).toString(); &#125; /// fluro 传递后取出参数，解析 static String fluroCnParamsDecode(String encodedCn) &#123; var decoded = encodedCn.split('[').last.split(']').first.split(','); // 对参数字符串分割 var list = &lt;int&gt;[]; decoded.forEach((s) =&gt; list.add(int.parse(s.trim()))); // 转回 int 列表 return Utf8Decoder().convert(list); // 解码 &#125;&#125; Database 管理类编写因为数据库的开启是一个很耗资源的过程，所以这边通过单例并提取到顶层。在该项目中，数据库主要用于存储城市信息，因为城市之间的关联比较复杂，如果通过 shared_preferences 或者文件存储会很复杂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/// 查看 `utils/db_utils.dart` 文件class DatabaseUtils &#123; final String _dbName = 'weather.db'; // 数据表名 final String _tableProvinces = 'provinces'; // 省表 final String _tableCities = 'cities'; // 市表 final String _tableDistricts = 'districts'; // 区表 static Database _db; static DatabaseUtils _instance; static DatabaseUtils get instance =&gt; DatabaseUtils(); /// 将数据库的初始化放到私有构造中，值允许通过单例访问 DatabaseUtils._internal() &#123; getDatabasesPath().then((path) async &#123; _db = await openDatabase(join(path, _dbName), version: 1, onCreate: (db, version) &#123; db.execute('create table $_tableProvinces(' 'id integer primary key autoincrement,' 'province_id integer not null unique,' // 省 id，id 唯一 'province_name text not null' // 省名 ')'); db.execute('create table $_tableCities(' 'id integer primary key autoincrement,' 'city_id integer not null unique,' // 市 id，id 唯一 'city_name text not null,' // 市名 'province_id integer not null,' // 对应的省的 id，作为外键同省表关联 'foreign key(province_id) references $_tableProvinces(province_id)' ')'); db.execute('create table $_tableDistricts(' 'id integer primary key autoincrement,' 'district_id integer not null unique,' // 区 id 'district_name text not null,' // 区名 'weather_id text not null unique,' // 查询天气用的 id，例如 CN13579826，id 唯一 'city_id integer not null,' // 对应市的 id，作为外键同市表关联 'foreign key(city_id) references $_tableCities(city_id)' ')'); &#125;, onUpgrade: (db, oldVersion, newVersion) &#123;&#125;); &#125;); &#125; /// 构建单例 factory DatabaseUtils() &#123; if (_instance == null) &#123; _instance = DatabaseUtils._internal(); &#125; return _instance; &#125; /// 查询所有的省，`ProvinceModel` 为省市接口返回数据生成的 model 类 /// 查看 `model/province_model.dart` 文件 Future&lt;List&lt;ProvinceModel&gt;&gt; queryAllProvinces() async =&gt; ProvinceModel.fromProvinceTableList(await _db.rawQuery('select province_id, province_name from $_tableProvinces')); /// 查询某个省内的所有市 Future&lt;List&lt;ProvinceModel&gt;&gt; queryAllCitiesInProvince(String proid) async =&gt; ProvinceModel.fromCityTableList(await _db.rawQuery( 'select city_id, city_name from $_tableCities where province_id = ?', [proid], )); /// 查询某个市内的所有区，`DistrictModel` 为区接口返回数据生成的 model 类 /// 查看 `model/district_model.dart` 文件 Future&lt;List&lt;DistrictModel&gt;&gt; queryAllDistrictsInCity(String cityid) async =&gt; DistrictModel.fromDistrictTableList(await _db.rawQuery( 'select district_id, district_name, weather_id from $_tableDistricts where city_id = ?', [cityid], )); /// 将所有的省插入数据库 Future&lt;void&gt; insertProvinces(List&lt;ProvinceModel&gt; provinces) async &#123; var batch = _db.batch(); provinces.forEach((p) =&gt; batch.rawInsert( 'insert or ignore into $_tableProvinces (province_id, province_name) values (?, ?)', [p.id, p.name], )); batch.commit(); &#125; /// 将省对应下的所有市插入数据库 Future&lt;void&gt; insertCitiesInProvince(List&lt;ProvinceModel&gt; cities, String proid) async &#123; var batch = _db.batch(); cities.forEach((c) =&gt; batch.rawInsert( 'insert or ignore into $_tableCities (city_id, city_name, province_id) values (?, ?, ?)', [c.id, c.name, proid], )); batch.commit(); &#125; /// 将市下的所有区插入数据库 Future&lt;void&gt; insertDistrictsInCity(List&lt;DistrictModel&gt; districts, String cityid) async &#123; var batch = _db.batch(); districts.forEach((d) =&gt; batch.rawInsert( 'insert or ignore into $_tableDistricts (district_id, district_name, weather_id, city_id) values (?, ?, ?, ?)', [d.id, d.name, d.weatherId, cityid], )); batch.commit(); &#125;&#125; 定义完全局使用的方法，就可以在 main 函数中进行相关的初始化了 1234567891011121314151617181920212223242526272829303132/// 查看 `main.dart` 文件void main() &#123; // 初始化 fluro router Router router = Router(); Routers.configureRouters(router); Application.router = router; // 初始化 http Application.http = HttpUtils(baseUrl: WeatherApi.WEATHER_HOST); // 初始化 db Application.db = DatabaseUtils.instance; // 强制竖屏，因为设置竖屏为 `Future` 方法，防止设置无效可等返回值后再启动 App SystemChrome.setPreferredOrientations([DeviceOrientation.portraitDown, DeviceOrientation.portraitUp]).then((_) &#123; runApp(WeatherApp()); // App 类可放在同个文件，个人习惯单独一个文件存放 if (Platform.isAndroid) &#123; SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent)); &#125; &#125;);&#125;class WeatherApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Weather App', onGenerateRoute: Application.router.generator, // 将 fluro 的路由进行注册 debugShowCheckedModeBanner: false, ); &#125;&#125; 初始化完毕，接着就可以进行页面的编写了。 首页编写首页主要是为了对 App 的一个大概展示，或者是一些广告的展示，同时也给一些数据初始化提供时间，当用户进入后有更好的体验效果。我们在这里就做一个图标的展示(图标可自行到项目中 images 文件夹查找)，延时 5s 后跳转下个页面。 12345678910111213141516171819202122232425262728293031323334353637383940414243/// 查看 `splash_page.dart` 文件class SplashPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; /// 因为已经引入了 rxdart，这里通过 rxdart.timer 进行倒计时 /// 当然也可以使用 Futuer.delayed 进行倒计时 /// 5s 计时，如果已经选择城市，跳转天气界面，否则进入城市选择 Observable.timer(0, Duration(milliseconds: 5000)).listen((_) &#123; PreferenceUtils.instance.getString(PreferencesKey.WEATHER_CITY_ID) .then((city) &#123; // 如果当前还未选择城市，则进入城市选择页，否则跳转天气详情页 // replace: true 即为 Navigator.pushReplacement 方法 Application.router.navigateTo(context, city.isEmpty ? Routers.provinces : Routers.generateWeatherRouterPath(city), replace: true); &#125;); &#125;); return Scaffold( body: Container( alignment: Alignment.center, color: Colors.white, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 展示图标 Image.asset(Resource.pngSplash, width: 200.0, height: 200.0), // 展示文字提醒，用 SizedBox 设置区域大小 SizedBox( width: MediaQuery.of(context).size.width * 0.7, child: Text( '所有天气数据均为模拟数据，仅用作学习目的使用，请勿当作真实的天气预报软件来使用', textAlign: TextAlign.center, softWrap: true, style: TextStyle(color: Colors.red[700], fontSize: 16.0), )) ], ), ), ); &#125;&#125; 城市选择页面当首次进入的时候，用户肯定没有选择城市，所以先编写城市选择列表页面，因为整体的项目使用 BLoC 分离业务逻辑和页面，所以先编写数据管理类吧，把数据请求和改变的业务逻辑放到这块，BLoC 的实现在前面讲过了，这边就不重复提了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/// 查看 `provinces_bloc.dart` 文件class ProvincesBloc extends BaseBloc &#123; final _logger = Logger('ProvincesBloc'); List&lt;ProvinceModel&gt; _provinces = []; // 全国省 List&lt;ProvinceModel&gt; _cities = []; // 省内市 List&lt;DistrictModel&gt; _districts = []; // 市内区 List&lt;ProvinceModel&gt; get provinces =&gt; _provinces; List&lt;ProvinceModel&gt; get cities =&gt; _cities; List&lt;DistrictModel&gt; get districts =&gt; _districts; BehaviorSubject&lt;List&lt;ProvinceModel&gt;&gt; _provinceController = BehaviorSubject(); BehaviorSubject&lt;List&lt;ProvinceModel&gt;&gt; _citiesController = BehaviorSubject(); BehaviorSubject&lt;List&lt;DistrictModel&gt;&gt; _districtController = BehaviorSubject(); /// stream，用于 StreamBuilder 的 stream 参数 Observable&lt;List&lt;ProvinceModel&gt;&gt; get provinceStream =&gt; Observable(_provinceController.stream); Observable&lt;List&lt;ProvinceModel&gt;&gt; get cityStream =&gt; Observable(_citiesController.stream); Observable&lt;List&lt;DistrictModel&gt;&gt; get districtStream =&gt; Observable(_districtController.stream); /// 通知刷新省份列表 changeProvinces(List&lt;ProvinceModel&gt; provinces) &#123; _provinces.clear(); _provinces.addAll(provinces); _provinceController.add(_provinces); &#125; /// 通知刷新城市列表 changeCities(List&lt;ProvinceModel&gt; cities) &#123; _cities.clear(); _cities.addAll(cities); _citiesController.add(_cities); &#125; /// 通知刷新区列表 changeDistricts(List&lt;DistrictModel&gt; districts) &#123; _districts.clear(); _districts.addAll(districts); _districtController.add(_districts); &#125; /// 请求全国省 Future&lt;List&lt;ProvinceModel&gt;&gt; requestAllProvinces() async &#123; var resp = await Application.http.getRequest(WeatherApi.WEATHER_PROVINCE, error: (msg) =&gt; _logger.log(msg, 'province')); return resp == null || resp.data == null ? [] : ProvinceModel.fromMapList(resp.data); &#125; /// 请求省内城市 Future&lt;List&lt;ProvinceModel&gt;&gt; requestAllCitiesInProvince(String proid) async &#123; var resp = await Application.http .getRequest('$&#123;WeatherApi.WEATHER_PROVINCE&#125;/$proid', error: (msg) =&gt; _logger.log(msg, 'city')); return resp == null || resp.data == null ? [] : ProvinceModel.fromMapList(resp.data); &#125; /// 请求市内的区 Future&lt;List&lt;DistrictModel&gt;&gt; requestAllDistricts(String proid, String cityid) async &#123; var resp = await Application.http .getRequest('$&#123;WeatherApi.WEATHER_PROVINCE&#125;/$proid/$cityid', error: (msg) =&gt; _logger.log(msg, 'district')); return resp == null || resp.data == null ? [] : DistrictModel.fromMapList(resp.data); &#125; @override void dispose() &#123; // 及时销毁 _provinceController?.close(); _citiesController?.close(); _districtController?.close(); &#125;&#125; 写完 BLoC 需要对其进行注册，因为城市选择相对还是比较频繁的，所以可以放最顶层进行注册 12345678return BlocProvider( bloc: ProvincesBloc(), // 城市切换 BLoC child: MaterialApp( title: 'Weather App', onGenerateRoute: Application.router.generator, debugShowCheckedModeBanner: false, ), ); 城市选择就是一个列表，直接通过 ListView 生成即可，前面讲 ListView 的时候提到，尽可能固定 item 的高度，会提高绘制效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// 查看 `provinces_page.dart` 文件class ProvinceListPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;ProvincesBloc&gt;(context); // 进入的时候先使用数据库的数据填充界面 Application.db.queryAllProvinces().then((ps) =&gt; _bloc.changeProvinces(ps)); // 网络数据更新列表并刷新数据库数据 _bloc.requestAllProvinces().then((provinces) &#123; _bloc.changeProvinces(provinces); Application.db.insertProvinces(provinces); &#125;); return Scaffold( appBar: AppBar( title: Text('请选择省份'), ), body: Container( color: Colors.black12, alignment: Alignment.center, // 省列表选择 child: StreamBuilder( stream: _bloc.provinceStream, initialData: _bloc.provinces, builder: (_, AsyncSnapshot&lt;List&lt;ProvinceModel&gt;&gt; snapshot) =&gt; !snapshot.hasData || snapshot.data.isEmpty // 如果当前的数据未加载则给一个加载，否则显示列表加载 ? CupertinoActivityIndicator(radius: 12.0) : ListView.builder( physics: BouncingScrollPhysics(), padding: const EdgeInsets.symmetric(horizontal: 12.0), itemBuilder: (_, index) =&gt; InkWell( child: Container( alignment: Alignment.centerLeft, child: Text(snapshot.data[index].name, style: TextStyle(fontSize: 18.0, color: Colors.black)), ), onTap: () =&gt; Application.router.navigateTo( context, // 跳转下层省内城市选择，需要将当前的省 id 以及省名传入 Routers. generateProvinceRouterPath(snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)), transition: TransitionType.fadeIn), ), itemExtent: 50.0, itemCount: snapshot.data.length), ), ), ); &#125;&#125; 对于市和区的列表选择也类似，除了最后的点击会有些区别页面的布局几乎一致，这边只提下点击事件 12345678910111213141516/// 查看 `cities_page.dart` 文件Application.router.navigateTo( context, // 跳转下层省内城市选择 Routers.generateProvinceRouterPath( snapshot.data[index].id, FluroConvertUtils.fluroCnParamsEncode(snapshot.data[index].name)), transition: TransitionType.fadeIn), )// 设置为当前区，并清理路由 stack，并将天气界面设置到最上层onTap: () &#123; PreferenceUtils.instance .saveString(PreferencesKey.WEATHER_CITY_ID, snapshot.data[index].weatherId); Application.router.navigateTo(context, Routers.generateWeatherRouterPath(snapshot.data[index].weatherId), transition: TransitionType.inFromRight, clearStack: true); &#125;) 天气详情页面天气详情页面相对部件会多点，为了看着舒服一点，这里拆成多个部分来编写，在这之前还是先编写数据的管理类，因为天气详情接口返回的数据嵌套层次比较多，关系比较复杂，不适合用 database 来做持久化，所以这里采用文件持久化方式。当然有些小伙伴会问干嘛不使用 shared_preferences 来存储，理论上应该没有太大的问题，但是个人建议相对复杂的数据使用文件存储会相对比较好点，一定要说个为什么，我也说不出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/// 查看 `weather_bloc.dart` 文件class WeatherBloc extends BaseBloc &#123; final _logger = Logger('WeatherBloc'); WeatherModel _weather; // 天气情况 String _background = WeatherApi.DEFAULT_BACKGROUND; // 背景 WeatherModel get weather =&gt; _weather; String get background =&gt; _background; BehaviorSubject&lt;WeatherModel&gt; _weatherController = BehaviorSubject(); BehaviorSubject&lt;String&gt; _backgroundController = BehaviorSubject(); Observable&lt;WeatherModel&gt; get weatherStream =&gt; Observable(_weatherController.stream); Observable&lt;String&gt; get backgroundStream =&gt; Observable(_backgroundController.stream); /// 更新天气情况 updateWeather(WeatherModel weather) &#123; _weather = weather; _weatherController.add(_weather); &#125; /// 更新天气背景 updateBackground(String background) &#123; _background = background; _backgroundController.add(_background); &#125; // 请求天气情况 Future&lt;WeatherModel&gt; requestWeather(String id) async &#123; var resp = await Application.http .getRequest(WeatherApi.WEATHER_STATUS, params: &#123;'cityid': id, 'key': WeatherApi.WEATHER_KEY&#125;, error: (msg) =&gt; _logger.log(msg, 'weather')); // 请求数据成功则写入到文件中 if (resp != null &amp;&amp; resp.data != null) &#123; _writeIntoFile(json.encode(resp.data)); &#125; return WeatherModel.fromMap(resp.data); &#125; Future&lt;String&gt; requestBackground() async &#123; var resp = await Application.http .getRequest&lt;String&gt;(WeatherApi.WEATHER_BACKGROUND, error: (msg) =&gt; _logger.log(msg, 'background')); return resp == null || resp.data == null ? WeatherApi.DEFAULT_BACKGROUND : resp.data; &#125; // 获取存储文件路径 Future&lt;String&gt; _getPath() async =&gt; '$&#123;(await getApplicationDocumentsDirectory()).path&#125;/weather.txt'; // 写入到文件 _writeIntoFile(String contents) async &#123; File file = File(await _getPath()); if (await file.exists()) file.deleteSync(); file.createSync(); file.writeAsString(contents); &#125; // 文件读取存储信息，如果不存在文件则返回空字符串 ''，不推荐返回 null Future&lt;String&gt; readWeatherFromFile() async &#123; File file = File(await _getPath()); return (await file.exists()) ? file.readAsString() : ''; &#125; @override void dispose() &#123; _weatherController?.close(); _backgroundController?.close(); &#125;&#125; 天气详情的刷新只有当个页面，所以 BLoC 的注册值需要在路由上注册即可，在 fluro 对应 handler 中加入注册 1234Handler weatherHandler = Handler(handlerFunc: (_, params) &#123; String cityId = params['city_id']?.first; // 这个 id 可以通过 BLoC 获取也可以 return BlocProvider(child: WeatherPage(city: cityId), bloc: WeatherBloc());&#125;); 那么接下来就可以编写界面了，先实现最外层的背景图变化 123456789101112131415161718192021222324252627282930313233343536373839/// 查看 `weather_page.dart` 文件class WeatherPage extends StatelessWidget &#123; final String city; WeatherPage(&#123;Key key, this.city&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;WeatherBloc&gt;(context); // 请求背景并更新 _bloc.requestBackground().then((b) =&gt; _bloc.updateBackground(b)); // 先读取本地文件缓存进行页面填充 _bloc.readWeatherFromFile().then((s) &#123; if (s.isNotEmpty) &#123; _bloc.updateWeather(WeatherModel.fromMap(json.decode(s))); &#125; &#125;); // 再请求网络更新数据 _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w)); return Scaffold( body: StreamBuilder( stream: _bloc.backgroundStream, initialData: _bloc.background, builder: (_, AsyncSnapshot&lt;String&gt; themeSnapshot) =&gt; Container( padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 20.0), alignment: Alignment.center, decoration: BoxDecoration( color: Colors.black12, image: DecorationImage( image: NetworkImage(themeSnapshot.data), fit: BoxFit.cover), ), child: // 具体内部布局通过拆分小部件实现 )), ); &#125;&#125; 页面最顶部是显示两个按钮，一个跳转城市选择，一个跳转设置页面，显示当前的城市 1234567891011121314151617181920212223242526272829class FollowedHeader extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; // snapshot 通过上层传入 FollowedHeader(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ // 城市选择页面跳转按钮 IconButton( icon: Icon(Icons.home, color: Colors.white, size: 32.0), onPressed: () =&gt; Application.router. navigateTo(context, Routers.provinces, transition: TransitionType.inFromLeft)), // 当前城市 Text('$&#123;snapshot.data.heWeather[0].basic.location&#125;', style: TextStyle(fontSize: 28.0, color: Colors.white)), // 设置页面跳转按钮 IconButton( icon: Icon(Icons.settings, color: Colors.white, size: 32.0), onPressed: () =&gt; Application.router .navigateTo(context, Routers.settings, transition: TransitionType.inFromRight)) ], ); &#125;&#125; 接着是当前的天气详情部分 1234567891011121314151617181920212223242526272829class CurrentWeatherState extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; CurrentWeatherState(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _now = snapshot.data.heWeather[0].now; var _update = snapshot.data.heWeather[0].update.loc.split(' ').last; return Column( crossAxisAlignment: CrossAxisAlignment.end, children: &lt;Widget&gt;[ // 当前的温度 Text('$&#123;_now.tmp&#125;℃', style: TextStyle(fontSize: 50.0, color: Colors.white)), // 当前的天气状况 Text('$&#123;_now.condTxt&#125;', style: TextStyle(fontSize: 24.0, color: Colors.white)), Row( // 刷新的时间 mainAxisAlignment: MainAxisAlignment.end, children: &lt;Widget&gt;[ Icon(Icons.refresh, size: 16.0, color: Colors.white), Padding(padding: const EdgeInsets.only(left: 4.0)), Text(_update, style: TextStyle(fontSize: 12.0, color: Colors.white)) ], ) ], ); &#125;&#125; 接下来是一个天气预报的列表块，以为是一个列表，当然可以通过 Cloumn 来实现，但是前面有提到过一个列表「粘合剂」—- CustomScrollView，所以这里的整体连接最后会通过 CustomScrollView 来实现，那么你可以放心在最上层容器的 child 属性加上 CustomScrollView 了。接着来实现这块预报模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class WeatherForecast extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; WeatherForecast(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var _forecastList = snapshot.data.heWeather[0].dailyForecasts; // 获取天气预报 return SliverFixedExtentList( delegate: SliverChildBuilderDelegate( (_, index) =&gt; Container( color: Colors.black54, // 外层设置背景色，防止被最外层图片背景遮挡文字 padding: const EdgeInsets.all(12.0), alignment: Alignment.centerLeft, child: index == 0 // 当第一个 item 情况，显示 ‘预报’ ? Text('预报', style: TextStyle(fontSize: 24.0, color: Colors.white)) : Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Text(_forecastList[index - 1].date, // 预报的日期 style: TextStyle(fontSize: 16.0, color: Colors.white)), Expanded( // 天气情况，这边通过 expanded 进行占位，并居中显示 child: Center(child: Text(_forecastList[index - 1].cond.txtD, style: TextStyle(fontSize: 16.0, color: Colors.white))), flex: 2), Expanded( child: Row( // 最高温度，最低温度 mainAxisAlignment: MainAxisAlignment.spaceBetween, children: &lt;Widget&gt;[ Text(_forecastList[index - 1].tmp.max, style: TextStyle(fontSize: 16.0, color: Colors.white)), Text(_forecastList[index - 1].tmp.min, style: TextStyle(fontSize: 16.0, color: Colors.white)), ], ), flex: 1) ], )), childCount: _forecastList.length + 1, // 这个数量需要 +1，因为有个标题需要一个数量 ), itemExtent: 50.0); &#125;&#125; 接着是空气质量报告，一个标题，下面由两个布局进行平分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class AirQuality extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; AirQuality(&#123;Key key, this.snapshot&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; var quality = snapshot.data.heWeather[0].aqi.city; return Container( padding: const EdgeInsets.all(12.0), color: Colors.black54, alignment: Alignment.centerLeft, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ // 标题 Padding(padding: const EdgeInsets.only(bottom: 20.0), child: Text('空气质量', style: TextStyle(fontSize: 24.0, color: Colors.white))), Row( children: &lt;Widget&gt;[ // 通过 expanded 进行平分横向距离 Expanded( child: Center( // 内部居中显示 child: Column( children: &lt;Widget&gt;[ Text('$&#123;quality.aqi&#125;', style: TextStyle(fontSize: 40.0, color: Colors.white)), Text('AQI 指数', style: TextStyle(fontSize: 20.0, color: Colors.white)), ], ), )), Expanded( child: Center( child: Column( children: &lt;Widget&gt;[ Text('$&#123;quality.pm25&#125;', style: TextStyle(fontSize: 40.0, color: Colors.white)), Text('PM2.5 指数', style: TextStyle(fontSize: 20.0, color: Colors.white)), ], ), )), ], ) ], )); &#125;&#125; 接下来是生活质量模块，看着也是个列表，但是后台返回的不是列表，而是根据不同字段获取不同质量指数，因为布局类似，所以可以对其进行封装再整体调用 12345678910111213141516171819202122232425262728293031class LifeSuggestions extends StatelessWidget &#123; final AsyncSnapshot&lt;WeatherModel&gt; snapshot; LifeSuggestions(&#123;Key key, this.snapshot&#125;) : super(key: key); // 生活指数封装 Widget _suggestionWidget(String content) =&gt; Padding(padding: const EdgeInsets.only(top: 20.0), child: Text(content, style: TextStyle(color: Colors.white, fontSize: 16.0))); @override Widget build(BuildContext context) &#123; var _suggestion = snapshot.data.heWeather[0].suggestion; return Container( padding: const EdgeInsets.all(12.0), color: Colors.black54, alignment: Alignment.centerLeft, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ Text('生活建议', style: TextStyle(fontSize: 24.0, color: Colors.white)), _suggestionWidget('舒适度：$&#123;_suggestion.comf.brf&#125;\n$&#123;_suggestion.comf.txt&#125;'), _suggestionWidget('洗车指数：$&#123;_suggestion.cw.brf&#125;\n$&#123;_suggestion.cw.txt&#125;'), _suggestionWidget('运动指数： $&#123;_suggestion.sport.brf&#125;\n$&#123;_suggestion.sport.txt&#125;'), ], ), ); &#125;&#125; 所有的分模块都已经编写完成，剩下就是通过粘合剂进行组装了 12345678910111213141516171819202122232425262728293031323334child: StreamBuilder( initialData: _bloc.weather, stream: _bloc.weatherStream, builder: (_, AsyncSnapshot&lt;WeatherModel&gt; snapshot) =&gt; !snapshot.hasData ? CupertinoActivityIndicator(radius: 12.0) : SafeArea( child: RefreshIndicator( child: CustomScrollView( physics: BouncingScrollPhysics(), slivers: &lt;Widget&gt;[ SliverToBoxAdapter(child: FollowedHeader(snapshot: snapshot)), // 实时天气 SliverPadding( padding: const EdgeInsets.symmetric(vertical: 30.0), sliver: SliverToBoxAdapter( child: CurrentWeatherState(snapshot: snapshot, city: city), ), ), // 天气预报 WeatherForecast(snapshot: snapshot), // 空气质量 SliverPadding( padding: const EdgeInsets.symmetric(vertical: 30.0), sliver: SliverToBoxAdapter(child: AirQuality(snapshot: snapshot)), ), // 生活建议 SliverToBoxAdapter(child: LifeSuggestions(snapshot: snapshot)) ], ), onRefresh: () async &#123; _bloc.requestWeather(city).then((w) =&gt; _bloc.updateWeather(w)); return null; &#125;), )), 最后就剩下设置页的全局主题切换了 设置页全局主题切换既然提到了数据的切换，那肯定就涉及 BLoC 毫无疑问了，还是照常编写管理类 12345678910111213141516171819202122232425/// 查看 `setting_bloc.dart` 文件class SettingBloc extends BaseBloc &#123; /// 所有主题色列表 static const themeColors = [Colors.blue, Colors.red, Colors.green, Colors.deepOrange, Colors.pink, Colors.purple]; Color _color = themeColors[0]; Color get color =&gt; _color; BehaviorSubject&lt;Color&gt; _colorController = BehaviorSubject(); Observable&lt;Color&gt; get colorStream =&gt; Observable(_colorController.stream); /// 切换主题通知刷新 switchTheme(int themeIndex) &#123; _color = themeColors[themeIndex]; _colorController.add(_color); &#125; @override void dispose() &#123; _colorController?.close(); &#125;&#125; 因为是全局的切换，那么这个 BLoC 肯定需要在最顶层进行注册，这边就不贴代码了，同 ProvinceBloc 一致。接着编写界面，设置界面因为有 GridView 和其他部件，所以也需要用 CustomScrollView 作为粘合剂，当然，你也可以用 Wrap 代替 GridView 来实现网格，就不需要用 CustomScrollView，使用 Column 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class SettingsPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; var _bloc = BlocProvider.of&lt;SettingBloc&gt;(context); return StreamBuilder( stream: _bloc.colorStream, initialData: _bloc.color, // Theme 是 Flutter 自带的一个设置主题的部件，里面可以设置多种颜色， // 通过接收到 color 的变化，改变主题色，其他页面也如此设置，小伙伴可以自己添加 builder: (_, AsyncSnapshot&lt;Color&gt; snapshot) =&gt; Theme( // IconThemeData 用于设置按钮的主题色 data: ThemeData(primarySwatch: snapshot.data, iconTheme: IconThemeData(color: snapshot.data)), child: Scaffold( appBar: AppBar( title: Text('设置'), ), body: Container( color: Colors.black12, padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 20.0), child: CustomScrollView( slivers: &lt;Widget&gt;[ SliverPadding( padding: const EdgeInsets.only(right: 12.0), sliver: SliverToBoxAdapter( child: Row( mainAxisAlignment: MainAxisAlignment.spaceBetween, crossAxisAlignment: CrossAxisAlignment.center, children: &lt;Widget&gt;[ Text('当前主题色：', style: TextStyle(fontSize: 16.0, color: snapshot.data)), Container(width: 20.0, height: 20.0, color: snapshot.data) ], )), ), SliverPadding(padding: const EdgeInsets.symmetric(vertical: 15.0)), SliverGrid( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Container(color: SettingBloc.themeColors[index]), onTap: () &#123; // 选择后进行保存，当下次进入的时候直接使用该主题色 // 同时切换主题色 _bloc.switchTheme(index); PreferenceUtils.instance.saveInteger(PreferencesKey.THEME_COLOR_INDEX, index); &#125;, ), childCount: SettingBloc.themeColors.length), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3, mainAxisSpacing: 20.0, crossAxisSpacing: 20.0)), ], ), ), ), )); &#125;&#125; 最终全局的主题切换也实现了。 编写完代码，需要打包啊，Android 下的打包大家肯定没问题，这里讲下 flutter 下如何打包 apk，ipa 因为没有 mac 所以你们懂的。 apk 文件打包 创建 jks 文件，如果已经存在可忽略这步从第二步开始。打开终端并输入 keytool -genkey -v -keystore [你的签名文件路径].jks -keyalg RSA -keysize 2048 -validity 10000 -alias key 然后输入密码以及一些基本信息就可以创建成功了 在项目的 android 目录下创建一个 key.properties 文件，里面进行如下配置 1234storePassword=&lt;password from previous step&gt;keyPassword=&lt;password from previous step&gt;keyAlias=keystoreFile=&lt;[你的签名文件路径].jks&gt; 在 android/app 下的 build.gradle 中进行如下修改 123456789101112131415161718192021222324252627apply from: "$flutterRoot/packages/flutter_tools/gradle/flutter.gradle" // 增加如下部分代码def keystorePropertiesFile = rootProject.file("key.properties")def keystoreProperties = new Properties()keystoreProperties.load(new FileInputStream(keystorePropertiesFile))android &#123; // ... defaultConfigs&#123; // ... &#125; // 增加如下代码 signingConfigs &#123; release &#123; keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] &#125; &#125; buildTypes&#123; // ... &#125;&#125; 再次打开终端运行 flutter build apk 会自动生成一个 apk 文件，文件路径为 [你的项目地址]\build\app\outputs\apk\release 通过 flutter install 就可以将正式包运行到手机上]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十三)之网络]]></title>
    <url>%2Fposts%2Fd9e32c9b.html</url>
    <content type="text"><![CDATA[前面讲完了常用的部件，BLoC 模式，数据持久化等常用的，今天再介绍个重头戏 —— 网络请求 HttpClientHttpClient 是 dart 自带的网络请求方式，在 dart:io 包下。使用 HttpClient 作为请求分以下几个步骤 创建 HttpClient 实例 1HttpClient client = HttpClient(); 打开连接，并设置一些头参数，请求参数等 123456789101112// 如果 url 中没有查询参数可直接创建Uri uri = Uri.parse('https://www.xxx.com');// 如果存在查询参数则在 Uri 中添加Uri uri = Uri(scheme: 'https', host: 'www.xxx.com', queryParameters: &#123;'a': 'AAA'&#125;);// 打开连接HttpClientRequest request = await client.getUrl(uri);request.headers.add('token', 'Bear $&#123;'x' * 20&#125;'); // 添加头部 token 信息// 如果是 post 或者 put 请求，通过 `add` 添加请求体// 因为 `add` 方法需要传入 `List&lt;int&gt;` 参数，可以通过 utf8.encode 进行编码request.add(utf8.encode('&#123;"a": "aaa"&#125;'));// 也可以通过添加流的方式进行添加request.addStream(input); 连接服务器 123// 设置 request 后通过 request.close() 获取一个响应对象 HttpClientResponse，// 包括响应头，响应内容等HttpClientResponse response = await request.close(); 读取服务器响应内容 1String responseBody = await response.transform(utf8.decoder).join(); 关闭实例 1client.close(); 例如我们要去请求 Bird.so 的首页并显示，我们可以这么实现 12345678910111213141516_httpClientRequest() async &#123; HttpClient client; // try catch finally 用于捕获请求过程中发生的异常，在 finally 中设置保证 client 能够关闭 try &#123; client = HttpClient(); HttpClientRequest request = await client.getUrl(Uri.parse(_BIRD_SO_URL)); HttpClientResponse response = await request.close(); String strResponse = await response.transform(utf8.decoder).join(); setState(() =&gt; _netBack = strResponse); &#125; catch (e) &#123; print('$&#123;e.toString()&#125;'); setState(() =&gt; _netBack = 'Fail'); &#125; finally &#123; client.close(); &#125; &#125; 最后实现的效果 很显然，用 HttpClient 请求相对来说是个非常麻烦的过程，如果要涉及到文本上传之类的，那么就会更麻烦了，所以这边引入一个网络请求的插件 dio，写本文的时候版本为 2.1.0 Diodio 是个非常强大的网络请求库，他的方式类似 OkHttp，我们可以直接查看官方文档，使用方式非常简单，创建一个 Dio 实例，然后就可以通过 get，post 等方式发起请求，返回 Future&lt;Response&gt;，而且支持多个并发请求，可以设置返回响应的类型，监听上传下载进度等等，看着就很给力。对于简单的方式，这边就不做太多介绍，主要讲下拦截器，也是非常给力的一部分。比如我们需要请求这么个接口 https://randomuser.me/api/ 这个接口通过 get 请求，可以加入任意的查询参数。比如我们需要实现一个请求加解密的过程，如果每次都在上传参数或者返回请求的时候去加密，解密的话，就做了非常多无用功了，那么这时候拦截器就派上用场了。先定义下加解密的规则，上传的参数统一转为小写，不存在大写，请求回的数据，不能含有 info 字段。看下如何实现 123456789101112131415161718192021222324252627282930313233_dioRequest() async &#123; BaseOptions options = BaseOptions(connectTimeout: 5000, receiveTimeout: 60000); Dio dio = Dio(options); dio.interceptors.add(InterceptorsWrapper(onRequest: (opt) &#123; // 获取查询的参数 Map params = opt.queryParameters; // 将所有的参数转为小写，因为查询参数通过 map 形式上传 params.forEach((key, value) =&gt; opt.queryParameters[key] = '$value'.toLowerCase()); // 这边还可以做些别的操作，例如需要 token 进行用户身份验证，则通过头部进行添加 // opt.headers['authorization'] = 'token'; // 在官网中，提供了 lock 和 unlock 的写法，被 lock 后，接下来的请求会进入队列等待， // 直到 unlock 后才能继续，可以用于几个请求，后续的需要用到前面的返回值的情况使用 // 返回修改后的 RequestOptions return opt; &#125;, onResponse: (resp) &#123; // 返回响应体后，将 info 字段的内容切除，并将 json 拼接完成 resp.data = '$&#123;'$&#123;resp.data&#125;'.split(', info').first&#125;&#125;'; return resp; &#125;, onError: (error) &#123; // 发生错误时的回调 return error; &#125;)); // 发送一个请求，可以查看下打印的结果 Response response = await dio.get(_USER_ME_URL, queryParameters: &#123;'a': 'AAA', 'b': 'BbBbBb'&#125;); print(response.data); print(response.request.headers); print(response.request.queryParameters); setState(() =&gt; _netBack = response.data.toString()); // 界面显示 response.data &#125; 看下最后的显示信息 请求体的头部成功加上了 authorization 参数，请求的参数全部变为小写，返回的信息也把 info 字段值去除。在很多时候，请求接口后，需要将 json 转换成 pojo 类来处理，可以通过 json_serializable 这个三方插件实现，这边提供文章 Flutter Json自动反序列化，当然这种方式比较麻烦，这里推荐个 Android Studio 下的插件 dart_json_format 直接搜索就可以，如果用的是 Vitual Code 或者别的不是 JetBrains 系列的，这里有个转换的网址 JsonToDart。 以上代码查看 http_main.dart 文件 实践一下下不知道小伙还记得前面讲的 BLoC 没有，忘了可以查看 Flutter 状态管理及 BLoC，这里结合 BLoC 和 Dio 实现界面和逻辑分离的小例子，接口使用前面提到的 https://randomuser.me/api/ 接口。网络应该是比较常用的，所以对其进行一些封装还是很有必要的，这边提供下我自己封装的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import 'package:dio/dio.dart';// 用于错误信息回调typedef ErrorCallback = void Function(String msg);class HttpUtils &#123; static const GET = 'get'; static const POST = 'post'; static Dio _dio; static HttpUtils _instance; Dio get hp =&gt; _dio; // dio 可以在 BaseOptions 中指定域名 baseUrl， // 后续接口就不需要再添加域名了 // 如果请求的接口域名发生了变化，只要把全部 url 写全，就会自动使用新的域名 HttpUtils._internal(String base) &#123; // 生成一个单例，防止多次打开关闭造成开销 _dio = Dio(BaseOptions(baseUrl: base, connectTimeout: 10000, receiveTimeout: 10000)); &#125; factory HttpUtils(String base) &#123; if (_instance == null) _instance = HttpUtils._internal(base); return _instance; &#125; // 添加拦截器 addInterceptor(List&lt;InterceptorsWrapper&gt; interceptors) &#123; _dio.interceptors.clear(); _dio.interceptors.addAll(interceptors); &#125; Future&lt;Response&lt;T&gt;&gt; getRequest&lt;T&gt;(url, &#123;Map params, ErrorCallback callback&#125;) =&gt; _request(url, GET, params: params, callback: callback); Future&lt;Response&lt;T&gt;&gt; postRequest&lt;T&gt;(url, &#123;Map params, ErrorCallback callback&#125;) =&gt; _request(url, POST, params: params, callback: callback); Future&lt;Response&gt; download(url, path, &#123;ProgressCallback receive, CancelToken token&#125;) =&gt; _dio.download(url, path, onReceiveProgress: receive, cancelToken: token); // T 可以指定返回的类型，String 或者 Map&lt;String, dynamic&gt; Future&lt;Response&lt;T&gt;&gt; _request&lt;T&gt;( url, String method, &#123; Map params, // 上传的参数 Options opt, ErrorCallback callback, // 错误回调 ProgressCallback send, // 上传进度监听 ProgressCallback receive, // 下载监听 CancelToken token, // 用于取消的 token，可以多个请求绑定一个 token &#125;) async &#123; try &#123; Response&lt;T&gt; rep; if (method == GET) &#123; // 如果不是重新创建 Dio 实例，get 方法使用 queryParams 会出错，不懂原因，使用拼接没有问题 if (params != null &amp;&amp; params.isNotEmpty) &#123; var sb = StringBuffer('?'); params.forEach((key, value) &#123; sb.write('$key=$value&amp;'); &#125;); // get 请求下拼接路径 url += sb.toString().substring(0, sb.length - 1); &#125; rep = await _dio.get(url, options: opt, onReceiveProgress: receive, cancelToken: token); &#125; else if (method == POST) &#123; // post 参数放请求体 rep = params == null ? await _dio.post(url, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive) : await _dio.post(url, data: params, options: opt, cancelToken: token, onSendProgress: send, onReceiveProgress: receive); &#125; // 如果 statusCode 不是 200 则错误回调，返回空的 Response if (rep.statusCode != 200 &amp;&amp; callback != null) &#123; callback('network error, and code is $&#123;rep.statusCode&#125;'); return null; &#125; return rep; &#125; catch (e) &#123; if (callback != null) &#123; callback('network error, catch error: $&#123;e.toString()&#125;'); &#125; return null; &#125; &#125;&#125; 封装后就可以愉快的调用了，如果有别的请求方式后期可以继续扩展。继续看代码，创建一个 application.dart 文件，用于存放全局参数 123class Application &#123; static HttpUtils http;&#125; 并在 main() 方法中进行初始化，接下来就可以直接使用 12345678910void main() &#123; Application.http = HttpUtils('https://randomuser.me'); runApp(DemoApp()); // 透明状态栏 if (Platform.isAndroid) &#123; SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle(statusBarColor: Colors.transparent)); &#125;&#125; 看下最后的实现效果吧，刚进入没有数据则通过转圈圈提示，加载完数据后，点击头像更换下个 实现 BLoC 需要有一个管理类 12345678910111213141516171819202122232425class UserBloc extends BaseBloc &#123; RandomUserModel _user; RandomUserModel get user =&gt; _user; BehaviorSubject&lt;RandomUserModel&gt; _controller = BehaviorSubject(); Observable&lt;RandomUserModel&gt; get stream =&gt; Observable(_controller.stream); // 网络请求获取新的数据，并更新 updateUserInfo() &#123; Application.http.getRequest('/api').then((response) &#123; // RandomUserModel 就是接口返回的 json 转成的 model 类 RandomUserModel model = RandomUserModel.fromMap(response.data); _user = model; // add 到 controller 通知修改 _controller.add(model); &#125;); &#125; @override void dispose() &#123; _controller?.close(); // 及时销毁 &#125;&#125; 设置好管理类后，就可以来编写界面了，界面也比较简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class UserPageDemo extends StatelessWidget &#123; // 将首字母大写 String _upperFirst(String content) &#123; assert(content != null &amp;&amp; content.isNotEmpty); return '$&#123;content.substring(0, 1).toUpperCase()&#125;$&#123;content.substring(1)&#125;'; &#125; // 地址信息通用部件 Widget _userLocation(String info) =&gt; Padding( padding: const EdgeInsets.only(top: 4.0), child: Text(info, style: TextStyle(color: Colors.white, fontSize: 16.0))); @override Widget build(BuildContext context) &#123; UserBloc _bloc = BlocProvider.of&lt;UserBloc&gt;(context); _bloc.updateUserInfo(); return Scaffold( // StreamBuilder 接受更新数据的 stream body: StreamBuilder( builder: (_, AsyncSnapshot&lt;RandomUserModel&gt; snapshot) =&gt; Container( alignment: Alignment.center, decoration: BoxDecoration( gradient: LinearGradient( begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: [Colors.blue[600], Colors.blue[400]])), child: !snapshot.hasData ? CupertinoActivityIndicator(radius: 12.0) : Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ InkWell( // 用于切换数据 child: ClipOval( // 圆形头像 child: FadeInImage.assetNetwork( placeholder: 'images/ava_default.png', image: snapshot.data.results[0].picture.large), ), onTap: () =&gt; _bloc.updateUserInfo()), // 更新数据 Padding( padding: const EdgeInsets.only(top: 20.0), child: Text( '$&#123;_upperFirst(snapshot.data.results[0].name.first)&#125; $&#123;_upperFirst(snapshot.data.results[0].name.last)&#125;', style: TextStyle(color: Colors.white, fontSize: 24.0)), ), Text('$&#123;snapshot.data.results[0].email&#125;', style: TextStyle(color: Colors.white, fontSize: 18.0)), _userLocation('$&#123;snapshot.data.results[0].location.street&#125;'), _userLocation('$&#123;_upperFirst(snapshot.data.results[0].location.city)&#125;'), _userLocation('$&#123;_upperFirst(snapshot.data.results[0].location.state)&#125;'), ]), ), initialData: _bloc.user, // 注入初始值 stream: _bloc.stream), // 注入更新 stream ); &#125;&#125; 以上代码查看 bloc_network 包下的所有文件]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十二)之数据持久化]]></title>
    <url>%2Fposts%2F6358b348.html</url>
    <content type="text"><![CDATA[上节讲了状态管理，但是当 App 重启后，数据就都丢失了，这样就比较尴尬了，什么都要重来，所以这节我们来讲下数据持久化。数据持久化主要有如下方式 文件读写 shared_preferences 存储 数据库存储 持久化的实现都需要通过三方插件来实现，接着会慢慢介绍三种实现方式 文件读写/ IO 操作文件读写需要 path_provider 插件，写这篇文章的时候，最新版本是 0.5.0+1，小伙伴们可以根据官网最新的版本进行替换，导入后我们就可以来看下如何实现文件的读写了。path_provider 的源码比较简单，这边就不单独拎出来说了，可以自行查看。path_provider 用于获取手机的存储文件位置，一共有三个方法 getTemporaryDirectory 临时目录，在 Android 中对应的方法为 getCacheDir，而在 iOS 中对应为 NSCachesDirectory，可以通过系统检测并清除 getApplicationDocumentsDirectory 缓存目录，在 Android 中对应为 AppData 文件夹，在 iOS 中对应为 NSDocumentsDirectory，只有当 App 被删除才能被删除 getExternalStorageDirectory 外部存储目录，只有在 Android 中有效，在 iOS 调用会抛出 UnsupportedError 异常，不过 Android 在写入前记得先申请权限哟，否则也是不行滴。 读写文件操作需要通过 Dart 的 IO 操作完成，这边小伙伴们可以自己看文档 File class，接着我们就直接通过例子来看文件实现数据持久化。先看下效果吧，最终重启 App 后，数据也能正常读取显示，说明数据被保存下来了 看下实现的代码，因为会涉及到多种方式，所以这边我把视图抽取出来实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Widget _fileIoPart() &#123; return Card( margin: const EdgeInsets.all(8.0), shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(8.0))), child: Column(children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(12.0), child: Text('File IO', style: TextStyle(fontSize: 20.0, color: Theme.of(context).primaryColor)), ), // RadioList 是单选按钮部件，通过选择不同的情况，创建不同目录的文件 RadioListTile( value: _radioText[0], title: Text(_radioText[0]), subtitle: Text(_radioDescriptions[0]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), RadioListTile( value: _radioText[1], title: Text(_radioText[1]), subtitle: Text(_radioDescriptions[1]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), RadioListTile( value: _radioText[2], title: Text(_radioText[2]), subtitle: Text(_radioDescriptions[2]), groupValue: _currentValue, onChanged: ((value) &#123; setState(() =&gt; _currentValue = value); &#125;)), Padding( padding: const EdgeInsets.all(12.0), // 用于写入文本信息 child: TextField( controller: _editController, decoration: InputDecoration(labelText: '输入存储的文本内容', icon: Icon(Icons.text_fields)), ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _writeTextIntoFile, child: Text('写入文件信息'), ), ), Padding( padding: const EdgeInsets.all(12.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[Text('文件内容：'), Expanded(child: Text(_fileContent, softWrap: true))], ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _readTextFromFile, child: Text('读取文件信息'), ), ), ]), ); &#125; 关键的部分在于 _writeTextIntoFile 和 _readTextFromFile 两个方法的实现。看下实现的代码 1234567891011121314151617181920212223242526272829303132333435363738394041// 如果写入外部内存需要读写权限，这边使用了第三方插件 `permission_handler` void _writeTextIntoFile() async &#123; if (_currentValue == _radioText[2]) &#123; PermissionStatus status = await PermissionHandler().checkPermissionStatus(PermissionGroup.storage); if (status == PermissionStatus.granted) // 如果是写入外部存储，则检测权限状态，同意则写入 _writeContent(); else if (status == PermissionStatus.disabled) // 拒绝了提示手动打开 Fluttertoast.showToast(msg: '未打开相关权限'); else // 未同意则主动申请权限 PermissionHandler().requestPermissions([PermissionGroup.storage]); &#125; else // 不是写入外部存储直接写入文件 _writeContent(); &#125;// 文本写入文件 void _writeContent() async &#123; // 写入文本操作 var text = _editController.value.text; // 获取文本框的内容 File file = File(await _getFilePath()); // 获取相应的文件 if (text == null || text.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入内容'); // 内容为空，则不写入并提醒 &#125; else &#123; // 内容不空，则判断是否已经存在，存在先删除，重新创建后写入信息 if (await file.exists()) file.deleteSync(); file.createSync(); // createSync 是一个同步的创建过程 file.writeAsStringSync(text); // writeAsStringSync 是同步写入的过程 _editController.clear(); // 写入文件后清空输入框信息 &#125; &#125; // 读取文本操作 void _readTextFromFile() async &#123; File file = File(await _getFilePath()); if (await file.exists()) &#123; setState(() =&gt; _fileContent = file.readAsStringSync()); // 文件存在则直接显示文本信息 &#125; else &#123; setState(() =&gt; _fileContent = ''); // 文件不存在则清空显示文本信息，并提示 Fluttertoast.showToast(msg: '文件还未创建，请先通过写入信息来创建文件'); &#125; &#125; 因为外部存储的文件需要涉及到权限问题，而且 iOS 也不支持，所以如果需要使用文件来持久化数据的话，尽量使用另外两种。因为在例子中，我们保存的数据相对比较简单，所以这边就不得不说另外一种更方便的持久化方式了 shared_preferences SharedPreferences写 Android 的小伙伴对这个应该不陌生了，但是 Flutter 并没有自带的 shared_preferences 功能，需要第三方插件来实现，引入 shared_preferences 插件，写文章的时候最新版本是 ^0.5.1+2，还是先看下最后的效果 代码的实现相对比较简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Widget _sharedPart() &#123; return Card( margin: const EdgeInsets.all(8.0), shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(8.0))), child: Column( children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.all(12.0), child: Text('Shared Preferences', style: TextStyle(fontSize: 20.0, color: Theme.of(context).primaryColor)), ), Padding( padding: const EdgeInsets.fromLTRB(12.0, 0, 12.0, 12.0), // 用于设置 key 信息 child: TextField( controller: _shareKeyController, decoration: InputDecoration(labelText: '输入 share 存储的 key', icon: Icon(Icons.lock_outline)), ), ), Padding( padding: const EdgeInsets.fromLTRB(12.0, 0, 12.0, 12.0), // 用于写入文本信息 child: TextField( controller: _shareValueController, decoration: InputDecoration(labelText: '输入 share 存储的 value', icon: Icon(Icons.text_fields)), ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _writeIntoShare, child: Text('写入 share'), ), ), Padding( padding: const EdgeInsets.all(12.0), child: Row( crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[Text('share 存储内容：'), Expanded(child: Text(_shareContent, softWrap: true))], ), ), Container( margin: const EdgeInsets.symmetric(horizontal: 12.0), width: MediaQuery.of(context).size.width, child: RaisedButton( onPressed: _readFromShare, child: Text('读取 share'), ), ), ], )); &#125; 实现的关键部分就是方法 _writeIntoShare 和 _readFromShare 12345678910111213141516171819202122232425262728293031323334void _writeIntoShare() async &#123; var shareKey = _shareKeyController.value.text; var shareContent = _shareValueController.value.text; if (shareKey == null || shareKey.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入 key'); &#125; else if (shareContent == null || shareContent.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入保存的内容'); &#125; else &#123; // 通过 `getInstance` 获取 `shared_preferences` 单例 var sp = await SharedPreferences.getInstance(); // sp 能保存的数据类型包括 `int`, `String`, `bool`, `double`, `StringList` sp.setString(shareKey, shareContent); &#125; &#125; void _readFromShare() async &#123; var shareKey = _shareKeyController.value.text; if (shareKey == null || shareKey.isEmpty) &#123; Fluttertoast.showToast(msg: '请输入 key'); &#125; else &#123; var sp = await SharedPreferences.getInstance(); // 数据读取的类型同写入类型，如果传入的 key 不存在则返回 null var value = sp.getString(shareKey); if (value == null) &#123; Fluttertoast.showToast(msg: '未找到该 key'); setState(() =&gt; _shareContent = ''); &#125; else &#123; setState(() =&gt; _shareContent = value); &#125; &#125; &#125; 这两种数据持久化的方式主要用于存储相对简单，关系不复杂的数据，如果涉及到大量的，且字段之间有关系的情况就需要通过数据库来实现了，Android 和 iOS 都自带 sqlite 数据库。 以上代码查看 data_persistence_main.dart 文件 SqfliteFlutter 实现数据库存储需要通过插件 sqflite 来实现，写文章的时候最新的版本是 sqflite 1.1.3，但是该版本需要 flutter 1.2 以上才行，所以我选择的是 sqflite 1.1.0，小伙伴可以根据自己的 flutter 版本选择相应的 sqflite 版本 sqflite 的基本操作语句，在文档中已经写得非常明白了，所以就不搬运了，这边直接讲下对于数据库的一些封装处理吧，因为打开数据库是一个很消耗资源的一个过程，所以呢，推荐实现单例会比较好。例如我们要实现一个 student 存储表 12345678910111213141516171819202122232425262728293031323334353637class DatabaseUtils &#123; final String _tableStudent = 'student'; static Database _database; // 创建单例，防止重复打开消耗内存 static DatabaseUtils _instance; static DatabaseUtils get instance =&gt; _instance; DatabaseUtils._internal() &#123; getDatabasesPath().then((path) async &#123; _database = await openDatabase(join(path, 'demo.db'), version: 2, onCreate: (db, version) &#123; // 创建数据库的时候在这边调用 db.execute('create table $_tableStudent ' 'id integer primary key autoincrement,' 'name text not null,' 'age integer not null default 0,' 'gender integer not null default 0'); // 更新升级增加的字段 db.execute('alter table $_tableStudent add column birthday text'); &#125;, onUpgrade: (db, oldVersion, newVersion) &#123; // 更新升级数据库的时候在这操作 if (oldVersion == 1) db.execute('alter table $_tableStudent add column birthday text'); &#125;, onOpen: (db) &#123; // 打开数据库时候的回调 print('$&#123;db.path&#125;'); &#125;); &#125;); &#125; factory DatabaseUtils() &#123; // 如果当前的单例已经存在，则不再创建，否则重新创建，factory 关键词看第一章 if (_instance == null) _instance = DatabaseUtils._internal(); return _instance; &#125;&#125; 那么对数据库的操作就完全考验你的 SQL 的掌握程度了，但是千万记住，sqlite 中的类型只有，整型 integer ，字符类型 text，浮点类型 real，二进制 blob。数据库的具体例子会等到最后的实际项目中展示，原谅我不懂如何展示一个界面给你操作，实现数据库的各种功能。 该部分代码查看 db_util.dart 文件，里面有一些基本的操作写法，小伙伴可自行查看。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十一)之状态管理，BLoC]]></title>
    <url>%2Fposts%2Fd121323a.html</url>
    <content type="text"><![CDATA[Stream在 dart 部分记得分享过 Stream 的文章链接，但是我知道你们肯定没几个愿意看的，所以这里再提下。还是得从源码开始…因为源码的注释比较长，就不贴注释了，可以自己看，我这边就提取一些关键信息。 Stream 是 Dart 提供的一种数据流订阅管理的”工具”，感觉有点像 Android 中的 EventBus 或者 RxBus，Stream 可以接收任何对象，包括是另外一个 Stream，接收的对象通过 StreamController 的 sink 进行添加，然后通过 StreamController 发送给 Stream，通过 listen 进行监听，listen 会返回一个 StreamSubscription 对象，StreamSubscription 可以操作对数据流的监听，例如 pause，resume，cancel 等。 Stream 分两种类型： Single-subscription Stream：单订阅 stream，整个生命周期只允许有一个监听，如果该监听 cancel 了，也不能再添加另一个监听，而且只有当有监听了，才会发送数据，主要用于文件 IO 流的读取等。 Broadcast Stream：广播订阅 stream，允许有多个监听，当添加了监听后，如果流中有数据存在就可以监听到数据，这种类型，不管是否有监听，只要有数据就会发送，用于需要多个监听的情况。 还是看下例子会比较直观 1234567891011121314151617181920212223242526272829303132333435363738class _StreamHomeState extends State&lt;StreamHome&gt; &#123; StreamController _controller = StreamController(); // 创建单订阅类型 `StreamController` Sink _sink; StreamSubscription _subscription; @override void initState() &#123; super.initState(); _sink = _controller.sink; // _sink 用于添加数据 // _controller.stream 会返回一个单订阅 stream， // 通过 listen 返回 StreamSubscription，用于操作流的监听操作 _subscription = _controller.stream.listen((data) =&gt; print('Listener: $data')); // 添加数据，stream 会通过 `listen` 方法打印 _sink.add('A'); _sink.add(11); _sink.add(11.16); _sink.add([1, 2, 3]); _sink.add(&#123;'a': 1, 'b': 2&#125;); &#125; @override void dispose() &#123; super.dispose(); // 最后要释放资源... _sink.close(); _controller.close(); _subscription.cancel(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: Container(), ); &#125;&#125; 看下控制台的输出： 果然把所有的数据都打印出来了，前面有说过，单订阅的 stream 只有当 listen 后才会发送数据，不试试我还是不相信的，我们把 _sink.add 放到 listen 前面去执行，再看控制台的打印结果。居然真的是一样的，Google 粑粑果然诚不欺我。接着试下 pause，resume 方法，看下数据如何监听，修改代码 123456789_sink = _controller.sink;_subscription = _controller.stream.listen((data) =&gt; print('Listener: $data'));_sink.add('A');_subscription.pause(); // 暂停监听_sink.add(11);_sink.add(11.16);_subscription.resume(); // 恢复监听_sink.add([1, 2, 3]);_sink.add(&#123;'a': 1, 'b': 2&#125;); 再看控制台的打印，你们可以先猜下是什么结果，我猜大部分人都会觉得应该是不会有 11 和 11.16 打印出来了。然鹅事实并非这样，打印的结果并未发生变化，也就是说，调用 pause 方法后，stream 被堵住了，数据不继续发送了。 接下来看下广播订阅 stream，对代码做下修改 1234567891011121314151617181920212223StreamController _controller = StreamController.broadcast(); Sink _sink; StreamSubscription _subscription; @override void initState() &#123; super.initState(); _sink = _controller.sink; _sink.add('A'); _subscription = _controller.stream.listen((data) =&gt; print('Listener: $data')); _sink.add(11); _subscription.pause(); _sink.add(11.16); _subscription.resume(); _sink.add([1, 2, 3]); _sink.add(&#123;'a': 1, 'b': 2&#125;); &#125;// ...&#125; 我们再看下控制台的打印： 你猜对答案了吗，这边做下小总结： 单订阅 Stream 只有当存在监听的时候，才发送数据，广播订阅 Stream 则不考虑这点，有数据就发送；当监听调用 pause 以后，不管哪种类型的 stream 都会停止发送数据，当 resume 之后，把前面存着的数据都发送出去。 sink 可以接受任何类型的数据，也可以通过泛型对传入的数据进行限制，比如我们对 StreamController 进行类型指定 StreamController&lt;int&gt; _controller = StreamController.broadcast(); 因为没有对 Sink 的类型进行限制，还是可以添加除了 int 外的类型参数，但是运行的时候就会报错，_controller 对你传入的参数做了类型判定，拒绝进入。 Stream 中还提供了很多 StremTransformer，用于对监听到的数据进行处理，比如我们发送 0~19 的 20 个数据，只接受大于 10 的前 5 个数据，那么可以对 stream 如下操作 123456_subscription = _controller.stream .where((value) =&gt; value &gt; 10) .take(5) .listen((data) =&gt; print('Listen: $data'));List.generate(20, (index) =&gt; _sink.add(index)); 那么打印出来的数据如下图 除了 where，take 还有很多 Transformer， 例如 map，skip 等等，小伙伴们可以自行研究。了解了 Stream 的基本属性后，就可以继续往下了~ StreamBuilder前面提到了 stream 通过 listen 进行监听数据的变化，Flutter 就为我们提供了这么个部件 StreamBuilder 专门用于监听 stream 的变化，然后自动刷新重建。接着来看下源码 12345678910const StreamBuilder(&#123; Key key, this.initialData, // 初始数据，不传入则为 null Stream&lt;T&gt; stream, @required this.builder &#125;) : assert(builder != null), super(key: key, stream: stream);@overrideAsyncSnapshot&lt;T&gt; initial() =&gt; AsyncSnapshot&lt;T&gt;.withData(ConnectionState.none, initialData); StreamBuilder 必须传入一个 AsyncWidgetBuilder 参数，初始值 initialData 可为空， stream 用于监听数据变化，initial 方法的调用在其父类 StremBuilderBase 中，接着看下 StreamBuilderBaseState 的源码，这里我删除一些不必要的源码，方便查看，完整的源码可自行查看 123456789101112131415161718192021222324252627282930313233343536class _StreamBuilderBaseState&lt;T, S&gt; extends State&lt;StreamBuilderBase&lt;T, S&gt;&gt; &#123; // ... @override void initState() &#123; super.initState(); _summary = widget.initial(); // 通过传入的初始值生成默认值，如果没有传入则会是 null _subscribe(); // 注册传入的 stream，用于监听变化 &#125; // _summary 为监听到的数据 @override Widget build(BuildContext context) =&gt; widget.build(context, _summary); // ... void _subscribe() &#123; if (widget.stream != null) &#123; // stream 通过外部传入，对数据的变化进行监听， // 在不同回调中，通过 setState 进行更新 _summary // 当 _summary 更新后，由于调用了 setState，重新调用 build 方法，将最新的 _summary 传递出去 _subscription = widget.stream.listen((T data) &#123; setState(() &#123; _summary = widget.afterData(_summary, data); &#125;); &#125;, onError: (Object error) &#123; setState(() &#123; _summary = widget.afterError(_summary, error); &#125;); &#125;, onDone: () &#123; setState(() &#123; _summary = widget.afterDone(_summary); &#125;); &#125;); _summary = widget.afterConnected(_summary); // &#125; &#125;&#125; 在之前更新数据都需要通过 setState 进行更新，这里了解完了 stream，我们就不使用 setState 更新，使用 Stream 来更新 1234567891011121314151617181920212223242526272829303132333435363738394041class _StreamHomeState extends State&lt;StreamHome&gt; &#123; // 定义一个全局的 `StreamController` StreamController&lt;int&gt; _controller = StreamController.broadcast(); // `sink` 用于传入新的数据 Sink&lt;int&gt; _sink; int _counter = 0; @override void initState() &#123; super.initState(); _sink = _controller.sink; &#125; @override void dispose() &#123; super.dispose(); // 需要销毁资源 _sink.close(); _controller.close(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, child: StreamBuilder( builder: (_, snapshot) =&gt; Text('$&#123;snapshot.data&#125;', style: TextStyle(fontSize: 24.0)), stream: _controller.stream, // stream 在 StreamBuilder 销毁的时候会自动销毁 initialData: _counter, ), )), // 通过 `sink` 传入新的数据，去通知 `stream` 更新到 builder 中 floatingActionButton: FloatingActionButton( onPressed: () =&gt; _sink.add(_counter++), child: Icon(Icons.add), ), ); &#125;&#125; 那么当点击按钮的时候，就会刷新界面上的值，通过上面的源码分析，StreamBuilder 也是通过 setState 方法进行刷新，那么两种方法孰优孰劣呢，当然是通过 Stream 啦，这不是废话吗。因为通过调用 setState 刷新的话，会把整个界面都进行重构，但是通过 StreamBuilder 的话，只刷新其 builder，这样效率就更高了，最后看小效果吧，所谓有图有真相嘛 这一步，我们摒弃了 setState 方法，那么下一步，我们试试把 StatefulWidget 替换成 StatelessWidget 吧，而且官方也推荐使用 StatelessWidget 替换 StatefulWidget，这里就需要提下 BLoC 模式了。 BLoC说实话，现在 Google 下 「flutter bloc」能搜到很多文章，基本上都是通过 InheritedWidget 来实现的，例如这篇Flutter | 状态管理探索篇——BLoC(三)，但是 InheritedWidget 没有提供 dispose 方法，那么就会存在 StreamController 不能及时销毁等问题，所以，参考了一篇国外的文章，Reactive Programming - Streams - BLoC 这里通过使用 StatefulWidget 来实现，当该部件销毁的时候，可以在其 dispose 方法中及时销毁 StreamController，这里我还是先当个搬运工，搬下大佬为我们实现好的基类 12345678910111213141516171819202122232425262728293031323334353637abstract class BaseBloc &#123; void dispose(); // 该方法用于及时销毁资源&#125;class BlocProvider&lt;T extends BaseBloc&gt; extends StatefulWidget &#123; final Widget child; // 这个 `widget` 在 stream 接收到通知的时候刷新 final T bloc; BlocProvider(&#123;Key key, @required this.child, @required this.bloc&#125;) : super(key: key); @override _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;(); // 该方法用于返回 Bloc 实例 static T of&lt;T extends BaseBloc&gt;(BuildContext context) &#123; final type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;(); // 获取当前 Bloc 的类型 // 通过类型获取相应的 Provider，再通过 Provider 获取 bloc 实例 BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type); return provider.bloc; &#125; static Type _typeOf&lt;T&gt;() =&gt; T;&#125;class _BlocProviderState&lt;T&gt; extends State&lt;BlocProvider&lt;BaseBloc&gt;&gt; &#123; @override void dispose() &#123; widget.bloc.dispose(); // 及时销毁资源 super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return widget.child; &#125;&#125; 接着我们对前面的例子使用 BLoC 进行修改。 首先，我们需要创建一个 Bloc 类，用于修改 count 的值 12345678910111213141516171819class CounterBloc extends BaseBloc &#123; int _count = 0; int get count =&gt; _count; // stream StreamController&lt;int&gt; _countController = StreamController.broadcast(); Stream&lt;int&gt; get countStream =&gt; _countController.stream; // 用于 StreamBuilder 的 stream void dispatch(int value) &#123; _count = value; _countController.sink.add(_count); // 用于通知修改值 &#125; @override void dispose() &#123; _countController.close(); // 注销资源 &#125;&#125; 在使用 Bloc 前，需要在最上层的容器中进行注册，也就是 MaterialApp 中 1234567891011121314151617181920212223242526272829303132333435363738394041void main() =&gt; runApp(StreamApp());class StreamApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // 这里对创建的 bloc 类进行注册，如果说有多个 bloc 类的话，可以通过 child 进行嵌套注册即可 // 放在最顶层，可以全局调用，当 App 关闭后，销毁所有的 Bloc 资源， // 也可以在路由跳转的时候进行注册，至于在哪里注册，完全看需求 // 例如实现主题色的切换，则需要在全局定义，当切换主题色的时候全局切换 // 又比如只有某个或者某几个特殊界面调用，那么完全可以通过在路由跳转的时候注册 return BlocProvider( child: MaterialApp( debugShowCheckedModeBanner: false, home: StreamHome(), ), bloc: CounterBloc()); &#125;&#125;class StreamHome extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // 获取注册的 bloc，必须先注册，再去查找 final CounterBloc _bloc = BlocProvider.of&lt;CounterBloc&gt;(context); return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, child: StreamBuilder( initialData: _bloc.count, stream: _bloc.countStream, builder: (_, snapshot) =&gt; Text('$&#123;snapshot.data&#125;', style: TextStyle(fontSize: 20.0)), ), )), floatingActionButton: // 通过 bloc 中的 dispatch 方法进行值的修改，通知 stream 刷新界面 FloatingActionButton(onPressed: () =&gt; _bloc.dispatch(_bloc.count + 1), child: Icon(Icons.add)), ); &#125;&#125; 重新运行后，查看效果还是一样的。所以我们成功的对 StatefulWidget 进行了替换 再继续讲之前，先总结下 Bloc ​ 1. 成功的把页面和逻辑分离开了，页面只展示数据，逻辑通过 BLoC 进行处理 ​ 2. 减少了 setState 方法的使用，提高了性能 ​ 3. 实现了状态管理 RxDart因为上面的参考文章中提到了 RxDart，个人觉得有必要了解下，当然目前也有很多文章介绍 RxDart，所以我就讲下和 BLoC 有点关系的部分吧。RxDart 需要通过引入插件的方式引入(rxdart: ^0.21.0) 如果需要查看详细的内容，我这里提供几篇文章链接 RxDart 文档 RxDart: Magical transformations of Streams 其实 RxDart 就是对 Stream 的进一步分装，RxDart 提供了三种 Subject，其功能类似 Stream 中的单订阅 stream 和 广播 stream。 PublishSubject 123/// PublishSubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. 通过注释可以发现 PuslishSubject 不可被多次订阅，尽管实现是通过 StreamController&lt;T&gt;.broadcast 方式实现，其实三种都是通过 broadcast 方式实现的，所以实现的功能就是类似 Single-subscription Stream 的功能。 BehaviorSubject 123/// BehaviorSubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. BehaviorSubject 可以被多次订阅，那么这个就是实现了 Broadcast Stream 功能。 ReplaySubject 123/// ReplaySubject is, by default, a broadcast (aka hot) controller, in order/// to fulfill the Rx Subject contract. This means the Subject's `stream` can/// be listened to multiple times. ReplaySubject 其实也是实现 Broadcast Stream 功能，那么它和 BehaviorSubject 的区别在哪呢，别急，等我慢慢讲。 123/// As items are added to the subject, the ReplaySubject will store them./// When the stream is listened to, those recorded items will be emitted to/// the listener. 当有数据添加了，但是还没有监听的时候，它会将数据存储下来，等到有监听了，再发送出去，也就是说，ReplaySubject 实现了 Brodacast Stream 的多订阅功能，同时也实现了 Single-subscription Stream 的存储数据的功能，每次添加了新的监听，都能够获取到全部的数据。当然，这还不是它的全部功能，它还可以设置最大的监听数量，会只监听最新的几个数据，在注释中，提供了这么两个例子，可以看下 1234567891011121314151617181920212223/// ### Example ////// final subject = new ReplaySubject&lt;int&gt;();////// subject.add(1);/// subject.add(2);/// subject.add(3);////// subject.stream.listen(print); // prints 1, 2, 3/// subject.stream.listen(print); // prints 1, 2, 3/// subject.stream.listen(print); // prints 1, 2, 3////// ### Example with maxSize////// final subject = new ReplaySubject&lt;int&gt;(maxSize: 2); // 实现监听数量限制////// subject.add(1);/// subject.add(2);/// subject.add(3);////// subject.stream.listen(print); // prints 2, 3/// subject.stream.listen(print); // prints 2, 3/// subject.stream.listen(print); // prints 2, 3 那么我们可以使用 RxDart 对前面使用 Stream 实现的例子进行替换，最简单的其实只需要使用 BehaviorSubject 替换 StreamController.broadcast() 就可以了，别的都不需要变化。但是 RxDart 有自己的变量，还是按照 RxDart 的方式来 1234567891011121314// 继承自 StreamController，所以 StreamController 拥有的属性都有BehaviorSubject&lt;int&gt; _countController = BehaviorSubject();// StreamController&lt;int&gt; _countController = StreamController.broadcast();// 继承自 Stream，所以这里直接用之前 stream 的写法也没问题，但是这样就有点不 RxDart 了Observable&lt;int&gt; get countStream =&gt; Observable(_countController.stream);// Stream&lt;int&gt; get countStream =&gt; _countController.stream;void dispatch(int value) &#123; _count = value; // 直接提供了 add 方法，不需要通过 sink 来添加 _countController.add(_count);// _countController.sink.add(_count);&#125; 再次运行还是能过实现相同的效果。如果说要在 RxDart 和 Stream 两种实现方式中选择一种，个人更偏向于 RxDart，因为它对 Stream 进行了进一步的封装，提供了更多更方便的数据转换方法，而且链式的写法真的很舒服，用过了就停不下来，具体的方法介绍可以参考上面提供的链接。 Provide说实话自己封装 BLoC 来实现分离逻辑和界面，相对还是有点难度的，这边可以通过第三方来实现，这边推荐 Google 粑粑的库，flutter_provide，看下官方对关键部件和静态方法的介绍 Provide&lt;T&gt; - Widget used to obtain values from a ProviderNode higher up in the widget tree and rebuild on change. The Provide&lt;T&gt;widget should only be used with Streams or Listenables. Equivalent to ScopedModelDescendant in ScopedModel Provide.value&lt;T&gt; - Static method used to get a value from a ProviderNode using the BuildContext. This will not rebuild on change. Similar to manually writing a static .of() method for an InheritedWidget. Provide.stream&lt;T&gt; - Static method used to get a Stream from a ProviderNode. Only works if either T is listenable, or if the Providercomes from a Stream. Provider&lt;T&gt; - A class that returns a typed value on demand. Stored in a ProviderNode to allow retrieval using Provide. ProviderNode - The equivalent of the ScopedModel widget. Contains Providers which can be found as an InheritedWidget. Provide 这个部件主要用于从上层的 ProvideNode 中获取值，当变化的时候刷新重建，只能同 Stream 和 Listenable 一同使用，类似于 ScopeMode 中的 ScopedModelDescendant。(这个部件放在需要状态管理的部件的上层，例如有个 Text 需要修改状态，那么就需要在外层提供一个 Provide 部件，通过内部 builder 参数返回 Text 部件) Provide.value 是个静态方法，用于从 ProvideNode 获取值，但是当接收的值改变的时候不会重建。类似于 InheritedWidget 的静态方法 of。(这个方法用于获取指定类型的 provide，每个 provide 都需要提供一个数据类，该类 with ChangeNotifier，当数据变化的时候通过 notifyListeners 通知 provide 变化，进行刷新重建) Provide.stream 是个静态方法，用于从 ProvideNode 获取一个 stream，仅在 T 可被监听，或者 Provide 来自 stream 的情况下有效。(这个通常结合 StreamBuilder 使用，StreamBuilder 在上面已经提到，就不多说了) Provider 按需要的类型返回相关值的类，存储在 ProviderNode 中方便 Provide 进行检索。(这个类主要是将我们自己创建的数据类通过 function 等方法转换成 Provider，并在 Providers 中进行注册) ProvideNode 类似于 ScopedModel 的一个部件，包含所有能被查找的 Providers。(这个需要放在顶层，方便下面的容器进行查找 provider，刷新相应的部件，一般放在 MaterialApp 上层) 这边再补充一个个人觉得关键的类 Providers，这个类主要用于存储定义的 Provider，主要是在建立 MaterialApp 的时候将需要用到的 Provider 通过 provide 方法添加进去存储起来，然后在 ProvideNode 中注册所有的 provider 方便下层容器获取值，并调用。 说那么多，还不如直接看个例子直接，代码来了~，首先需要建立一个类似 BLoC 中监听数据变化的 counter_bloc 类的数据管理类，我们这边定义为 count_provider 需要混入 ChangeNotifier 类 12345678910class CountProvider with ChangeNotifier &#123; int _value = 0; // 存储的数据，也是我们需要管理的状态值 int get value =&gt; _value; // 获取状态值 void changeValue(int value) &#123; _value = value; notifyListeners(); // 当状态值发生变化的时候，通过该方法刷新重建部件 &#125;&#125; 然后需要将定义的类注册到全局的 Providers 中 12345678910void main() &#123; final providers = Providers() // 将我们创建的数据管理类，通过 Provider.function 方法转换成 Provider， // 然后添加到 Providers 中 ..provide(Provider.function((_) =&gt; CountProvider())); // 在 App 上层，通过包裹一层 ProvideNode，并将我们生成的 Providers 实例 // 注册到 ProvideNode 中去，这样整个 App 都可以通过 Provide.value 查找相关的 Provider // 找到 Provider 后就可以找到我们的数据管理类 runApp(ProviderNode(child: StreamApp(), providers: providers));&#125; 接着就是替换我们的界面实现了，前面通过 BLoC 实现，这里替换成 Provide 来实现 123456789101112131415161718192021class StreamHome extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, // 通过指定类型，获取特定的 Provide，这个 Provide 会返回我们的数据管理类 provider // 通过内部定义的方法，获取到需要展示的值 child: Provide&lt;CountProvider&gt;(builder: (_, widget, provider) =&gt; Text('$&#123;provider.value&#125;')), )), floatingActionButton: FloatingActionButton( onPressed: () =&gt; // 通过 value 方法获取到我们的数据管理类 provider， // 通过调用改变值的方法，修改内部的值，并通知界面刷新重建 Provide.value&lt;CountProvider&gt;(context).changeValue( Provide.value&lt;CountProvider&gt;(context).value + 1), child: Icon(Icons.add)) ); &#125;&#125; 本文代码查看 bloc 包名下的所有文件，需要单独运行 stream_main.dart 文件 最后运行后还是一样的效果，也摒弃了 StatefulWidget 部件和 SetState 方法，实现了逻辑和界面分离。但是 Provide 最终还是通过 InheritedWidget 来实现，当然在资源方面 Google 的大佬们做了一些相关的处理，至于如何处理，这边就不多说了。目前 provide 的这个库还存在一点争议的地方，具体查看 issue#3，但是目前来看并没有太大的影响。当然你不放心的话，可以使用 Scoped_model 或者上面的 Bloc 模式，Google 在文档也有相关的注明 If you must choose a package today, it’s safer to go with package:scoped_model than with this package. 这篇概念性的比较多，但是等理解了以后，对于以后的开发还是非常有利的。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(十)之手势处理和动画]]></title>
    <url>%2Fposts%2Fd4756fd3.html</url>
    <content type="text"><![CDATA[在 Flutter 中，自带手势监听的目前为止好像只有按钮部件和一些 chip 部件，例如 Text 等部件需要实现手势监听，就需要借助带有监听事件的部件来实现了，这节我们会讲下 InkWell 和 GestureDetector 来实现手势的监听。 InkWell在前面的一些例子中，小伙伴应该看到了好几次 InkWell 这个部件，通过它我们可以实现对一些手势的监听，并实现 MD 的水波纹效果，举个简单的一个例子 1234InkWell( child: Text('点我...点我...我能响应点击手势'), onTap: () =&gt; print('啊...我被点击了...')), 那么当点击 Text 的时候就会响应点击事件，控制台输出日志 我们还是老套路，分析下源码。Ctrl 点击 InkWell 来查看源码(Android Studio 的操作，别的我不懂喔…)，然后，「嗯…除了构造函数怎么什么都没有？？？」那只能看它的父类 InkResponse 了，在那之前，我们看下 InkWell 的说明 12&gt; /// A rectangular area of a [Material] that responds to touch.&gt; InkWell 是在 MaterialDesign 风格下的一个用来响应触摸的矩形区域（注意加粗的文字，1.如果不是 MD 风格的部件下，你是不能用这个来做点击响应的；2.InkWell 是一块矩形区域，如果你要的是圆形区域，8 好意思，不行！） 1234&gt; /// The [InkWell] widget must have a [Material] widget as an ancestor. The&gt; /// [Material] widget is where the ink reactions are actually painted. This&gt; /// matches the material design premise wherein the [Material] is what is&gt; /// actually reacting to touches by spreading ink. 123456789101112131415161718192021222324252627282930313233343536373839`InkWell` 必须要有一个 `Material` 风格的部件作为锚点，巴拉巴拉巴拉....再次强调必须要在 `MD` 风格下使用。接下来看下 `InkResponse` 吧#### InkResponse```dartconst InkResponse(&#123; Key key, this.child, // 需要监听的子部件 // 一个 `GestureTapCallback` 类型参数，看下 `GestureTapCallback` 的定义, // `typedef GestureTapCallback = void Function();` 就是简单的无参无返回类型参数 // 监听手指点击事件 this.onTap, // 一个 `GestureTapDownCallback` 类型参数，需要 `TapDownDetails` 类型参数， // `TapDownDetails` 里面有个 `Offset` 参数用于记录点击的位置，监听手指点击屏幕的事件 this.onTapDown, // 同 `onTap` 表示点击事件取消监听 this.onTapCancel, // 同 `onTap` 表示双击事件监听 this.onDoubleTap, // 一个 `GestureLongPressCallback` 类型参数，也是无参无返回值，表示长按的监听 this.onLongPress, // 监听高亮的变化，返回 `true` 表示往高亮变化，`false` 相反 this.onHighlightChanged, // 是否需要裁剪区域，`InkWell` 该值为 `true`，会根据 `highlightShape` 裁剪 this.containedInkWell = false, // 高亮的外形，`InkWell` 该值设置成 `BoxShape.rectangle`，所以是个矩形区域 this.highlightShape = BoxShape.circle, this.radius, // 手指点下去的时候，出现水波纹的半径 this.borderRadius, // 点击时候外圈阴影的圆角半径 this.customBorder, this.highlightColor, // 高亮颜色 this.splashColor, // 手指点下生成的水波颜色 this.splashFactory, // 两个值 `InkRipple.splashFactory` 和 `InkSplash.splashFactory` this.enableFeedback = true, // 检测到手势是否有反馈 this.excludeFromSemantics = false, &#125;) 所以一些简单的触摸事件直接通过 InkWell 或者 InkResponse 就能够实现，但是面临一些比较复杂的手势，就有点不太够用了，我们需要通过 GestureDector 来进行处理 GestureDectorGestureDetector 也是一个部件，主要实现对各种手势动作的监听，其监听事件查看下面的表格 回调方法 回调描述 onTapDown 点击屏幕的手势触碰到屏幕时候触发 onTapUp 点击屏幕抬手后触发，点击结束 onTap 点击事件已经完成的时候触发，和 onTapUp 几乎同时 onTapCancel 点击未完成，被其它手势取代的时候触发 onDoubleTap 双击屏幕的时候触发 onLongPress 长按屏幕的时候触发 onLongPressUp 长按屏幕后抬手触发 onVerticalDragDown 触碰到屏幕，可能发生垂直方向移动触发，onVerticalDrag 系列事件不会同 onHorizontalDrag 系列事件同时发生 ，如果发生了 onVerticalDrag 则接下来如何变化移动，都不会触发 onHorizontalDrag 事件，除非取消后重新触发。判断两者的关键是准备滑动的意图，先发生横向滑动则触发 onHorizontalDrag 事件，否则 onVerticalDrag 事件。 onVerticalDragStart 触碰到屏幕，并开始发生垂直方向的移动触发 onVerticalDragUpdate 垂直方向移动的距离变化触发 onVerticalDragEnd 抬手取消垂直方向移动的时候触发 onVerticalDragCancel 触发 onVerticalDragDown 但是没有完成整个 onVerticalDrag 事件触发 onHorizontalDrag 系列介绍省略同上… onPanDown 触碰到屏幕，准备滑动的时候触发，onPan 系列回调不可和 onVerticalDrag 或者 onHorizontalDrag 系列回调同时设置 onPanStart 触碰到屏幕，并开始滑动时候触发 onPanUpdate 滑动位置发生改变的时候触发 onPanEnd 滑动完成并抬手的时候触发 onPanCancel 触发 onPanDown 但是没有完成整个 onPan 事件触发 onScaleStart 两个手指之间建立联络点触发，初始缩放比例为 1.0 onScaleUpdate 手指距离发生变化，缩放比例也跟随变化触发 onScaleEnd 手指抬起，至间的联络断开时候触发 还有 onForcePress 系列事件，这个是根据对屏幕的挤压力度进行触发，需要达到某些定值才能触发。GestureDetector 有个 behavior 属性用于设置手势监听过程中的表现形式 deferToChild 默认值，触摸到 child 的范围才会触发手势，空白处不会触发 opaque 不透明模式，防止 background widget 接收到手势 translucent 半透明模式，刚好同 opaque 相反，允许 background widget 接收到手势 介绍完了手势，那就可以实际操练起来了，比如，实现一个跟随手指运动的小方块，先看下效果图 简单的分析下，通过 Positioned 来设置小方块的位置，根据 GestureDetector 的 onPanUpdate 修改 Positioned 的 left 和 top 值，当 onPanEnd 或者 onPanCancel 的时候设置为原点，那么就可以有如图的效果了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class GestureDemoPage extends StatefulWidget &#123; @override _GestureDemoPageState createState() =&gt; _GestureDemoPageState();&#125;class _GestureDemoPageState extends State&lt;GestureDemoPage&gt; &#123; double left = 0.0; double top = 0.0; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Gesture Demo'), ), body: Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ Positioned(child: Container(width: 50.0, height: 50.0, color: Colors.red), left: left, top: top), GestureDetector( behavior: HitTestBehavior.translucent, child: Container( color: Colors.transparent, width: MediaQuery.of(context).size.width - 10, height: MediaQuery.of(context).size.height), onPanDown: (details) &#123; setState(() &#123; left = details.globalPosition.dx; top = details.globalPosition.dy; &#125;); &#125;, onPanUpdate: (details) &#123; setState(() &#123; left = details.globalPosition.dx; top = details.globalPosition.dy; &#125;); &#125;, onPanCancel: () &#123; setState(() &#123; left = 0.0; top = 0.0; &#125;); &#125;, onPanEnd: (details) &#123; setState(() &#123; left = 0.0; top = 0.0; &#125;); &#125;, ) ], )); &#125;&#125; 如果说要实现一个放大缩小的方块，就可以通过 onScaleUpdate 中获取到的 details.scale 来设置方块的宽高即可。这个比较简单就留给小伙伴们自己实现效果了。 该部分代码查看 gesture_main.dart 文件 Animation 动画Flutter 的 Animation 是个抽象类，具体的实现需要看其子类 AnimationController，在这之前，先了解下 Animation 的一些方法和介绍。 addListener / removeListener 添加的监听用于监听值的变化，remove 用于停止监听 addStatusListener / removeStatusListener 添加动画状态变化的监听，remove 停止监听，Animation 的状态有 4 种：dismissed 动画初始状态，反向运动结束状态，forward 动画正向运动状态，reverse 动画反向运动状态，completed 动画正向运动结束状态。 drive 方法用于连接动画，例如官方举的例子，因为 AnimationController 是其子类，所以也拥有该方法 123456Animation&lt;Alignment&gt; _alignment1 = _controller.drive( AlignmentTween( begin: Alignment.topLeft, end: Alignment.topRight, ), ); 上面的例子将 AnimationController 和 AlignmentTween 结合成一个 Animation&lt;Alignment&gt; 动画，当然 drive 可以结合多个动画，例如 123456Animation&lt;Alignment&gt; _alignment3 = _controller .drive(CurveTween(curve: Curves.easeIn)) .drive(AlignmentTween( begin: Alignment.topLeft, end: Alignment.topRight, )); 因为 Animation 是抽象类，所以具体的还是需要通过 AnimationController 来实现。 AnimationController123456789101112AnimationController(&#123; double value, // 设置初始的值 this.duration, // 动画的时长 this.debugLabel, // 主要是用于 `toString` 方法中输出信息 this.lowerBound = 0.0, // 最小范围 this.upperBound = 1.0, // 最大范围 // AnimationController 结束时候的行为，有 `normal` 和 `preserve` 两个值可选 this.animationBehavior = AnimationBehavior.normal, // 这个属性可以通过 with `SingleTickerProviderStateMixin` // 或者 `TickerProviderStateMixin` 引入到 `State`，通过 `this` 指定 @required TickerProvider vsync, &#125;) AnimationController 控制动画的方法有这么几个 forward 启动动画，和上面提到的 forward 状态不一样 reverse 方向启动动画 repeat 重复使动画运行 stop 停止动画 reset 重置动画 大概了解了 AnimationController ，接下来通过一个实际的小例子来加深下印象，例如实现如下效果，点击开始动画，结束后再点击反向动画 123456789101112131415161718192021222324252627282930313233343536373839404142class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; @override void initState() &#123; super.initState(); _animationController = AnimationController( vsync: this, duration: Duration(milliseconds: 1000), lowerBound: 28.0, upperBound: 50.0); // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); &#125; @override void dispose() &#123; // 一定要释放资源 _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Center( child: IconButton( icon: Icon(Icons.android, color: Colors.green[500], size: _animationController.value), onPressed: () &#123; // 根据状态执行不同动画运动方式 if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;), ), ); &#125;&#125; 那么如果要实现无限动画呢，那就可以通过 addStatusListener 监听动画的状态来执行，修改代码，在 initState 增加如下代码 12345678_animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); // 正向结束后开始反向 else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); // 反向结束后开始正向 &#125;); _animationController.forward(); // 启动动画 把 Center 的 child 替换成一个 Icon，因为上面已经启动了动画，所以不需要再用点击去启动了，运行后就会无限放大缩小循环跑了。 在这个例子中，通过设置 AnimationController 的 lowerBound 和 upperBound 实现了动画的变化范围，接下来，将通过 Tween 来实现动画的变化范围。先看下 Tween 的一些介绍。 Tween 1234567891011121314&gt; /// A linear interpolation between a beginning and ending value.&gt; ///&gt; /// [Tween] is useful if you want to interpolate across a range.&gt; ///&gt; /// To use a [Tween] object with an animation, call the [Tween] object's&gt; /// [animate] method and pass it the [Animation] object that you want to&gt; /// modify.&gt; ///&gt; /// You can chain [Tween] objects together using the [chain] method, so that a&gt; /// single [Animation] object is configured by multiple [Tween] objects called&gt; /// in succession. This is different than calling the [animate] method twice,&gt; /// which results in two separate [Animation] objects, each configured with a&gt; /// single [Tween].&gt; Tween 是一个线性插值(如果要修改运动的插值，可以通过 CurveTween 来修改)，所以在线性变化的时候很有用 通过调用 Tween 的 animate 方法生成一个 Animation(animate 一般传入 AnimationController) 还可以通过 chain 方法将多个 Tween 结合到一起，这样就不需要多次去调用 Tween 的 animate 方法来生成动画了，多次调用 animate 相当于使用了两个分开的动画来完成效果，但是 chain 结合到一起就是一个动画过程 那么对前面的动画进行一些修改，通过 Tween 来控制值的变化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; Animation _scaleAnimation; // 动画实例，用于修改值的大小 @override void initState() &#123; super.initState(); _animationController = AnimationController(vsync: this, duration: Duration(milliseconds: 1000)); // 不通过 `lowerBound` 和 `upperBound` 设置范围，改用 `Tween` // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); _animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;); // 通过 `Tween` 的 `animate` 生成一个 Animation // 再通过 Animation.value 进行值的修改 _scaleAnimation = Tween(begin: 28.0, end: 50.0).animate(_animationController); _animationController.forward(); &#125; @override void dispose() &#123; // 一定要释放资源 _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Center( // 通过动画返回的值，修改图标的大小 child: Icon(Icons.favorite, color: Colors.red, size: _scaleAnimation.value), ), ); &#125;&#125; 再次运行，还是能过达到之前的效果，那么很多小伙伴肯定会问了，「**，加了那么多代码，效果还是和以前的一样，还不如不加…」好吧，我无法反驳，但是如果要实现多个动画呢，那么使用 Tween 就有优势了，比如我们让图标大小变化的同时，颜色和位置也发生变化，只通过 AnimationController 要怎么实现? 又比如说，运动的方式要先加速后减速，那只通过 AnimationController 要如何实现？这些问题通过 Tween 就会非常方便解决，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class _AnimationDemoPageState extends State&lt;AnimationDemoPage&gt; with TickerProviderStateMixin &#123; AnimationController _animationController; Animation _scaleAnimation; // 用于控制图标大小 Animation&lt;Color&gt; _colorAnimation; // 控制图标颜色 Animation&lt;Offset&gt; _positionAnimation; // 控制图标位置 @override void initState() &#123; super.initState(); _animationController = AnimationController(vsync: this, duration: Duration(milliseconds: 2000)); // 当动画值发生变化的时候，重绘下 icon _animationController.addListener(() &#123; setState(() &#123;&#125;); &#125;); _animationController.addStatusListener((status) &#123; if (_animationController.status == AnimationStatus.completed) _animationController.reverse(); else if (_animationController.status == AnimationStatus.dismissed) _animationController.forward(); &#125;); // 通过 `chain` 结合 `CurveTween` 修改动画的运动方式，曲线类型可自行替换 _scaleAnimation = Tween(begin: 28.0, end: 50.0).chain(CurveTween(curve: Curves.decelerate)).animate(_animationController); _colorAnimation = ColorTween(begin: Colors.red[200], end: Colors.red[900]) .chain(CurveTween(curve: Curves.easeIn)) .animate(_animationController); _positionAnimation = Tween(begin: Offset(100, 100), end: Offset(300, 300)) .chain(CurveTween(curve: Curves.bounceInOut)) .animate(_animationController); _animationController.forward(); // 启动动画 &#125; @override void dispose() &#123; _animationController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Animation Demo'), ), body: Stack( children: &lt;Widget&gt;[ Positioned( child: Icon(Icons.favorite, color: _colorAnimation.value, size: _scaleAnimation.value), left: _positionAnimation.value.dx, top: _positionAnimation.value.dy, ) ], ), ); &#125;&#125; 那么最后的效果图 当然，Flutter 中已经实现的 Tween 还有很多，包括 BorderTween、TextStyleTween、ThemeDataTween ..等等，实现的方式都是类似的，小伙伴们可以自己慢慢看。 AnimationWidget在上面的例子中，都是通过 addListener 监听动画值变化，然后通过 setState 方法来实现刷新效果。那么 Flutter 也提供了一个部件 AnimationWidget 来实现动画部件，就不需要一直监听了，还是实现上面的例子 1234567891011121314151617181920212223242526class RunningHeart extends AnimatedWidget &#123; final List&lt;Animation&gt; animations; // 传入动画列表 final AnimationController animationController; // 控制动画 RunningHeart(&#123;this.animations, this.animationController&#125;) // 对传入的参数进行限制(当然你也可以不做限制) : assert(animations.length == 3), assert(animations[0] is Animation&lt;Color&gt;), assert(animations[1] is Animation&lt;double&gt;), assert(animations[2] is Animation&lt;Offset&gt;), super(listenable: animationController); @override Widget build(BuildContext context) &#123; return Stack( children: &lt;Widget&gt;[ Positioned( // 之前的 animation 都通过 animations 参数传入到 `AnimationWidget` child: Icon(Icons.favorite, color: animations[0].value, size: animations[1].value), left: animations[2].value.dx, top: animations[2].value.dy, ) ], ); &#125;&#125; 其实内部返回的部件和前面的是一样的 接着对 _AnimationDemoPageState 类进行修改，注释 initState 中的 _animationController.addListener 所有内容，然后将 body 属性替换成新建的 RunningHeart 部件，记得传入的动画列表的顺序 1234body: RunningHeart( animations: [_colorAnimation, _scaleAnimation, _positionAnimation], animationController: _animationController, ) 这样就实现了刚才一样的效果，并且没有一直调用 setState 来刷新。 该部分代码查看 animation_main.dart 文件 StaggeredAnimationsFlutter 还提供了交错动画，听名字就可以知道，是按照时间轴，进行不同的动画，并且由同个AnimationController 进行控制。因为没有找到好的例子，原谅我直接搬官方的例子来讲，官方交错动画 demo 在继续看之前，先了解下 Interval 12345&gt; /// An [Interval] can be used to delay an animation. For example, a six second&gt; /// animation that uses an [Interval] with its [begin] set to 0.5 and its [end]&gt; /// set to 1.0 will essentially become a three-second animation that starts&gt; /// three seconds later.&gt; Interval 用来延迟动画，例如一个时长 6s 的动画，通过 Interval 设置其 begin 参数为 0.5，end 参数设置为 1.0，那么这个动画就会变成 3s 的动画，并且开始的时间延迟了 3s。 了解 Interval 功能后，就可以看下实例了，当然我们不和官方的 demo 一样，中间加个旋转动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class StaggeredAnim extends StatelessWidget &#123; final AnimationController controller; final Animation&lt;double&gt; opacity; final Animation&lt;double&gt; width; final Animation&lt;double&gt; height; final Animation&lt;EdgeInsets&gt; padding; final Animation&lt;BorderRadius&gt; border; final Animation&lt;Color&gt; color; final Animation&lt;double&gt; rotate; StaggeredAnim(&#123;Key key, this.controller&#125;): // widget 透明度 opacity = Tween(begin: 0.0, end: 1.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.0, 0.1, curve: Curves.ease))), // widget 宽 width = Tween(begin: 50.0, end: 150.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.1, 0.250, curve: Curves.ease))), // widget 高 height = Tween(begin: 50.0, end: 150.0) .animate(CurvedAnimation(parent: controller, curve: Interval(0.25, 0.375, curve: Curves.ease))), // widget 底部距离 padding = EdgeInsetsTween(begin: const EdgeInsets.only(top: 150.0), end: const EdgeInsets.only(top: .0)) .animate(CurvedAnimation(parent: controller, curve: Interval(0.25, 0.375, curve: Curves.ease))), // widget 旋转 rotate = Tween(begin: 0.0, end: 0.25) .animate(CurvedAnimation(parent: controller, curve: Interval(0.375, 0.5, curve: Curves.ease))), // widget 外形 border = BorderRadiusTween(begin: BorderRadius.circular(5.0), end: BorderRadius.circular(75.0)) .animate(CurvedAnimation(parent: controller, curve: Interval(0.5, 0.75, curve: Curves.ease))), // widget 颜色 color = ColorTween(begin: Colors.blue, end: Colors.orange) .animate(CurvedAnimation(parent: controller, curve: Interval(0.75, 1.0, curve: Curves.ease))), super(key: key); Widget _buildAnimWidget(BuildContext context, Widget child) &#123; return Container( padding: padding.value, alignment: Alignment.center, // 旋转变化 child: RotationTransition( turns: rotate, // turns 表示当前动画的值 * 360° 角度 child: Opacity( opacity: opacity.value, // 透明度变化 child: Container( width: width.value, // 宽度变化 height: height.value, // 高度变化 decoration: BoxDecoration( color: color.value, // 颜色变化 border: Border.all(color: Colors.indigo[300], width: 3.0), borderRadius: border.value), // 外形变化 ), ), ), ); &#125; @override Widget build(BuildContext context) &#123; // AnimatedBuilder 继承 AnimationWidget，用来快速构建动画部件 return AnimatedBuilder(animation: controller, builder: _buildAnimWidget); &#125;&#125; 然后修改 body 的参数，设置成我们的动画，当点击的时候就会启动动画 1234567891011121314GestureDetector( behavior: HitTestBehavior.opaque, onTap: _playAnim, child: Center( // 定义一个外层圈，能够使动画显眼点 child: Container( width: 300, height: 300, decoration: BoxDecoration( color: Colors.black.withOpacity(0.1), border: Border.all(color: Colors.black.withOpacity(0.5))), child: StaggeredAnim(controller: _controller), ), ), ) 看下最后的效果吧 该部分代码查看 staggered_animation_main.dart 文件 结束前，我们再讲一种比较简单的 Hreo 动画，用来过渡用。 Hero通过指定 Hero 中的 tag，在切换的时候 Hero 会寻找相同的 tag，并实现动画，具体的实现逻辑，这里可以推荐一篇文章 谈一谈Flutter中的共享元素动画Hero，里面写的很详细，就不造车轮了。当然这边还是得提供个简单的 demo 的，替换前面的 body 参数 12345678910body: Container( alignment: Alignment.center, child: InkWell( child: Hero( tag: 'hero_tag', // 这里指定 tag child: Image.asset('images/ali.jpg', width: 100.0, height: 100.0), ), onTap: () =&gt; Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; HeroPage())), ), ) 然后创建 HeroPage 界面，当然也可以是个 Dialog，只要通过路由实现即可 1234567891011121314class HeroPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Container( alignment: Alignment.center, child: InkWell( child: Hero(tag: 'hero_tag', child: Image.asset('images/ali.jpg', width: 200.0, height: 200.0)), onTap: () =&gt; Navigator.pop(context), ), ), ); &#125;&#125; 看下最后的效果图： 该部分代码查看 animation_main.dart 文件 这一部分讲的比较多，小伙伴可以慢慢消化，下节我会尽量填下之前留下的状态管理的坑。 最后代码的地址还是要的： 文章中涉及的代码：demos 基于郭神 cool weather 接口的一个项目，实现 BLoC 模式，实现状态管理：flutter_weather 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：flutter_shop]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(九)之弹窗和提示(SnackBar、BottomSheet、Dialog)]]></title>
    <url>%2Fposts%2F5da6faeb.html</url>
    <content type="text"><![CDATA[前面的小节把常用的一些部件都介绍了，这节介绍下 Flutter 中的一些操作提示。Flutter 中的操作提示主要有这么几种 SnackBar、BottomSheet、Dialog，因为 Dialog 样式比较多，放最后讲好了 SnackBarSnackBar 的源码相对简单 12345678const SnackBar(&#123; Key key, @required this.content, // 提示信息 this.backgroundColor, // 背景色 this.action, // SnackBar 尾部的按钮，用于一些回退操作等 this.duration = _kSnackBarDisplayDuration, // 停留的时长，默认 4000ms this.animation, // 进出动画 &#125;) 例如我们需要实现一个功能，修改某个值，修改后给用户一个提示，同时给用户一个撤销该操作的按钮，那么就可以通过 SnackBar 来简单实现。还有就是 SnackBar 可以和 floatingActionButton 完美的配合，弹出的时候不会遮挡住 fab 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class _PromptDemoPageState extends State&lt;PromptDemoPage&gt; &#123; var count = 0; @override void initState() &#123; super.initState(); &#125; @override void dispose() &#123; super.dispose(); &#125; // 自增操作 increase() &#123; setState(() =&gt; count++); &#125; // 自减操作 decrease() &#123; setState(() =&gt; count--); &#125; _changeValue(BuildContext context) &#123; increase(); Scaffold.of(context).showSnackBar(SnackBar( content: Text('当前值已修改'), action: SnackBarAction(label: '撤销', onPressed: decrease), duration: Duration(milliseconds: 2000))); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Prompt Demo'), ), body: Column(children: &lt;Widget&gt;[ Text('当前值：$count', style: TextStyle(fontSize: 20.0)), Expanded( // 为了方便拓展，我这边提取了 `snackBar` 的方法，并把按钮放在列表 child: ListView(padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ // SnackBar 需要提供一个包含 context，但是 context 不能是 Scaffold 节点下的 context，所以需要通过 Builder 包裹一层 Builder(builder: (context) =&gt; RaisedButton(onPressed: () =&gt; _changeValue(context), child: Text('修改当前值'))), ])) ]), // 当 SnackBar 弹出时，fab 会上移一段距离 floatingActionButton: Builder( builder: (context) =&gt; FloatingActionButton(onPressed: () =&gt; _changeValue(context), child: Icon(Icons.send))), ); &#125;&#125; 可以看下最后的效果图，请注意看 fab 和值的变化： BottomSheetBottomSheet 看命名就知道是从底部弹出的菜单，展示 BottomSheet 有两种方式，分别是 showBottomSheet 和 showModalBottomSheet，两种方式只有在展示类型上的差别，方法调用无差，而且 showBottomSheet 和 fab 有组合动画，showModalBottomSheet 则没有，看下实际的例子吧。在 ListView 中增加一个 BottomSheet 的按钮，因为 BottomSheet 需要的 context 也不能是 Scaffold 下的 context，所以需要通过 Builder 进行包裹一层，然后增加 _showBottomSheet 的方法 12345678910111213141516_showBottomSheet(BuildContext context) &#123; showBottomSheet( context: context, builder: (context) =&gt; ListView( // 生成一个列表选择器 children: List.generate( 20, (index) =&gt; InkWell( child: Container(alignment: Alignment.center, height: 60.0, child: Text('Item $&#123;index + 1&#125;')), onTap: () &#123; print('tapped item $&#123;index + 1&#125;'); Navigator.pop(context); &#125;), )), ); &#125; 把 showBottomSheet 替换成 showModalBottomSheet 就是另外一种展示方式了，内部不需要做任何改变，我们看下两种的运行效果： 可以看到 showBottomSheet 会充满整个屏幕，然后 fab 会跟随一起到 AppBar 的底部位置，而 showModalBottomSheet 展示的高度不会超过半个屏幕的高度，但是 fab 被其遮挡了。假如我们只需要展示 2-3 个 item，但是按照刚才的方式 showModalBottomSheet 的高度太高了，那我们可以在 ListView 外层包裹一层 Container，然后指定 height 即可 123456789101112131415161718_showModalBottomSheet(BuildContext context) &#123; showModalBottomSheet( context: context, builder: (context) =&gt; Container( child: ListView( children: List.generate( 2, (index) =&gt; InkWell( child: Container(alignment: Alignment.center, height: 60.0, child: Text('Item $&#123;index + 1&#125;')), onTap: () &#123; print('tapped item $&#123;index + 1&#125;'); Navigator.pop(context); &#125;), )), height: 120, ), ); &#125; 修改高度后的效果： Dialog相对于 SnackBar 和 BottomSheet，Dialog 的使用场景相对会更多，在 MaterialDesign 下，Dialog 主要有 3 种：AlertDialog，SimpleDialog 和 AboutDialog，当然在 Cupertino 风格下也有相应的 Dialog，因为这个系列以 MaterialDesign 风格为主，所以 Cupertiono 等下次有时间再写吧。 AlertDialog在 ListView 中增加一个 AlertDialog 的按钮，用于点击显示 AlertDialog 用，然后加入显示 AlertDilaog 的方法，并将按钮的 onPressed 指向该方法，Dialog 的 context 可以是 Scaffold 下的 context，所以不需要用 Builder 来包裹一层。 1234567891011121314151617181920212223242526_showAlertDialog() &#123; showDialog( // 设置点击 dialog 外部不取消 dialog，默认能够取消 barrierDismissible: false, context: context, builder: (context) =&gt; AlertDialog( title: Text('我是个标题...嗯，标题..'), titleTextStyle: TextStyle(color: Colors.purple), // 标题文字样式 content: Text(r'我是内容\(^o^)/~, 我是内容\(^o^)/~, 我是内容\(^o^)/~'), contentTextStyle: TextStyle(color: Colors.green), // 内容文字样式 backgroundColor: CupertinoColors.white, elevation: 8.0, // 投影的阴影高度 semanticLabel: 'Label', // 这个用于无障碍下弹出 dialog 的提示 shape: Border.all(), // dialog 的操作按钮，actions 的个数尽量控制不要过多，否则会溢出 `Overflow` actions: &lt;Widget&gt;[ // 点击增加显示的值 FlatButton(onPressed: increase, child: Text('点我增加')), // 点击减少显示的值 FlatButton(onPressed: decrease, child: Text('点我减少')), // 点击关闭 dialog，需要通过 Navigator 进行操作 FlatButton(onPressed: () =&gt; Navigator.pop(context), child: Text('你点我试试.')), ], )); &#125; 最后看下效果： SimpleDialogSimpleDialog 相比于 AlertDialog 少了 content 和 action 参数，多了 children 属性，需要传入 Widget 列表，那就可以自定义全部内容了。那我们这里就实现一个性别选择的 Dialog，选择后通过 Taost 提示选择的内容，Taost 就是之前导入的第三方插件，先看下效果图吧 只要实现 children 是个列表选择器就可以了，比较简单，直接上代码 123456789101112131415161718_showSimpleDialog() &#123; showDialog( barrierDismissible: false, context: context, builder: (context) =&gt; SimpleDialog( title: Text('我是个比较正经的标题...\n选择你的性别'), // 这里传入一个选择器列表即可 children: _genders .map((gender) =&gt; InkWell( child: Container(height: 40.0, child: Text(gender), alignment: Alignment.center), onTap: () &#123; Navigator.pop(context); Fluttertoast.showToast(msg: '你选择的性别是 $gender'); &#125;, )) .toList(), )); &#125; AboutDialogAboutDialog 主要是用于展示你的 App 或者别的相关东西的内容信息的，平时用的比较少，显示 AboutDialog 有两种方式可以展示，一种是前面一样的 showDialog 方法，传入一个 AboutDialog 实例，还有中方法是直接调用 showAboutDialog 方法。我们还是一样在列表加个按钮，并指向显示 AboutDialog 的事件。 1234567891011121314151617_showAboutDialog() &#123; showDialog( barrierDismissible: false, context: context, builder: (context) =&gt; AboutDialog( // App 的名字 applicationName: 'Flutter 入门指北', // App 的版本号 applicationVersion: '0.1.1', // App 基本信息下面会显示一行小字，主要用来显示版权信息 applicationLegalese: 'Copyright: this is a copyright notice topically', // App 的图标 applicationIcon: Icon(Icons.android, size: 28.0, color: CupertinoColors.activeBlue), // 任何你想展示的 children: &lt;Widget&gt;[Text('我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)')], )); &#125; 也可以通过 showAboutDialog 实现同样的效果 12345678910_showAboutDialog() &#123; showAboutDialog( context: context, applicationName: 'Flutter 入门指北', applicationVersion: '0.1.1', applicationLegalese: 'Copyright: this is a copyright notice topically', applicationIcon: Image.asset('images/app_icon.png', width: 40.0, height: 40.0), children: &lt;Widget&gt;[Text('我是个比较正经的对话框内容...你可以随便把我替换成任何部件，只要你喜欢(*^▽^*)')], );&#125; 最后的效果： AboutDialog 会自带两个按钮 VIEW LICENSES 和 CLOSE，VIEW LICENSES 会跳转一个 Flutter Licenses 的网页，CLOSE 会关闭，至于为什么是英文的，是因为我们没有设置语言的原因，这个涉及到多语言，这边推荐几篇之前看过的文章，如果下次有时间的话会单独拿出来讲下 英文原版多语言设置，介绍两种方式实现 国人翻译版，未持续更新第二种方式 使用插件 in18 版 这边为了支持中文，我们做下如下的修改，首先打开 pubspec.ymal 文件加入如下支持 get package 后给 MaterialApp 加入如下属性，这样就会支持中文了，这里需要导入包 package:flutter_localizations/flutter_localizations.dart，再次运行，就会发现之前的英文变成中文了，当然你也可以设置成别的语言。 Dialog 状态保持假如有个需求，需要在弹出的 Dialog 显示当前被改变的值，然后通过按钮可以修改这个值 ，该如何实现。相信很多小伙伴都会这么认为，通过 setState 来修改不就行了吗，没错，我一开始的确这么去实现的，我们先看下代码好了，增加一个 DialogState 按钮，然后指向对应的点击事件 1234567891011121314151617181920212223242526272829_showStateDialog() &#123; showDialog( context: context, barrierDismissible: false, builder: (context) =&gt; SimpleDialog( title: Text(&apos;我这边能实时修改状态值&apos;), contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ Text(&apos;当前的值是： $_count&apos;, style: TextStyle(fontSize: 18.0)), Padding( padding: const EdgeInsets.symmetric(vertical: 12.0), child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( onPressed: increase, child: Text(&apos;点我自增&apos;), ), RaisedButton( onPressed: decrease, child: Text(&apos;点我自减&apos;), ), RaisedButton( onPressed: () =&gt; Navigator.pop(context), child: Text(&apos;点我关闭&apos;), ) ]), ) ], )); &#125; 然后我们运行看下 诶诶诶，怎么 Dialog 的值不改变呢，明明界面上的已经修改了啊。所以说图样图森破咯，看下官方对 showDialog 方法的解释吧 12345// This function takes a `builder` which typically builds a [Dialog] widget.// Content below the dialog is dimmed with a [ModalBarrier]. The widget// returned by the `builder` does not share a context with the location that// `showDialog` is originally called from. Use a [StatefulBuilder] or a// custom [StatefulWidget] if the dialog needs to update dynamically. 糟糕透的翻译又来了：该方法通过 builder 参数来传入一个 Dialog 部件，dialog 下的内容被一个「模态障碍」阻隔，builder 的 context 和调用 showDialog 时候的 context 不是共享的，如果需要动态修改 dialog 的状态值，需要通过 StatefulBuilder 或者自定义 dialog 继承于 StatefulWidget 来实现 所以解决的方法很明确，对上面的代码进行修改，在外层嵌套一个 StatefulBuilder 部件 12345678910111213141516171819202122232425262728293031323334_showStateDialog() &#123; showDialog( context: context, barrierDismissible: false, // 通过 StatefulBuilder 来保存 dialog 状态 // builder 需要传入一个 BuildContext 和 StateSetter 类型参数 // StateSetter 有一个 VoidCallback，修改状态的方法在这写 builder: (context) =&gt; StatefulBuilder( builder: (context, dialogStateState) =&gt; SimpleDialog( title: Text('我这边能实时修改状态值'), contentPadding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8.0), children: &lt;Widget&gt;[ Text('当前的值是： $_count', style: TextStyle(fontSize: 18.0)), Padding( padding: const EdgeInsets.symmetric(vertical: 12.0), child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ RaisedButton( // 通过 StatefulBuilder 的 StateSetter 来修改值 onPressed: () =&gt; dialogStateState(() =&gt; increase()), child: Text('点我自增'), ), RaisedButton( onPressed: () =&gt; dialogStateState(() =&gt; decrease()), child: Text('点我自减'), ), RaisedButton( onPressed: () =&gt; Navigator.pop(context), child: Text('点我关闭'), ) ]), ) ], ))); &#125; 然后再运行下，可以看到 dialog 和界面的值保持一致了 以上部分代码查看 prompt_main.dart 文件 差不多常用弹窗和操作提示就在这了，好好消化吧~]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(八)之Sliver组件及NestedScrollView]]></title>
    <url>%2Fposts%2Ff600e8a7.html</url>
    <content type="text"><![CDATA[上节最后留了个坑到这节来解决，因为涉及部件比较多，所以留到这边来继续讲，不然写太多了怕小伙伴看不下去 在上节最后，给小伙伴们展示了 SliveGrid 和 SliverFixedExtentList 的用法，基本上和 GridView 和 ListView 的用法差不多，所以这边就不多讲这两个部件了。 SliverAppBar相信很多 Android 开发的小伙伴会用到 MaterialDesign 的 CollapsingToolbarLayout 来实现折叠头部，既然 Android 有的，那么 Flutter 也不会少，毕竟 Flutter 主打的也是 MaterialDesign 啊。首先看下 SliverAppBar 的源码吧，其实和 AppBar 的参数差不多，只是多了一些比较特殊的属性 1234567891011121314151617181920212223const SliverAppBar(&#123;Key key,this.leading,this.automaticallyImplyLeading = true,this.title,this.actions,this.flexibleSpace, // 通过这个来设置背景this.bottom,this.elevation,this.forceElevated = false, // 是否显示层次感this.backgroundColor,this.brightness,this.iconTheme,this.textTheme,this.primary = true,this.centerTitle,this.titleSpacing = NavigationToolbar.kMiddleSpacing,this.expandedHeight, // 展开的高度// 以下三个等例子再讲this.floating = false,this.pinned = false,this.snap = false,&#125;) 别的参数应该不陌生吧，都是 AppBar 的，那么直接来看个例子吧，还是通过上节说的 CustomScrollView 来包裹 Sliver 部件 12345678910111213141516171819202122232425262728293031323334353637class SliverDemoPage extends StatelessWidget &#123;@overrideWidget build(BuildContext context) &#123;return Scaffold(body: CustomScrollView(slivers: &lt;Widget&gt;[SliverAppBar(title: Text('Sliver Demo'),centerTitle: true,// 展开的高度expandedHeight: 300.0,// 强制显示阴影forceElevated: true,// 设置该属性，当有下滑手势的时候，就会显示 AppBar// floating: true,// 该属性只有在 floating 为 true 的情况下使用，不然会报错// 当上滑到一定的比例，会自动把 AppBar 收缩（不知道是不是 bug，当 AppBar 下面的部件没有被 AppBar 覆盖的时候，不会自动收缩）// 当下滑到一定比例，会自动把 AppBar 展开// snap: true,// 设置该属性使 Appbar 折叠后不消失// pinned: true,// 通过这个属性设置 AppBar 的背景flexibleSpace: FlexibleSpaceBar(// title: Text('Expanded Title'),// 背景折叠动画collapseMode: CollapseMode.parallax,background: Image.asset('images/timg.jpg', fit: BoxFit.cover),),),// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，// 可以在 child 属性加入需要展示的部件SliverFillRemaining(child: Center(child: Text('FillRemaining', style: TextStyle(fontSize: 30.0))),),]));&#125;&#125; 这里分别给出不同的动图来查看三个属性的影响 如果设置了 floating 属性，当有下拉动作时，会显示 AppBar 如果设置了 snap 属性，滑动距离达到一定值后，会根据滑动方向收缩或者展开 如果设置了 pinned 属性，那么 AppBar 就会在界面上不会消失 以上的效果图把 SliverFillRemaining 换成列表 SliverFixedExtentList 效果可能会更加明显，这边给小伙伴自己替换测试吧。 SliverFillViewport这边提到了 SliverFillRemaining 用来填充视图，那么顺带提下 SliverFillViewport 这个部件 12345const SliverFillViewport(&#123;Key key,@required SliverChildDelegate delegate, // 这个 delegate 同 SliverGridthis.viewportFraction = 1.0, // 同屏幕的比例值，1.0 为一个屏幕大小&#125;) 如果一个滑动列表，每个 item 需要占满一个屏幕或者更大，可以使用该部件生成列表，但是如果 item 的高度小于一个屏幕高度，那就不太推荐了，在首尾会用空白 item 来把未填满的补上，就是首尾都会留空白。我们使用 SliverFillViewport 对 SliverFillRemaning 进行替换 12345SliverFillViewport(viewportFraction: 1.0,delegate: SliverChildBuilderDelegate((_, index) =&gt; Container(child: Text('Item $index'), alignment: Alignment.center, color: colors[index % 4]),childCount: 10)) 效果就不展示了，可自行运行查看。 SliverToBoxAdapter还记得上节最后的代码中，有使用 SliverToBoxAdapter 这个部件吗，这个部件只需要传入一个 child 属性。因为在 CustomScrollView 中只允许传入 Sliver 部件，那么类似 Container 等普通部件就不可以使用了，那么这样就需要更多的 Sliver 组件才能完成视图，所以为了方便，直接通过 SliverToBoxAdapter 对普通部件进行包裹，这样就成为一个 Sliver 部件了。总结下 SliverToBoxAdapter 的功能就是 把一个普通部件包裹成为 Sliver 部件，例子就不举了，上节已经有了。 SliverPadding那么在 CustomScrollView 中部件之间如何设置间距呢，可能你会想到用 SliverToBoxAdapter 包裹一个 Padding 来处理，当然没问题。不过 Flutter 也提供了专门的部件 SliverPadding 使用方式同 Padding，但是需要传入一个 sliver 作为子类。 SliverPersistentHeaderFlutter 中，为我们提供了这么一个作为头部的部件 SliverPersistentHeader，这个部件可以根据滚动的距离缩小高度，有点类似 SliverAppBar 的背景效果。 123456const SliverPersistentHeader(&#123;Key key,@required this.delegate, // SliverPersistentHeaderDelegate，用来创建展示内容this.pinned = false, // 同 SliverAppBar 属性this.floating = false,&#125;) SliverPersistentHeaderDelegate这个代理比较特殊，是个抽象类，也就是需要我们自己进行继承后再实现方法。SliverPersistentHeaderDelegate 需要提供一个最大值，最小值，展示内容，以及更新部件条件 比如我们需要展示一个最大高度 300，最小高度 100，居中的文字，那么我们可以这么写这个代理类 123456789101112131415161718class DemoHeader extends SliverPersistentHeaderDelegate &#123;@overrideWidget build(BuildContext context, double shrinkOffset, bool overlapsContent) &#123;return Container(color: Colors.pink,alignment: Alignment.center,child: Text('我是一个头部部件', style: TextStyle(color: Colors.white, fontSize: 30.0)));&#125; // 头部展示内容@overridedouble get maxExtent =&gt; 300.0; // 最大高度@overridedouble get minExtent =&gt; 100.0; // 最小高度@overridebool shouldRebuild(SliverPersistentHeaderDelegate oldDelegate) =&gt; false; // 因为所有的内容都是固定的，所以不需要更新&#125; 使用 SliverPersistentHeader 代替 SliverAppBar，看下效果 1234567891011121314151617class SliverDemoPage extends StatelessWidget &#123;final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink];@overrideWidget build(BuildContext context) &#123;return Scaffold(body: CustomScrollView(slivers: &lt;Widget&gt;[SliverPersistentHeader(delegate: DemoHeader(), pinned: true),// 这个部件一般用于最后填充用的，会占有一个屏幕的高度，// 可以在 child 属性加入需要展示的部件SliverFillRemaining(child: Center(child: Text('FillRemaining', style: TextStyle(fontSize: 30.0))),),]));&#125;&#125; 最后的效果图 当然，为了方便扩展，需要重新封装下 Delegate ，通过外部传入范围和展示内容 123456789101112131415161718192021222324252627282930// 自定义 SliverPersistentHeaderDelegateclass CustomSliverPersistentHeaderDelegate extends SliverPersistentHeaderDelegate &#123;final double max; // 最大高度final double min; // 最小高度final Widget child; // 需要展示的内容CustomSliverPersistentHeaderDelegate(&#123;@required this.max, @required this.min, @required this.child&#125;)// 如果 assert 内部条件不成立，会报错: assert(max != null),assert(min != null),assert(child != null),assert(min &lt;= max),super();// 返回展示的内容，如果内容固定可以直接在这定义，如果需要可扩展，这边通过传入值来定义@overrideWidget build(BuildContext context, double shrinkOffset, bool overlapsContent) =&gt; child;@overridedouble get maxExtent =&gt; max; // 返回最大高度@overridedouble get minExtent =&gt; min; // 返回最小高度@overridebool shouldRebuild(CustomSliverPersistentHeaderDelegate oldDelegate) &#123;// 是否需要更新，这里我们定义当高度范围和展示内容被替换的时候进行刷新界面return max != oldDelegate.max || min != oldDelegate.min || child != oldDelegate.child;&#125;&#125; 然后我们就可以愉快的使用了，不需要每个 Delegate 都重新写一遍，例如替换下刚才写死的 DemoHeader 12345678SliverPersistentHeader(// 属性同 SliverAppBarpinned: true,floating: true,// 因为 SliverPersistentHeaderDelegate 是一个抽象类，所以需要自定义delegate: CustomSliverPersistentHeaderDelegate(max: 300.0, min: 100.0, child: Text('我是一个头部部件', style: TextStyle(color: Colors.white, fontSize: 30.0))),), 例如需要替换成一张图片，直接将 Text 修改成 Image 即可。 以上部分代码查看 sliver_main.dart 文件 NestedScrollView讲到这了，不得不提下 Scrollable 中比较重要的一员 NestedScrollView，先看下官方的解释 12/// A scrolling view inside of which can be nested other scrolling views, with/// their scroll positions being intrinsically linked. 糟透了的翻译 X 1：一个内部能够嵌套其他滚动部件，并使其滚动位置联结到一起的滚动部件 1234/// The most common use case for this widget is a scrollable view with a/// flexible [SliverAppBar] containing a [TabBar] in the header (build by/// [headerSliverBuilder], and with a [TabBarView] in the [body], such that the/// scrollable view's contents vary based on which tab is visible. 糟透了的翻译 X 2：最常用的情况，就是在其 headerSliverBuilder 中使用携带 TabBar 的 SliverAppBar（就是使用 SliverAppBar 的 bottom 属性添加 tab 切换也），其 body 属性使用 TabBarView 来展示 Tab 页的内容，这样通过切换 Tab 页就能展示该页下的展示内容。 看下 headerSliverBuilder 的定义 1234567/// Signature used by [NestedScrollView] for building its header.////// The `innerBoxIsScrolled` argument is typically used to control the/// [SliverAppBar.forceElevated] property to ensure that the app bar shows a/// shadow, since it would otherwise not necessarily be aware that it had/// content ostensibly below it.typedef NestedScrollViewHeaderSliversBuilder = List&lt;Widget&gt; Function(BuildContext context, bool innerBoxIsScrolled); 糟透了的翻译 X 3：用于构建 NestScrollView 的头部部件，innerBoxIsScrolled 主要用来控制 SliverAppBar 的 forceElevated 属性，当内部内容滚动时，显示 SliverAppbar 的阴影，主要用来提醒内部的内容低于 SliverAppBar （相当于给人一种物理层次感，否则很容易被认为，头部和内容是连接在一起的） 接下来看下 NestedScrollView 内部个人觉得有点重要的一个方法 sliverOverlapAbsorberHandleFor 12345678910111213/// Returns the [SliverOverlapAbsorberHandle] of the nearest ancestor/// [NestedScrollView].////// This is necessary to configure the [SliverOverlapAbsorber] and/// [SliverOverlapInjector] widgets.////// For sample code showing how to use this method, see the [NestedScrollView]/// documentation.static SliverOverlapAbsorberHandle sliverOverlapAbsorberHandleFor(BuildContext context) &#123; final _InheritedNestedScrollView target = context.inheritFromWidgetOfExactType(_InheritedNestedScrollView); assert(target != null, 'NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView.'); return target.state._absorberHandle;&#125; 请注意到中间的注释 糟透了的翻译 X 4：这个方法返回的值对于 SliverOverlapAbsorber 和 SliverOverlapInjector 部件是非常重要的参数 接着请注意代码中的那段 assert 中的文字 糟透了的翻译 X 5：sliverOverlapAbsorberHandleFor 传入的参数 context 中必须包含 NestedScrollView SliverOverlapAbsorber这边又引入了两个部件 SliverOverlapAbsorber + SliverOverlapInjector 还是看源码的解释吧 1234567891011/// Creates a sliver that absorbs overlap and reports it to a/// [SliverOverlapAbsorberHandle].////// The [handle] must not be null.////// The [child] must be a sliver.const SliverOverlapAbsorber(&#123; Key key, @required this.handle, Widget child,&#125;) 糟透了的翻译 X 6：一个 sliver 部件，用于把部件重叠的高度反馈给 SliverOverlapAbsorberHandle，而且指明了 handle 不能空，可以通过 NestedScrollView 的 sliverOverlapAbsorberHandleFor 方法来赋值，并且 child 必须是个 sliver 部件，也就是说我们的 SliverAppBar 需要放到 SliverOverlapAbsorber 里面。 SingleChildScrollView123456789/// Creates a sliver that is as tall as the value of the given [handle]'s/// layout extent.////// The [handle] must not be null.const SliverOverlapInjector(&#123; Key key, @required this.handle, Widget child,&#125;) 糟透了的翻译 X 7：创建一个和指定的 handle 一样高度的 sliver 部件，这个 handle 同 SliverOverlapAbsorber 的 handle 保持一致即可。 分析完源码后，例子的目标很明确，使用 SliverAppBar + TabBar + TabBarView，先看下最后的效果图吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class NestedScrollDemoPage extends StatelessWidget &#123;final _tabs = &lt;String&gt;['TabA', 'TabB'];final colors = &lt;Color&gt;[Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple];@overrideWidget build(BuildContext context) &#123;return Scaffold(body: DefaultTabController(length: _tabs.length,child: NestedScrollView(headerSliverBuilder: (context, innerScrolled) =&gt; &lt;Widget&gt;[SliverOverlapAbsorber(// 传入 handle 值，直接通过 `sliverOverlapAbsorberHandleFor` 获取即可handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),child: SliverAppBar(pinned: true,title: Text('NestedScroll Demo'),expandedHeight: 200.0,flexibleSpace: FlexibleSpaceBar(background: Image.asset('images/timg.jpg', fit: BoxFit.cover)),bottom: TabBar(tabs: _tabs.map((tab) =&gt; Text(tab, style: TextStyle(fontSize: 18.0))).toList()),forceElevated: innerScrolled,),)],body: TabBarView(children: _tabs// 这边需要通过 Builder 来创建 TabBarView 的内容，否则会报错// NestedScrollView.sliverOverlapAbsorberHandleFor must be called with a context that contains a NestedScrollView..map((tab) =&gt; Builder(builder: (context) =&gt; CustomScrollView(// key 保证唯一性key: PageStorageKey&lt;String&gt;(tab),slivers: &lt;Widget&gt;[// 将子部件同 `SliverAppBar` 重叠部分顶出来，否则会被遮挡SliverOverlapInjector(handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context)),SliverGrid(delegate: SliverChildBuilderDelegate((_, index) =&gt; Image.asset('images/ali.jpg'),childCount: 8),gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 4, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0)),SliverFixedExtentList(delegate: SliverChildBuilderDelegate((_, index) =&gt; Container(child: Text('$tab - item$&#123;index + 1&#125;',style: TextStyle(fontSize: 20.0, color: colors[index % 6])),alignment: Alignment.center),childCount: 15),itemExtent: 50.0)],),)).toList()))),);&#125;&#125; 使用的部件和之前讲的没啥大区别，就是多了 SliverOverlapAbsorber 和 SliverOverlapInjector 没啥难度 以上部分代码查看 nested_scroll_main.dart 文件 sliver 部件常用的也就那么多了，望小伙伴好好吸收，跟着例子撸撸代码，撸顺下思路]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(七)之滑动部件]]></title>
    <url>%2Fposts%2F8d9ab46a.html</url>
    <content type="text"><![CDATA[前面的小节基本上讲完了常用的部件和容器部件，也可以完成很多的界面，但是又一个问题，假如我们要显示一段文字，比如将 一段又臭又长的文字 在界面上显示 1000 次，不难完成吧 12// ..省略一些无关代码body: Text('一段又臭又长的文字' * 1000, softWrap: true) 很简单，运行到手机…「诶诶诶，**，怎么只显示了一部分，剩下的怎么画不下去」 日常开发中，会遇到很多这种情况，许多界面不是一页就能够显示完的。那么这里提下可滑动的容器部件 SingleChildScrollView这个部件非常简单，不贴源码了。最简单的使用方式只需要提供一个 child 即可。现在给前面写的 Text 包裹上一层 SingleChildScrollView 然后再运行，文字全部都展示出来了。 如果需要实现一个垂直的滚动列表，可以直接通过 SingleChildScrollView 包裹 Column 来实现，列表内容全部塞到 Column 即可 123456789101112131415161718192021222324class SingleChildScrollDemoPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; /// letters 自由发挥吧...一定要大量，大量，大量 List&lt;String&gt; letters = [......]; return Scaffold( appBar: AppBar( title: Text('Single Child Demo'), ), body: SingleChildScrollView( child: Center( child: Column( children: List.generate( letters.length, (index) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: Text(letters[index], style: TextStyle(fontSize: 18.0)), )), ), )), ); &#125;&#125; 运行结果会根据你的 letters 不同而不同，这边就不贴效果图了，反正你可以看到一串列表… 那么如果需要实现横向滚动列表呢，稍稍做下修改就行了 123456789101112131415161718body: SingleChildScrollView( // 设置滚动方向 scrollDirection: Axis.horizontal, child: Center( // 修改为 `Row` 即可 child: Row( children: List.generate( letters.length, // 如果你的 letters 数量比较少，推荐加个 `Container` 把宽度指定大点 (index) =&gt; Container( child: Padding( padding: const EdgeInsets.symmetric(vertical: 4.0, horizontal: 6.0), child: Text(letters[index], style: TextStyle(fontSize: 18.0)), ), width: 30.0)), ), )) 效果图也不贴了，都比较简单。 该部分代码查看 single_child_scroll_main.dart 文件* ListView平时开发 Android 的时候，如果有相同格式的列表要实现，一般会使用 ListView 或者 RecyclerView 来实现，Flutter 也提供了类似的部件 ListView 实现 ListView 的方法主要有 通过 ListView 设置 children 属性实现 通过 ListView.custom 实现 通过 ListView.builder 实现 通过 ListView.separated 实现带分割线列表 ListView children第一种方法实现列表，和通过 SingleChildScrollView + Column / Row 的方法比较类似，不过可以直接通过指定 ListView 的 scrollDirection 就可以了。 1234567891011body: ListView( // 通过修改滑动方向设置水平或者垂直方向滚动 scrollDirection: Axis.vertical, // 通过 iterable.map().toList 和 List.generate 方法效果是一样的 children: letters .map((s) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), child: Center( child: Text(s)))) .toList()), ListView.custom1234567891011body: ListView.custom( // 指定 item 的高度，可以加快渲染的速度 itemExtent: 40.0, // item 代理 childrenDelegate: SliverChildBuilderDelegate( // IndexedWidgetBuilder，根据 index 设置 item 中需要变化的数据 (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.red))), // 指定 item 的数量 childCount: letters.length, )), 如果每个 item 的高度可以确定，那么推荐通过 itemExtent 来设置 item 的高度/宽度，能够加快 ListView 的渲染速度。如果不指定高度/宽度，ListView 需要根据每个 item 来计算 ListView 的高度，这个计算过程是需要消耗时间和资源的 ListView.builder该方法同 custom 类似，custom 需要通过一个 Delegate 生成 item，该方法直接通过 builder 生成，同时也可以直接指定 item 的高度 12345body: ListView.builder( itemBuilder: (_, index) =&gt; Center(child: Text(letters[index], style: TextStyle(color: Colors.green))), itemExtent: 40.0, itemCount: letters.length),)), 相对比较简单，代码也比较少…就冲这点，我也愿意用这个方法 ListView.separated如果需要在每个 item 之间添加分割线，那么通过以上的方式实现就比较困难了，所以 Flutter 提供了 separated 方法用来快速构建带有分割线的 ListView 加入我们的 item 之间的分割线需要如下样式：奇数位和偶数位之间用黑色分割线，偶数位和奇数位之间用红色分割线 123456789// 需要分割线的时候才使用，不能指定 item 的高度body: ListView.separated( itemBuilder: (_, index) =&gt; Padding( padding: const EdgeInsets.symmetric(vertical: 20.0), child: Center(child: Text(letters[index], style: TextStyle(color: Colors.blue))), ), // 这里用来定义分割线 separatorBuilder: (_, index) =&gt; Divider(height: 1.0, color: index % 2 == 0 ? Colors.black : Colors.red), itemCount: letters.length), 最终的效果如下： 以上代码查看 listview_main.dart 文件 总结下：如果 item 的高度能够准确获取，一定要指定 itemExtent 的值，这样会更加高效，至于要通过哪种方式来生成，完全看个人喜好吧。 ExpansionTile既然讲到了 ListView，在日常开发中，折叠列表也是一个比较常用的，所以这边要提下 ExpansionTile 这个部件，因为相对比较简单，所以直接上代码了 123456789101112131415161718192021222324252627282930313233class ExpansionTilesDemoPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('ExpansionTile Demo'), ), body: ExpansionTile( // 最前面的 widget leading: Icon(Icons.phone_android), // 替换默认箭头// trailing: Icon(Icons.phone_iphone), title: Text('Parent'), // 默认是否展开 initiallyExpanded: true, // 展开时候的背景色 backgroundColor: Colors.yellow[100], // 展开或者收缩的回调，true 表示展开 onExpansionChanged: (expanded) =&gt; print('ExpansionTile is $&#123;expanded ? 'expanded' : 'collapsed'&#125;'), children: List.generate( 10, (position) =&gt; Container( padding: const EdgeInsets.only(left: 80.0), child: Text('Children $&#123;position + 1&#125;'), height: 50.0, alignment: Alignment.centerLeft, )), ), ); &#125;&#125; 这样就完成了一个折叠部件，看下最后的效果 那么实现折叠列表也就是通过 ListView 创建一个 ExpansionTile 列表即可，先准备下模拟的数据 123456789final _keys = ['ParentA', 'ParentB', 'ParentC', 'ParentD', 'ParentE', 'ParentF']; final Map&lt;String, List&lt;String&gt;&gt; _data = &#123; 'ParentA': ['Child A0', 'Child A1', 'Child A2', 'Child A3', 'Child A4', 'Child A5'], 'ParentB': ['Child B0', 'Child B1', 'Child B2', 'Child B3', 'Child B4', 'Child B5'], 'ParentC': ['Child C0', 'Child C1', 'Child C2', 'Child C3', 'Child C4', 'Child C5'], 'ParentD': ['Child D0', 'Child D1', 'Child D2', 'Child D3', 'Child D4', 'Child D5'], 'ParentE': ['Child E0', 'Child E1', 'Child E2', 'Child E3', 'Child E4', 'Child E5'], 'ParentF': ['Child F0', 'Child F1', 'Child F2', 'Child F3', 'Child F4', 'Child F5'] &#125;; 在平时开发过程中，后台返回的数据应该是列表嵌套列表的形式比较多，我这边主要就是为了偷懒就随便弄了，接着修改下 body 的代码 12345678910111213141516body: ListView( children: _keys .map((key) =&gt; ExpansionTile( title: Text(key), children: _data[key] .map((value) =&gt; InkWell( child: Container( child: Text(value), padding: const EdgeInsets.only(left: 80.0), height: 50.0, alignment: Alignment.centerLeft, ), onTap: () &#123;&#125;)) .toList(), )) .toList()), 最终的效果就是个折叠列表了 该部分代码查看 expansion_tile_main.dart 文件 当然了，只要数据到位，别说两层折叠，三层，四层甚至更多层都能够实现，源码中有实现四层的 demo，这边就不贴代码了，有需要的小伙伴可以查看源码 GridView生成列表可以通过 ListView 来实现，那么同样，实现网格列表 Flutter 也提供了 GridView 来实现，实现 GridView 的方法也很多…我数了下，大概有 10 种..对你没看错，就是那么多，(诶诶诶，别走啊…虽然方法有点多，但是，大同小异) GridView GridView 需要一个 gridDelegate，gridDelegate 目前有两种 SliverGridDelegateWithFixedCrossAxisCount 看命名就知道，值固定数量的，这个数量是只单排的数量 SliverGridDelegateWithMaxCrossAxisExtent 这个是设置最大宽度/高度，在这个值范围内取最大值，比如一排能给你排下 6 个，但是远不到设置的最大值，它绝不给你排 6 个 那么接下来的使用就比较简单了 1234567891011121314151617181920212223242526272829303132class GridViewDemoPage extends StatelessWidget &#123; // 自行设置 final List&lt;String&gt; letters = [ ..... ]; // 用于区分网格单元 final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('GridView Demo'), ), body: GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, // 单行的个数 mainAxisSpacing: 10.0, // 同 scrollDirection 挂钩，item 之间在主轴方向的间隔 crossAxisSpacing: 10.0, // item 之间在副轴方法的间隔 childAspectRatio: 1.0 // item 的宽高比 ), // 需要根据 index 设置不同背景色，所以使用 List.generate，如果不设置背景色，也可用 iterable.map().toList children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, child: Text(letters[index]), color: colors[index % 4], )), ), ); &#125;&#125; 关键地方已经添加了注释，跑下运行效果 接下来换一种 delegate 试试效果，当然这个最大值可以根据个人喜好来设置 123456789101112body: GridView( // 通过设置 `maxCrossAxisExtent` 来指定最大的宽度，在这个值范围内，会选取相对较大的值 gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent( maxCrossAxisExtent: 60.0, crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0), children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, child: Text(letters[index]), color: colors[index % 4], )), ) 最后效果： 为了方便写法呢，Flutter 对以上的两种方式进行了封装，省略了 delegate GridView.count/GridView.extent 直接看下如何修改 1234567891011121314// 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithFixedCrossAxisCount` 代理的方法 body: GridView.count( crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0, crossAxisCount: 5, childAspectRatio: 2.0, children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ))), 1234567891011121314// 这种情况简化了 `GridView` 使用 `SliverGridDelegateWithMaxCrossAxisExtent` 代理的方法 body: GridView.extent( crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0, maxCrossAxisExtent: 60.0, children: List.generate( letters.length, (index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ))), 运行的效果入和前面的相同 GridView.custom 这种生成方式，比 GridView 多了一个 childrenDelegate，childrenDelegate 主要分为两种，一种是通过 IndexedWidgetBuilder 来构建 item 的 SliverChildBuilderDelegate，还有一种是通过 List 来构建 item 的 SliverChildListDelegate，所以…这边直接有 4 中生成方式，当然，我们只需要了解 childrenDelegate 如何使用即可 12345678910111213body: GridView.custom( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 1.0), // item 通过 delegate 来生成，内部实现还是 `IndexedWidgetBuilder` childrenDelegate: SliverChildBuilderDelegate( (_, index) =&gt; Container( alignment: Alignment.center, color: colors[index % 4], child: Text(letters[index]), ), childCount: letters.length)), 1234567891011121314body: GridView.custom( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 1.0), // 内部通过返回控件列表实现 childrenDelegate: SliverChildListDelegate( List.generate( letters.length, (index) =&gt; Container( child: Text(letters[index]), alignment: Alignment.center, color: colors[index % 4], )), )), 运行效果也同上面。 GridView.builder 前面介绍的方法中，生成 item 的方式基本上是通过 List 进行转换的，在 custom 提到了 IndexWidgetBuilder 的生成方式，当然，在 ListView 的时候也用到了这种生成方式，当然 GridView 也有啊，要「雨露均沾」你说是吧 12345678// 通过 `IndexedWidgetBuilder` 来构建 item，别的参数同上 body: GridView.builder( // 这里又需要分两种 `gridDelegate` gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 5, crossAxisSpacing: 10.0, mainAxisSpacing: 10.0, childAspectRatio: 1.0), itemCount: letters.length, itemBuilder: (_, index) =&gt; Container(color: colors[index % 4], child: Text(letters[index]), alignment: Alignment.center)), 到这 10 种方式就说完了。终于可以歇一口气了。 该部分代码查看 gridview_main.dart 文件 CustomScrollView在平时的开发中，应该会遇到这么种情况，头部是一个 GridView 接下来拼接一些别的部件，然后再拼接一个列表，例如下图 因为 GridView 和 ListView 亮着都是可滑动的部件，直接拼接肯定会有「滑动冲突」，所以 Flutter 就提供了一个粘合剂，CustomScrollView，那么 Flutter 如何实现呢，因为会涉及到 Sliver 系列部件，所以这边先看下大概的代码，下节会补充 Sliver 系列部件的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class CustomScrollDemoPage extends StatelessWidget &#123; // 这边用的 A-Z 字母 final List&lt;String&gt; letters = [ ..... ]; final List&lt;Color&gt; colors = [Colors.red, Colors.green, Colors.blue, Colors.pink, Colors.yellow, Colors.deepPurple]; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('CustomScrollDemo'), ), body: CustomScrollView( // 这里需要传入 `Sliver` 部件，下节课填坑 slivers: &lt;Widget&gt;[ // SliverGrid 实现同 GridView 实现方式一样 // 同样 SliverGrid 有提供 `count`, `entent` 方法便于快速生成 SliverGrid SliverGrid( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Image.asset('images/ali.jpg'), onTap: () &#123;&#125;, ), childCount: 8), gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 4, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0)), // 这里下节讲 SliverToBoxAdapter( child: Container( color: Colors.black12, margin: const EdgeInsets.symmetric(vertical: 10.0), child: Column(children: &lt;Widget&gt;[ Divider(height: 2.0, color: Colors.black54), Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), Text('我是一些别的东西..例如广告', textScaleFactor: 1.5, style: TextStyle(color: Colors.red)) ], ), Divider(height: 2.0, color: Colors.black54), ], mainAxisAlignment: MainAxisAlignment.spaceBetween), alignment: Alignment.center)), // SliverFixedExtentList 实现同 List.custom 实现类似 SliverFixedExtentList( delegate: SliverChildBuilderDelegate( (_, index) =&gt; InkWell( child: Container( child: Text(letters[index] * 10, style: TextStyle(color: colors[index % colors.length], letterSpacing: 2.0), textScaleFactor: 1.5), alignment: Alignment.center, ), onTap: () &#123;&#125;, ), childCount: letters.length), itemExtent: 60.0) ], ), ); &#125;&#125; 该部分代码查看 custom_scroll_main.dart 文件 滑动部件其实还有好几个，但是以上介绍的在平时开发过程中够用了，如果后期发现还需要别的部件，我会继续补上。在结束前，我们再说下如何通过 ScrollController 来控制 Scrollable 的滚动位置。例如我们需要实现，当滚动的距离大于一定距离的时候显示一个回到顶部的按钮，有了 ScrollController 就能够非常方便的实现 ScrollController因为需要根据滑动的距离显示回到顶部按钮，那么就需要通过一个状态位来控制按钮显隐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class ScrollControllerDemoPage extends StatefulWidget &#123; @override _ScrollControllerDemoPageState createState() =&gt; _ScrollControllerDemoPageState();&#125;class _ScrollControllerDemoPageState extends State&lt;ScrollControllerDemoPage&gt; &#123; var _scrollController = ScrollController(); var _showBackTop = false; @override void initState() &#123; super.initState(); // 对 scrollController 进行监听 _scrollController.addListener(() &#123; // _scrollController.position.pixels 获取当前滚动部件滚动的距离 // window.physicalSize.height 获取屏幕高度 // 当滚动距离大于 800 后，显示回到顶部按钮 setState(() =&gt; _showBackTop = _scrollController.position.pixels &gt;= 800); &#125;); &#125; @override void dispose() &#123; // 记得销毁对象 _scrollController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('ScrollController Demo'), ), body: ListView( controller: _scrollController, children: List.generate( 20, (index) =&gt; Container(height: 50.0, alignment: Alignment.center, child: Text('Item $&#123;index + 1&#125;'))), ), floatingActionButton: _showBackTop // 当需要显示的时候展示按钮，不需要的时候隐藏，设置 null ? FloatingActionButton( onPressed: () &#123; // scrollController 通过 animateTo 方法滚动到某个具体高度 // duration 表示动画的时长，curve 表示动画的运行方式，flutter 在 Curves 提供了许多方式 _scrollController.animateTo(0.0, duration: Duration(milliseconds: 500), curve: Curves.decelerate); &#125;, child: Icon(Icons.vertical_align_top), ) : null, ); &#125;&#125; 最后的效果图]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(六)路由]]></title>
    <url>%2Fposts%2Fb89d6378.html</url>
    <content type="text"><![CDATA[上一节撸了个界面，虽然比较简单，但是把前面讲的知识串联了下，但是界面之间的跳转一直没说，这节就讲下 Flutter 中的「路由」来管理界面。 1、NavigatorFlutter 通过 Navigator 来进行页面之间的跳转，分为 push 系列和 pop 系列操作，带 push 方法为入栈操作，带 pop 方法为出栈操作。Navigator 的 push 方法分两类，一类是带 Name 的，需要在 MaterialApp 下将 routers 属性进行注册，否则将会找不到该路由，还有一个是不带 Name 的，可以通过 Router 直接跳转。 说那么多相信还不如直接上代码和图来的更直接。因为需要展示所有的跳转至少需要 3 个页面，所以我们创建最简单的三个界面，通过文字来区别不同的页面，因为需要调用带有 Name 的方法，所以需要先在 MaterialApp 对路由进行注册。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class DemoApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Learning Demo', // 在这里注册路由，关联 name 和界面 // '/' 表示根页面，也就是 home 所对应的页面，这边就不需要配置 home 属性了 routes: &#123;'/': (_) =&gt; APage(), '/page_b': (_) =&gt; BPage(), '/page_c': (_) =&gt; CPage()&#125;, debugShowCheckedModeBanner: false, ); &#125;&#125;/// Page A，Button 的跳转事件等会进行修改，目前先空着class APage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page A'), ), body: Center(child: RaisedButton(onPressed: () &#123;&#125;, child: Text('To Page B'))), ); &#125;&#125;/// Page Bclass BPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page B'), ), body: Center( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton(onPressed: () &#123;&#125;, child: Text('To Page C')), RaisedButton(onPressed: () &#123;&#125;, child: Text('Back Page A')) ])), ); &#125;&#125;/// Page Cclass CPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Page C'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[RaisedButton(onPressed: () &#123;&#125;, child: Text('Back Last Page'))])), ); &#125;&#125; push / pushNamed 方式跳转 我们在 APage 的 RaiseButton 的 onPressed 方法加入如下代码 1Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage())); 或者 1Navigator.pushNamed(context, '/page_b'); 效果相同。跳转后，可以发现，在 BPage 的 AppBar 上有个返回按钮，点击可以返回 APage ，那么也就是说通过 push 或者 pushNamed 方式跳转的时候，界面堆栈的变化是直接在原来的堆栈上添加一个新的 page 为了凸显堆栈的变化，所以绘制的图中，会比使用的实际页面多一个，下图同 pushReplacement / pushReplacementNamed / popAndPushNamed 将 APage 中的跳转方式进行替换 1Navigator.pushReplacement(context, MaterialPageRoute(builder: (_) =&gt; BPage())); 或者 1Navigator.pushReplacementNamed(context, '/page_b'); 或者 123/ 如果是第一个界面跳转到下个界面，勿用，`BPage` 会显示返回按钮，但是点击后，界面会变黑// 因为 `APage` 已经不在堆栈中了，点击后堆栈就没有 `Page` 了，所以界面变黑Navigator.popAndPushNamed(context, '/page_b'); 效果相同，跳转后，可以发现 BPage 的返回按钮消失了，消失了，消失了，我们可以试下点击返回按键，发现 App 直接退出了，也就是说，BPage 替代了 APage 在堆栈中的位置。那么堆栈的变化图就是这样的 pushAndRemoveUntil / pushNamedAndRemoveUntil CASE 1 这个跳转方式需要通过 CPage 来协助完成，将 APage 的跳转方式修改为 push 方式，然后在 BPage 的第一个按钮加入如下代码 12Navigator.pushAndRemoveUntil(context, MaterialPageRoute(builder: (_) =&gt; CPage()), (Route router) =&gt; false); 或者 1Navigator.pushNamedAndRemoveUntil(context, '/page_c', (Route router) =&gt; false); 效果相同，点击 BPage 的跳转 CPage 按钮后，界面来到 CPage，然后发现还是没有返回按钮，没有返回按钮，没有返回按钮，点击下返回按键，然后发现 App 直接退出了，退出了，退出了，那么堆栈变化如图 CASE 2 你以为这两个方法只是为了把堆栈都清空吗，那就太图样图森破了，这边展示另一种。修改跳转的代码 12Navigator.pushAndRemoveUntil(context, MaterialPageRoute(builder: (_) =&gt; CPage()), ModalRoute.withName('/')); 或者 1Navigator.pushNamedAndRemoveUntil(context, '/page_c', ModalRoute.withName('/')); 点击跳转 CPage 以后，发现返回按钮又回来了…就这么回来了…只是修改了一个参数，点击返回按钮，又回到了 APage，你可以在 APage 跳转 BPage 中加入DPage EPage 等等更多的界面，只要保证 BPage 跳转 CPage 的方式不变，点击 CPage 的返回按钮，又回到 APage 了，所以…堆栈的变化图如下 SUMMARY 为什么会这样变化呢，还记得在 MaterialApp 中注册的 router 么，APage 的 name 对应的为 ‘/‘，也就是说，该方法会把堆栈中在 ModalRoute.withName 所对应的 page 上的所有都 pop 出堆栈，如果把参数换成 /page_b，然后在跳转 CPage 之前加入更多的界面，点击 CPage 的返回按钮，就会回到 BPage pop 在 BPage 的第二个按钮中加入 pop 操作 1Navigator.pop(context); 跳转到 BPage 后点击该按钮，界面回到 APage，那么堆栈的变化很明显了，如图 popUntil 这个方法还需要借助 CPage ，在 CPage 的按钮中加入 1Navigator.popUntil(context, ModalRoute.withName('/')); 点击返回按钮，界面跳过 BPage 回到了 APage，解释同 pushAndRemoveUntil 那么堆栈的变化也显而易见咯 2、Navigator 传值CASE 1 传值给下个界面 修改下 BPage 和 APage 的按钮点击事件 1234567891011121314151617class BPage extends StatelessWidget &#123; final String message; BPage(&#123;Key key, @required this.message&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; print('passed value: $message'); return Scaffold( // 省略相同代码 ); &#125;&#125;// APage 跳转事件Navigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage(message: 'Message From Page A'))); 点击 APage 可以查看控制台有输出 2019-03-17 00:04:06.854 12868-12888/com.kuky.demo.flutterartsdemosapp I/flutter: passed value: Message From Page A 也就是成功把值传递过来了。但是，需要传递参数的话，之前在 MaterialApp 下注册的路由就需要去除了。 CASE 2 传值给上个界面 这边可以查看下 pop 方法 12345@optionalTypeArgs // pop 可以传入一个可选参数 result，这个 result 也就是回传给上个页面的参数值了 static bool pop&lt;T extends Object&gt;(BuildContext context, [ T result ]) &#123; return Navigator.of(context).pop&lt;T&gt;(result); &#125; 既然知道 pop 如何传递值给上个界面，那么如何在上个界面接收这个参数呢，还是看下 push 方法 123456789101112131415@optionalTypeArgs static Future&lt;T&gt; push&lt;T extends Object&gt;(BuildContext context, Route&lt;T&gt; route) &#123; return Navigator.of(context).push(route); &#125;///@optionalTypeArgs Future&lt;T&gt; push&lt;T extends Object&gt;(Route&lt;T&gt; route) &#123; // ...省略无关代码 // 这边返回一个 Future 值，`pop` 所传递的值会在这边返回 return route.popped; &#125;/// The future completes with the value given to [Navigator.pop], if any.Future&lt;T&gt; get popped =&gt; _popCompleter.future; 官方的注释非常明白的指出，会在 Future 中携带 pop 传递的参数，那么我们对 APage跳转 BPage 以及 BPage 返回 APage 的逻辑进行修改 1234567/// APageNavigator.push(context, MaterialPageRoute(builder: (_) =&gt; BPage(message: 'Message From Page A'))) .then((value) =&gt; print('BACK MESSAGE =&gt; $value')); /// BPageNavigator.pop(context, 'Message back to PageA From BPage'); 点击返回后，能够在控制台发现有如下输入 2019-03-17 16:35:53.820 13417-13442/com.kuky.demo.flutterartsdemosapp I/flutter: BACK MESSAGE =&gt; Message back to PageA From BPage 上个页面成功接收到下个页面回传的数据。 CASE 3 通过系统返回按钮传值 在 CASE 2 情况下，通过按钮对返回事件进行监听，那加入我们需求没有这个按钮，只能通过系统默认的返回按钮，或者物理返回按键，那该如何传值呢，这里就需要用 WillpopScope 对系统的返回按钮进行监听。我们对 CPage 做下修改，在 Scaffold 外面包裹一个 WillpopScope 1234567891011121314151617181920212223242526class CPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return WillPopScope( child: Scaffold( appBar: AppBar( title: Text('Page C'), ), body: Center( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123; Navigator.popUntil(context, ModalRoute.withName('/')); &#125;, child: Text('Back Last Page')) ])), ), // 这里对系统返回按钮做监听.. // 如果返回的是 `true` 则相当于 `pop` 操作，返回 `false` 则只执行上一步的 `pop` 操作 // 例如双击返回退出，也是通过 `WillpopScope` 来进行监听 onWillPop: () async &#123; Navigator.pop(context, 'Hello~'); return false; &#125;); &#125;&#125; 通过返回按钮，BPage 会成功收到从 CPage 返回的 Hello~ 值 以上代码查看 router_main.dart 文件 3、路由切换动画假如说我们不想用系统自带的切换动画，需要弄一些比较酷炫的效果该怎么办，那就需要用到自定义路由切换动画了。直接修改 BPage 跳转 CPage 的代码 12345678910111213141516Navigator.push( context, PageRouteBuilder( // 返回目标页面 pageBuilder: (context, anim, _) =&gt; CPage(), // 切换动画的切换时长 transitionDuration: Duration(milliseconds: 500), // 切换动画的切换效果，系统自带的常用 Transition // ScaleTransition: 缩放 SlideTransition: 滑动 // RotationTransition: 旋转 FadeTransition: 透明度 transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( // Tween 是 flutter 的补间动画，等讲到动画的时候再提吧，这边先记住这么使用 scale: Tween(begin: 0.0, end: 1.0).animate(anim), // 这个值必须记得要传，否则会不显示界面 child: child, ))); 当再次点击跳转的时候，切换的动画就有开始自带的平滑效果变成缩放效果了。那如果要实现多个动画呢，例如边缩放，边改变透明度，也很容易实现，只需要将 child 替换成 Transition 即可 12345678910111213Navigator.push( context, PageRouteBuilder( pageBuilder: (context, anim, _) =&gt; CPage(), transitionDuration: Duration(milliseconds: 500), transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( scale: Tween(begin: 0.0, end: 1.0).animate(anim), // 替换即可，如果要加入更多的动画，替换 `child` 属性就可以了 child: FadeTransition( opacity: Tween(begin: 0.0, end: 1.0).animate(anim), child: child, ), ))); 当然，为了方便重复利用，需要进行封装，例如我们要封装上面的缩放动画效果 123456789101112class ScalePageRoute extends PageRouteBuilder &#123; final Widget widget; ScalePageRoute(this.widget) : super( transitionDuration: Duration(milliseconds: 500), pageBuilder: (context, anim, _) =&gt; widget, transitionsBuilder: (context, anim, _, child) =&gt; ScaleTransition( scale: Tween(begin: 0.0, end: 1.0).animate(anim), child: child, ));&#125; 然后直接在 Navigator 跳转的时候调用该 Route 就可以了 该部分代码查看 custom_routes.dart 文件 还记得我们之前写的 demo 都是单个文件写一个入口的吗，现在我们就可以写一个统一管理的页面，对这些界面进行管理了，这个工作就交给大家伙自己了，当然我也在源码做了修改，可以查看 main.dart 文件 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(五)输入处理及登录界面实战]]></title>
    <url>%2Fposts%2F4b62f141.html</url>
    <content type="text"><![CDATA[前面提到基础部件的时候，忘了提输入内容处理部件，这里补上，然后顺带撸个实际的界面吧 1、TextField123456789101112131415161718192021222324252627282930const TextField(&#123; Key key, this.controller, // 定义一个 `TextEditingController` 实例，用来获取输入框内容等操作 this.focusNode, // 定义一个 `FocusNode` 实例，判断当前输入框是否获取到焦点等操作 this.decoration = const InputDecoration(), // 输入框样式，包括提醒字样，hint 等等 TextInputType keyboardType, // 输入文本类型，例如 数字，email 等等 this.textInputAction, // 键盘确认按钮的事件类型 this.textCapitalization = TextCapitalization.none, this.style, // 文字样式 this.textAlign = TextAlign.start, // 对齐方式 this.textDirection, // 文字方向 this.autofocus = false, // 是否自动获取焦点 this.obscureText = false, // 文字是否隐藏，多用于密码 this.autocorrect = true, this.maxLines = 1, // this.maxLength, // 最大长度 this.maxLengthEnforced = true, // 设置最大长度后，输入内容超出后是否强制不给输入 this.onChanged, // 输入内容发生变化时候的回调 this.onEditingComplete, // 输入完毕的回调 this.onSubmitted, // 提交内容的回调 this.inputFormatters, // this.enabled, // 是否可输入，false 不可输入 this.cursorWidth = 2.0, // 游标宽度 this.cursorRadius, // 游标半径 this.cursorColor, // 游标颜色 this.keyboardAppearance, // 该属性只在 iOS 设备有效 this.scrollPadding = const EdgeInsets.all(20.0), this.enableInteractiveSelection, this.onTap, // 点击事件 &#125;) 那么，简单的来个输入框示例吧，然后通过 Text 展示结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; // 可以传入初始值 TextEditingController _editController = TextEditingController(); FocusNode _editNode = FocusNode(); // 保存按钮点击后的输入内容值 String _content = ''; // 监听输入内容变化的内容值 String _spyContent = ''; @override void initState() &#123; super.initState(); // 当输入框获取到焦点或者失去焦点的时候回调用 _editNode.addListener(() &#123; print('edit has focus? =&gt; $&#123;_editNode.hasFocus&#125;'); &#125;); &#125; @override void dispose() &#123; // 记得销毁，防止内存溢出 _editController.dispose(); _editNode.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Input Content'), ), body: Container( padding: const EdgeInsets.symmetric(horizontal: 12.0), child: Column( children: &lt;Widget&gt;[ TextField( controller: _editController, focusNode: _editNode, decoration: InputDecoration( icon: Icon(Icons.phone_iphone, color: Theme.of(context).primaryColor), labelText: '请输入手机号', helperText: '手机号', hintText: '手机号...在这儿输入呢'), keyboardType: TextInputType.number, // 输入类型为数字类型 textInputAction: TextInputAction.done, style: TextStyle(color: Colors.redAccent, fontSize: 18.0), textDirection: TextDirection.ltr, maxLength: 11, // 最大长度为 11 maxLengthEnforced: true, // 超过长度的不显示 onChanged: (v) &#123; // 输入的内容发生改变会调用 setState(() =&gt; _spyContent = v); &#125;, onSubmitted: (s) &#123; // 点击确定按钮时候会调用 setState(() =&gt; _spyContent = _editController.value.text); &#125;, ), Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), child: RaisedButton( onPressed: () &#123; // 获取输入的内容 setState(() =&gt; _content = _editController.value.text); // 清理输入内容 _editController.clear(); setState(() =&gt; _spyContent = ''); &#125;, child: Text('获取输入内容'))), // 展示输入的内容，点击按钮会显示 Text(_content.isNotEmpty ? '获取到输入内容: $_content' : '还未获取到任何内容...'), Padding( padding: const EdgeInsets.symmetric(vertical: 8.0), // 监听输入内容的变化，会跟随输入的内容进行改变 child: Text('我是文字内容监听：$_spyContent'), ) ], )), ); &#125;&#125; 这边需要提下的是 setState 方法，该方法只有 StatefulWidget 才有，当需要修改某个值的内容的时候，通过该方法进行修改，最后的效果图如下，当输入框文字发生变化的时候，监听的 Text 内容会随之改变，获取内容的 Text 当点击按钮了才发生变化 该部分代码查看 text_field_main.dart 文件 那么如果有个需求，在点击按钮的时候需要对输入的内容的合理性进行检测，当然可以通过 TextEditingController 的结果进行检测，但是还有个更加方便的方法，可以直接使用部件 TextFormField 来实现，不过需要我们在外层加一个 Form 部件，接下来，就要准备通过 TextFormField 来撸一个登录界面，但是这之前，前面有个坑需要先解决下 2、导入自定义的图标在这之前，涉及到 Icon 部件，都是使用的系统自带的图标，那么如何导入第三方自定义图标呢，马上为你揭晓答案，首先我们需要打开「阿里妈妈」也就是 iconfont，不知道的小伙伴通过链接打开，然后需要注册个账户，也可以直接通过 Github 等三方登录，然后就可以搜索我们需要的图标了，接下来需要撸一个登录，那我们就找一个 用户 和 密码 的图标吧，选择喜欢的图标，然后鼠标放到图标会出现三个按钮，直接点击 购物车 那个按钮，然后就可以通过顶部的 购物车 按钮查看添加的图标，点击下载代码，把资源文件下载到本地。 解压后，需要用到的文件有两个，别的可以忽略 demo_index.html 这边用来查看图标的 unicode iconfont.ttf 这边就是图标资源文件了 回到项目，创建一个文件夹 fonts ，和 images 同级，将 iconfont.ttf 文件放到该文件夹下，然后打开 pubspec.ymal 文件，注册下导入的资源，可以自己命名 iconfont.ttf 文件名，便于自己发现就行，例如我命名为 third_part_icon.ttf，在注册图片下面继续添加 1234fonts: - family: ThirdPartIcons fonts: - asset: fonts/third_part_icon.ttf 注册完了记得点击 Package get，否则会找不到资源。接着新建个 third_icons.dart文件 1234567891011121314import 'package:flutter/material.dart';class ThirdIcons &#123; // codePoint 值通过打开 `demo_index.html` 获取 // 会在相应 icon 下带有相应的 code，把 `&amp;#` 替换成 `0`，然后去掉最后的 `;` 即可 // 例如 &amp;#xe672; 对应我们需要的图标就是 0xe672 static const IconData username = ThirdIconData(0xe672); static const IconData password = ThirdIconData(0xe62f);&#125;class ThirdIconData extends IconData &#123; // fontFamily 就是我们在 `pubspec.yaml` 中注册的 family 值 const ThirdIconData(int codePoint) : super(codePoint, fontFamily: 'ThirdPartIcons');&#125; 接下来就可以通过该类导入需要的第三方图标了。 3、导入第三方插件其实 Flutter 中缺少很多功能，需要通过导入第三方插件来实现功能，插件就是 Flutter 和原生交互的桥梁，也就是说，要写 Flutter 的插件，需要写 Android 和 iOS 两端代码才可，否则只有在其中一个端能够实现功能。好在有很多现成的插件已经开源，可以通过 FlutterPackage 搜索到，例如等会我们会需要用到 FlutterToast 这个插件，用来做提醒用，在 FlutterPackage 中搜索到插件后，打开项目中的 pubspec.ymal 文件，在 dependencies 类目下将 fluttertoast 插件引入，如图： 然后点击 Package get 让其导入即可，别的插件也是这样导入。做好准备工作，我们就可以撸一个登录界面了~ 4、撸一个登录界面在开撸之前，我们先看下最终的效果图吧，虽然是比较常用的界面 因为两个界面比较相似，所以这边只贴外层的代码和登录的代码，具体的代码，可以查看源码，已经推到 Github 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191void main() &#123; runApp(LoginApp()); if (Platform.isAndroid) &#123; var style = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(style); &#125;&#125;/// 外层界面，包裹登录界面和注册界面，使用的都是前面讲过的，忘记可以查看之前的章节class LoginApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Login Demo', debugShowCheckedModeBanner: false, theme: ThemeData(primarySwatch: Colors.lightBlue), home: LoginHomePage(), ); &#125;&#125;class LoginHomePage extends StatefulWidget &#123; @override _LoginHomePageState createState() =&gt; _LoginHomePageState();&#125;class _LoginHomePageState extends State&lt;LoginHomePage&gt; with SingleTickerProviderStateMixin &#123; TabController _tabController; List&lt;String&gt; _pageIndicators = ['登录', '注册']; List&lt;Widget&gt; _pages = []; int _position = 0; @override void initState() &#123; super.initState(); _tabController = TabController(length: _pageIndicators.length, vsync: this); // 将登录界面和注册界面添加到列表，用于放到 IndexStack 的 children 属性 _pages..add(LoginPage())..add(RegisterPage()); _tabController.addListener(() &#123; // 当 tab 切换的时候，联动 IndexStack 的 child 页面也进行修改，通过 setState 来修改值 if (_tabController.indexIsChanging) setState(() =&gt; _position = _tabController.index); &#125;); &#125; @override void dispose() &#123; super.dispose(); &#125; @override Widget build(BuildContext context) &#123; // 先忽略... return Theme( data: ThemeData(primarySwatch: Colors.pink, iconTheme: IconThemeData(color: Colors.pink)), child: Scaffold( body: Container( padding: const EdgeInsets.all(20.0), alignment: Alignment.center, decoration: BoxDecoration(image: DecorationImage(image: AssetImage('images/login_bg.png'), fit: BoxFit.cover)), // 先忽略...下面会讲，主要是解决软键盘弹出的时候，界面内容会溢出的问题 child: SingleChildScrollView( child: SafeArea( child: Column(mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 顶部页面切换指示器，代码可以参考 `app_bar_main.dart` 文件 TabBar( indicatorSize: TabBarIndicatorSize.label, controller: _tabController, indicatorWeight: 4.0, indicatorColor: Colors.white, // 返回 tab 列表 tabs: _pageIndicators .map((v) =&gt; Text(v, style: TextStyle(color: Colors.white, fontSize: 24.0))) .toList()), Padding( padding: const EdgeInsets.only(top: 30.0), child: SizedBox( // 切换界面列表 child: IndexedStack(children: _pages, index: _position), // 指定高度 height: MediaQuery.of(context).size.height / 2)) ])), ), ), )); &#125;&#125;/// 登录界面class LoginPage extends StatefulWidget &#123; @override _LoginPageState createState() =&gt; _LoginPageState();&#125;class _LoginPageState extends State&lt;LoginPage&gt; &#123; // 用于后面判断表单内容是否有效 GlobalKey&lt;FormState&gt; _formKey = GlobalKey(); // 用于获取输入框的内容 TextEditingController _usernameController = TextEditingController(); TextEditingController _passwordController = TextEditingController(); @override void initState() &#123; super.initState(); &#125; @override void dispose() &#123; // 防止内存溢出，记得销毁..销毁..销毁 _usernameController.dispose(); _passwordController.dispose(); super.dispose(); &#125; _login() &#123; // 取消焦点 FocusScope.of(context).requestFocus(FocusNode()); // 判断表单是否有效 if (_formKey.currentState.validate()) &#123; // 获取输入框内容 var username = _usernameController.value.text; var password = _passwordController.value.text; // 判断登录条件 if (username == 'kuky' &amp;&amp; password == '123456') // 引入的三方插件方法，`Flutter` 没有自带的 `Taost` Fluttertoast.showToast(msg: '登录成功'); else Fluttertoast.showToast(msg: '登录失败'); &#125; &#125; @override Widget build(BuildContext context) &#123; return Form( // 将 key 设置给表单，用于判断表单是否有效 key: _formKey, child: Column( children: &lt;Widget&gt;[ Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), // 表单输入框，参数同 TextField 基本类似 child: TextFormField( controller: _usernameController, style: TextStyle(color: Colors.white, fontSize: 16.0), decoration: InputDecoration( icon: Icon(ThirdIcons.username, size: 24.0, color: Colors.white), labelText: '请输入用户名', labelStyle: TextStyle(color: Colors.white), helperStyle: TextStyle(color: Colors.white)), // 有效条件(为空不通过，返回提示语，通过返回 null) validator: (value) =&gt; value.trim().isEmpty ? '用户名不能为空' : null, ), ), Padding( padding: const EdgeInsets.symmetric(vertical: 4.0), child: TextFormField( obscureText: true, controller: _passwordController, style: TextStyle(color: Colors.white, fontSize: 16.0), decoration: InputDecoration( icon: Icon(ThirdIcons.password, size: 24.0, color: Colors.white), labelText: '请输入密码', labelStyle: TextStyle(color: Colors.white), helperStyle: TextStyle(color: Colors.white)), validator: (value) =&gt; value.trim().length &lt; 6 ? '密码长度不能小于6位' : null, ), ), Padding( padding: const EdgeInsets.only(top: 20.0), child: SizedBox( // 主要用于使 RaisedButton 和上层容器同宽 width: MediaQuery.of(context).size.width, child: RaisedButton( color: Colors.pink, shape: RoundedRectangleBorder(borderRadius: BorderRadius.all(Radius.circular(4.0))), onPressed: _login, child: Text( '登录', style: TextStyle(color: Colors.white, fontSize: 20.0), )), ), ) ], )); &#125;&#125; 撸完界面后，可以试下登录效果，如果输入框的内容，和 TextFormField 的 validator的条件不符合，则会显示错误文字的提示 如果按照条件用户名为 kuky 密码为 123456 (条件可以根据自己进行修改)则会显示登录成功的逻辑 以上代码查看 login_home_page.dart 文件 注册界面的逻辑和登录界面的逻辑几乎一样，算是第一次实战了，望小伙伴能够好好的写一遍 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(四)常用布局]]></title>
    <url>%2Fposts%2F14587b6a.html</url>
    <content type="text"><![CDATA[上节填完了 Scaffold 留下的坑，这节继续填坑，之前留下关于 Layout 的坑，又是一堆部件袭来 1、Container为了让我们的界面更容易被扩展，通常会在最外层包裹一层 Container，其构造函数也不是很难理解 1234567891011121314151617181920212223Container(&#123; Key key, this.alignment, // child 的对齐方式，包括左对齐，居中，右对齐，左上对齐..等等 this.padding, // child 和 Container 的边距 Color color, // Container 的背景色 Decoration decoration, // 样式，可以设置背景图，圆角等属性 this.foregroundDecoration, // child 的样式 double width, // 宽度 double height, // 高度 BoxConstraints constraints, // 默认使用 BoxConstraints.tightFor，可以手动传入 this.margin, // Container 同上层容器的边距 this.transform, // 是个 Matrix4 矩阵，(嗯..这个参数基本很少用，没怎么了解 /捂脸) this.child, // 需要展示的内容 &#125;)// ...const BoxConstraints.tightFor(&#123; double width, double height &#125;): minWidth = width != null ? width : 0.0, maxWidth = width != null ? width : double.infinity, minHeight = height != null ? height : 0.0, maxHeight = height != null ? height : double.infinity; 让我们写个圆角矩形的外层，内层值显示白色文字 12345678910111213141516171819202122232425class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: SafeArea( child: Container( alignment: Alignment.center, // 宽，高度同上层容器相同 width: MediaQuery.of(context).size.width, height: MediaQuery.of(context).size.height, margin: const EdgeInsets.all(8.0), padding: const EdgeInsets.all(20.0), // Container 的样式 decoration: BoxDecoration( borderRadius: BorderRadius.circular(20.0), color: Colors.red,// shape: BoxShape.circle, // 该属性不可同 borderRadius 一起使用 backgroundBlendMode: BlendMode.colorDodge, // 背景图片和颜色混合模式 image: DecorationImage(image: AssetImage('images/ali.jpg'), fit: BoxFit.cover)), child: Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0)),// color: Theme.of(context).primaryColor, // 该属性不可和 decoration 一起使用 )), ); &#125;&#125; 效果图如下 该部分代码查看 column_main.dart 文件 看到这，应该很多小伙伴注意到 margin 和 padding 属性用来和别的部件保持间距，那…那我就是不用 Container 呢(专门来挑事的…)，当然没问题，有个专门用来设置间距的部件 Padding，看名字就可以看出来作用了，修改下 child 部分代码，这边先提前用下接下来会讲的部件 1234567891011child: Column( children: &lt;Widget&gt;[ Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0)), Padding( // 需要传入一个间隔值，`Flutter` 提供了很多 EdgeInsets 来设置间隔， // 参数也很明确，可以一一尝试 padding: const EdgeInsets.symmetric(vertical: 12.0), // 传入需要间隔的部件 child: Text('Container Text', style: TextStyle(color: Colors.white, fontSize: 30.0))) ], ), 效果就不展示了，接下来就要开始我的填坑之旅了…. 2、Flex，Row，Column写 Android 的小伙伴应该比较常用 LinearLayout，在 Flutter 中用两个部件，Row Column来代替 Android 中的 LinearLayout，其中 Row 是横向布局，Column 是垂直布局，因为 Row 和 Column 都是继承于 Flex 部件，Flex 比他们多了 direction 属性用来指定方向，所以主要拿 Column 来讲解，Flex 、Row 用法相同 123456789101112131415Column(&#123; Key key, // 对齐方式，对于 `Column` start 为顶部，对于 `Row` 需要分语言，和语言同向 // 3 种比较特殊的对齐方式，前端的小伙伴会了解， // spaceAround 两个部件之间的间隔是部件和上层容器间隔的两倍 // spaceBetween 两侧部件同上层容器间隔为 0，部件之间的间隔相等 // spaceEvenly 部件之间的间隔同两侧部件与上层容器间隔 MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, // 主轴的大小 CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, // 副轴对齐方式 TextDirection textDirection, // 文字方向，决定 start VerticalDirection verticalDirection = VerticalDirection.down, // 垂直方向 TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[], // 内部子部件 &#125;) Row 和 Column 都有主轴和副轴，如何区分呢，布局平行方向为主轴，垂直方向为副轴，我们把 Container 的 child 修改成 Column，然后把 Text 放到 Column 中，多放几个，然后自己设置 mainAxisAlignment 属性，查看布局的变化 1234567891011// ... 省略相同代码child: Column( mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ Text('Container Text 1', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 2', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 3', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 4', style: TextStyle(color: Colors.white, fontSize: 30.0)), Text('Container Text 5', style: TextStyle(color: Colors.white, fontSize: 30.0)), ], ) 最后的效果图如下 这边 Column 内部的子部件因为高度相同，如果不同还需要等分空间的话，就不可以通过设置 mainAxisAlignment 属性来实现了，这里介绍一个等分的部件 Expanded 12345const Expanded(&#123; Key key, int flex = 1, // 所占比例 @required Widget child, // 子部件 &#125;) 直接给 Text 外层加一个 Expanded 即可实现效果，当然可以按照需求来设置 flex 来修改比例值。 当然，在使用过程中也会遇到那么些坑，我们修改下代码，把 child 的代码修改成如下 123456789child: Row( children: &lt;Widget&gt;[ Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)), Text('ABC' * 5, style: TextStyle(color: Colors.white, fontSize: 16.0)) ], ) 然后运行下，你的屏幕就提示你 RIGHT OVERFLOWED BY XXX PIXELS 「, ***」我猜你内心肯定这样的，冷静冷静 既然遇到问题，当然要解决，不然和产品去撕逼吗..？这边，我们把 Row 换成另一个布局 Wrap 然后再运行，Prefect，Wrap 和 Row 的参数基本类似 3、Wrap123456789101112Wrap(&#123; Key key, this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, // 两个子部件之间的间隔，默认 0.0，如果值过大，可能导致原来同行的两个部件分行 this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, // 排布方向上 两个子部件的间隔 this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, List&lt;Widget&gt; children = const &lt;Widget&gt;[], &#125;) 当然，很多时候只有以上的布局是不行的，比如我们需要实现一个圆形头像，然后一段文字在其上面 ，例如下面的效果 接下来介绍一个堆叠的部件 Stack，源码比较简单，就不贴了，直接上效果代码 123456789101112131415161718class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Stack( // 内部子部件的对齐方式 alignment: Alignment.center, children: &lt;Widget&gt;[ // 圆形头像，指定半径，指定背景图为头像即可 CircleAvatar(backgroundImage: AssetImage('images/ali.jpg'), radius: 100.0), Text( 'Kuky', style: TextStyle(color: Colors.white, fontSize: 34.0)), ], )), ); &#125;&#125; 如果我们需要第三个部件，底部距离圆形头像10px，那么只靠 alignment 是不可能实现了 所以，另外一个灰常流弊的部件就出来了 Positioned，其源码也比较简单，我还是不贴了吧~，还是直接上代码，直接修改 12345678910111213141516171819class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center( child: Stack( alignment: Alignment.center, children: &lt;Widget&gt;[ CircleAvatar(backgroundImage: AssetImage('images/ali.jpg'), radius: 100.0), Text( 'Kuky', style: TextStyle(color: Colors.white, fontSize: 34.0), ), Positioned(child: Text('另外一段文字', style: TextStyle(color: Colors.white, fontSize: 20.0)), bottom: 10.0), // left, right, top, bottom 分别表示和 stack 的间距 ], )), ); &#125;&#125; 最后的效果图如下 很好，今天填了布局的这个大坑，而且讲的部件貌似还挺多的，虽然还是比较简单，剩下的就给小伙伴们慢慢消化今天的内容。 下节，除了有常用的部件外，我会尽量加上实战内容 代码地址: https://github.com/kukyxs/flutter_arts_demos_app]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(三)快速搭建界面]]></title>
    <url>%2Fposts%2F5c762cf7.html</url>
    <content type="text"><![CDATA[上一篇讲完 Flutter 中的一些基本部件，这篇就先填完上篇留下的没写的 AppBar 的坑，以及 Scaffold 其他参数的使用，在开始前，先补一张缩略版的脑图 1、AppBar这一部分，我们只关注 Scaffold 中的 AppBar 剩下的还是埋坑【坑4】(，居然已经埋了那么多坑了，坑虽多，代码还是要继续的)，因为稍后会用到 StatefulWidget 的属性，所以就直接先使用了，和 StatelessWidget 区别用法可以这么记 需要数据更新的界面用 StatefulWidget，当然也不是绝对的，就是之前留的【坑1】所说的状态管理 1234567891011121314151617181920212223242526272829class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, // 标题内容居中 automaticallyImplyLeading: false, // 不使用默认 leading: Icon(Icons.menu, color: Colors.red, size: 30.0), // 左侧按钮 flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), // 背景 title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), // 标题内容 // 末尾的操作按钮列表 actions: &lt;Widget&gt;[ PopupMenuButton( onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], ), ); &#125;&#125; 最后的效果图，未点击右侧按钮如左侧所示，点击右侧按钮会弹出相应的 mune 该部分代码查看 app_bar_main.dart 文件 看到效果图，相信很多小伙伴会吐槽，「**，上面那层半透明的啥玩意，那么丑」，接下来我们来解决这个问题，修改 void main 方法 123456789void main() &#123; runApp(DemoApp()); // 添加如下代码，使状态栏透明 if (Platform.isAndroid) &#123; var style = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(style); &#125;&#125; 关闭后重新运行，就可以看到那层丑丑的「半透明蒙层」没有了 接着介绍下 PopupMenuButton 这个部件，还是按照惯例看构造函数 123456789101112131415161718// itemBuildertypedef PopupMenuItemBuilder&lt;T&gt; = List&lt;PopupMenuEntry&lt;T&gt;&gt; Function(BuildContext context);// onSelectedtypedef PopupMenuItemSelected&lt;T&gt; = void Function(T value);const PopupMenuButton(&#123; Key key, @required this.itemBuilder, // 用于定义 menu 列表，需要传入 List&lt;PopupMenuEntry&lt;T&gt;&gt; this.initialValue, // 初始值，是个泛型 T，也就是类型和你传入的值有关 this.onSelected, // 选中 item 的回调函数，返回 T value，例如选中 `s` 则返回 s this.onCanceled, // 未选择任何 menu，直接点击外侧使 mune 列表关闭的回调 this.tooltip, // 长按时的提示 this.elevation = 8.0, this.padding = const EdgeInsets.all(8.0), this.child, // 用于自定义按钮的内容 this.icon, // 按钮的图标 this.offset = Offset.zero, // 展示时候的便宜，Offset 需要传入 x,y 轴偏移量，会根据传入值平移 &#125;) 2、AppBar - bottomAppBar 还有个 bottom 属性没讲，因为 bottom 这个属性和图片背景一起使用会比较丑，所以就单独拎出来讲，我们直接在原来的代码上修改 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 这里需要用 with 引入 `SingleTickerProviderStateMixin` 这个类class _HomePageState extends State&lt;HomePage&gt; with SingleTickerProviderStateMixin &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; TabController _tabController; // TabBar 必须传入这个参数 @override void initState() &#123; super.initState(); // 引入 `SingleTickerProviderStateMixin` 类主要是因为 _tabController 需要传入 vsync 参数 _tabController = TabController(length: _abs.length, vsync: this); &#125; @override void dispose() &#123; // 需要在界面 dispose 之前把 _tabController dispose，防止内存泄漏 _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, automaticallyImplyLeading: false, leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, // 选中时的颜色 unselectedLabelColor: Colors.white, // 未选中颜色 controller: _tabController, isScrollable: false, // 是否固定，当超过一定数量的 tab 时，如果一行排不下，可设置 true indicatorColor: Colors.yellow, // 导航的颜色 indicatorSize: TabBarIndicatorSize.tab, // 导航样式，还有个选项是 TabBarIndicatorSize.label tab 时候，导航和 tab 同宽，label 时候，导航和 icon 同宽 indicatorWeight: 5.0, // 导航高度 tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), // 导航内容列表 ), ); &#125;&#125; 最终的效果图如下 3、PageView + TabBar那么如何通过 TabBar 切换界面呢，这边我们需要用到 PageView 这个部件，当然还有别的部件，例如 IndexStack 等，小伙伴可以自己尝试使用别的，这边通过 PageView 和 TabBar 进行关联，带动页面切换，PageViede 的属性参数相对比较简单，这边就不贴啦。最终的效果我们目前只展示一个文字即可，我们先定义一个通用的切换界面 12345678910111213141516class TabChangePage extends StatelessWidget &#123; // 需要传入的参数 final String content; // TabChangePage(this.content); 不推荐这样写构造方法 // 推荐用这样的构造方法，key 可以作为唯一值查找 TabChangePage(&#123;Key key, this.content&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; // 仅展示传入的内容 return Container( alignment: Alignment.center, child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0))); &#125;&#125; 定义通用界面后，就可以作为 PageView 的子界面传入并展示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class HomePage extends StatefulWidget &#123; @override _HomePageState createState() =&gt; _HomePageState();&#125;class _HomePageState extends State&lt;HomePage&gt; with SingleTickerProviderStateMixin &#123; List&lt;String&gt; _abs = ['A', 'B', 'S']; TabController _tabController; // 用于同 TabBar 进行联动 PageController _pageController; @override void initState() &#123; super.initState(); _tabController = TabController(length: _abs.length, vsync: this); _pageController = PageController(initialPage: 0); _tabController.addListener(() &#123; // 判断 TabBar 是否切换位置了，如果切换了，则修改 PageView 的显示 if (_tabController.indexIsChanging) &#123; // PageView 的切换通过 controller 进行滚动 // duration 表示切换滚动的时长，curve 表示滚动动画的样式， // flutter 已经在 Curves 中定义许多样式，可以自行切换查看效果 _pageController.animateToPage(_tabController.index, duration: Duration(milliseconds: 300), curve: Curves.decelerate); &#125; &#125;); &#125; @override void dispose() &#123; _tabController.dispose(); super.dispose(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true, automaticallyImplyLeading: false, leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, unselectedLabelColor: Colors.white, controller: _tabController, isScrollable: false, indicatorColor: Colors.yellow, indicatorSize: TabBarIndicatorSize.tab, indicatorWeight: 5.0, tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), ), // 通过 body 来展示内容，body 可以传入任何 Widget，里面就是你需要展示的界面内容 // 所以前面留下 Scaffold 中 body 部分的坑就解决了 body: PageView( controller: _pageController, children: _abs.map((str) =&gt; TabChangePage(content: str)).toList(), // 通过 Map 转换后再通过 toList 转换成列表，效果同 List.generate onPageChanged: (position) &#123; // PageView 切换的监听，这边切换 PageView 的页面后，TabBar 也需要随之改变 // 通过 tabController 来改变 TabBar 的显示位置 _tabController.index = position; &#125;, ), ); &#125;&#125; 最终的效果图就不贴了，可以发现滑动 PageView 或者点击切换 TabBar 的位置，界面显示的内容都会随之改变，同时，解决前面 Scaffold 留下 body 属性没讲的一个坑，就剩下 drawer 、 bottomNavigationBar 属性没讲了，在解决这两个坑之前，我们先处理下另一个问题 Scaffold 能够使我们快速去搭建一个界面，但是，并不是所有的界面都需要 AppBar 这个标题，那么我们就不会传入 appBar 的属性，我们注释 _HomePageState 中 Scaffold 的 appBar 传入值，把 body 传入的 PageView 修改成单个 TabChangePage ，然后把 TabChangePage 这个类做下修改，把 Container 的 aligment 属性也注释了，这样显示的内容就会显示在左上角 1234567891011121314151617// _HomePageState// ..@override Widget build(BuildContext context) &#123; return Scaffold(body: TabChangePage(content: 'Content')); &#125;class TabChangePage extends StatelessWidget &#123; final String content; TabChangePage(&#123;Key key, this.content&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0))); &#125;&#125; 然后运行下，「**，文字怎么被状态栏给挡了…」不要慌，静下心喝杯茶，眺望下远方，这里就需要用 SafeArea 来处理了，在 TabChangePage 的 Container 外层加一层 SafeArea 123456@override Widget build(BuildContext context) &#123; return SafeArea( child: Container(child: Text(content, style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0)))); &#125; 然后重新运行，一切正常，SafeArea 的用途可以看下源码的解释 12345/// A widget that insets its child by sufficient padding to avoid intrusions by/// the operating system.////// For example, this will indent the child by enough to avoid the status bar at/// the top of the screen. 翻译过来大概就是「给子部件和系统点击无效区域留有足够空间，比如状态栏和系统导航栏」，SafeArea 可以很好解决刘海屏覆盖页面内容的问题，那么到目前为止，AppBar 的一些坑就说的差不多了，就要解决剩下的坑了 4、Scaffold - Drawerdrawer 同 endDrawer 属性是一样的，除了滑动的方向，Drawer 这个组件也相对比较简单，只要传入一个 child 即可，在展示之前，先对 appBar 做下处理，设置 leading 为系统默认，点击 leading 的时候 Drawer 就可以滑出来了，当然手动滑也可以 123456789101112131415161718192021222324252627282930313233343536373839@override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( centerTitle: true,// automaticallyImplyLeading: false,// leading: Icon(Icons.menu, color: Colors.red, size: 30.0),// flexibleSpace: Image.asset('images/app_bar_hor.jpg', fit: BoxFit.cover), title: Text('AppBar Demo', style: TextStyle(color: Colors.red)), actions: &lt;Widget&gt;[ PopupMenuButton( offset: Offset(50.0, 100.0), onSelected: (val) =&gt; print('Selected item is $val'), icon: Icon(Icons.more_vert, color: Colors.red), itemBuilder: (context) =&gt; List.generate(_abs.length, (index) =&gt; PopupMenuItem(value: _abs[index], child: Text(_abs[index])))) ], bottom: TabBar( labelColor: Colors.red, unselectedLabelColor: Colors.white, controller: _tabController, isScrollable: false, indicatorColor: Colors.yellow, indicatorSize: TabBarIndicatorSize.tab, indicatorWeight: 5.0, tabs: List.generate(_abs.length, (index) =&gt; Tab(text: _abs[index], icon: Icon(Icons.android)))), ), // body .... drawer: Drawer( // 记得要先添加 `SafeArea` 防止视图顶到状态栏下面 child: SafeArea( child: Container( child: Text('Drawer', style: TextStyle(color: Theme.of(context).primaryColor, fontSize: 30.0)), )), ), ); // return Scaffold(body: TabChangePage(content: 'Content')); &#125; 最终的效果图也不贴了，当手势从左侧滑出或者点击 leading 图标，抽屉就出来了 5、AppBar - bottomNavigationBarbottomNavigarionBar 可以传入一个 BottomNavigationBar 实例，BottomNavigationBar 需要传入 BottomNavigationBarItem 列表作为 items ，但是这边为了实现一个 bottomNavigationBar 和 floatingActionButton 一个特殊的组合效果，我们不使用 BottomNavigationBar，换做 BottomAppBar，直接上代码吧 1234567891011121314151617181920@override Widget build(BuildContext context) &#123; return Scaffold( /// 一样的代码省略.... bottomNavigationBar: BottomAppBar( shape: CircularNotchedRectangle(), child: Row( mainAxisSize: MainAxisSize.max, mainAxisAlignment: MainAxisAlignment.spaceAround, children: &lt;Widget&gt;[ IconButton(icon: Icon(Icons.android, size: 30.0, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;), IconButton(icon: Icon(Icons.people, size: 30.0, color: Theme.of(context).primaryColor), onPressed: () &#123;&#125;) ], ), ), floatingActionButton: FloatingActionButton(onPressed: () =&gt; print('Add'), child: Icon(Icons.add, color: Colors.white)), // FAB 的位置，一共有 7 中位置可以选择，centerDocked, endDocked, centerFloat, endFloat, endTop, startTop, miniStartTop，这边选择悬浮在 dock floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, ); 最终的效果图 ![image-20190425161447777](/Users/zm/Library/Application Support/typora-user-images/image-20190425161447777.png) 既然提到了 StatefulWidget，顺带提下两种比较简单的部件，也算是基础部件吧。CheckBox、CheckboxListTile，Switch、SwitchListTile 因为比较简单，就直接上代码了，里面都有完整的注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class CheckSwitchDemoPage extends StatefulWidget &#123; @override _CheckSwitchDemoPageState createState() =&gt; _CheckSwitchDemoPageState();&#125;class _CheckSwitchDemoPageState extends State&lt;CheckSwitchDemoPage&gt; &#123; var _isChecked = false; var _isTitleChecked = false; var _isOn = false; var _isTitleOn = false; @override void initState() &#123; super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text('Check Switch Demo'), ), body: Column(children: &lt;Widget&gt;[ Row( children: &lt;Widget&gt;[ Checkbox( // 是否开启三态 tristate: true, // 控制当前 checkbox 的开启状态 value: _isChecked, // 不设置该方法，处于不可用状态 onChanged: (checked) &#123; // 管理状态值 setState(() =&gt; _isChecked = checked); &#125;, // 选中时的颜色 activeColor: Colors.pink, // 这个值有 padded 和 shrinkWrap 两个值， // padded 时候所占有的空间比 shrinkWrap 大，别的原谅我没看出啥 materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, ), /// 点击无响应 Checkbox(value: _isChecked, onChanged: null, tristate: true) ], ), Row( children: &lt;Widget&gt;[ Switch( // 开启时候，那个条的颜色 activeTrackColor: Colors.yellow, // 关闭时候，那个条的颜色 inactiveTrackColor: Colors.yellow[200], // 设置指示器的图片，当然也有 color 可以设置 activeThumbImage: AssetImage('images/ali.jpg'), inactiveThumbImage: AssetImage('images/ali.jpg'), // 开始时候的颜色，貌似会被 activeTrackColor 顶掉 activeColor: Colors.pink, materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, value: _isOn, onChanged: (onState) &#123; setState(() =&gt; _isOn = onState); &#125;), /// 点击无响应 Switch(value: _isOn, onChanged: null) ], ), CheckboxListTile( // 描述选项 title: Text('Make this item checked'), // 二级描述 subtitle: Text('description...description...\ndescription...description...'), // 和 checkbox 对立边的部件，例如 checkbox 在头部，则 secondary 在尾部 secondary: Image.asset('images/ali.jpg', width: 30.0, height: 30.0), value: _isTitleChecked, // title 和 subtitle 是否为垂直密集列表中一员，最明显就是部件会变小 dense: true, // 是否需要使用 3 行的高度，该值为 true 时候，subtitle 不可为空 isThreeLine: true, // 控制 checkbox 选择框是在前面还是后面 controlAffinity: ListTileControlAffinity.leading, // 是否将主题色应用到文字或者图标 selected: true, onChanged: (checked) &#123; setState(() =&gt; _isTitleChecked = checked); &#125;, ), SwitchListTile( title: Text('Turn On this item'), subtitle: Text('description...description...\ndescription...description...'), secondary: Image.asset('images/ali.jpg', width: 30.0, height: 30.0), isThreeLine: true, value: _isTitleOn, selected: true, onChanged: (onState) &#123; setState(() =&gt; _isTitleOn = onState); &#125;) ]), ); &#125;&#125; 该部分代码查看 checkbox_swicth_main.dart 文件 终于这节把 Scaffold 留下的坑都填完了，然后又讲了两种基础部件，下节要填留下的别的坑了，目测还留了 2 个大坑，那就等以后继续解决吧~ 最后代码的地址还是要的： 文章中涉及的代码：demos 基于郭神 cool weather 接口的一个项目，实现 BLoC 模式，实现状态管理：flutter_weather 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：flutter_shop 作者：Kuky_xs 链接：https://www.jianshu.com/p/9119a1c1a123 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(二)基础部件]]></title>
    <url>%2Fposts%2F88b946ec.html</url>
    <content type="text"><![CDATA[前言主要包括 MaterialApp、Scaffold、Text、Image、Icon、Button 以及 AppBar 部分内容，准备出发~ ​ 看完这篇文章你就在知道怎么写以上效果了 1、Flutter runApp新建 flutter 项目后，可以看到 lib 下的 main.dart 中 void main() =&gt; runApp(MyApp());这句就是程序的入口了。这里可以简单看下源码 123456789101112131415161718192021void runApp(Widget app) &#123; WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame();&#125;///....static WidgetsBinding ensureInitialized() &#123; if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance;&#125;///....void attachRootWidget(Widget rootWidget) &#123; _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;( container: renderView, debugShortDescription: '[root]', child: rootWidget ).attachToRenderTree(buildOwner, renderViewElement);&#125; 首先会创建一个 WidgetsBinding 单例对象，然后把传入的 App 添加到 rootWidget中，scheduleWarmUpFrame 方法比较长，这边看下对该方法的注释第一句就能了解方法的主要功能了 Schedule a frame to run as soon as possible 「安排框架尽快运行起来」(原谅我这渣英语，只能看懂不会翻译..大概就是「快速启动框架」的意思吧) 2、Flutter App接着看下 MyApp 这个类，继承自 StatelessWidget 并在 build 方法返回一个 MaterialApp 实例，(偷偷讲下，其实这边还可以返回 CupertinoApp，这是一个 iOS 风格的 widget，基本上你看到部件带 「Cupertino」的都是 iOS 风格的 widget，这里先不讲 iOS 风格的部件，目前 flutter 对 Cupertino 系列的 widget 支持不是很好，包括部件的广度，多语言的支持等等方面都不是很友好，所以我们还是继续看 MD 风格的 Android 部件吧~)，这里先看下 MaterialApp 的构造函数，介绍一些常用的参数 1234567891011121314151617181920212223242526const MaterialApp(&#123; Key key, this.navigatorKey, this.home, // 主界面的内容 widget this.routes = const &lt;String, WidgetBuilder&gt;&#123;&#125;, // 带 router 和路由跳转有关 this.initialRoute, this.onGenerateRoute, this.onUnknownRoute, this.navigatorObservers = const &lt;NavigatorObserver&gt;[], this.builder, this.title = '', // *类似标题 this.onGenerateTitle, // 主要用于多语言情况下，需要根据当前语言替换 title，需要使用该值 this.color, // 主题色，如果该值未设置，取 theme.primaryColor,未设置 theme 则取蓝色 this.theme, // App 的主题风格，包括主题色，按钮默认颜色等等 this.locale, // 带 locale 的和多语言适配相关 this.localizationsDelegates, this.localeListResolutionCallback, this.localeResolutionCallback, this.supportedLocales = const &lt;Locale&gt;[Locale('en', 'US')], this.debugShowMaterialGrid = false, this.showPerformanceOverlay = false, this.checkerboardRasterCacheImages = false, this.checkerboardOffscreenLayers = false, this.showSemanticsDebugger = false, this.debugShowCheckedModeBanner = true, // debug 模式下，是否显示 DEBUG 标示横幅 &#125;) MaterialApp 继承自 StatefulWidget，它和 MyApp 所继承的类 StatelessWidget，就是日常开发中，自定义部件通常继承的抽象类了。 StatelessWidget 是状态不可变部件，通过其构建的部件一般用来展示固定内容，例如需要展示固定的功能按钮列表，不需要根据不同界面状态进行修改其展示内容 StatefulWidget 是可改变状态的部件，比如我们需要通过网络或者数据库获取数据，然后修改部件锁展示的数据内容，则需要通过 StatefulWidget 来构建。当然，不是说 StatelessWidget 不能实现修改界面数据的功能，这就需要涉及到 状态管理 的概念了，后面有机会再讲，这边先埋坑【坑1】 3、Flutter Scaffold进入 App 后就需要构建界面了，Flutter 提供了 Scaffold 来快速构建一个 MaterialDesign 风格的界面，还是先看下 Scaffold 的构造函数吧，了解几个比较常用的部分。 12345678910111213141516const Scaffold(&#123; Key key, this.appBar, // 界面顶部的那条栏，这边需要返回一个 AppBar 实例 this.body, // 界面的内容部分 this.floatingActionButton, // 悬浮部分，可以通过 floatingActionButtonLocation 设置位置 this.floatingActionButtonLocation, this.floatingActionButtonAnimator, this.persistentFooterButtons, this.drawer, // 侧滑抽屉部分，从左侧滑出(应该和语言有关，和文字方向同向) this.endDrawer, // 侧滑抽屉部分，从右侧滑出 this.bottomNavigationBar, // 底部导航栏，就是通常看到的底部 TAB 切换部件 this.bottomSheet, // 展示从底部弹出的，起到提示作用的，通过 showModalBottomSheet 展示 this.backgroundColor, // 界面的背景色 this.resizeToAvoidBottomPadding = true, // 避免 body 被底部弹出部件填充，例如输入法键盘 this.primary = true, // 当前的 Scaffold 是否需要被展示在屏幕最上层 &#125;) 来张图吧，简洁明了 了解完 Scaffold 的整体构造后，我们从上到下，通过构造函数来了解下各个 Widget的使用方法 4、AppBar12345678910111213141516171819AppBar(&#123; Key key, this.leading, // 用于设置 AppBar 前置的按钮，例如设置返回我们需要的返回按钮等 this.automaticallyImplyLeading = true, // 是否使用系统默认生成的按钮，如果替换 leading 的默认按钮，最好将该属性设置成 false this.title, // AppBar 所需要展示的组件，传入一个 Widget 实例，通常使用 Text 展示一个标题 this.actions, // AppBar 末尾悬浮的一些操作组件，例如常见的会在末尾设置一个「...」按钮，点击弹出一个 menue 提供给用户操作选择 this.flexibleSpace, // AppBar 的背景，可以设置颜色，背景图等等 this.bottom, // bottom 用于展示顶部导航 TAB this.elevation = 4.0, this.backgroundColor, // AppBar 的背景色，如果只需要修改颜色，可以不通过 flexibleSpace 修改 this.brightness, this.iconTheme, // 按钮的默认样式 this.textTheme, // 文字的默认样式 this.primary = true, this.centerTitle, // 是否将展示的 title 居中 this.titleSpacing = NavigationToolbar.kMiddleSpacing, // AppBar title 两侧的空白间隔 this.toolbarOpacity = 1.0, this.bottomOpacity = 1.0, &#125;) 在展示 AppBar 的 demo 之前，我们先学习几个基本的组件 Text、Image、Icon、Button 分布用于展示文字，图片，图标，按钮 5、Text123456789101112const Text(this.data, &#123; // Text 需要展示的文字 Key key, this.style, // 文字的样式，包括颜色，大小，间距等等属性，这边就不继续展示 TextStyle 构造函数了，不然我怕大家都不想继续看了，稍后通过例子来说明 this.textAlign, // 文字的对齐方式，包括左对齐，右对齐，居中等，详见 TextAlign 类 this.textDirection, // 文字方向，ltr(left to right) 或者 rtl(right to left) this.locale, this.softWrap, // 当文字一行显示不完是否换行 this.overflow, // 如果超出限制的行数，以哪种方式省略未展示的内容 this.textScaleFactor, // 文字缩放比例 this.maxLines, // 最多展示的行数 this.semanticsLabel, &#125;) 说了那么多，相信很多小伙伴都要急着撸代码了吧，接着来展示一些 Text 的示例，接下来的例子都会直接替换 HomePage 内的展示内容，其余都是相同的，接下来请关注 Text 别的部件先忽略，后面会介绍，这边先埋坑【坑2】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import 'package:flutter/material.dart';void main() =&gt; runApp(DemoApp());class DemoApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return MaterialApp( title: 'Flutter Demo', debugShowCheckedModeBanner: false, theme: ThemeData(primarySwatch: Colors.lightBlue), home: HomePage(), ); &#125;&#125;class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text('绿色背景黑色文字展示', style: TextStyle( color: Colors.black, // 设置文字颜色，不可和 foreground 同时设置 fontSize: 24.0, // 字体大小 letterSpacing: 2.0, // 每个字符之间的间隔 background: Paint()..color = Colors.green)), // 背景色 Text('这是一个带红色下划线的文字展示', style: TextStyle( color: Colors.black, fontSize: 24.0, // 文字装饰线，除了 underline 还有 overline, lineThrough， // 不同的样式小伙伴可以通过自己修改代码来查看 decoration: TextDecoration.underline, // 文字装饰线的类型，除了 solid 还有 double,dotted,dashed,wavy 可选 decorationStyle: TextDecorationStyle.solid, // 装饰线的颜色 decorationColor: Colors.red)) ], )), )); &#125;&#125; 该部分代码查看源码 text_main.dart 文件 最后的展示效果如下图 6、Image按照惯例，我们还是先看下 Image 的构造函数吧 123456789101112131415161718192021const Image(&#123; Key key, // 一个 ImageProvider 实例，但是 ImageProvider 是一个抽象类，Flutter 已经给我们提供如下 // AssetImage，NetworkImage，FileImage，MemoryImage 这四种图片加载器，为了方便调用 // 我们可以直接通过 Image.asset, Image.network, Image.file, Image.memory 简化， // 通过方法名，可以看出分别从 asset 文件，网络，文件，内存中加载图片 @required this.image, this.semanticLabel, this.excludeFromSemantics = false, this.width, // 图片宽度 this.height, // 图片高度 this.color, // 图片背景色 this.colorBlendMode, // color 和图片的混合模式(这个值比较多，可以一个个尝试) this.fit, // 图片填充方式 fill, cover, contain, fillWidth, fillHeight, scaleDown, none this.alignment = Alignment.center, // 对齐方式 this.repeat = ImageRepeat.noRepeat, // 若未填充满空间，重复展示的方式 this.centerSlice, this.matchTextDirection = false, this.gaplessPlayback = false, this.filterQuality = FilterQuality.low, &#125;) 好了好了，我知道你们又想自己写代码尝试下了，在这之前，需要你先准备一张本地图片，然后在项目的根目录，也就是 lib 文件夹同层，创建一个新的文件夹，命名为 images，把你准备好的图片放到这个目录下。放好之后打开 pubspec.yaml 把图片资源文件注册下 1234567891011# The following section is specific to Flutter.flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true # 这边注册资源文件，以后有图片文件也可以只注册 images 文件夹，会自动读取内部的文件 assets: - images/ali.jpg 注册完成后，就可以继续愉快的撸代码了~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class HomePage extends StatelessWidget &#123; final String _assetAli = 'images/ali.jpg'; final String _picUrl = 'https://timg05.bdimg.com/timg?wapbaike&amp;quality=60&amp;size=b1440_952&amp;cut_x=143&amp;cut_y=0&amp;cut_w=1633&amp;' 'cut_h=1080&amp;sec=1349839550&amp;di=cbbc175a45ccec5482ce2cff09a3ae34&amp;' 'src=http://imgsrc.baidu.com/baike/pic/item/4afbfbedab64034f104872baa7c379310b551d80.jpg'; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ // 这种展示图片方式和下一种会有相同的效果 Image(image: AssetImage(_assetAli), width: 80.0, height: 80.0), // 接下来加载图片都会使用这些比较方便的方法 Image.asset(_assetAli, width: 80.0, height: 80.0), // 加载一张网络图片 Image.network(_picUrl, height: 80.0, // 横向重复 repeat: ImageRepeat.repeatX, // MediaQuery.of(context).size 获取到的为上层容器的宽高 width: MediaQuery.of(context).size.width), // 通过设置混合模式，可以看到图片展示的样式已经修改 Image.asset(_assetAli, width: 80.0, height: 80.0, color: Colors.green, colorBlendMode: BlendMode.colorDodge), // 会优先加载指定的 asset 图片，然后等网络图片读取成功后加载网络图片，会通过渐隐渐现方式展现 // cover 方式按照较小的边布满，较大的给切割 // contain 会按照最大的边布满，较小的会被留白 // fill 会把较大的一边压缩 // fitHeight, fitWidth 分别按照长宽来布满 FadeInImage.assetNetwork( placeholder: _assetAli, image: _picUrl, width: 120.0, height: 120.0, fit: BoxFit.cover), // Icon 相对属性少了很多，需要传入一个 IconData 实例，flutter 提供了很多图标， // 但是实际情况我们需要加入我们自己的图标，这边再埋坑【坑3】 // size 为图标显示的大小，color 为图标的颜色，这边通过 Theme 获取主题色调 Icon(Icons.android, size: 40.0, color: Theme.of(context).primaryColorDark) ], )), )); &#125;&#125; 该部分代码查看源码 image_main.dart 文件 最后的效果如下 7、ButtonFlutter 提供了各种类型的 Button 几乎是大同小异的，这边就抽取一些比较常用的展示下效果，常用的主要有 RaisedButton 、FlatButton、IconButton、OutlineButton、MaterialButton、FloatActionButton、FloatingActionButton.extended Button 都有一个 onPress 参数，是 VoidCallback 类型的参数，通过查看源码可以知道 VoidCallback 是无参无返回值的一种类型参数。如果该参数传入的值为 null 那么这个按钮的就不可点击状态，无点击效果，等会可以在例子中查看。还有就是 child 参数，这里就是传入你需要展示的内容，比如 Text、Icon 等等。别的参数基本可以通过参数名了解，这边不扩展了(再看源码我怕你们都不想继续看下去了…) Talk is cheap, show me the code 1234567891011121314151617181920212223242526272829303132333435363738class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar(), body: Container( padding: const EdgeInsets.only(top: 10.0), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ RaisedButton( onPressed: () &#123; print('This is a Rased Button can be clicked'); &#125;, child: Text('Raised Enable'), ), RaisedButton(onPressed: null, child: Text('Raised Disable')), FlatButton( onPressed: () =&gt; print('This is a Flat Button can be clicker'), child: Text('Flat Enable'), ), FlatButton(onPressed: null, child: Text('Flat Disable')), IconButton(icon: Icon(Icons.android), onPressed: () &#123;&#125;), IconButton(icon: Icon(Icons.android), onPressed: null), MaterialButton(onPressed: () &#123;&#125;, child: Text('Material Enable')), MaterialButton(onPressed: null, child: Text('Material Disable')), OutlineButton(onPressed: () &#123;&#125;, child: Text('Outline Enable')), OutlineButton(onPressed: null, child: Text('Outline Enable')), ], )), ), floatingActionButton: FloatingActionButton.extended(onPressed: () &#123;&#125;, icon: Icon(Icons.android), label: Text('Android')), floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, ); &#125;&#125; 该部分代码查看源码 button_main.dart 部分 最终的效果图 这篇终于到末尾了，最后留了 3 个坑等以后解决 文章 demo 的地址：https://github.com/kukyxs/flutter_arts_demos_app 一个课程(当时买了想看下代码规范的，代码更新会比较慢，虽然是跟着课上的一些写代码，但是还是做了自己的修改，很多地方看着不舒服，然后就改成自己的实现方式了)：https://github.com/kukyxs/flutter_shop 如果对你有帮助的话，记得给个 Star，先谢过，你的认可就是支持我继续写下去的动力~]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门指南(一)Dart]]></title>
    <url>%2Fposts%2F6114f592.html</url>
    <content type="text"><![CDATA[前言最近 Flutter 真心火爆到不要不要的，随大流，学一波，在这之前，对于语言的语法还是需要有些必要的了解的，Dart 这门语言，说实话对于会 Java 这类面向对象的语言的小伙伴们来说，真的灰常灰常简单，这边我总结了一些 Dart 和 Java 的一些语法差异，当然，只是部分，但是，按照我目前的学习进度来说，了解了这些对于写 Flutter 项目绝对够了。小伙伴也可以自己查看，我这边提供一个自己学习的网址 Dart 快速入门：https://www.dartcn.com/ 温馨提示：本篇文章没有图，没有图，没有图，可能会造成部分不适，请注意，请注意，请注意，系好安全带，我们要「开车了」…… 1、VariablesDart 变量类型可以通过具体的赋值进行推导，例如：var name = ‘kuky’ 则定义了一个 String 类型对象 name，也可以通过指定具体的类型 String name = ‘kuky’，如果没有初始化变量，则默认值为 null，类型为数字的变量默认值同为 null（同 java 不同，java 中 int 默认为 0.）如果需要定义常量，可以通过 final 和 const 进行定义，final 变量只能赋值一次，const 是编译时常量。 2、Build-in-typesDart 内置类型包括 ： Numbers 包括 int[-2^53 ~ 2^53]， double[64-bit 浮点数] *Strings * Dart 字符串是 UTF-16 编码的字符序列， 可以使用单引号或者双引号来创建字符串。 通过 == 判断两个字符串是否相同 通过三对单引号’’’aaa’’’或者双引号”””aaa”””可以创建多行字符串对象 使用前缀 r 创建 raw string，字符串内不会进行转义，例如：var a = r’haha \n breakLine’ 打印 a 对象则会按照输入的输出，不会进行换行 Booleans Dart 中，只有 true 对象才被认为是 true， 所有其他的值都是 false Lists 列表，例如：var list = [1, 2, 3, 4] 通过 const 关键词可以定义一个不可变列表 var list = const [1, 2, 3, 4] 参数化定义var name = [‘Jone’, ‘Jack’] Maps 键值对，例如：var map = {‘one’: 1, ‘two’: 2} 如果键值对需要添加新的键值对，直接指定即可，map[‘three’] = 3，若查找的键不存在，返回 null 参数化定义 var map = &lt;String, int&gt;{‘one’: 1, ‘two’: 2} Runes 代表字符串的 UTF-32 code points，通常使用 \uXXXX 的方式来表示 Unicode code point， XXXX 是4个 16 进制的数，例如 \u2665 返回心形符号 () Symbols 代表 Dart 程序中声明的操作符或者标识符，几乎不使用 3、Function函数方法的可选参数通过在参数列表中用 {} 指定，例如： 1234567void say(String name, &#123;String word = 'hello'&#125;)&#123; print('$name say $word'); &#125;// 通过（可选参数名 + :）进行可选参数的赋值main()&#123; say('zm', word: 'Hello World'); // kuky say Hello World&#125; word 参数为可选参数，默认值为 hello 4、Operators操作符几乎和别的语言类似，提个比较特殊的赋值操作符 ??= 和 ?.操作符 123var a = 1;var b ?? = a; // 如果 b 的值是 null 则将 a 赋值给 b，否则保持不变var c = size?.x; // 如果 size 为 null 则返回 null，否则返回 size.a 的值 5、Conditional ExpressionsDart 可以通过两个特殊的操作符替换 if(){} else{} 表达式 1234/// condition? expr1: expr2 同 java 三目运算符var a = if(a &lt; 0) -a : a/// expr1 ?? expr2 String toString() =&gt; msg ?? super.toString() // 如果 expr1 不为 null 则返回 expr1 否则返回 expr 6、Cascade Notaion(..)级联操作符 (..) 可以在同一个对象上 连续调用多个函数以及访问成员变量 12345678910111213141516class Size&#123; double x; double y; @override String toString() &#123; return 'Size&#123;x: $x, y: $y&#125;'; &#125;&#125;var size = Size();/// 通过级联操作符进行赋值，可以更加简洁，!!如果函数返回值为 void 则不能进行级联!!print(size ..x = 10 ..y = 100 ..toString()); /// 输出 Size&#123;x: 10.0, y: 100.0&#125; 7、foreach通过 foreach 循环遍历一个实现 Iterable 接口的对象 12345var items = [1, 2, 3, 4, 5];var maps = &#123;'a': 1, 'b': 2&#125;;items.where((i) =&gt; i &gt; 2).forEach((i) =&gt; print(i)); // 3, 4, 5maps.forEach((key, value) =&gt; print('$key =&gt; $value')); // a =&gt; 1, b =&gt; 2 8、Switch and case如果需要实现继续到下一个 case 语句中继续执行，则可以 使用 continue 语句跳转到对应的标签处继续执行 1234567891011var command = 'Close';switch (command.toLowerCase()) &#123; case 'close': print('close'); continue open; open: // 这是个标签 case 'open': print('open'); break;&#125; 9、Assert如果条件表达式结果不满足需要，则可以使用 assert 语句俩打断代码的执行，例如：assert(a == 1); 10、Exceptions所有的 Dart 异常是非检查异常。捕捉 exceptions 的时候可以通过 on 指定 exceptions 类型，再使用 catch 捕获 1234567891011try &#123; breedMoreLlamas();&#125; on OutOfLlamasException &#123; buyMoreLlamas();&#125; on Exception catch (e) &#123; print('Unknown exception: $e');&#125; catch (e, s) &#123; // 函数 catch 可以带有一个或两个参数，第一个参数为抛出的异常对象，第二个为堆栈信息 print('Something really unknown: $e'); print('Stack trace:\n $s'); rethrow; // 通过 rethrow 可以将异常重新抛出&#125; 11、ClassesDart 中的类都是单继承，但是同时支持 mixin 的继承机制（除 Object 类，每个类都只有一个超类），所有的类都继承于 Object，通过调用 runtimeType 判断实例的类型。每个实例变量都会自动生成一个 getter 方法（隐含的）， Non-final 实例变量还会自动生成一个 setter 方法。 Constructors Dart 的构造函数同 Java 类似 12345678910class Size &#123; num x, y; Size(num nx, num y)&#123; x = nx; this.y = y; // this 关键字只有当名字冲突时候使用，否则 Dart 推荐省略 this &#125; Size(this.x, this.y); // Dart 通过语法糖省略了构造函数的赋值过程，效果同上&#125; 如果没有定义构造函数，则会有个默认构造函数。默认构造函数没有参数，并且会调用超类的 没有参数的构造函数。子类不会继承超类的构造函数，子类如果没有定义构造函数，则只有一个默认构造函数。 Dart 通过命名构造函数为类创建多个构造函数，同时指明意图 12345678910111213141516class Size &#123; num x, y; Size(this.x, this.y); Size.fromJson(Map json)&#123; this.x = json['x']; this.y = json['y']; &#125; // 因为构造函数不能继承，如果希望子类也有超类一样的命名构造函数，必须在子类中实现该构造函数 // 构造函数体执行之前除了可以调用超类构造函数之外，还可以初始化实例参数 // 初始化列表非常适合用来设置 final 变量的值 Size.fromJsonInit(Map json) : this.x = json['x'], this.y = json['y'];&#125; 常量构造函数（如果类需要提供一个状态不变的对象，通过 const 构造函数实现） 123456class ConstPoint &#123; final num x; final num y; const ConstPoint(this.x, this.y);&#125; 工厂方法构造函数（如果一个类不需要每次都提供一个新的对象，通过 factory 构造函数实现） 12345678910111213141516class HttpCore &#123; HttpCore._internal(); factory HttpCore() &#123; if (_instance == null) _instance = HttpCore._internal(); return _instance; &#125; static HttpCore _instance; static HttpCore get instance =&gt; HttpCore(); void _request()&#123; //... &#125;&#125; 每个类都隐式的定义了一个包含所有实例成员的接口， 并且这个类实现了这个接口，通过抽象类实现类似 Java 接口的功能。 12345678910abstract class Callback &#123; void print(String msg);&#125;class A implements Callback&#123; @override void print(String msg) &#123; print(msg); &#125;&#125; Mixins Dart | 什么是Mixin：https://www.jianshu.com/p/a578bd2c42aa 12、Asynchrony supportFuture 123456789loopIntegers() &#123; // 通过 then 进行获取到 Future 对象后的操作 getListDelay().then((ints) =&gt; ints.forEach((i) =&gt; print(i)));&#125;// 生成一个 Future 对象Future&lt;List&lt;int&gt;&gt; getListDelay() &#123; return Future.delayed(Duration(seconds: 2), () =&gt; List.generate(10, (delta) =&gt; delta));&#125; 通过 async await 简化 Future 操作 1234567891011121314runUsingFuture() &#123; //... findEntrypoint().then((entrypoint) &#123; return runExecutable(entrypoint, args); &#125;).then(flushThenExit);&#125;// 简化了 thenrunUsingAsyncAwait() async &#123; //... var entrypoint = await findEntrypoint(); var exitCode = await runExecutable(entrypoint, args); await flushThenExit(exitCode);&#125; 有时候要求调用很多异步方法，并且等待 所有方法完成后再继续执行，通过使用 Future.wait() 进行管理 12345678Future deleteDone = deleteLotsOfFiles();Future copyDone = copyLotsOfFiles();Future checksumDone = checksumLotsOfOtherFiles();Future.wait([deleteDone, copyDone, checksumDone]) .then((List values) &#123; print('Done with all the long steps'); &#125;); Stream Dart|什么是 Stream：https://www.jianshu.com/p/a5d7758938ef 大概了解了 Dart 的语法，下节就开始写 Flutter 啦~，环境的安装具体查看官网，很详细 Flutter 环境安装 记得一定要配置镜像，配置镜像，配置镜像 https://flutterchina.club/get-started/install/]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter开发环境搭建Mac版]]></title>
    <url>%2Fposts%2F3223dff5.html</url>
    <content type="text"><![CDATA[系统环境要求Flutter因为是新出的框架，所以对系统还是有一定的要求的。 MacOS （64-bit） 磁盘空间：大于700M，如果算上Android Studio等编辑工具，尽量大于3G。 命令号工具：bash、mkdir、rm、git、curl、unzip、which、brew 这些命令在都可以使用。 注意：一般你会在brew这个命令下载坑，很多mac系统都没有安装这个，你可以进行安装，因为这个和本知识关系性不大，所以我就不写流程了，如果你出现问题，直接点击链接学习安装就可以了。 学习安装brew：https://segmentfault.com/a/1190000013317511 下载Flutter SDK包这里推荐去官网下载就好，我挂了梯子，速度并不慢。 网址：https://flutter.dev/docs/development/tools/sdk/releases?tab=macos 配置环境变量压缩包下载好以后，找个位置进行解压。这个位置很重要，因为下面配置环境变量的时候要用到。比如你配置到了根目录下的app文件夹。 1.打开终端工具（这个我就不用写了吧），使用vim进行配置环境变量，命令如下： 1open ~/.bash_profile 在打开的文件里增加一行代码，意思是配置flutter命令在任何地方都可以使用。 1export PATH=/app/flutter/bin:$PATH 提示：这行命令你要根据你把压缩包解压的位置来进行编写，写的是你的路径，很有可能不跟文章一样。 配置完成后，需要用source命令重新加载一下 ，具体命令如下： 1source ~/.bash_profile 完成这部以后，就算我们flutter的安装工作完成了，但是这还不能进行开发。可以使用命令来检测一下，是否安装完成了。 1flutter -h 检查开发环境到上边为止，我们安装好了Flutter，但是还不具备开发环境。开发还需要很多软件和插件的支持，那到底需要哪些插件和软件那？我们可以使用Flutter为我们提供的命令来进行检查： 1flutter doctor 如果你英文很好，你应该可以很容易读出上面的检测结果，有很多条目都没有通过。需要我们安装检测结果一条条进行安装，直到满足开发环境。（如果有[!]x标志，表示本行检测没有通过，就需要我们设置或者安装相应的软件了。） 如果你有安装，那么第一步要作的是允许协议（android-licenses）。允许方法就是在终端运行如下命令： 1flutter doctor --android-licenses 然后让你输入Y/N的时候，一路Y就可以了（至于什么意思，我也没仔细看，大概就和安装软件的下一步下一步是一样的，你按N是不能成功的）。 这不完成后，我们再使用flutter doctor进行检测后，会看到还是有很多x。 其实大概意思就是我们需要这些软件，Flutter推荐你用brew命令进行安装。 我们可以直接在终端里输入下列命令（每输完一个都要等一会，等待软件包安装完成） 12345brew install --HEAD libimobiledevicebrew install ideviceinstallerbrew install ios-deploybrew install cocoapodspod setup 安装完这些，我们还需要为Android Studio安装一下Flutter插件（这个有可能你安装过，如果出现下面的提示，说明你还没有安装） 12✗ Flutter plugin not installed; this adds Flutter specific functionality.✗ Dart plugin not installed; this adds Dart specific functionality. 打开Android Stuido 软件，然后找到Plugin的配置，搜索Flutter插件。 点中间的Search in repositories,然后点击安装。 安装完成后，你需要重新启动一下Android Studio软件。 Pub源的配置如果你没有梯子，一个人人都知道的原因，你还需要在环境变量里配置一下Pub源，不然你是无法进行使用的。 运行： 1open ~/.bash_profile 增加两行配置 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 重新加载环境变量 1source ~/.bash_profile Android studio新建Flutter项目打开Andorid Studio ，会出现下面的界面，我们选择第二项，新建Flutter项目。 打开第二个窗口后，选择第一个选项Flutter Application(flutter应用)。 这步完成后，系统就会自动为我们创建一个Flutter项目 安装AVD虚拟机 现在需要一个虚拟机来运行我们的程序，可以点击Android Studio中的上方菜单tool -AVD Manager选项。 出现新建菜单，选择Create Virtual Device.....,如果你一个虚拟机也没建过，这个选项在对话框的中间 选择虚拟机类型，这个你随意选就好，我选择的是Nexus 5x。（如果你屏幕小，就选择一个小屏幕的虚拟机）![image-20190528113941915](/Users/zhangmiao/Library/Application Support/typora-user-images/image-20190528113941915.png) 选择系统，这里尽量选择最新的，我选择了Android 9.0系统，选择好后，又是一个漫长的等待过程。 安装好后，点击开始按钮，运行虚拟机了（第一次运行，需要安装系统，会慢一些），运行起来后，如下图。 让Flutter跑起来虚拟机运行以后，可以点击debug按钮，让Flutter程序跑起来。如果你幸运的话，你的Flutter程序经过编译后，就会跑起来了。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android和java泛型扫盲]]></title>
    <url>%2Fposts%2Fc4ef6275.html</url>
    <content type="text"><![CDATA[Android、Java泛型扫盲首先我们定义A、B、C、D四个类，他们的关系如下 1234class A &#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125;class D extends C &#123;&#125; 不指明泛型类型12345678//以下代码均编译通过List list = new ArrayList();//不指明泛型类型，泛型默认为Object类型，故能往里面添加任意实例对象list.add(new A());list.add(new B());list.add(new C());//取出则默认为Object类型Object o = list.get(0); 这个好理解，因为所有的类都继承与Object，故能往list里面添加任意实例对象 无边界通配符 ？首先我们要明白一个概念，通配符？意义就是它是一个未知的符号，可以是代表任意的类。 123456789101112131415//我们发现，这样写编译不通过，原因很简单，泛型不匹配，虽然B继承AList&lt;A&gt; listA = new ArrayList&lt;B&gt;(); //以下5行代码均编译通过List&lt;?&gt; list;list = new ArrayList&lt;A&gt;();list = new ArrayList&lt;B&gt;();list = new ArrayList&lt;C&gt;();list = new ArrayList&lt;D&gt;();Object o = list.get(0); //编译通过list.add(new A()); //编译不通过list.add(new B()); //编译不通过list.add(new C()); //编译不通过list.add(new D()); //编译不通过 知识点 无边界通配符 ？ 能取不能存。这个好理解，因为编译器不知道?具体是啥类型，故不能存；但是任意类型都继承于Object，故能取，但取出默认为Object对象。 上边界符 ？extends继续上代码 123456789List&lt;? extends C&gt; listC;listC = new ArrayList&lt;A&gt;(); //编译不通过listC = new ArrayList&lt;B&gt;(); //编译不通过listC = new ArrayList&lt;C&gt;(); //编译通过listC = new ArrayList&lt;D&gt;(); //编译通过C c = listC.get(0); //编译通过listC.add(new C()); //编译不通过listC.add(new D()); //编译不通过 知识点 上边界符 ? extends 只是限定了赋值给它的实例类型(这里为赋值给listC的实例类型)，且边界包括自身。 上边界符 ? extends 跟 ？ 一样能取不能存，道理是一样的，虽然限定了上边界，但编译器依然不知道 ? 是啥类型，故不能存；但是限定了上边界，故取出来的对象类型默认为上边界的类型 下边界符 ？super1234567891011List&lt;? super B&gt; listB;listB = new ArrayList&lt;A&gt;(); //编译通过listB = new ArrayList&lt;B&gt;(); //编译通过listB = new ArrayList&lt;C&gt;(); //编译不通过listB = new ArrayList&lt;D&gt;(); //编译不通过Object o = listB.get(0); //编译通过listB.add(new A()); //编译不通过listB.add(new B()); //编译通过listB.add(new C()); //编译通过listB.add(new D()); //编译通过 知识点 下边界符 ？super，跟上边界符一样，只是限定了赋值给它的实例类型，也包括边界自身 下边界符 ？super 能存能取，因为设定了下边界，故我们能存下边界以下的类型，当然也包括边界自身；然而取得时候编译器依然不知道 ? 具体是什么类型，故取出默认为Object类型。 类型擦除首先我们要明白一点：Java 的泛型在编译期有效，在运行期会被删除 我们来看一段代码 123//这两个方法写在同一个类里public void list(List&lt;A&gt; listA) &#123;&#125; public void list(List&lt;B&gt; listB) &#123;&#125; 上面的代码会有问题吗？显然是有的，编译器报错，提示如下信息： list(List&lt;A&gt;) clashed with list(List&lt;B&gt;) ; both methods have same erasure 翻译过来就是，在类型擦除后，两个方法具有相同的签名，我们来看看类型擦除后是什么样子 12public void list(List listA) &#123;&#125; public void list(List listB) &#123;&#125; 可以看出，两个方法签名完全一致，故编译不通过。 明白了类型擦除，我们还需要明白一个概念 泛型类并没有自己独有的Class类对象 比如并不存在List.class或是List.class，而只有List.class 接下来这个案例就好理解了 123List&lt;A&gt; listA = new ArrayList&lt;A&gt;();List&lt;B&gt; listB = new ArrayList&lt;B&gt;();System.out.println(listA.getClass() == listB.getClass()); //输出true 泛型传递现实开发中，我们经常会用到泛型传递，例如我们经常需要对Http请求返回的结果做反序列化操作 1234567public static &lt;T&gt; T fromJson(String result, Class&lt;T&gt; type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 此时我们传进去是什么类型，就会返回自动该类型的对象 12345678String result="xxx";A a = fromJson(result, A.class);B b = fromJson(result, B.class);C c = fromJson(result, C.class);D d = fromJson(result, D.class);Integer integer = fromJson(result, Integer.class);String str = fromJson(result, String.class);Boolean boo = fromJson(result, Boolean.class); 那如果我们想返回一个集合呢，如List&lt;A&gt;，下面这样明显是不对的。 12//编译报错，前面类型擦除时，我们讲过，不存List&lt;A&gt;.class这种类型ArrayList&lt;A&gt; list = fromJson(result, ArrayList&lt;A&gt;.class)； 那我们该怎么做呢？首先，我们对fromJson改造一下，如下： 123456789//type为一个数组类型public static &lt;T&gt; List&lt;T&gt; fromJson(String result, Class&lt;T[]&gt; type) &#123; try &#123; T[] arr = new Gson().fromJson(result, type);//首先拿到数组 return Arrays.asList(arr); //数组转集合 &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 这个时候我们就可以这么做了 12345678String result="xxx";List&lt;A&gt; listA = fromJson(result, A[].class);List&lt;B&gt; listB = fromJson(result, B[].class);List&lt;C&gt; listC = fromJson(result, C[].class);List&lt;D&gt; listD = fromJson(result, D[].class);List&lt;Integer&gt; listInt = fromJson(result, Integer[].class);List&lt;String&gt; listStr = fromJson(result, String[].class);List&lt;Boolean&gt; listBoo = fromJson(result, Boolean[].class); ok，我在再来，相信大多数Http接口返回的数据格式是这样的： 123456public class Response&lt;T&gt; &#123; private T data; private int code; private String msg; //省略get/set方法&#125; 那这种我们又该如何传递呢？显然用前面的两个fromJson方法都行不通，我们再来改造一下，如下: 12345678//这里我们直接传递一个Type类型public static &lt;T&gt; T fromJson(String result, Type type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 这个Type是什么鬼？点进去看看 12345public interface Type &#123; default String getTypeName() &#123; return toString(); &#125;&#125; 哦，原来就是一个接口，并且只有一个方法，我们再来看看它的实现类 发现有5个实现类，其中4个是接口，另外一个是Class类，我们再来看看Class类的声明 123456public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; //省略内部代码&#125; 现在有没有明白点，现在我们重点来关注下Type接口的其中一个实现接口ParameterizedType，我们来看下它的内部代码，里面就只有3个方法 12345678910111213141516171819202122232425262728293031public interface ParameterizedType extends Type &#123; /** * 例如: * List&lt;String&gt; list; 则返回 &#123;String.class&#125; * Map&lt;String,Long&gt; map; 则返回 &#123;String.class,Long.class&#125; * Map.Entry&lt;String,Long&gt; entry; 则返回 &#123;String.class,Long.class&#125; * * @return 以数组的形式返回所有的泛型类型 */ Type[] getActualTypeArguments(); /** * 例如: * List&lt;String&gt; list; 则返回 List.class * Map&lt;String,Long&gt; map; 则返回 Map.class * Map.Entry&lt;String,Long&gt; entry; 则返回 Entry.class * * @return 返回泛型类的真实类型 */ Type getRawType(); /** * 例如: * List&lt;String&gt; list; 则返回 null * Map&lt;String,Long&gt; map; 则返回 null * Map.Entry&lt;String,Long&gt; entry; 则返回 Map.class * * @return 返回泛型类持有者的类型，这里可以简单理解为返回外部类的类型，如果没有外部类，则返回null */ Type getOwnerType();&#125; 顾名思义，ParameterizedType 代表一个参数化类型。 这个时候我们来自定义一个类，并实现ParameterizedType接口，如下： 12345678910111213141516171819202122public class ParameterizedTypeImpl implements ParameterizedType &#123; private Type rawType;//真实类型 private Type actualType;//泛型类型 public ResponseType(Type rawType,Type actualType) &#123; this.rawType = rawType; this.actualType = actualType; &#125; public Type[] getActualTypeArguments() &#123; return new Type[]&#123;actualType&#125;; &#125; public Type getRawType() &#123; return rawType; &#125; public Type getOwnerType() &#123; return null; &#125;&#125; 我们再次贴出fromJson方法 12345678//这里我们直接传递一个Type类型public static &lt;T&gt; T fromJson(String result, Type type) &#123; try &#123; return new Gson().fromJson(result, type); &#125; catch (Exception ignore) &#123; return null; &#125;&#125; 此时我们想得到Response&lt;T&gt;对象，就可以这样写 123Response&lt;A&gt; responseA = fromJson(result, new ParameterizedTypeImpl(Response.class, A.class));Response&lt;B&gt; responseB = fromJson(result, new ParameterizedTypeImpl(Response.class, B.class));Response&lt;C&gt; responseC = fromJson(result, new ParameterizedTypeImpl(Response.class, C.class)); 想得到List&lt;T&gt;对象，也可以通过ParameterizedTypeImpl得到，如下: 123List&lt;A&gt; listA = fromJson(result, new ParameterizedTypeImpl(List.class, A.class));List&lt;B&gt; listB = fromJson(result, new ParameterizedTypeImpl(List.class, B.class));List&lt;C&gt; listC = fromJson(result, new ParameterizedTypeImpl(List.class, C.class)); 然而，如果我们想得到Response&lt;List&lt;T&gt;&gt;对象，又该如何得到呢？ ParameterizedTypeImpl一样能够实现，如下： 1234567891011121314//第一步，创建List&lt;T&gt;对象对应的Type类型Type listAType = new ParameterizedTypeImpl(List.class, A.class);Type listBType = new ParameterizedTypeImpl(List.class, B.class);Type listCType = new ParameterizedTypeImpl(List.class, C.class);//第二步，创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型Type responseListAType = new ParameterizedTypeImpl(Response.class, listAType);Type responseListBType = new ParameterizedTypeImpl(Response.class, listBType);Type responseListCType = new ParameterizedTypeImpl(Response.class, listCType);//第三步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType); 然后，能不能再简单一点呢？可以，我们对ParameterizedTypeImpl改造一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * User: ljx * Date: 2018/10/23 * Time: 09:36 */public class ParameterizedTypeImpl implements ParameterizedType &#123; private final Type rawType; private final Type ownerType; private final Type[] actualTypeArguments; //适用于单个泛型参数的类 public ParameterizedTypeImpl(Type rawType, Type actualType) &#123; this(null, rawType, actualType); &#125; //适用于多个泛型参数的类 public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... actualTypeArguments) &#123; this.rawType = rawType; this.ownerType = ownerType; this.actualTypeArguments = actualTypeArguments; &#125; /** * 本方法仅使用于单个泛型参数的类 * 根据types数组，确定具体的泛型类型 * List&lt;List&lt;String&gt;&gt; 对应 get(List.class, List.class, String.class) * * @param types Type数组 * @return ParameterizedTypeImpl */ public static ParameterizedTypeImpl get(@NonNull Type rawType, @NonNull Type... types) &#123; final int length = types.length; if (length &gt; 1) &#123; Type parameterizedType = new ParameterizedTypeImpl(types[length - 2], types[length - 1]); Type[] newTypes = Arrays.copyOf(types, length - 1); newTypes[newTypes.length - 1] = parameterizedType; return get(rawType, newTypes); &#125; return new ParameterizedTypeImpl(rawType, types[0]); &#125; //适用于多个泛型参数的类 public static ParameterizedTypeImpl getParameterized(@NonNull Type rawType, @NonNull Type... actualTypeArguments) &#123; return new ParameterizedTypeImpl(null, rawType, actualTypeArguments); &#125; public final Type[] getActualTypeArguments() &#123; return actualTypeArguments; &#125; public final Type getOwnerType() &#123; return ownerType; &#125; public final Type getRawType() &#123; return rawType; &#125;&#125; 此时，我们就可以这样写 123456789//第一步，直接创建Response&lt;List&lt;T&gt;&gt;对象对应的Type类型Type responseListAType = ParameterizedTypeImpl.get(Response.class, List.class, A.class);Type responseListBType = ParameterizedTypeImpl.get(Response.class, List.class, B.class)Type responseListCType = ParameterizedTypeImpl.get(Response.class, List.class, C.class)//第二步，通过Type对象，获取对应的Response&lt;List&lt;T&gt;&gt;对象Response&lt;List&lt;A&gt;&gt; responseListA = fromJson(result, responseListAType);Response&lt;List&lt;B&gt;&gt; responseListB = fromJson(result, responseListBType);Response&lt;List&lt;C&gt;&gt; responseListC = fromJson(result, responseListCType); 现实开发中，我们还可能遇到这样的数据结构 12345678&#123; "code": 0, "msg": "", "data": &#123; "totalPage": 0, "list": [] &#125;&#125; 此时，Response&lt;T&gt; 里面的泛型传List肯定是不能正常解析的，我们需要再定一个类 12345public class PageList&lt;T&gt;&#123; private int totalPage; private List&lt;T&gt; list; //省略get/set方法&#125; 此时就可以这样解析数据 123456789//第一步，直接创建Response&lt;PageList&lt;T&gt;&gt;对象对应的Type类型Type responsePageListAType = ParameterizedTypeImpl.get(Response.class, PageList.class, A.class);Type responsePageListBType = ParameterizedTypeImpl.get(Response.class, PageList.class, B.class)Type responsePageListCType = ParameterizedTypeImpl.get(Response.class, PageList.class, C.class)//第二步，通过Type对象，获取对应的Response&lt;PageList&lt;T&gt;&gt;对象Response&lt;PageList&lt;A&gt;&gt; responsePageListA = fromJson(result, responsePageListAType);Response&lt;PageList&lt;B&gt;&gt; responsePageListB = fromJson(result, responsePageListBType);Response&lt;PageList&lt;C&gt;&gt; responsePageListC = fromJson(result, responsePageListCType); 注：ParameterizedTypeImpl get(Type... types)仅仅适用于单个泛型参数的时候，如Map等，有两个泛型参数以上的不要用此方法获取Type类型。如果需要获取Map等两个泛型参数以上的Type类型。可调用getParameterized(@NonNull Type rawType, @NonNull Type... actualTypeArguments)构造方法获取，如： 12345//获取 Map&lt;String,String&gt; 对应的Type类型Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, String.classs, String.class)//获取 Map&lt;A,B&gt; 对应的Type类型Type mapType = ParameterizedTypeImpl.getParameterized(Map.class, A.classs, B.class) 到这，泛型相关知识点讲解完毕，如有疑问，请留言。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5 to ESNext 自2015以来JavaScript新增的所有新特性]]></title>
    <url>%2Fposts%2Fbf9085e4.html</url>
    <content type="text"><![CDATA[这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。 JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。 JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。 目录ECMAScript 简介ES2015 let 和 const 箭头函数 类 默认参数 模板字符串 解构赋值 增强的对象字面量 For-of 循环 Promises 模块 String 新方法 Object 新方法 展开运算符 Set Map Generators ES2016 Array.prototype.includes() 求幂运算符 ES2017 字符串填充 Object.values() Object.entries() Object.getOwnPropertyDescriptors() 尾逗号 共享内存 and 原子操作 ES2018 Rest/Spread Properties Asynchronous iteration Promise.prototype.finally() 正则表达式改进 ESNext Array.prototype.{flat,flatMap} try/catch 可选的参数绑定 Object.fromEntries() String.prototype.{trimStart,trimEnd} Symbol.prototype.description JSON improvements Well-formed JSON.stringify() Function.prototype.toString() ECMAScript 简介每当阅读 JavaScript 相关的文章时，我都会经常遇到如下术语： ES3, ES5, ES6, ES7, ES8, ES2015, ES2016, ES2017, ECMAScript 2017, ECMAScript 2016, ECMAScript 2015 等等，那么它们是指代的是什么？ 它们都是指代一个名为 ECMAScript 的标准。 JavaScript 就是基于这个标准实现的，ECMAScript 经常缩写为 ES。 除了 JavaScript 以外，其它基于 ECMAScript 实现语言包括： ActionScript ( Flash 脚本语言)，由于 Adobe 将于 2020 年末停止对 Flash 的支持而逐渐失去热度。 JScript (微软开发的脚本语言),在第一次浏览器大战最激烈的时期，JavaScript 只被Netscape所支持，微软必须为 Internet Explorer 构建自己的脚本语言。 但是现在流传最广、影响最大的基于 ES 标准的语言实现无疑就是 JavaScript了 为啥要用这个奇怪的名字呢？Ecma International 是瑞士标准协会，负责制定国际标准。 JavaScript 被创建以后，经由 Netscape 和 Sun Microsystems 公司提交给欧洲计算机制造商协会进行标准化，被采纳的 ECMA-262 别名叫 ECMAScript。 This press release by Netscape and Sun Microsystems (the maker of Java) might help figure out the name choice, which might include legal and branding issues by Microsoft which was in the committee, according to Wikipedia. IE9 之后微软的浏览器中就看不到对 JScript 这个命名的引用了，取而代之都统称为 JavaScript。 因此，截至201x，JavaScript 成为最流行的基于 ECMAScript 规范实现的语言。 ECMAScript 当前的版本。目前的最新的 ECMAScript 版本是 ES2018。 于 2018 年 6 月发布。 TC39 是什么？TC39（Technical Committee 39）是一个推动 JavaScript 发展的委员会。 TC39的成员包括各个主流浏览器厂商以及业务与浏览器紧密相连的公司，其中包括 Mozilla，Google ，Facebook，Apple，Microsoft，Intel，PayPal，SalesForce等。 每个标准版本提案都必须经过四个不同的阶段，这里有详细的解释。 ES Versions令我费解的是 ES 版本的命名依据有时根据迭代的版本号，有时却根据年份来进行命名。而这个命名的不确定性又使得人们更加容易混淆 JS/ES 这个两个概念😄。 在 ES2015 之前，ECMAScript 各个版本的命名规范通常与跟着标准的版本更新保持一致。因此，2009年 ECMAScript 规范更新以后的的正式版本是 ES5。 Why does this happen? During the process that led to ES2015, the name was changed from ES6 to ES2015, but since this was done late, people still referenced it as ES6, and the community has not left the edition naming behind — the world is still calling ES releases by edition number. 为什么会发生这一切？在ES2015诞生的过程中，名称由ES6更改为ES2015，但由于最终完成太晚，人们仍然称其为ES6，社区也没有将版本号完全抛之于后 — 世界仍然使用 ES 来定义版本号。 接下来，我们来深入了解 JavaScript 自 ES5 以来增加的特性。 let和constES2015 之前, var 是唯一可以用来声明变量的语句。 1var a = 0 上面语句如果你遗漏了 var，那么你会把这个值（0）赋给一个未声明的变量，其中声明和未声明变量之间存在一些差异。 在现代浏览器开启严格模式时，给未声明的变量赋值会抛出 ReferenceError 异常，在较老的浏览器（或者禁用严格模式）的情况下，未声明的变量在执行赋值操作时会隐式的变为全局对象的属性。 当你声明一个变量却没有进行初始化，那么它的值直到你对它进行赋值操作之前都是 undefined 。 1var a //typeof a === 'undefined' 你可以对一个变量进行多次重新声明，并覆盖它： 12var a = 1var a = 2 你也可以在一条声明语句中一次声明多个变量： 1var a = 1, b = 2 作用域是变量可访问的代码部分。 在函数之外用 var 声明的会分配给全局对象，这种变量可以在全局作用域中被访问到。而在函数内部声明的变量只能在函数局部作用域被访问到，这类似于函数参数。 在函数中定义的局部变量名如何跟全局变量重名，那么局部变量的优先级更高，在函数内无法访问到同名的全局变量。 需要注意的是，var 是没有块级作用域（标识符是一对花括号）的，但是 var 是有函数作用域的，所以在新创建的块级作用域或者是函数作用域里面声明变量会覆盖全局同名变量，因为 var 在这两种情况下没有创建新的作用域。 在函数内部，其中定义的任何变量在所有函数代码中都是可见的，因为JavaScript在执行代码之前实际上将所有变量都移到了顶层（被称为悬挂的东西）。 在函数的内部定义的变量在整个函数作用域中都是可见（可访问），即使变量是在函数体末尾被声明，但是仍然可以再函数体开头部分被引用，因为 JavaScript存在变量提升机制。为避免混淆，请在函数开头声明变量，养成良好的编码规范。 Using letlet 是ES2015中引入的新功能，它本质上是具有块级作用域的 var 。它可以被当前作用域（函数以及块级作用域）以及子级作用域访问到。 现代 JavaScript 开发者在 let 和 var 的选择中可能会更倾向于前者。 如果 let 看起来是一个很抽象的术语，当你阅读到 let color = ‘red’ 这一段，因为使用 let 定义了color 为红色，那么这一切就变的有意义了。 在任何函数之外用 let 声明变量，和 var相反的是 它并不会创建全局变量。 Using const使用变量 var 或 let 声明的变量可以被重新赋值。 使用 const 声明的变量一经初始化，它的值就永远不能再改变，即不可重新被赋值。 1const a = 'test' 我们不能再为 a 进行赋值操作。然而，a 如果它是一个具有属性或者方法的对象，那么我们可以改变它的属性或者方法。 const 并不意味着具有不可变性，只是保证用 const 声明的变量的引用地址不被变更。 类似于 let，const 也具有块级作用域。 现代 JavaScript 开发者在遇到不会进行二次赋值的变量声明时，应该尽量使用 const。 箭头函数箭头函数的引入极大的改变了代码的书写风格和一些工作机制。 在我看来，箭头函数很受开发者欢迎，现在很少在比较新的代码库中看到 function 关键字了，虽然它并未被废弃。 箭头函数看起来会更加的简洁，因为它允许你使用更短的语法来书写函数： 123const myFunction = function() &#123; //...&#125; 到 123const myFunction = () =&gt; &#123; //...&#125; 如果函数体中只包含一条语句，你甚至可以省略大括号并直接书写这条语句： 1const myFunction = () =&gt; doSomething() 参数在括号中传递： 1const myFunction = (param1, param2) =&gt; doSomething(param1, param2) 如果该函数只有一个参数，那么可以省略掉括号： 1const myFunction = param =&gt; doSomething(param) 由于这种简短的语法，使得我们可以更便捷的使用比较简短的函数 隐式返回箭头函数支持隐式返回：可以正常的 return 一个返回值但是可以不使用 return 关键字。 隐式返回只在函数体内只包含一条语句的情况下生效： 12const myFunction = () =&gt; 'test'myFunction() //'test' 需要注意的一种情况，当返回一个对象时，记得将大括号括在括号中以避免产生歧义，误将其（大括号）解析为函数体的大括号。 12const myFunction = () =&gt; (&#123; value:'test' &#125;)myFunction() //&#123;value: 'test'&#125; 箭头函数中的 thisthis 可能是一个很难掌握的概念，因为它会根据上下文而进行变化，并且会在不同的 JavaScript的模式（是否为严格模式）下表现出差异。 理解 this 这个概念对于箭头函数的使用很重要，因为与常规函数相比，箭头函数的表现非常不同。 对象的方法为常规函数时，方法中的this指向这个对象，因此可以这样做： 1234567const car = &#123; model:'Fiesta', manufacturer:'Ford', fullName:function() &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 执行 car.fullName() 会返回 “Ford Fiesta”。 如果上述方法使用是是箭头函数，由于箭头中的 this 的作用域继承自执行上下文，箭头函数自身不绑定 this，因此 this 的值将在调用堆栈中查找，因此在此代码 car.fullName() 中不会返回常规函数那样的结果，实际会返回字符串 “undefined undefined”： 1234567const car = &#123; model:'Fiesta', manufacturer:'Ford', fullName:() =&gt; &#123; return `$&#123;this.manufacturer&#125; $&#123;this.model&#125;` &#125;&#125; 因此，箭头函数不适合作为对象方法。 同样，箭头函数也不适合使用在作为创建构造函数，因为在实例化对象时会抛出 TypeError。 所以在不需要动态上下文时请使用常规函数。 当然，在事件监听器上使用箭头函数也会存在问题。因为 DOM 事件侦听器会自动将 this 与目标元素绑定，如果该事件处理程序的逻辑依赖 this，那么需要常规函数： 12345678const link = document.querySelector('#link')link.addEventListener('click', () =&gt; &#123; // this === window&#125;)const link = document.querySelector('#link')link.addEventListener('click', function() &#123; // this === link&#125;) Classes类JavaScript 实现继承的方式比较罕见：原型继承。原型继承虽然在我看来很棒，但与其它大多数流行的编程语言的继承实现机制不同，后者是基于类的。 因此 Java、Python 或其它语言的开发者很难理解原型继承的方式，因此 ECMAScript 委员会决定在原型继承之上实现 class 的语法糖，这样便于让其它基于类实现继承的语言的开发者更好的理解 JavaScript 代码。 注意：class 并没有对 JavaScript 底层做修改，你仍然可以直接访问对象原型。 class 定义如下是一个 class 的例子： 12345678class Person &#123; constructor(name) &#123; this.name = name &#125; hello() &#123; return 'Hello, I am ' + this.name + '.' &#125;&#125; class 具有一个标识符，我们可以使用 new ClassIdentifier() 来创建一个对象实例。 初始化对象时，调用 constructor方法，并将参数传递给此方法。 类声明语句中也可以增加类需要的一些原型方法。在这种情况下 hello 是 Person 类的一个原型方法，可以在这个类的对象实例上调用： 12const flavio = new Person('Flavio')flavio.hello() Class 继承一个子类可以 extend 另一个类，通过子类实例化出来的对象可以继承这两个类的所有方法。 如果子类中的方法与父类中的方法名重复，那么子类中的同名方法优先级更高： 1234567class Programmer extends Person &#123; hello() &#123; return super.hello() + ' I am a programmer.' &#125;&#125;const flavio = new Programmer('Flavio')flavio.hello() (上述代码会打印出：“Hello, I am Flavio. I am a programmer.”) 类没有显示的类变量声明，但你必须在初始化构造函数 constructor 中去初始化类成员变量。 在子类中，你可以通过调用super()引用父类。 静态方法在类中，通常会把方法直接挂载到实例对象上，直接在实例对象上调用。 而静态方法则是直接使用类名来调用，而不是通过对象实例调用： 123456class Person &#123; static genericHello() &#123; return 'Hello' &#125;&#125;Person.genericHello() //Hello 私有方法JavaScript 没有内置真正意义上的受保护的私有方法。 社区有解决方法，但我不会在这里做讲解。 Getters 和 setters你可以通过增加方法 前缀 get 或者 set 创建一个 getter 和 setter，getter 和 setter会在你去获取特定值或者修改特定值的时候执行 get 或者 set内的相关方法。 1234567891011class Person &#123; constructor(name) &#123; this._name = name &#125; set name(value) &#123; this._name = value &#125; get name() &#123; return this._name &#125;&#125; 如果你只有 getter，该属性无法被设置，并且设置此属性的操作都会被忽略： 12345678class Person &#123; constructor(name) &#123; this._name = name &#125; get name() &#123; return this._name &#125;&#125; 如果你只有一个 setter，则可以更改该值，但不能从外部访问它： 12345678class Person &#123; constructor(name) &#123; this._name = name &#125; set name(value) &#123; this._name = value &#125;&#125; 默认参数函数 doSomething 接收一个 param1 参数。 12const doSomething = (param1) =&gt; &#123;&#125; 我们可以给 param1 设定默认值，如果在调用函数时未传入参数，那么该参数自动设定未默认值。 12const doSomething = (param1 = 'test') =&gt; &#123;&#125; 当然，这种机制同样适用于多个参数： 12const doSomething = (param1 = 'test', param2 = 'test2') =&gt; &#123;&#125; 假如你的函数是一个具有特定属性的对象该怎么处理？ 曾几何时，如果我们必须要取一个对象的特定属性值，为了做兼容处理（对象格式不正确），你必须在函数中添加一些代码： 1234567const colorize = (options) =&gt; &#123; if (!options) &#123; options = &#123;&#125; &#125; const color = ('color' in options) ? options.color :'yellow' ...&#125; 通过解构，你可以给特定属性提供默认值，如此可以大大简化代码： 123const colorize = (&#123; color = &apos;yellow&apos; &#125;) =&gt; &#123; ...&#125; 如果在调用 colorize 函数时没有传递任何对象，我们同样可以得到一个默认对象作为参数以供使用： 123const spin = (&#123; color = 'yellow' &#125; = &#123;&#125;) =&gt; &#123; ...&#125; 模板字符串模板字符串不同于 ES5 以前的版本，你可以用新颖的方式使用字符串。 这个语法看起来非常简便，只需要使用一个反引号替换掉单引号或双引号： 1const a_string = `something` 这个用法是独一无二的，因为它提供了许多普通字符串所没有的功能，如下： 它为定义多行字符串提供了一个很好的语法 它提供了一种在字符串中插入变量和表达式的简单方法 它允许您创建带有模板标签的DSL (DSL意味着领域特定语言，例如：就如同在 React 中使用 styled-components 定义你组件的 CSS 一样) 下面让我们深入每个功能的细节。 多行字符串在 ES6 标准之前，创建跨越两行的字符串只能在一行的结尾使用 ‘’ 字符： 123const string = 'first partsecond part' 这样使得你创建的字符串虽然跨越了两汉，但是渲染时仍然表现成一行： 1first part second part 需要渲染为多行的话，需要在一行结尾添加 ‘ ’，比如这样： 1234const string = 'first line second line' 或者 12const string = 'first line'+ 'second line' 模板字符串使得定义多行字符串变得更加简便。 一个模板字符串由一个反引号开始，你只需要按下回车键来创建新的一行，不需要插入特殊符号，最终的渲染效果如下所示： 1234const string = `Heythisstringis awesome!` 需要特别留意空格在这里是有特殊意义的，如果这样做的话： 12const string = `First Second` 那么它会创建出像下面的字符串： 12First Second 有一个简单的方法可以修复这个问题，只需要将第一行置为空，然后添加了右边的翻译好后调用一个 trim() 方法，就可以消除第一个字符前的所有空格： 123const string = `FirstSecond`.trim() 插值模板字符串提供了插入变量和表达式的便捷方法 你只需要使用 ${…} 语法 12const var = 'test'const string = `something $&#123;var&#125;` //something test 在 ${} 里面你可以加入任何东西，甚至是表达式： 12const string = `something $&#123;1 + 2 + 3&#125;`const string2 = `something $&#123;foo() ? 'x' : 'y'&#125;` Template tags标记模板可能是一个听起来不太有用的功能，但它实际上被许多流行的库使用，如 Styled Components 、Apollo 、GraphQL客户端/服务器库，因此了解它的工作原理至关重要。 在 Styled Components 模板标签中用于定义CSS字符串 1234const Button = styled.button` font-size: 1.5em; background-color: black; color: white; 在 Apollo 中，模板标签用于定义 GraphQL 查询模式： 12345const query = gql` query &#123; ... &#125;` 上面两个例子中的styled.button和gql模板标签其实都是函数: 1function gql(literals, ...expressions) &#123;&#125; 这个函数返回一个字符串，可以是任意类型的计算结果。 字面量(literals)是一个包含了表达式插值的模板字面量的序列。 表达式(expressions)包含了所有的插值。 举个例子： 1const string = `something $&#123;1 + 2 + 3&#125;` 这个例子里面的字面量是由2个部分组成的序列。第1部分就是something，也就是第一个插值位置(${})之前的字符串，第2部分就是一个空字符串，从第1个插值结束的位置直到字符串的结束。 这个例子里面的表达式就是只包含1个部分的序列，也就是6。 举一个更复杂的例子： 1234const string = `somethinganother $&#123;'x'&#125;new line $&#123;1 + 2 + 3&#125;test` 这个例子里面的字面量的序列里面，第1个部分是： 12;`somethinganother ` 第2部分是： 12;`new line ` 第3部分是： 12;`test` 这个例子里面的表达式包含了2个部分：x和6。 拿到了这些值的函数就可以对其做任意处理，这就是这个特性的威力所在。 比如最简单的处理就是字符串插值，把字面量和表达式拼接起来： 1const interpolated = interpolate`I paid $&#123;10&#125;€` 插值的过程就是： 12345678function interpolate(literals, ...expressions) &#123; let string = `` for (const [i, val] of expressions) &#123; string += literals[i] + val &#125; string += literals[literals.length - 1] return string&#125; 解构赋值给定一个object，你可以抽取其中的一些值并且赋值给命名的变量： 1234567const person = &#123; firstName:'Tom', lastName:'Cruise', actor:true, age:54, //made up&#125;const &#123;firstName: name, age&#125; = person name和age就包含了对应的值。 这个语法同样可以用到数组当中： 12const a = [1,2,3,4,5]const [first, second] = a 下面这个语句创建了3个新的变量，分别取的是数组a的第0、1、4下标对应的值： 1const [first, second, , , fifth] = a 更强大的对象字面量ES2015赋予了对象字面量更大的威力。 简化了包含变量的语法原来的写法： 1234const something = 'y'const x = &#123; something: something&#125; 新的写法： 1234const something = 'y'const x = &#123; something&#125; 原型原型可以这样指定： 12345678910111213const anObject = &#123; y:'y' &#125;const x = &#123; __proto__: anObject&#125;super()const anObject = &#123; y:'y', test:() =&gt; 'zoo' &#125;const x = &#123; __proto__: anObject, test() &#123; return super.test() + 'x' &#125;&#125;x.test() //zoox 动态属性1234const x = &#123; ['a' + '_' + 'b']:'z'&#125;x.a_b //z For-of循环2009年的ES5引入了forEach()循环。虽然很好用，但是它跟for循环一样，没法break。 ES2015引入了for-of 循环，就是在forEach的基础上加上了break的功能： 123456789//iterate over the valuefor (const v of ['a', 'b', 'c']) &#123; console.log(v);&#125;//get the index as well, using `entries()`for (const [i, v] of ['a', 'b', 'c'].entries()) &#123; console.log(index) //index console.log(value) //value&#125; 留意一下const的使用。这个循环在每次迭代中都会创建一个新的作用域，所以我们可以使用const来代替let。 它跟for…in的区别在于： for…of遍历属性值 for…in遍历属性名 Promisespromise的一般定义： 它是一个代理，通过它可以最终得到一个值. Promise是处理异步代码的一种方式，可以少写很多回调。 异步函数是建立在promise API上面的，所以理解Promise是一个基本的要求。 promise的原理简述一个promise被调用的时候，首先它是处于pending状态。在promise处理的过程中，调用的函数（caller）可以继续执行，直到promise给出反馈。 此时，调用的函数等待的promise结果要么是resolved状态，要么是rejected状态。但是由于JavaScript是异步的，所以promise处理的过程中，函数会继续执行。 为什么JS API使用promises?除了你的代码和第三方库的代码之外，promise在用在现代的Web API中，比如： 电池API Fetch API Service Workers 在现代的JavaScript中，不使用promise是不太可能的，所以我们来深入研究下promise吧。 创建一个promisePromise API暴露了一个Promise构造函数，可以通过new Promise()来初始化： 12345678910let done = trueconst isItDoneYet = new Promise((resolve, reject) =&gt; &#123; if (done) &#123; const workDone = 'Here is the thing I built' resolve(workDone) &#125; else &#123; const why = 'Still working on something else' reject(why) &#125;&#125;) promise会检查done这个全局变量，如果为true，就返回一个resolved promise，否则就返回一个rejected promise。 通过resolve和reject，我们可以得到一个返回值，返回值可以是字符串也可以是对象。 使用一个promise上面讲了怎么创建一个promise，下面就讲怎么使用（consume）这个promise。 1234567891011const isItDoneYet = new Promise()//...const checkIfItsDone = () =&gt; &#123; isItDoneYet .then(ok =&gt; &#123; console.log(ok) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;)&#125; 运行checkIfItsDone()方法时，会执行isItDoneYet()这个promise，并且等待它resolve的时候使用then回调，如果有错误，就用catch回调来处理。 链式promise一个promise可以返回另一个promise，从而创建promise链条（chain）。 一个很好的例子就是Fetch API，它是基于XMLHttpRequest API的一个上层API，我们可以用它来获取资源，并且在获取到资源的时候链式执行一系列promise。 Fetch API是一个基于promise的机制，调用fetch()相当于使用new Promise()来声明我们自己的promise。 链式promise的例子 12345678910111213141516const status = response =&gt; &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return Promise.resolve(response) &#125; return Promise.reject(new Error(response.statusText))&#125;const json = response =&gt; response.json()fetch('/todos.json') .then(status) .then(json) .then(data =&gt; &#123; console.log('Request succeeded with JSON response', data) &#125;) .catch(error =&gt; &#123; console.log('Request failed', error) &#125;) 在这个例子当中，我们调用fetch()，从根目录的todos.json文件中获取一系列的TODO项目，并且创建一个链式promise。 运行fetch()方法会返回一个response，它包含很多属性，我们从中引用如下属性： status, 一个数值，表示HTTP状态码 statusText, 一个状态消息，当请求成功的时候返回OK response还有一个json()方法，它返回一个promise，返回内容转换成JSON后的结果。 所以这些promise的调用过程就是：第一个promise执行一个我们定义的status()方法，检查response status，判断是否一个成功的响应(status在200和299之间)，如果不是成功的响应，就reject这个promise。 这个reject操作会导致整个链式promise跳过后面的所有promise直接到catch()语句，打印Request failed和错误消息。 如果这个promise成功了，它会调用我们定义的json()函数。因为前面的promise成功之后返回的response对象，我们可以拿到并作为第2个promise的参数传入。 在这个例子里面，我们返回了JSON序列化的数据，所以第3个promise直接接收这个JSON： 123.then((data) =&gt; &#123; console.log('Request succeeded with JSON response', data)&#125;) 然后我们把它打印到console。 处理错误在上一节的的例子里面，我们有一个catch接在链式promise后面。 当promise链中的任意一个出错或者reject的时候，就会直接跳到promise链后面最近的catch()语句。 1234567891011new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;).catch(err =&gt; &#123; console.error(err)&#125;)// ornew Promise((resolve, reject) =&gt; &#123; reject('Error')&#125;).catch(err =&gt; &#123; console.error(err)&#125;) 级联错误如果在catch()里面抛出一个错误，你可以在后面接上第二个catch()来处理这个错误，以此类推。 123456789new Promise((resolve, reject) =&gt; &#123; throw new Error('Error')&#125;) .catch(err =&gt; &#123; throw new Error('Error') &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 组织多个promisePromise.all()如果你要同时完成不同的promise,可以用Promise.all()来声明一系列的promise，然后当它们全部resolve的时候再执行一些操作。 例子： 123456789const f1 = fetch('/something.json')const f2 = fetch('/something2.json')Promise.all([f1, f2]) .then(res =&gt; &#123; console.log('Array of results', res) &#125;) .catch(err =&gt; &#123; console.error(err) &#125;) 结合ES2015的解构赋值语法，你可以这样写： 123Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123; console.log('Results', res1, res2)&#125;) 当然这不限于使用fetch， 这适用于任何promise. Promise.race()Promise.race()运行所有传递进去的promise，但是只要有其中一个resolve了，就会运行回调函数，并且只执行一次回调，回调的参数就是第一个resolve的promise返回的结果。 例子： 123456789const promiseOne = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, 'one')&#125;)const promiseTwo = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'two')&#125;)Promise.race([promiseOne, promiseTwo]).then(result =&gt; &#123; console.log(result) // 'two'&#125;) 模块ES Module是用于处理模块的ECMAScript标准。 虽然 Node.js 多年来一直使用 CommonJS标准，但浏览器却从未有过模块系统，因为模块系统的决策首先需要 ECMAScript 标准化后才由浏览器厂商去实施实现。 这个标准化已经完成在 ES2015中，浏览器也开始实施实现这个标准，大家试图保持一致，以相同的方式工作。现在 ES Module 可以在 Chrome Safari Edge 和 Firefox（从60版本开始） 中使用。 模块非常酷，他们可以让你封装各种各样的功能，同时将这些功能作为库暴露给其它 JavaScript 文件使用。 ES 模块语法引入模块的语法: 1import package from 'module-name' CommonJS 则是这样使用： 1const package = require('module-name') 一个模块是一个 JavaScript 文件，这个文件使用 export 关键字 导出 一个或多个值（对象、函数或者变量）。例如，下面这个模块提供了一个将字符串变成大写形式的函数： 12uppercase.jsexport default str =&gt; str.toUpperCase() 在这个例子中，这个模块定义了唯一一个 default export，因此可以是一个匿名函数。否则，需要一个名称来和其它 导出 做区分。 现在，任何其它的 JavaScript 模块 可以通过 import 导入 uppercase.js 的这个功能。 一个 HTML 页面可以通过使用了特殊的 type=module 属性的 &lt;script&gt; 标签添加一个模块。 1&lt;script type="module" src="index.js"&gt;&lt;/script&gt; 注意: 这个模块导入的行为就像 defer 脚本加载一样。具体可以看 efficiently load JavaScript with defer and async 需要特别注意的是，任何通过 type=”module” 载入的脚本会使用 严格模式 加载。 在这个例子中，uppercase.js 模块定义了一个 default export，因此当我们在导入它的时候，我们可以给他起一个任何我们喜欢的名字： 1import toUpperCase from './uppercase.js' 同时我们可以这样使用它: 1toUpperCase('test') //'TEST' 你也可以通过一个绝对路径来导入模块，下面是一个引用来自其它域底下定义的模块的例子： 1import toUpperCase from 'https://flavio-es-modules-example.glitch.me/uppercase.js' 下面同样是一些合法的 import语法： 12import &#123; toUpperCase &#125; from '/uppercase.js'import &#123; toUpperCase &#125; from '../uppercase.js' 下面是错误的使用: 12import &#123; toUpperCase &#125; from 'uppercase.js'import &#123; toUpperCase &#125; from 'utils/uppercase.js' 因为这里既不是使用绝对地址，也不是使用的相对地址。 其它的 import/export 语法我们了解了上面的例子： 1export default str =&gt; str.toUpperCase() 这里生成了一个 default export。然而，你可以通过下面的语法在一个文件里面 导出 多个功能： 1234const a = 1const b = 2const c = 3export &#123; a, b, c &#125; 另外一个模块可以使用下面的方式 import 导入所有： 1import * from 'module' 你也可以通过解构赋值的方式仅仅 import 导出一部分： 12import &#123; a &#125; from 'module'import &#123; a, b &#125; from 'module' 为了方便，你还可以使用 as 重命名任何 import 的东西： 1import &#123; a, b as two &#125; from 'module' 你可以导入模块中的默认出口以及通过名称导入任何非默认的出口： 1import React, &#123; Component &#125; from 'react' 这是一篇关于 ES 模块的文章，可以看一下： https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html CORS(跨域资源共享)进行远程获取模块的时候是遵循 CORS 机制的。这意味着当你引用远程模块的时候，必须使用合法的 CORS 请求头来允许跨域访问（例如：Access-Control-Allow-Origin: *）。 对于不支持模块的浏览器应该怎么做？结合 type=”module”、nomodule 一起使用： 12&lt;script type="module" src="module.js"&gt;&lt;/script&gt;&lt;script nomodule src="fallback.js"&gt;&lt;/script&gt; 包装模块ES 模块是现代浏览器中的一大特性。这些特性是 ES6 规范中的一部分，要在浏览器中全部实现这些特性的路还很漫长。 我们现在就能使用它们！但是我们同样需要知道，有一些模块会对我们的页面性能产生性能影响。因为浏览器必须要在运行时执行它们。 Webpack 可能仍然会被大量使用，即使 ES 模块可以在浏览器中执行。但是语言内置这个特性对于客户端和 nodejs 在使用模块的时候是一种巨大的统一。 新的字符串方法任何字符串有了一些实例方法： repeat() codePointAt() repeat() 根据指定的次数重复字符串： 1'Ho'.repeat(3) //'HoHoHo' 没有提供参数以及使用 0 作为参数的时候返回空字符串。如果给一个负数参数则会得到一个 RangeError 的错误。 codePointAt()这个方法能用在处理那些需要 2 个 UTF-16 单元表示的字符上。 使用 charCodeAt 的话，你需要先分别得到两个 UTF-16 的编码然后结合它们。但是使用 codePointAt() 你可以直接得到整个字符。 下面是一个例子，中文的 “𠮷” 是由两个 UTF-16 编码组合而成的： 12"𠮷".charCodeAt(0).toString(16) //d842"𠮷".charCodeAt(1).toString(16) //dfb7 如果你将两个 unicode 字符组合起来： 1"𠮷" //"𠮷" 你也可以用 codePointAt() 得到同样的结果: 1"𠮷".codePointAt(0) //20bb7 如果你将得到的 unicode 编码组合起来： 1"𠮷" //"𠮷" 更多关于 Unicode 的使用方法，参考我的Unicode guide。 新的对象方法ES2015 在 Object 类下引入了一些静态方法： Object.is() 确定两个值是不是同一个 Object.assign() 用来浅拷贝一个对象 Object.setPrototypeOf 设置一个对象的原型 Object.is() 这个方法用来帮助比较对象的值： 使用方式: 1Object.is(a, b) 返回值在下列情况之外一直是 false： a 和 b 是同一个对象 a 和 b 是相等的字符串(用同样的字符组合在一起的字符串是相等的) a 和 b 是相等的数字 a 和 b 都是 undefined, null, NaN, true 或者都是 false 0 和 -0 在 JavaScript 里面是不同的值, 所以对这种情况要多加小心（例如在比较之前，使用 + 一元操作符将所有值转换成 +0）。 Object.assign()在 ES2015 版本中引入，这个方法拷贝所有给出的对象中的可枚举的自身属性到另一个对象中。 这个 API 的基本用法是创建一个对象的浅拷贝。 1const copied = Object.assign(&#123;&#125;, original) 作为浅拷贝，值会被复制，对象则是拷贝其引用（不是对象本身），因此当你修改了源对象的一个属性值，这个修改也会在拷贝出的对象中生效，因为内部引用的对象是相同的。: 1234567891011const original = &#123; name:'Fiesta', car:&#123; color:'blue' &#125;&#125;const copied = Object.assign(&#123;&#125;, original)original.name = 'Focus'original.car.color = 'yellow'copied.name //Fiestacopied.car.color //yellow 我之前提到过，源对象可以是一个或者多个: 123456789const wisePerson = &#123; isWise:true&#125;const foolishPerson = &#123; isFoolish:true&#125;const wiseAndFoolishPerson = Object.assign(&#123;&#125;, wisePerson, foolishPerson)console.log(wiseAndFoolishPerson) //&#123; isWise: true, isFoolish: true &#125;Object.setPrototypeOf() 设置一个对象的原型。可以接受两个参数：对象以及原型。 使用方法: 1Object.setPrototypeOf(object, prototype) 例子: 1234567891011121314const animal = &#123; isAnimal:true&#125;const mammal = &#123; isMammal:true&#125;mammal.__proto__ = animalmammal.isAnimal //trueconst dog = Object.create(animal)dog.isAnimal //trueconsole.log(dog.isMammal) //undefinedObject.setPrototypeOf(dog, mammal)dog.isAnimal //truedog.isMammal //true 展开操作符你可以展开一个数组、一个对象甚至是一个字符串，通过使用展开操作符 …。 让我们以数组来举例，给出： 1const a = [1, 2, 3] 你可以使用下面的方式创建出一个新的数组： 1const b = [...a, 4, 5, 6] 你也可以像下面这样创建一个数组的拷贝： 1const c = [...a] 这中方式对于对象仍然有效。使用下面的方式克隆一个对象： 1const newObj = &#123; ...oldObj &#125; 用在字符串上的时候，展开操作符会以字符串中的每一个字符创建一个数组： 12const hey = 'hey'const arrayized = [...hey] // ['h', 'e', 'y'] 这个操作符有一些非常有用的应用。其中最重要的一点就是以一种非常简单的方式使用数组作为函数参数的能力： 123const f = (foo, bar) =&gt; &#123;&#125;const a = [1, 2]f(...a) （在之前的语法规范中，你只能通过 f.apply(null, a) 的方式来实现，但是这种方式不是很友好和易读。） 剩余参数（rest element）在和数组解构（array destructuring）搭配使用的时候非常有用。 12const numbers = [1, 2, 3, 4, 5][first, second, ...others] = numbers 下面是展开元素 （spread elements）: 123const numbers = [1, 2, 3, 4, 5]const sum = (a, b, c, d, e) =&gt; a + b + c + d + econst sum = sum(...numbers) ES2018 引入了 剩余属性 ，同样的操作符但是只能用在对象上。 剩余属性（Rest properties）:12345678910const &#123; first, second, ...others &#125; = &#123; first:1, second:2, third:3, fourth:4, fifth:5&#125;first // 1second // 2others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 属性展开（Spread properties）允许我们结合跟在 … 操作符之后对象的属性： 12const items = &#123; first, second, ...others &#125;items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; Set一个 Set 数据结构允许我们在一个容器里面增加数据。 一个 Set 是一个对象或者基础数据类型（strings、numbers或者booleans）的集合，你可以将它看作是一个 Map，其中值作为映射键，map 值始终为 true。 初始化一个 SetSet 可以通过下面的方式初始化： 1const s = new Set() 向 Set 中添加一项你可以使用 add 方法向 Set 中添加项： 12s.add('one')s.add('two') Set 仅会存贮唯一的元素，因此多次调用 s.add(‘one’) 不会重复添加新的元素。 你不可以同时向 set 中加入多个元素。你需要多次调用 add() 方法。 检查元素是否在 set 中我们可以通过下面的方式检查元素是否在 set 中： 12s.has('one') //trues.has('three') //false 从 set 中删除一个元素：使用 delete() 方法： 1s.delete('one') 确定 set 中元素的数量使用 size 属性： 1s.size 删除 set 中的全部元素使用 clear() 方法： 1s.clear() 对 set 进行迭代使用 keys() 或者 values() 方法 - 它们等价于下面的代码： 123456for (const k of s.keys()) &#123; console.log(k)&#125;for (const k of s.values()) &#123; console.log(k)&#125; entries() 方法返回一个迭代器，你可以这样使用它： 12const i = s.entries()console.log(i.next()) 调用 i.next() 将会以 { value, done = false } 对象的形式返回每一个元素，直到迭代结束，这时 done 是 true。 你也可以调用 set 的 forEach() 方法： 1s.forEach(v =&gt; console.log(v)) 或者你就直接使用 for..of 循环吧： 123for (const k of s) &#123; console.log(k)&#125; 使用一些初始值初始化一个 set你可以使用一些值初始化一个 set： 1const s = new Set([1, 2, 3, 4]) 将 set 转换为一个数组 123const a = [...s.keys()]// orconst a = [...s.values()] WeakSet一个 WeakSet 是一个特殊的 Set. 在 set 中，元素不会被 gc（垃圾回收）。一个 weakSet 让它的所有元素都是可以被 gc 的。weakSet 中的每个键都是一个对象。当这个对象的引用消失的时候，对应的值就可以被 gc 了。 下面是主要的不同点： WeakSet 不可迭代 你不能清空 weakSet 中的所有元素 不能够得到 weakSet 的大小 一个 weakSet 通常是在框架级别的代码中使用，仅仅暴露了下面的方法： add() has() delete() Map一份map结构的数据允许我们建立数据和key的关系 在ES6之前在引入Map之前，开发者通常把对象(Object)当Map使用，把某个object或value值与指定的key进行关联: 1234567const car = &#123;&#125;car['color'] = 'red'car.owner = 'Flavio'console.log(car['color']) //redconsole.log(car.color) //redconsole.log(car.owner) //Flavioconsole.log(car['owner']) //Flavio 引入Map之后ES6引入了Map数据结构，它为我们处理这种数据结构提供了一种合适的工具 Map的初始化: 1const m = new Map() 添加条目到Map中 你可以通过set()方法把条目设定到map中： 12m.set(&apos;color&apos;, &apos;red&apos;)m.set(&apos;age&apos;, 2) 通过key值从map中获取条目 你可以通过get()方法从map中取出条目: 12const color = m.get('color')const age = m.get('age') 通过key值从map中删除条目 使用delete()方法： 1m.delete('color') 从map中删除所有条目 使用clear()方法： 1m.clear() 通过key值检查map中是否含有某个条目 使用has()方法 1const hasColor = m.has('color') 获取map中的条目数量 使用 size 属性: 1const size = m.size 用value值初始化一个map 你可以用一组value来初始化一个map： 1const m = new Map([['color', 'red'], ['owner', 'Flavio'], ['age', 2]]) Map 的key值 任何值(对象，数组，字符串，数字)都可以作为一个map的value值(使用key-value键值的形式)，任何值也可以用作key，即使是object对象。 如果你想通过get()方法从map中获取不存在的key，它将会返回undefined 在真实世界中你几乎不可能找到的诡异情况 123456const m = new Map()m.set(NaN, 'test')m.get(NaN) //testconst m = new Map()m.set(+0, 'test')m.get(-0) //test 使用Iterate迭代器获取map的keys值 Map提供了keys()方法，通过该方法我们可以迭代出所有的key值: 123for (const k of m.keys()) &#123; console.log(k)&#125; 使用Iterate迭代器获取map的values值 Map提供了values()方法，通过该方法我们可以迭代出所有的value值: 123for (const v of m.values()) &#123; console.log(v)&#125; 使用Iterate迭代器获取key-value组成的键值对 Map提供了entries()方法，通过该方法我们可以迭代出所有的键值对: 123for (const [k, v] of m.entries()) &#123; console.log(k, v)&#125; 使用方法还可以简化为： 123for (const [k, v] of m) &#123; console.log(k, v)&#125; 将map的keys值转换为数组 1const a = [...m.keys()] 将map的values值转换为数组 1const a = [...m.values()] WeakMapWeakMap是一种特殊的Map 在一个map对象中，定义在其上数据永远不会被垃圾回收，WeakMap替而代之的是它允许在它上面定义的数据可以自由的被垃圾回收走，WeakMap的每一个key都是一个对象，当指向该对象的指针丢失，与之对应的value就会被垃圾回收走。 这是WeakMap的主要不同处： 你不可以在WeakMap上迭代keys值和values值(或者key-value键值对) 你不可以从WeakMap上清除所有条目 你不可以获取WeakMap的大小WeakMap提供了如下几种方法，这些方法的使用和在Map中一样： get(k) set(k, v) has(k) delete(k) 关于WeakMap的用例不如Map的用例那么明显，你可能永远也不会在哪里会用到它，但从实际出发，WeakMap可以构建不会干扰到垃圾回收机制的内存敏感性缓存，还可以满足封装的严谨性及信息的隐藏性需求。 Generators生成器Generators是一种特殊的函数，它能够暂停自身的执行并在一段时间后再继续运行，从而允许其它的代码在此期间运行(有关该主题的详细说明，请参阅完整的“javascript生成器指南”)。 Generators的代码决定它必须等待，因此它允许队列中的其它代码运行，并保留“当它等待的事情”完成时恢复其操作的权力。 所有这一切都是通过一个简单的关键字“yield`”完成的。当生成器包含该关键字时，将停止执行。 generator生成器可以包含许多yield关键字，从而使自己能多次停止运行，它是由*function关键字标识(不要将其与C、C++或Go等低级语言中使用的取消指针引用操作符混淆)。 Generators支持JavaScript中全新的编程范式，包括： 在generator运行时支持双向通信 不会“冻结”长期运行在程序中的while循环 这里有一个解释generator如何工作的例子： 12345function *calculator(input) &#123; var doubleThat = 2 * (yield (input / 2)) var another = yield (doubleThat) return (input * doubleThat * another)&#125; 我们先初始化它： 1const calc = calculator(10) 然后我们在generator中开始进行iterator迭代： calc.next()第一个迭代器开始了迭代，代码返回如下object对象： 1234&#123; done:false value:5&#125; 具体过程如下：代码运行了函数，并把input=10传入到生成器构造函数中，该函数一直运行直到抵达yield，并返回yield输出的内容: input / 2 = 5，因此，我们得到的值为5，并告知迭代器还没有done(函数只是暂停了)。 在第二个迭代处，我们输入7： 1calc.next(7) 然后我们得到了结果： 1234&#123; done:false value:14&#125; 7被作为doubleThat的值，注意：你可能会把input/2作为输入参数，但这只是第一次迭代的返回值。现在我们忽略它，使用新的输入值7，并将其乘以2. 然后，我们得到第二个yield的值，它返回doubleThat，因此返回值为14。 在下一个，也是最后一个迭代器，我们输入100 1calc.next(100) 这样我们得到: 1234&#123; done:true value:14000&#125; 当迭代器完成时(没有更多的yield关键字)，我们返回input doubleThat another，这相当于10 14100。 这些都是在2015年的ES2015引入的特性，现在我们深入了解下ES2016，它的作用域范围更小。 Array.prototype.includes()该特性引入了一种更简洁的语法，同来检查数组中是否包含指定元素。 对于ES6及更低版本，想要检查数组中是否包含指定元素，你不得不使用indexOf方法，它检查数组中的索引，如果元素不存在，它返回-1，由于-1被计算为true，你需对其进行取反操作，例子如下： 123if (![1,2].indexOf(3)) &#123; console.log('Not found')&#125; 通过ES7引入的新特性，我们可以如此做： 123if (![1,2].includes(3)) &#123; console.log('Not found')&#125; 求幂运算符求幂运算符**相当于Math.pow()方法，但是它不是一个函数库，而是一种语言机制： 1Math.pow(4, 2) == 4 ** 2 对于需要进行密集数学运算的程序来说，这个特性是个很好的增强，在很多语言中，**运算符都是标准(包括Python、Ruby、MATLAB、Perl等其它多种语言)。 这些都是2016年引入的特性，现在让我们进入2017年。 字符串填充字符串填充的目的是给字符串添加字符，以使其达到指定长度。 ES2017引入了两个String方法：padStart()和padEnd()。 12padStart(targetLength [, padString])padEnd(targetLength [, padString]) 使用例子： Object.values()该方法返回一个数组，数组包含了对象自己的所有属性，使用如下： 12const person = &#123; name:'Fred', age:87 &#125;Object.values(person) // ['Fred', 87] Object.values()也可以作用于数组： 12const people = ['Fred', 'Tony']Object.values(people) // ['Fred', 'Tony'] Object.entries()该方法返回一个数组，数组包含了对象自己的所有属性键值对，是一个[key, value]形式的数组，使用如下： 12const person = &#123; name:'Fred', age:87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] Object.entries()也可以作用于数组： 12const people = ['Fred', 'Tony']Object.entries(people) // [['0', 'Fred'], ['1', 'Tony']] Object.getOwnPropertyDescriptors()该方法返回自己(非继承)的所有属性描述符，JavaScript中的任何对象都有一组属性，每个属性都有一个描述符，描述符是属性的一组属性(attributes)，由以下部分组成： value: 熟悉的value值 writable: 属性是否可以被更改 get: 属性的getter函数, 当属性读取时被调用 set: 属性的setter函数, 当属性设置值时被调用 configurable: 如果为false, 不能删除该属性，除了它的value值以为，也不能更改任何属性。 enumerable: 该属性是否能枚举 Object.getOwnPropertyDescriptors(obj)接受一个对象，并返回一个带有描述符集合的对象。 In what way is this useful?ES6给我们提供了Object.assign()方法，它从一个一个或多个对象中复制所有可枚举的属性值，并返回一个新对象。 但是，这也存在着一个问题，因为它不能正确的复制一个具有非默认属性值的属性。 如果对象只有一个setter，那么它就不会正确的复制到一个新对象上，使用Object.assign()进行如下操作： 12345const person1 = &#123; set name(newName) &#123; console.log(newName) &#125;&#125; 这将不会起作用： 12const person2 = &#123;&#125;Object.assign(person2, person1) 但这将会起作用： 123const person3 = &#123;&#125;Object.defineProperties(person3, Object.getOwnPropertyDescriptors(person1)) 通过一个简单的console控制台，你可以查看以下代码： 12345person1.name = 'x'"x"person2.name = 'x'person3.name = 'x'"x" person2没有setter，它没能复制进去，对象的浅复制限定也出现在Object.create()方法中。 尾逗号该特性允许在函数定义时有尾逗号，在函数使用时可以有尾逗号： 1234const doSomething = (var1, var2,) =&gt; &#123; //...&#125;doSomething('test2', 'test2',) 该改变将鼓励开发者停止“在一行开始时写逗号”的丑陋习惯 异步函数JavaScript在很短的时间内从回调函数进化到Promise函数(ES2015)，并自从ES2017以来，异步JavaScript的async/wait语法变得更加简单。 异步函数是Promise和generator的结合，基本上，它是比Promise更高级的抽象，我再重复一般：async/await是基于Promise建立的 为什么要引入async/await它减少了围绕promise的引用，并打破了Promise — “不要打断链式调用”的限制。 当Promise在ES2015中引入时，它的本意是来解决异步代码的问题，它也确实做到了，但在ES2015和ES2017间隔的这两年中，大家意识到：Promise不是解决问题的终极方案。 Promise是为了解决著名的回调地狱而被引入的，但它本身也带来了使用复杂性和语法复杂性。 Promise是很好的原生特性，围绕着它开发人员可以探索出更好的语法，因此当时机成熟后，我们得到了async函数 async函数使代码看起来像是同步函数一样，但其背后却是异步和非堵塞的。 它如何工作一个async函数会返回一个promise，如下例： 12345const doSomethingAsync = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125; 当你想要调用该函数时，你在前面加上了一个wait，这样调用就会被停止，直到该promise进行resolve或reject，需注意的是：外层函数必须定义为async，这是例子： 123const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125; 一个上手示例这是一个使用async/await进行异步函数的简单示例： 1234567891011const doSomethingAsync = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 3000) &#125;)&#125;const doSomething = async () =&gt; &#123; console.log(await doSomethingAsync())&#125;console.log('Before')doSomething()console.log('After') 上面的代码将会在浏览器的console中打印出如下结果： 123BeforeAfterI did something //after 3s 关于 Promise将 async 关键字标记在任何函数上，意味着这个函数都将返回一个 Promise，即使这个函数没有显式的返回，它在内部也会返回一个 Promise，这就是下面这份代码有效的原因： 1234const aFunction = async () =&gt; &#123; return 'test'&#125;aFunction().then(alert) // This will alert 'test' 下面的例子也一样: 1234const aFunction = async () =&gt; &#123; return Promise.resolve('test')&#125;aFunction().then(alert) // This will alert 'test' 更易于阅读的代码正如上述的例子，我们将它与普通回调函数或链式函数进行比较，我们的代码看起来非常的简单。 这是一个很简单的例子，当代码足够复杂时，它会产生更多的收益。 例如，使用 Promise 来获取 JSON 资源并解析它： 12345678const getFirstUserData = () =&gt; &#123; return fetch('/users.json') // get users list .then(response =&gt; response.json()) // parse JSON .then(users =&gt; users[0]) // pick first user .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // get user data .then(userResponse =&gt; response.json()) // parse JSON&#125;getFirstUserData() 这是使用 async/await 实现相同功能的例子： 123456789const getFirstUserData = async () =&gt; &#123; const response = await fetch('/users.json') // get users list const users = await response.json() // parse JSON const user = users[0] // pick first user const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // get user data const userData = await user.json() // parse JSON return userData&#125;getFirstUserData() 串行多个异步功能async 函数非常容易，并且它的语法比 Promise 更易读。 12345678910111213141516const promiseToDoSomething = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('I did something'), 10000) &#125;)&#125;const watchOverSomeoneDoingSomething = async () =&gt; &#123; const something = await promiseToDoSomething() return something + ' and I watched'&#125;const watchOverSomeoneWatchingSomeoneDoingSomething = async () =&gt; &#123; const something = await watchOverSomeoneDoingSomething() return something + ' and I watched as well'&#125;watchOverSomeoneWatchingSomeoneDoingSomething().then(res =&gt; &#123; console.log(res)&#125;) 打印结果: 1I did something and I watched and I watched as well 更简单的调试调试 Promise 就很困难，因为调试器无法跨越异步代码，但调试 async/await 就非常的简单，调试器会像调试同步代码一样来处理它。 共享内存和原子WebWorkers 可以在浏览器中创建多线程程序。 它们通过事件的方式来传递消息，从 ES2017 开始，你可以使用 SharedArrayBuffer 在每一个 Worker 中和它们的创建者之间共享内存数组. 由于不知道写入内存部分需要多长的周期来广播，因此在读取值时，任何类型的写入操作都会完成，Atomics 可以避免竞争条件的发生。 关于它的更多细节可以在proposal中找到。 这是 ES2017，接下来我将介绍 ES2018 的功能。 Rest/Spread PropertiesES2015 引入了解构数组的方法，当你使用时： 12const numbers = [1, 2, 3, 4, 5][first, second, ...others] = numbers and 展开参数: 123const numbers = [1, 2, 3, 4, 5]const sum = (a, b, c, d, e) =&gt; a + b + c + d + econst sum = sum(...numbers) ES2018 为对象引入了同样的功能。 解构: 1234const &#123; first, second, ...others &#125; = &#123; first:1, second:2, third:3, fourth:4, fifth:5 &#125;first // 1second // 2others // &#123; third: 3, fourth: 4, fifth: 5 &#125; 展开属性 允许通过组合在展开运算符之后传递的对象属性而创建新对象： 12const items = &#123; first, second, ...others &#125;items //&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125; 异步迭代器for-await-of 允许你使用异步可迭代对象做为循环迭代： 123for await (const line of readLines(filePath)) &#123; console.log(line)&#125; 因为它使用的了 await，因此你只能在 async 函数中使用它。 Promise.prototype.finally()当一个 Promise 是 fulfilled 时，它会一个接一个的调用 then。 如果在这个过程中发生了错误，则会跳过 then 而执行 catch。 而 finally() 允许你运行一些代码，无论是成功还是失败： 1234fetch('file.json') .then(data =&gt; data.json()) .catch(error =&gt; console.error(error)) .finally(() =&gt; console.log('finished')) 正则表达式改进ES2018 对正则表达式引入了许多改进，这些都可以在 https://flaviocopes.com/javascript-regular-expressions/ 上找到。 以下是关于 ES2018 正则表达式改进的具体补充： RegExp lookbehind assertions: 根据前面的内容匹配字符串 这是一个 lookahead: 你可以使用 ?= 来匹配字符串，后面跟随一个特定的字符串： 123/Roger(?=Waters)//Roger(?=Waters)/.test('Roger is my dog') //false/Roger(?=Waters)/.test('Roger is my dog and Roger Waters is a famous musician') //true ?! 可以执行逆操作，如果匹配的字符串是no而不是在此后跟随特定的子字符串的话： 123/Roger(?!Waters)//Roger(?!Waters)/.test('Roger is my dog') //true/Roger(?!Waters)/.test('Roger Waters is a famous musician') //false Lookaheads 使用 ?= Symbol，它们已经可以用了。 Lookbehinds, 是一个新功能使用?&lt;=. 123/(?&lt;=Roger) Waters//(?&lt;=Roger) Waters/.test('Pink Waters is my dog') //false/(?&lt;=Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //true 如果一个 lookbehind 是否定，那么使用 ?&gt;!: 123/(?&lt;!Roger) Waters//(?&lt;!Roger) Waters/.test('Pink Waters is my dog') //true/(?&lt;!Roger) Waters/.test('Roger is my dog and Roger Waters is a famous musician') //false Unicode属性转义 p{…} and P{…}在正则表达式模式中，你可以使用 d 来匹配任意的数字，s 来匹配任意不是空格的字符串，w 来匹配任意字母数字字符串，以此类推。 This new feature extends this concept to all Unicode characters introducing p{} and is negation P{}. 这个新功能扩展了unicode字符，引入了 p{} 来处理 任何 unicode 字符都有一组属性，例如 script 确认语言，ASCII 是一个布尔值用于检查 ASCII 字符。你可以将此属性方在() 中，正则表达式将来检查是否为真。 123/^p&#123;ASCII&#125;+$/u.test('abc') //✅/^p&#123;ASCII&#125;+$/u.test('ABC@') //✅/^p&#123;ASCII&#125;+$/u.test('ABC🙃') //❌ ASCII_Hex_Digit 是另一个布尔值，用于检查字符串是否包含有效的十六进制数字： 12/^p&#123;ASCII_Hex_Digit&#125;+$/u.test('0123456789ABCDEF') //✅/^p&#123;ASCII_Hex_Digit&#125;+$/u.test('h') //❌ 此外，还有很多其它的属性。你可以在()中添加它们的名字来检查它们，包括 Uppercase, Lowercase, White_Space, Alphabetic, Emoji等等： 1234/^p&#123;Lowercase&#125;$/u.test('h') //✅/^p&#123;Uppercase&#125;$/u.test('H') //✅/^p&#123;Emoji&#125;+$/u.test('H') //❌/^p&#123;Emoji&#125;+$/u.test('🙃🙃') //✅ 除了二进制属性外，你还可以检查任何 unicode 字符属性以匹配特定的值，在这个例子中，我检查字符串是用希腊语还是拉丁字母写的： 12/^p&#123;Script=Greek&#125;+$/u.test(&apos;ελληνικά&apos;) //✅/^p&#123;Script=Latin&#125;+$/u.test(&apos;hey&apos;) //✅ 阅读https://github.com/tc39/proposal-regexp-unicode-property-escapes 获取使用所有属性的详细信息。 Named capturing groupsIn ES2018 a capturing group can be assigned to a name, rather than just being assigned a slot in the result array: 123456789101112const re = /(?&lt;year&gt;d&#123;4&#125;)-(?&lt;month&gt;d&#123;2&#125;)-(?&lt;day&gt;d&#123;2&#125;)/const result = re.exec('2015-01-02')// result.groups.year === '2015';// result.groups.month === '01';// result.groups.day === '02';The s flag for regular expressionsThe s flag, short for single line, causes the . to match new line characters as well. Without it, the dot matches regular characters but not the new line:/hi.welcome/.test('hiwelcome') // false/hi.welcome/s.test('hiwelcome') // true ESNext什么是 ESNext ？ ESNext 是一个始终指向下一个版本 JavaScript 的名称。 当前的 ECMAScript 版本是 ES2018，它于2018年6月被发布。 历史上 JavaScript 标准化的版本都是在夏季被发布，因此我们可以预期 ECMAScript 2019 将于 2019 年的夏季被发布。 所以在编写本文时 ES2018 已经被发布，因此 ESNext 指的是 ES2019。 ECMAScript 标准的提案是分阶段组织的，第一到第三阶段属于功能性的孵化，第四阶段的功能才最终确定为新标准的一部分。 在编写本文时主要浏览器都实现了第四阶段大部分的功能，因此我将在本文中介绍它们。 其中一些变化主要在内部使用，但知道发生了什么这也很好。 第三阶段还有一些其它功能，可能会在接下来的几个月内升级到第四阶段，你可以在这个 Github 仓库中查看它们：https://github.com/tc39/proposals。 1Array.prototype.&#123;flat,flatMap&#125; flat() 是一个新的数组实例方法，它可以将多维数组转化成一维数组。 例子: 12['Dog', ['Sheep', 'Wolf']].flat()//[ 'Dog', 'Sheep', 'Wolf' ] 默认情况下它只能将二维的数组转化成一维的数组，但你可以添加一个参数来确定要展开的级别，如果你将这个参数设置为 Infinity 那么它将展开无限的级别到一维数组： 123456['Dog', ['Sheep', ['Wolf']]].flat()//[ 'Dog', 'Sheep', [ 'Wolf' ] ]['Dog', ['Sheep', ['Wolf']]].flat(2)//[ 'Dog', 'Sheep', 'Wolf' ]['Dog', ['Sheep', ['Wolf']]].flat(Infinity)//[ 'Dog', 'Sheep', 'Wolf' ] 如果你熟悉数组的 map 方法，那么你就知道使用它可以对数组的每个元素执行一个函数。 flatMap() 是一个新的数组实例方法，它将 flat() 和 map 结合了起来，当你期望在map函数中做一些处理时这非常有用，同时又希望结果如同 flat ： 1234['My dog', 'is awesome'].map(words =&gt; words.split(' '))//[ [ 'My', 'dog' ], [ 'is', 'awesome' ] ]['My dog', 'is awesome'].flatMap(words =&gt; words.split(' '))//[ 'My', 'dog', 'is', 'awesome' ] Optional catch binding有时候我们并不需要将参数绑定到 try/catch 中。 在以前我们不得不这样做： 12345try &#123; //...&#125; catch (e) &#123; //handle error&#125; 即使我们从来没有通过 e 来分析错误，但现在我们可以简单的省略它： 1234567try &#123; //...&#125; catch &#123; //handle error&#125;Object.fromEntries()Objects have an entries() method, since ES2017. 从 ES2017 开始 Object将有一个 entries() 方法。 它将返回一个包含所有对象自身属性的数组的数组，如[key, value]： 12const person = &#123; name:'Fred', age:87 &#125;Object.entries(person) // [['name', 'Fred'], ['age', 87]] ES2019 引入了一个新的 Object.fromEntries() 方法，它可以从上述的属性数组中创建一个新的对象： 123456const person = &#123; name:'Fred', age:87 &#125;const entries = Object.entries(person)const newPerson = Object.fromEntries(entries)person !== newPerson //trueString.prototype.&#123;trimStart,trimEnd&#125; 这些功能已经被 v8/Chrome 实现了近一年的时间，它将在 ES2019 中实现标准化。 trimStart()删除字符串首部的空格并返回一个新的字符串： 1234'Testing'.trimStart() //'Testing'' Testing'.trimStart() //'Testing'' Testing '.trimStart() //'Testing ''Testing'.trimStart() //'Testing' trimEnd()删除字符串尾部的空格并返回一个新的字符串： 1234'Testing'.trimEnd() //'Testing'' Testing'.trimEnd() //' Testing'' Testing '.trimEnd() //' Testing''Testing '.trimEnd() //'Testing' Symbol.prototype.description现在你可以使用 description 来获取 Symbol 的值，而不必使用 toString() 方法： 12const testSymbol = Symbol('Test')testSymbol.description // 'Test' JSON improvements在此之前 JSON 字符串中不允许使用分隔符（）和分隔符（）。 使用 JSON.parse 时，这些字符会导致一个 SyntaxError 错误，但现在它们可以正确的解析并如 JSON 标准定义的那样。 Well-formed JSON.stringify()修复 JSON.stringify() 在处理 UTF-8 code points (U+D800 to U+DFFF)。 在修复之前，调用 JSON.stringify() 将返回格式错误的 Unicode 字符，如（a “�”)。 现在你可以安全放心的使用 JSON.stringify() 转成字符串，也可以使用 JSON.parse() 将它转换回原始表示的形态。 Function.prototype.toString()函数总会有一个 toString 方法，它将返回一个包含函数代码的字符串。 ES2019 对返回值做了修改，以避免剥离注释和其它字符串（如：空格），将更准确的表示函数的定义。 If previously we had 以前也许我们这样过： 1function /* this is bar */ bar () &#123;&#125; 当时的行为： 1bar.toString() //'function bar() &#123;&#125; 现在的行为： 1bar.toString(); // 'function /* this is bar */ bar () &#123;&#125;' 总结一下，我希望这篇文章可以帮助你了解一些最新的 JavaScript 以及我们在 2019 年即将看见的内容。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程看这篇就够了]]></title>
    <url>%2Fposts%2F52228cda.html</url>
    <content type="text"><![CDATA[引如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。 用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。 很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。 多线程：指的是这个程序（一个进程）运行时产生了不止一个线程 并行与并发： 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。 线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码： 1234void transferMoney(User from, User to, float amount)&#123; to.setMoney(to.getBalance() + amount); from.setMoney(from.getBalance() - amount);&#125; 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。 好了，让我们开始吧。我准备分成几部分来总结涉及到多线程的内容： 扎好马步：线程的状态 内功心法：每个对象都有的方法（机制） 太祖长拳：基本线程类 九阴真经：高级多线程控制类 一、扎好马步：线程的状态先来两张图： ​ 线程状态 ​ 线程状态转换 各种状态一目了然，值得一提的是”Blocked”和”Waiting”这两个状态的区别： 线程在Running的过程中可能会遇到阻塞(Blocked)情况对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。从jdk源码注释来看，blocked指的是对monitor的等待（可以参考下文的图）即该线程位于等待区。 线程在Running的过程中可能会遇到等待（Waiting）情况线程可以主动调用object.wait或者sleep，或者join（join内部调用的是sleep，所以可看成sleep的一种）进入。从jdk源码注释来看，waiting是等待另一个线程完成某一个操作，如join等待另一个完成执行，object.wait()等待object.notify()方法执行。 Waiting状态和Blocked状态有点费解，我个人的理解是：Blocked其实也是一种wait，等待的是monitor，但是和Waiting状态不一样，举个例子，有三个线程进入了同步块，其中两个调用了object.wait()，进入了waiting状态，这时第三个调用了object.notifyAll()，这时候前两个线程就一个转移到了Runnable,一个转移到了Blocked。 从下文的monitor结构图来区别：每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态Blocked,从jstack的dump中来看是 “Waiting for monitor entry”，而在 “Wait Set”中等待的线程状态是Waiting，表现在jstack的dump中是 “in Object.wait()”。 此外，在runnable状态的线程是处于被调度的线程，此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。 二、 内功心法：每个对象都有的方法（机制）synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们 他们是应用于同步问题的人工线程调度工具。讲其本质，首先就要明确monitor的概念，Java中的每个对象都有一个监视器，来监测并发代码的重入。在非多线程编码时该监视器不发挥作用，反之如果在synchronized 范围内，监视器发挥作用。 wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。 当某代码并不持有监视器的使用权时（如图中5的状态，即脱离同步块）去wait或notify，会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify，因为不同对象的监视器不同，同样会抛出此异常。 再讲用法： synchronized单独使用： 代码块：如下，在多线程环境下，synchronized块中的方法获取了lock实例的monitor，如果实例相同，那么只有一个线程能执行该块内容 12345678public class Thread1 implements Runnable &#123; Object lock; public void run() &#123; synchronized(lock)&#123; ..do something &#125; &#125;&#125; 直接用于方法：相当于上面代码中用lock来锁定的效果，实际获取的是Thread1类的monitor。更进一步，如果修饰的是static方法，则锁定该类所有实例。 12345public class Thread1 implements Runnable &#123; public synchronized void run() &#123; ..do something &#125;&#125; synchronized, wait, notify结合:典型场景生产者消费者问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 生产者生产出来的产品交给店员 */ public synchronized void produce() &#123; if(this.product &gt;= MAX_PRODUCT) &#123; try &#123; wait(); System.out.println("产品已满,请稍候再生产"); &#125; catch(InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; this.product++; System.out.println("生产者生产第" + this.product + "个产品."); notifyAll(); //通知等待区的消费者可以取出产品了 &#125; /** * 消费者从店员取产品 */ public synchronized void consume() &#123; if(this.product &lt;= MIN_PRODUCT) &#123; try &#123; wait(); System.out.println("缺货,稍候再取"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; System.out.println("消费者取走了第" + this.product + "个产品."); this.product--; notifyAll(); //通知等待去的生产者可以生产产品了 &#125; volatile 多线程的内存模型：main memory（主存）、working memory（线程栈），在处理数据时，线程会把值从主存load到本地栈，完成操作后再save回去(volatile关键词的作用：每次针对该变量的操作都激发一次load and save)。 针对多线程使用的变量如果不是volatile或者final修饰的，很有可能产生不可预知的结果（另一个线程修改了这个值，但是之后在某线程看到的是修改之前的值）。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的，本质上，volatile就是不去缓存，直接取值。在线程安全的情况下加volatile会牺牲性能。 三、太祖长拳：基本线程类基本线程类指的是Thread类，Runnable接口，Callable接口Thread 类实现了Runnable接口，启动一个线程的方法： 12 MyThread my = new MyThread(); my.start(); Thread类相关方法： 12345678//当前线程可转让cpu控制权，让别的就绪状态线程运行（切换）public static Thread.yield()//暂停一段时间public static Thread.sleep()//在一个线程中调用other.join(),将等待other执行完后才继续本线程。 public join()//后两个函数皆可以被打断public interrupte() 关于中断：它并不像stop方法那样会中断一个正在运行的线程。线程会不时地检测中断标识位，以判断线程是否应该被中断（中断标识值是否为true）。终端只会影响到wait状态、sleep状态和join状态。被打断的线程会抛出InterruptedException。Thread.interrupted()检查当前线程是否发生中断，返回booleansynchronized在获锁的过程中是不能被中断的。 中断是一个状态！interrupt()方法只是将这个状态置为true而已。所以说正常运行的程序不去检测状态，就不会终止，而wait等阻塞方法会去检查并抛出异常。如果在正常运行的程序中添加while(!Thread.interrupted()) ，则同样可以在中断后离开代码体 Thread类最佳实践：写的时候最好要设置线程名称 Thread.name，并设置线程组 ThreadGroup，目的是方便管理。在出现问题的时候，打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题，这个线程是干什么的。 如何获取线程中的异常 ​ 不能用try,catch来获取线程中的异常 Runnable 与Thread类似 Callable future模式：并发模式的一种，可以有两种形式，即无阻塞和阻塞，分别是isDone和get。其中Future对象用来存放该线程的返回值以及状态 12345ExecutorService e = Executors.newFixedThreadPool(3); //submit方法有多重参数版本，及支持callable也能够支持runnable接口类型.Future future = e.submit(new myCallable());future.isDone() //return true,false 无阻塞future.get() // return 返回值，阻塞直到该线程运行结束 四、九阴真经：高级多线程控制类以上都属于内功心法，接下来是实际项目中常用到的工具了，Java1.5提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。 1.ThreadLocal类 用处：保存线程的独立变量。对一个线程类（继承自Thread)当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。常用于用户登录控制，如记录session信息。 实现：每个Thread都持有一个TreadLocalMap类型的变量（该类是一个轻量级的Map，功能与map一样，区别是桶里放的是entry而不是entry的链表。功能还是一个map。）以本身为key，以目标为value。 主要方法是get()和set(T a)，set之后在map里维护一个threadLocal -&gt; a，get时将a返回。ThreadLocal是一个特殊的容器。 2.原子类（AtomicInteger、AtomicBoolean……） 如果使用atomic wrapper class如atomicInteger，或者使用自己保证原子的操作，则等同于synchronized 12//返回值为booleanAtomicInteger.compareAndSet(int expect,int update) 该方法可用于实现乐观锁，考虑文中最初提到的如下场景：a给b付款10元，a扣了10元，b要加10元。此时c给b2元，但是b的加十元代码约为： 123456if(b.value.compareAndSet(old, value))&#123; return ;&#125;else&#123; //try again // if that fails, rollback and log&#125; AtomicReference 对于AtomicReference 来讲，也许对象会出现，属性丢失的情况，即oldObject == current，但是oldObject.getPropertyA != current.getPropertyA。这时候，AtomicStampedReference就派上用场了。这也是一个很常用的思路，即加上版本号 3.Lock类 lock: 在java.util.concurrent包内。共有三个实现： ReentrantLock ReentrantReadWriteLock.ReadLock ReentrantReadWriteLock.WriteLock 主要目的是和synchronized一样， 两者都是为了解决同步问题，处理资源争端而产生的技术。功能类似但有一些区别。 区别如下： lock更灵活，可以自由定义多把锁的枷锁解锁顺序（synchronized要按照先加的后解顺序） 提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。 本质上和监视器锁（即synchronized是一样的） 能力越大，责任越大，必须控制好加锁和解锁，否则会导致灾难。 和Condition类的结合。 性能更高，对比如下图： ​ synchronized和Lock性能对比 ReentrantLock 可重入的意义在于持有锁的线程可以继续持有，并且要释放对等的次数后才真正释放该锁。使用方法是： 1.先new一个实例 1static ReentrantLock r=new ReentrantLock(); 2.加锁 1r.lock()或r.lockInterruptibly(); 此处也是个不同，后者可被打断。当a线程lock后，b线程阻塞，此时如果是lockInterruptibly，那么在调用b.interrupt()之后，b线程退出阻塞，并放弃对资源的争抢，进入catch块。（如果使用后者，必须throw interruptable exception 或catch） 3.释放锁 1r.unlock() 必须做！何为必须做呢，要放在finally里面。以防止异常跳出了正常流程，导致灾难。这里补充一个小知识点，finally是可以信任的：经过测试，哪怕是发生了OutofMemoryError，finally块中的语句执行也能够得到保证。 ReentrantReadWriteLock 可重入读写锁（读写锁的一个实现） 123 ReentrantReadWriteLock lock = new ReentrantReadWriteLock() ReadLock r = lock.readLock(); WriteLock w = lock.writeLock(); 两者都有lock,unlock方法。写写，写读互斥；读读不互斥。可以实现并发读的高效线程安全代码 4.容器类 这里就讨论比较常用的两个： BlockingQueue ConcurrentHashMap BlockingQueue 阻塞队列。该类是java.util.concurrent包下的重要类，通过对Queue的学习可以得知，这个queue是单向队列，可以在队列头添加元素和在队尾删除或取出元素。类似于一个管 道，特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue（优先队列），有兴趣可以研究 BlockingQueue在队列的基础上添加了多线程协作的功能： 除了传统的queue功能（表格左边的两列）之外，还提供了阻塞接口put和take，带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞，直到有空间时被唤醒；take在队 列空的时候阻塞，直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用，堪称神器。 常见的阻塞队列有： ArrayListBlockingQueue LinkedListBlockingQueue DelayQueue SynchronousQueue ConcurrentHashMap 高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap 5.管理类 管理类的概念比较泛，用于管理线程，本身不是多线程的，但提供了一些机制来利用上述的工具做一些封装。了解到的值得一提的管理类：ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean ThreadPoolExecutor 如果不了解这个类，应该了解前面提到的ExecutorService，开一个自己的线程池非常方便： 12345678ExecutorService e = Executors.newCachedThreadPool(); ExecutorService e = Executors.newSingleThreadExecutor(); ExecutorService e = Executors.newFixedThreadPool(3); // 第一种是可变大小线程池，按照任务数来分配线程， // 第二种是单线程池，相当于FixedThreadPool(1) // 第三种是固定大小线程池。 // 然后运行 e.execute(new MyRunnableImpl()); 该类内部是通过ThreadPoolExecutor实现的，掌握该类有助于理解线程池的管理，本质上，他们都是ThreadPoolExecutor类的各种实现版本。请参见javadoc： ​ ThreadPoolExecutor参数解释 翻译一下：corePoolSize:池内线程初始值与最小值，就算是空闲状态，也会保持该数量线程。maximumPoolSize:线程最大值，线程的增长始终不会超过该值。keepAliveTime：当池内线程数高于corePoolSize时，经过多少时间多余的空闲线程才会被回收。回收前处于wait状态unit：时间单位，可以使用TimeUnit的实例，如TimeUnit.MILLISECONDS workQueue:待入任务（Runnable）的等待场所，该参数主要影响调度策略，如公平与否，是否产生饿死(starving)threadFactory:线程工厂类，有默认实现，如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让我们聊一聊计算机基础知识的最小集合组]]></title>
    <url>%2Fposts%2F2d2dd747.html</url>
    <content type="text"><![CDATA[前言很多人工作后痛感计算机基础知识的缺乏， 那计算机基础知识都有哪些呢？ 我觉得首先计算机专业的那六大件：组成原理，操作系统，数据库，编译原理，计算机网络，数据结构（这个说太多遍了，这次不再讲了）， 其次还得加上分布式的基础知识， 因为现在的系统都变成分布式的了。 如果你是做应用层开发的，那几门课程中的有些内容和日常工作关联度不大，我挑那些最重要的来说一说，也算是一个最小集合吧！ 一、计算机组成原理如果你不是做操作系统/驱动程序的，直接和硬件打交道的机会很少，因为操作系统已经把他们屏蔽掉了，提供了抽象的API给我们使用。 但是还必须理解冯诺依曼体系的结构，CPU和内存，硬盘，各种外设之间的关系，寄存器、缓存等知识。 CPU有哪些指令，如何执行这些指令，如果实现数组，结构体，函数调用，这就涉及到汇编的知识。 像原码，反码，补码，定点数、浮点数的表示和运算也是编程中必备的知识，几乎每种语言都要涉及。 现在很多语言都是在虚拟机上运行的，你只要是了解了计算机的组成原理，再去看哪些虚拟机，就会发现概念都是相通的。 另外CPU中的缓存，缓存一致性协议，DMA的异步思想都会在应用层中有所体现。 如果能找一本书，尽可能多的囊括这些知识的话，我觉得还是神书《深入理解计算机系统》的前4章。 《编码》是一个更加科普性，但是也更加有趣的讲组成原理的书。 二、操作系统言操作系统是比较枯燥的， 站在应用层的角度，我认为重点是掌握操作系统对外提供的抽象，包括进程、线程，文件，虚拟内存，以及进程间的通信问题。 几乎所有的编程语言都会涉及到对多进程或者多线程编程的支持， 特别是多线程的并发编程，所以必须得搞明白他们的本质是什么，线程都有哪些实现方式（对以后学习各种语言和并发模型有极大好处）。得真正地体会到“进程是资源分配的最小单位，线程是调度的最小单位。” 这句话的含义。 几乎所有的编程语言都会涉及到锁和死锁，最好在最底层理解锁是怎么实现的。 需要理解虚拟内存和物理内存直接的关系，分段和分页，文件系统的基本原理。 对于进程的调度，页面分配/置换算法，磁盘的调度算法，I/O系统，我认为优先级比较低。 三、计算机网络我认为必须要理解的是这些： 什么分组交换 TCP可靠性传输原理，TCP/IP的协议细节， 三次握手，四次挥手，TCP状态转换。 几个重要的协议DHCP，UDP, ARP, DNS。 能够说出一个客户端如何在接入网络以后，通过这些协议，跨域网络和服务器通信的。 和应用层结合非常紧密的Socket知识和网络安全（对称加密，非对称加密，Hash, 数字签名，以及集大成者Https） 至于网络层的路由选择算法，链路层的各种协议，我认为优先级比较低。 还有一个重要的知识点，一般的网络书都没提，就是I/O多路复用，涉及到同步/异步，阻塞/非阻塞，select/epoll ，这个是很多软件的基础，在《Unix网络编程》，《深入理解计算机系统》中有讲述。 以上这些知识，在你学习Redis ,Ngnix, Tomcat, LVS等软件时将有极大的帮助。 四、数据库你这一辈子也许都不会去写一个编译器，但是很有可能会利用现成的工具去生成/操作一个抽象语法树（AST），甚至可以会写一个DSL（领域特定语言）。所以你得理解词法分析、语法分析、语义分析，中间代码生成，代码优化这个基本编译的过程。 学习了编译与原理，会对语言的一些设计有更深的理解，比如LISP。 五、分布式的理论知识由于现在的系统慢慢地变成了分布式， 所以又扩展出了很多相关基础知识需要学习： 数据复制与一致性: CAP理论， BASE原则，幂等性, 2PC, TCC Paxos , Raft , Gossip 数据分片和路由: Hash分片：Hash取模（实际中非常常见的算法）， 虚拟桶（Redis使用），一致性Hash（memcached使用） 范围分片 最后想说的是，不能带着特别功利的目的去学习这些基础，不能想着立刻、马上就应用到实战中，从中获益。更重要的理解掌握它们背后的思想，有一天你会发现：奥，这个问题我在哪里见过，可以用类似的办法来解决啊！]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-数组]]></title>
    <url>%2Fposts%2F979f2162.html</url>
    <content type="text"><![CDATA[一、创建方法1、空数组1var Obj = new Array(); 2、指定长度数组1var Obj = new Array(Size); 3、指定元素数组1var Obj = new Array(元素1,元素2,元素3,...,元素N); 4、单维数组1var Obj = [元素1,元素2,元素3,...,元素N] 5、多维数组1var a = new Array([数组序列1],[数组序列2],[数组序列N]); 二、基本操作1、存取数组元素 单维数组 1数组名[下标索引] 多维数组 1数组名[外层数组下标][内层元素下标] 特性 数组长度是弹性的，可自由伸缩 数组下标从0开始 下标类型 数值 非数值 转为字符串 生成关联数组 下标将作为对象属性的名字 数组元素可添加到对象中 2、增加数组1使用“[]”运算符指定一个新下标 3、删除数组1delete数组名[下标]; 4、遍历数组1for(var 数组元素变量 in 数组) 三、数组属性1、constructor引用数组对象的构造函数 2、length返回数组的长度 3、prototype通过增加属性和方法扩展数组定义 四、ECMAScript 3 方法1、添加 push() 在数组末尾增加数组 unshift 在数组头部添加元素 concat 合并两个数组 2、删除 pop() 删除并返回数值的最后一个元素 shift() 删除并返回数组的第一个元素 队列方法，先进先出 栈方法，后进先出 3、子数组 splice() 删除任意数量的项 要删除的起始下标 要删除的项数 在指定位置插入指定的项 起始下标 0（不删除任何项） 要插入的项 替换任意数量的项 起始下标 要删除的项数 要插入的项 功能 从已有数组中选取部分元素构成新数组 参数 返回项的起始位置 返回项的结束位置 特性 如果是负数，则用数组长度加上该值确定位置 起始位置实为数组的实际下标 结束位置的实际下标为结束数值减1 4、数组排序 reverse() 颠倒数组中元素的顺序 sort() 功能：对字符数组或数字数组进行排序 特性：按数值大小比较，需函数支持（升序） 12345678910functioncompare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125; else if(value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125;&#125; 5、数组转换 toString() 转换为字符串并返回 toLocaleString() 转换为本地格式字符串并返回 join() 用指定分隔符分割数组并转换为字符串 五、ECMAScript 5 方法1、位置方法 indexof 从数组的起始位置开始查找 lastIndexof 从数组的结束位置开始查找 参数 要查找的项 标识查找起点的位置索引 2、迭代方法 every 如果该函数对每一项都返回true，则返回true filter 返回值为true的所有数组成员 forEach 无返回值 map 返回每次函数调用的结果数组 some 有任意一项返回true，则返回true 参数 接收参数 要在每一项上运行的函数 运行该函数的作用域对象 传入参数 数组项的值 item 该项在数组中的位置index 数组对象本身 array 3、缩小方法 reduce 从数组起始位开始遍历 reduceRight 从数组末尾开始遍历 参数 接收参数 每一项上调用的函数 作为缩小基础的初始值 传入参数 前一个值 prev 当前值 cur 项的索引 index 数组对象 array]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-函数基础]]></title>
    <url>%2Fposts%2F5768cb4e.html</url>
    <content type="text"><![CDATA[一、定义方法1、静态方法1234function 函数名([虚参数列表])&#123; 函数体; [return[函数返回值;]]&#125; 2、动态匿名方法var 函数名 = new Function([“虚参数列表”],”函数体”); 3、直接量方法函数名 = function([虚参数列表]){函数体;} 二、调用方法1、直接调用函数名(实参列表) 2、在连接中调用1&lt;a herf = &quot;javascript:函数名()&quot;&gt;描述字&lt;/a&gt; 3、在事件中调用事件类型 = “函数名()” 4、递归调用 定义 在函数体内部调用函数自身 格式 1234function 函数名()&#123; 代码; 函数名();&#125; 三、方法1、apply 将函数作为对象的方法来调用 将参数以数组形式传递给该方法 2、call 将函数作为对象的方法来调用 将指定参数传递给该方法 3、toString 返回函数的字符串表示 四、arguments对象1、功能 存放实参的参数列表 2、特性 仅能在函数体内使用 带有下标属性，并非数组 函数声明时自动初始化 3、属性 length 获取函数实参的长度 callee 返回当前正在指向的函数 caler 返回调用当前正在执行的函数的函数名 五、函数参数1、参数类型 形参 定义函数时使用的参数 接收该函数时传递的参数 实参 调用函数时传递给函数的实际参数 2、特性 参数个数没有限制 实参 &lt; 形参 ：多余形参 = undefined 实参 &gt; 形参 ：多余实参被忽略 参数的数据类型没有限制 通过arguments对象访问参数数组 参数始终按值传递 基本类型：传值 引用类型：传址 六、指针标识1、this指向当前操作对象 2、callee指向形参集合所属函数 3、prototype指向函数附带的原型对象 4、constructor指向创建该对象的构造函数]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-运算符]]></title>
    <url>%2Fposts%2F4cf212f3.html</url>
    <content type="text"><![CDATA[一、算术运算符1、运算符a、+ 功能 对数字进行代数求和 对字符串进行连接操作 将一个数值转换成字符串（数值+空字符串） 字符串拼接 字符串+字符串（二者直接拼接） 字符串+数值（数值转为字符串再拼接） b、- 功能 对操作数进行“取反”操作 对数字进行减法操作 将字符串转换成数值（数值型字符串 - 0） c、* 功能 对两个运算数进行乘法运算 符号问题 同号得正，异号得负 d、/ 功能 对两个运算数进行除法运算 符号问题 同号得正，异号得负 e、% 功能 返回两个除数的余数 符号问题 和第一个运算数的符号相同 2、复合赋值运算符 +=、- =、*=、/=、%= 二、自增与自减1、功能相反 ++：对唯一的运算数进行递增操作（每次加1） —：对唯一的运算数进行递减操作（每次减1） 2、规则相同 运算数必须是一个变量、数组的一个元素或者对象的属性 如果运算数是非数值的则运算符会将它转成数值 3、符号位置决定运算结果 运算数之前：先进行递增（递减）操作，再进行求值 运算数之后：先求值，再进行递增（递减）操作 三、关系运算符1、大小关系检测a、运算符 &lt; ：如果A小于B，则返回true，否则返回false &lt;=：如果A小于等于B，则返回true，否则返回false &gt;=：如果A大于等于B，则返回true，否则返回false &gt;：如果A大于B，则返回true，否则返回false b、操作规则 数值与数值的比较：比较它们的代数值 仅一个运算数是数值：将另一个运算数转换成数值，并比较它们的代数值 字符串间的比较：逐字符比较它们的Unicode数值 字符串与非数值的比较：将运算符转换成字符串并进行比较 运算数即非数值也非字符串：转换成数值或字符串后进行比较 运算数无法转换成数值或字符串：返回值为false 与NaN的比较：返回值为false 2、等值关系检测a、相等比较 操作符 ==：比较两个运算数的返回值看是否相等 !=：比较两个运算数的返回值看是否不相等 类型转换 布尔值 true：1 false：0 对象 调用valueOf()，基本类型 字符串与数值的比较 字符串转换为数值 比较原则 null与undefined 相等 比较前不进行任何转换 NaN 与任何数值都不相等包括其本身 对象 是否属于同一对象 是：== 否：!= b、相同比较 运算符 ===：比较两个运算数的返回值及数据类型看是否相同 !==：比较两个运算数的返回值及数据类型看是否不同 比较原则 值类型比较 只有数据类型相同，且数值相等时才能够相同 值类型与引用类型比较 肯定不相同 引用类型间比较 比较它们的引用值（内存地址） 四、对象运算符 in：判断左侧运算数是否为右侧运算数的成员 instancesof：判断对象实例是否属于某个类或构造函数 new：根据构造函数创建一个新的对象，并初始化该对象 delete：删除指定对象的属性，数组元素或变量 .及[]：存取对象或数组元素 ()：函数调用，改变运算运算符优先级等 五、逻辑运算符1、! 逻辑非a、返回值 true 空字符串 0 null NaN undefined false 对象 非空字符串 非0数值（Infinity） b、特性 如果运算数的值为false则返回true，否则返回false 连续使用两次!，可将任意类型转为布尔值 2、&amp;&amp;逻辑与a、规则 第一个操作数是对象：返回第二个操作数 第二个操作数是对象：第一个操作数值为true时返回该对象 两个操作数都是对象：返回第二个操作数 一个操作数是null：返回null 一个操作数是NaN：返回NaN 一个操作数是undefined：返回undefined b、特性 当且仅当两个运算数的值都是true时，才返回true，否则返回false 短路操作：当第一个操作数的值为false则不再对第二个操作数进行求值 3、||逻辑或a、规则 第一个操作数是对象：返回第一个操作数 第一个操作数值为false：返回第二个操作数 两个操作数都是对象：返回第一个操作数 两个操作数是null：返回null 两个操作数是NaN：返回NaN 两个操作数是undefined：返回undefined b、特性 当且仅当连个运算数的值都是false时，才返回false，否则返回true 如果第一个操作数为true，则不会对第二个操作数进行求值 六、位运算符1、基础知识a、类型 有符号 数值位：前31位 符号位：第32位 0：正数 1：负数 无符号 只能是正数 第32位表示数值 数值范围可以加大 b、数值范围 - 2147483648 ~ 2147483647 c、存储方式 正数 纯二进制存储 31位中每一位表示2的幂 用0补充无用位 负数 二进制补码存储 补码的计算步骤 确定该数字的非负版本的二进制表示 求得二进制反码，既要把0替换为1，把1替换为0 在二进制反码上加1 d、当做0来处理的特殊值 NaN Infinity 2、逻辑位运算符a、返回值为1 按位非~：0 按位与&amp;：对应位全是1 按位或|：任何一位都是1 按位异或^：既不同时为0，也不同时为1 b、返回值为0 按位非~：1 按位与&amp;：任何一位都是0 按位或|：对应位全是0 按位异或^：对应位全是0或全是1 3、位移操作a、左移&lt;&lt; 将数值的所有位左移指定的位数 所有空位用0补充 左移1位对其乘2，左移2为对其乘4，以此类推 b、有符号右移&gt;&gt; 将数值的所有位右移指定的位数 移除位被舍弃 保留符号位 右移1位对其除2，右移2为对其除4，以此类推 c、无符号右移&gt;&gt; 正数：与有符号右移结果相同 负数：会出现无限大的数值 4、复合赋值运算符 位操作符与等号结合，复合赋值不会有性能方面的提升 七、其他运算符1、? 条件运算符，简洁的if else 2、type of 类型判定运算符 3、, 逗号，在一行语句中执行多个不同的操作 4、void 舍弃运算数的值，返回undefined作为表达式的值]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-DOM基本操作]]></title>
    <url>%2Fposts%2Faf67cb0c.html</url>
    <content type="text"><![CDATA[一、获取节点1、document getElementById 语法：document.getElementById(元素id) 功能：通过元素ID获取节点 getElementByName 语法：document.getElementByName(元素name属性) 功能：通过元素的name属性获取节点 getElementByTagName 语法：document.getElementByTagName(元素标签) 功能：通过元素标签获取节点 2、节点指针 firstChild 语法：父节点.firstChild 功能：获取元素的首个子节点 lastChild 语法：父节点.lastChild 功能：获取元素的最好一个子节点 childNodes 语法：父节点.childNodes 功能：获取元素的子节点列表 previousSibling 语法：兄弟节点.previousSibling 功能：获取已知节点的前一个节点 nextSibling 语法：兄弟节点.nextSibling 功能：获取已知节点的后一个节点 parentNodes 语法：子节点.parentNodes 功能：获取已知节点的父节点 二、节点操作1、创建节点 createElement 语法：document.createElement(元素标签) 功能：创建元素节点 createAttribute 语法：documen.createAttribute(元素属性) 功能：创建属性节点 createTextNode 语法：document.createTextNode(文本内容) 功能：创建文本节点 2、插入节点 appendChild 语法：appendChild(所添加的新节点) 功能：向节点的子节点列表的末尾添加新的子节点 insertBefore 语法：insertBefore(所要添加的新节点，已知子节点) 功能：在已知子节点钱插入一个新的子节点 3、替换节点 replaceChild 语法：replaceChild(要插入的新元素，将被替换的老元素) 功能：将某个子节点替换为另一个 4、复制节点 cloneNode 语法：需要被复制的节点.cloneNode(true/fasle) 功能：创建置顶节点的副本 参数 true：复制当前节点及其所有子节点 false：仅复制当前节点 5、删除节点 removeChild 语法：removeChild*(要删除的节点) 功能：删除指定的节点 三、属性操作1、获取属性 getAttribute 语法：元素节点.getAttribute(元素属性名) 功能：获取元素节点中指定属性的属性值 2、设置设置属性 setAttribute 语法：元素节点.setAttribute(属性名,属性值) 功能：创建或改变元素节点的属性 3、删除属性 removeAttribute 语法：元素节点.removeAttribute(属性名) 功能：删除元素中的指定属性 四、文本操作 insertData(offset,string) ：从offset指定的位置插入string appendata(sring) ：将string插入到文本节点的末尾处 deleteData(offset,count) ：从offset起删除count个字符 replaceData(off,count,string) ：从off将count个字符用string替代 splitData(offset)：从offset起将文本节点分成两个节点 substring(offset,count)：返回由offset起的count个节点]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-流程语句]]></title>
    <url>%2Fposts%2F121ee7e9.html</url>
    <content type="text"><![CDATA[一、循环语句1、while 语法 123while(条件表达式)&#123; 循环执行代码段&#125; 流程 判断条件表达式的值 当值为true时循环执行代码段 当值为false时退出循环体 热性 先检查条件，再执行循环 条件不满足则循环一次也不执行 时机 一个动作被重复执行到满足某个 条件时 2、do-while 语法 123do&#123; 循环执行的代码段&#125;while(条件表达式) 流程 先执行循环体内代码段再进行判断 如果表达式的值为true，则重复执行代码段 如果表达式的值为false，则退出循环体 特性 先执行循环体，再进行条件判断 循环体内代码至少执行一次 时机 希望一个动作至少被执行一次时 3、for 语法 123for(循环变量 = 初值;循环条件;递增/递减计数器)&#123; 循环代码段&#125; 流程 用循环变量初始值与循环条件相比较，确定返回值 如果返回值为true则执行循环体 执行完一次后进行递增/递减运算 将运算结果与循环条件相比较 如果返回值为true则继续执行循环体 如果返回值为false则退出循环体 时机 重复一个动作到一定次数时 4、for-in 语法 123for(声明变量 in 对象)&#123; 代码段&#125; 作用 枚举对象属性 注意事项 循环输出的属性顺序不可预知 对象的值不能是null或undefined 二、跳转语句1、return 终止函数体的运行，并返回一个值 2、break 终止整个循环，不再进行判断 3、continue 结束本次循环，接着去判断是否执行下次循环 三、选择语句1、if 语法 1234567if(条件表达式1)&#123; 代码段1&#125;else if(条件表达式2)&#123; 代码段2&#125;else&#123; 代码段3&#125; 流程 判断条件1，如果返回值为true则执行代码段1 如果条件1的返回值为false则跳过语句1并检测条件2 如果所有的表达式的值均为false则执行else后面的语句 特性 结构复杂，可嵌套 可测试多个条件表达式 表达式的值具有线性特征 表达式的值是动态的 适用于任意类型的数据 可处理复杂的逻辑关系 2、switch 语句 1234567891011switch(条件表达式)&#123; case 标签1: 代码段1; break; case 标签2: 代码段2; break; …… …… default: 代码段n;&#125; 流程 计算表达式的值，并与各标签相比较 若找到与之匹配的标签，则执行其后的代码段 若没有找到与之匹配的标签则执行default之后的代码段 格式 case标签为常量，可以是字符串或数字 每个标签均以冒号:结束 虽然break与default为可选性，但为了逻辑清晰最好不要省略 case标签的值必须和条件表达式在值完全匹配 特性 结构简洁，专为多重选择设计 仅可测试一条条件表达式 表达式的值具有离散性 表达式的值是固定的，不会动态变化的 仅能应用整数，枚举，字符串等类型数据 仅能处理多个枚举型逻辑关系 四、异常处理语句 throw 主动抛出异常 try 指明需要处理的代码段 catch 捕获异常 finally 后期处理]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-正则表达式]]></title>
    <url>%2Fposts%2F75cf4b3.html</url>
    <content type="text"><![CDATA[一、创建1、方式 字面量：var变量名 = / 表达式 / 模式修饰符 函数构造：var变量名 = ** **new RegExp(“表达式”,”模式修饰符”) 2、说明a、表达式 单个字符与数字 . : 匹配除换行符之外的任意字符 [a-z0-9] ：匹配方括号中的任意字符 [^a-z0-9] ：匹配不在方括号中的任意字符 \d：匹配数字 \D：匹配非数字 \w：匹配字母 \W：匹配非字母 空白字符 \0：匹配null字符 \b：匹配空格字符 \f：匹配换页符 \n：匹配换行符 \r：匹配回车符 \s：匹配空白字符、空格、制表符或换行符 \S：匹配非空白字符 \t：匹配制表符 定位符 ^：行首匹配 $：行尾匹配 \A：只匹配字符串的开始处 \b：匹配单词边界，词在[]内无效 \B：匹配非单词边界 \G：匹配当前搜索的开始位置 \Z：匹配字符串结束处或行尾 \z：只匹配字符串结束处 限定符 x?：匹配0个或1个x x*：匹配0个或任意多个x x+：匹配至少1个x x(m,n)：匹配最少m个，最多n个x 分组 (?:x)：匹配x但不记录匹配结果 x(?=y)：当x后接y时匹配x x(?!y)：当x后不是y时匹配x 引用 \1…\9：$1…$9，返回九个在模式匹配期间找到的、最近保存的部分 或模式 x|y|z：匹配x或z或y b、模式修饰符 g ：全局模式，应用于所有字符串 i ：区分大小写模式 m ：多行匹配模式 二、属性1、实例属性 global：检测是否设置g标记 ignoreCase：检测是否设置i标记 multiline：检测是否设置了m标记 lastIndex：开始检索下一个匹配项的字符位置，开始为0 source：返回正则表达式的字符串表示 2、构造函数属性 $_ input ：返回最近一次匹配的字符串 $&amp; lastMatch：返回最近一次的匹配项 $+ lastParen：返回最近一次匹配的捕获组 $` leftContext：返回被查找的字符串中从字符串开始位置到最后匹配之前的位置之间的字符 $’ rightContext：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符 $* multiline：检测表达式是否采用多行模式匹配m 三、方法1、实例方法a、exec 功能：在字符串中执行匹配检索，返回结果数组 参数：要应用模式匹配的字符串 特性 使用全局标记g：持续查找所有匹配项并返回 不使用全局标记g：始终返回第一个匹配项信息 执行过程 检索字符串参数，获取正则表达式匹配文本 找到匹配文本则返回一个数组 第0个元素：与整个模式匹配的字符串 其他元素：与捕获组匹配的字符串 否则返回null 派生属性 index：匹配项在字符串中的位置 input：应用正则表达式的字符串 length：返回数组元素个数 b、test 功能：在字符串中测试模式匹配，返回true或false 2、字符串方法 match：找到一个或多个正则表达式的匹配 replace：替换与正则表达式匹配的子串 seach：检索与正则表达式相匹配的值 split：把字符串分割为字符串数组]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-字符串函数]]></title>
    <url>%2Fposts%2F2675d2d0.html</url>
    <content type="text"><![CDATA[一、查找方法1、字符方法a、charAt() 功能：返回字符串中第n个字符 参数：超出范围，返回空字符串 返回值：string中第n个字符的实际值 b、charCodeAt() 功能：返回字符串中第n个字符的代码 参数：超出范围，返回Nan 返回值： 内容：string中第n个字符的Unicode编码 范围：0~65535之间的16位整数 c、fromCharCode() 功能：根据字符编码创建字符串 参数：0个或多个整数，代码字符的Unicode编码 返回值：由指定编码字符组成的新字符串 特效：静态方法，实为构造函数String()的属性 d、关系charAt和charCodeAt共性 功能：根据下标查找指定字符 参数：n，要查询的字符下标；有效范围，0length1之间 charCodeAt与fromCharCode 互为反向操作 2、位置方法a、indexOf() 从前向后检索字符串，看其是否含有指定子串 b、lastIndexOf() 从后向前检索字符串，看其是否含有指定子串 c、共性 功能：根据字符串查找下标位置 参数： 必选：将要查询的字符串 可选：开始查找的位置下标 值为负数，视作 0 省略，从默认起始位开始查找 超出 0length1，返回 -1 返回值 找到：字串首次出现的下标 未找到：返回-1 3、匹配方法a、match() 功能：找到一个或多个正则表达式的匹配 参数 要进行模式匹配的正则表达式 非正则表达式，将其传递给RegExp()的构造函数，并转换为正则表达式对象 返回值：存放匹配结果的数组 有全局标记g：执行全局检索 找到：返回数组 内容：所有匹配的子串 缺陷 没有派生属性 不提供与子表达式匹配的文本信息 不声明每个匹配子串的位置 弥补：使用RegExp.exec()方法 没找到：返回null 无全局标记g：执行一次匹配 找到：返回数组 内容 第0个元素，匹配文本 其他元素，与正则表达式匹配的文本 属性 input，调用该方法的字符串对象 index，匹配为本的起始字符在字符串中的位置 lastIndex，匹配为本的末尾字符在字符串中的位置 未找到：返回null b、seach() 功能：检索字符串中与正则表达式匹配的子串 参数：与match()相同 返回值 找到：字符串中第一个与正则表达式相匹配的子串的起始位置 未找到：返回 -1 特性：忽略全局标记g与lastIndex()属性 c、replace() 功能：替换一个与正则表达式匹配的子串 参数 参数 1：需要进行替换正则表达式对象或字符串 参数 2：替换文本或替换函数 特性 如果参数1仅为字符串则只进行一次匹配替换，若替代所有子串则必选制定全局标记g 如果参数2仅为字符串则可使用特殊字符序列 $$ : $ $&amp; : 匹配整个模式的子字符串 $’ : 匹配的子字符串之前的子字符串 $` : 匹配的子字符串之后的子字符串 $n : 匹配第n个捕获组的子字符串，n=0~9 $nn: 匹配第nn个捕获组的子字符串，nn=01~99 d、split() 功能：根据指定分隔符将字符串分割成多个子串，并返回成数组 参数 必须：指定的分隔符 可选：指定数组的长度 二、操作方法1、拼接方法a、concat() 语法：string.cancat(varue,…) 功能：连接字符串 参数：要连接到string上的一个或多个值 返回值：把所有参数都连接到字符串string上得到的新字符串 特性：功能与‘’+‘’相同原始字符串的实际值并未被真正修改 2、截取方法a、 根据下标截取子串 *slice() *: 赋值参数，与字符长度相加 substring() **: 赋值参数，转换为0** 共性 ：参数2的子字符串最后一个字符后面的下标 b、根据长度截取子串 substr() 参数2 ：返回的字符个数 赋值参数 参数1：与字符串长度相加 参数2：转换为0 c、共性 功能：截取被操作字符串中的子串 参数1：指定子串的开始位置 省略参数2：以字符串长度为结束位置 3、空格处理 trim：清除前置及后缀空格 trimLeft：清除前置空格 trimRight：清除后缀空格 4、比较方法a、localeCompare() 功能：用本地特定顺序比较两个字符串 参数：与原字符串进行比较的字符串 返回值：说明比较结果的数字 负数：原字符串 &lt; 参数字符串 0 ： 原字符串 = 参数字符串 正数：原字符串 &gt; 参数字符串 三、编码方法1、字符串常规编码与解码 escape() unescape() 2、URI字符串编码与解码 encodeURI() decodeURI() 3、URI组件编码与解码 encodeURIComponent() decodeURIComponent() 四、转换方法1、大小写转换a、转为大写 toUpperCase() toLocaleUpperCase() ：本地 b、转为小写 toLowerCase() toLocaleLowerCase() ：本地 2、代码转换 用js动态格式化html，不具语义性，舍弃]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习总结-变量]]></title>
    <url>%2Fposts%2Fb062d643.html</url>
    <content type="text"><![CDATA[一、命名1、方法a、匈牙利命名法（变量名=类型+对象描述） Int 整型 i float 浮点型 fi Bollean 布尔 b String 字符串 s Array 数组 a Obeject 对象 o Function 函数 fn Regular Expression 正则 re b、驼峰命名法 全部小写 单词与单词间用下划线分割 大小写混合 大驼峰：每个单词首字母大写 小驼峰：第一个单词首字母小写，其他首字母大写 2、规则 首字母：英文字母或者下划线 组成：英文字母，数字，下划线 禁忌：JavaScript关键词与保留字 二、声明1、显示声明 var变量名 2、陋习 没有类型 重复声明 隐式声明 不声明直接赋值 3、正解 先声明、后读写 先赋值、后运算 三、变量类型1、值类型 占用空间固定，保存在栈中 保存与复制的是值本身 使用typeof检测数据的类型 基本类型数据是值类型 2、引用类型 占用空间不固定，保存在堆中 保存与复制的是指向对象的一个指针 使用instanceof检测数据的类型 使用new()方法构造出的对象是引用型 四、作用域1、全局变量a、包含 在函数体外定义的变量 在函数体内定义的无var声明的变量 b、调用 任何位置 2、局部变量a、包含 在函数内部使用var声明的变量 函数的参数变量 b、调用 当前函数体部 3、优先级 局部变量高于同名全局变量 参数变量高于同名全局变量 局部变量高于同名参数变量 4、热性a、忽略块级作用域b、全局变量是全局对象的属性c、局部变量是调用对象的属性d、作用域链 内层函数可访问外层函数局部变量 外层函数不能访问内层函数局部变量 e、生命周期 全局变量：除非被显示删除，否则一直存在 局部变量：自声明起至函数运行完毕或被显示删除 回收机制 标记清除 引用计数]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList和LinkedList集合有什么区别？]]></title>
    <url>%2Fposts%2Fcd624839.html</url>
    <content type="text"><![CDATA[Arraylist底层是基于动态数组，根据下表随机访问数组元素的效率高，向数组尾部添加元素的效率高；但是，删除数组中的数据以及向数组中间添加数据效率低，因为需要移动数组。例如最坏的情况是删除第一个数组元素，则需要将第2至第n个数组元素各向前移动一位。 Linkedlist基于链表的动态数组，数据添加删除效率高，只需要改变指针指向即可，但是访问数据的平均效率低，需要对链表进行遍历。 总结：1、对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。2、各自效率问题： tips： ArrayList是线性表(数组) get()直接读取第几个下标，复杂度O(1) add(E)添加元素，直接在后面添加，复杂度O(1) add(inedx，E)添加元素，在第几个元素后面插入，后面的元素需要向后移动，复杂度O(n) remove()删除元素，后面的元素需要逐个移动，复杂度O(n) linkedlist是链表的操作 get()获取第几个元素，依次遍历，复杂度O(n) add(E)添加到末尾，复杂度O(1) add(index，E)添加第几个元素后，需要先查找到第几个元素，直接指针指向操作，复杂度O(1) remove()删除元素，直接指针指向操作，复杂度O(1)]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件之间8种组件通信方式总结]]></title>
    <url>%2Fposts%2F40775045.html</url>
    <content type="text"><![CDATA[对于vue来说，组件之间的消息传递是非常重要的，下面是我对组件之间消息传递的各种方式的总结，总共有8种方式。 1 props和$emit 2 $attrs和$listeners 3 中央事件总线 4 provide和inject 5 v-model 6 $parent和$children 7 boradcast和dispatch 8 vuex处理组件之间的数据交互 1.props和$emit父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Vue.component(&apos;child&apos;,&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;/div&gt; `, props:[&apos;message&apos;],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit(&apos;getChildData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child :message=&quot;message&quot; v-on:getChildData=&quot;getChildData&quot;&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125;, methods:&#123; //执行子组件触发的事件 getChildData(val)&#123; console.log(val) &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 在上面的例子中，有父组件parent和子组件child。1).父组件传递了message数据给子组件，并且通过v-on绑定了一个getChildData事件来监听子组件的触发事件；2).子组件通过props得到相关的message数据,最后通过this.$emit触发了getChildData事件。 2.$attrs和$listeners第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Vue.component(&apos;C&apos;,&#123; template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messagec&quot; @input=&quot;passCData($attrs.messagec)&quot;&gt; &lt;/div&gt; `, methods:&#123; passCData(val)&#123; //触发父组件A中的事件 this.$emit(&apos;getCData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;B&apos;,&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt; &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt; &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt; &lt;/div&gt; `, props:[&apos;message&apos;],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit(&apos;getChildData&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;A&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;B :messagec=&quot;messagec&quot; :message=&quot;message&quot; v-on:getCData=&quot;getCData&quot; v-on:getChildData=&quot;getChildData(message)&quot;&gt;&lt;/B&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos;, messagec:&apos;hello c&apos; //传递给c组件的数据 &#125; &#125;, methods:&#123; getChildData(val)&#123; console.log(&apos;这是来自B组件的数据&apos;) &#125;, //执行C子组件触发的事件 getCData(val)&#123; console.log(&quot;这是来自C组件的数据：&quot;+val) &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;A&gt;&lt;/A&gt; &lt;/div&gt; ` &#125;) 3.中央事件总线上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Vue.component(&apos;brother1&apos;,&#123; data()&#123; return &#123; mymessage:&apos;hello brother1&apos; &#125; &#125;, template:` &lt;div&gt; &lt;p&gt;this is brother1 compoent!&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; &lt;/div&gt; `, methods:&#123; passData(val)&#123; //触发全局事件globalEvent bus.$emit(&apos;globalEvent&apos;,val) &#125; &#125; &#125;) Vue.component(&apos;brother2&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is brother2 compoent!&lt;/p&gt; &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, data()&#123; return &#123; mymessage:&apos;hello brother2&apos;, brothermessage:&apos;&apos; &#125; &#125;, mounted()&#123; //绑定全局事件globalEvent bus.$on(&apos;globalEvent&apos;,(val)=&gt;&#123; this.brothermessage=val; &#125;) &#125; &#125;) //中央事件总线 var bus=new Vue(); var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt; &lt;/div&gt; ` &#125;) 4.provide和inject父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。 123456789101112131415161718192021222324252627282930313233343536Vue.component(&apos;child&apos;,&#123; inject:[&apos;for&apos;],//得到父组件传递过来的数据 data()&#123; return &#123; mymessage:this.for &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;tet&quot; v-model=&quot;mymessage&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, provide:&#123; for:&apos;test&apos; &#125;, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 5.v-model父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.component(&apos;child&apos;,&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$emit(&apos;input&apos;,this.mymessage);//通过如此调用可以改变父组件上v-model绑定的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @change=&quot;changeValue&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;child v-model=&quot;message&quot;&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 6.$parent和$children12345678910111213141516171819202122232425262728293031323334353637383940414243444546Vue.component(&apos;child&apos;,&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$parent.message = this.mymessage;//通过如此调用可以改变父组件的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @change=&quot;changeValue&quot;&gt; &lt;/div&gt; &#125;) Vue.component(&apos;parent&apos;,&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;button @click=&quot;changeChildValue&quot;&gt;test&lt;/button &gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, methods:&#123; changeChildValue()&#123; this.$children[0].mymessage = &apos;hello&apos;; &#125; &#125;, data()&#123; return &#123; message:&apos;hello&apos; &#125; &#125; &#125;) var app=new Vue(&#123; el:&apos;#app&apos;, template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 7.boradcast和dispatchvue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和on和emit的封装，但在一些基础组件中却很实用。 1234567891011121314151617181920212223242526272829303132function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; var name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat(params)); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;; 8.vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。 详情可参考：https://vuex.vuejs.org/zh-cn/]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（十）DOM0和DOM2级事件]]></title>
    <url>%2Fposts%2F64d673ce.html</url>
    <content type="text"><![CDATA[JS中的DOM0和DOM2事件JS中的事件基础及核心原理以及项目实战事件的定义 事件：元素天生具备的行为方式（和写不写JS代码没有关系）【onclick不是事件，click才是事件，浏览器会把一些常用事件挂载到元素对象的私有属性上，让我们可以实现DOM0事件绑定】，当我们去操作元素的时候会触发元素的很多事件事件绑定：给当前元素的某个事件绑定方法，目的是让当前元素某个事件被触发时，做出一些反应 事件绑定的两种方法 DOM0级事件绑定 curEle.onclick=function(){}; DOM2级事件绑定 标准浏览器：curEle.addEventListener(‘click’,function(){},false) IE6-8:curEle.attachEvent(‘onclick’,function(){}) DOM0事件常用事件汇总[PC端] 表单元素常用的事件 blur:失去焦点 focus:获取焦点 change:内容改变 select:被选中事件 键盘常用事件行为 keydown:键盘按下 keyup:键盘抬起 keypress:键盘按下（中文输入法不能触发，英文状态下可以触发，因为文本被输入到文本框中） 鼠标常用事件行为 click:点击（不是单击） dblclick:双击（300ms之内连续触发两次点击事件） mouseover:鼠标滑过 mouseout:鼠标滑出 mouseenter: 鼠标进入 mouseleave: 鼠标离开 mousedown:鼠标按下（左键） mouseup:鼠标左键抬起 mousewheel:鼠标滚轮滚动 其他常用事件行为 load:加载成功 error:加载失败 scroll: resize:大小改变事件:window.onresize:浏览器窗口改变大小触发该事件 [移动端 移动端键盘一般都是虚拟键盘，虽然存在keydown,keyup,但兼容不好，使用input事件代替移动端没有鼠标，所以鼠标类事件在移动端兼容性非常差，mouse类事件基本无法使用移动端大部分事件是靠手指完成的，所以它独有手指事件-单手指事件：touchstart touchmove touchend touchcancel-多手指事件：gesturestart gestuerchange gestuerend…..移动端还有很多事件是靠硬件完成的：手机传感器，陀螺仪，重力感应器等移动端兼容click事件，它把click当做单击使用（会有300MS的延迟事件） 事件对象 对以下事件绑定的严谨版描述：基于DOM0级事件的绑定方式，给box的click事件绑定了一个方法。当手动触发click事件时，会把绑定的方法执行box.onclick=function(e){arguments[0]===e;//=&gt;e就是事件对象e=e||window.event;(兼容版获取事件对象的写法)};当元素的某个事件行为被触发，不仅会把之前绑定的方法执行，还会给绑定的方法传递一个值（浏览器默认传递的），我们把传递的这个值称为事件对象：（标准浏览器） 这个值是个对象类型的值，里面存储了很多的属性和方法， 这些存储的值都是当前本次操作的基本信息，例如：鼠标位置，触发行为类型。。。。【只和本次操作有关,一个页面中只有一个事件对象】 IE6-8下关于事件对象的机制 方法被触发执行时，浏览器并没有把事件对象当做值传递给函数；(e是undefined) IE6-8下的事件对象需要我们通过window.event来获取 鼠标事件对象（mouseevent） clientX/clientY:当前鼠标触发点距离当前窗口左上角的X/Y坐标 pageX/pageY:当前鼠标触发点距离BODY左上角的X/Y坐标(IE6-8中没有这两个属性)兼容处理 123456789101112131415161718box.onckick=function(e)&#123; if(typeof e==='undefined')&#123; e=window.event; //-&gt;处理e //-&gt;pageX/pageY e.pageX=e.clientX+(document.documentElement.scrollLeft||document.body.scrollLeft); e.pageY=e.clientY+(document.documentElement.scrollTop||document.body.scrollTop); //-&gt;target e.target=e.srcElement; //-&gt;preventDafault e.preventDefault=function()&#123; e.returnValue=false; &#125;; //=&gt;stopPropagation e.stopPropagation=function()&#123; e.cancelBubble=true &#125; &#125; &#125;//该兼容比较完整，当处理一个简单兼容时可简单处理 type:当前触发事件的类型 target：事件源（当前鼠标操作的是那个元素）（IE6-8没有该属性，用srcElement这个属性代表事件源） preventDefault:作用：阻止事件的默认行为；（IE6-8没有该方法，使用 returnValue=false处理） stopPropagation:阻止事件的冒泡传播 [IE6-8不兼容，使用cancelBubble=true来处理] 键盘事件对象(keyboardEvent) code:当前按得键盘按键是哪一个 【IE6-8没有这个属性】key属性和code一样，储存形式不一样 keyCode：存储的是当前按键的码值（大部分按键都有自己的码值） which:和keyCode一样，也是当前按键的码值（which不兼容IE6-8） 这几个码值需要记住（删除：8 、 回车：13、 空格：32、 tab ：9、） 手指事件对象（TouchEvent）touches&amp;&amp;changedTouches&amp;&amp;targetTouches:存储的是当前屏幕上每一个手指操作的位置信息 touches：只有手指在屏幕上我们才能获取相关信息，手指离开后，这样touchend事件中我们就无法通过touches获取手指信息 changedTouches：手指在屏幕上时，和touches一样可以获得相关信息，手指离开后也可以记录手指离开屏幕一瞬间所在的位置信息（最常用的） 1234567891011121314touchesEvent type:'touchStart', target:事件源， touches: 0:&#123; clientX:xxx, clientY:xxx, pageX:xxx, pageY:xxx, ..... &#125; ... lentth：1 chan 详细处理 1234567891011121314151617181920212223242526272829303132333435363738let oBox = document.querySelector('#box');oBox.ontouchstart = function (e) &#123; let point = e.changedTouches[0]; //=&gt;记录当前手指的起始坐标位置(记录在当前元素的自定义属性上) this.strX = point.pageX; this.strY = point.pageY; this.isMove = false;&#125;;oBox.ontouchmove = function (e) &#123; let point = e.changedTouches[0]; //=&gt;一般我们手指操作，都会或多或少的发生一些偏移（习惯性偏移），此时不应该算作滑动，只有滑动的距离超出一定范围，我们按照滑动处理即可（一般都是把10px作为偏差值） let changeX = point.pageX - this.strX, changeY = point.pageY - this.strY; this.changeX = changeX; this.changeY = changeY; if (Math.abs(changeX) &gt; 10 || Math.abs(changeY) &gt; 10) &#123; this.isMove = true; &#125;&#125;;oBox.ontouchend = function (e) &#123; let point = e.changedTouches[0]; //=&gt;手指离开的时候：验证是否发生滑动 if (!this.isMove) &#123; //=&gt;点击操作 console.log('我是点击操作~~'); return; &#125; //=&gt;滑动操作 let dir = null; if (Math.abs(this.changeX) &gt; Math.abs(this.changeY)) &#123; //=&gt;左右滑动 dir = this.changeX &lt; 0 ? 'LEFT' : 'RIGHT'; &#125; else &#123; //=&gt;上下滑动 dir = this.changeY &lt; 0 ? 'UP' : 'DOWN'; &#125; console.log(`当前手指滑动的方向为：$&#123;dir&#125;`);&#125;; 手机移动端的点击、长按、滑动等都是基于内置的原生的touchstart/touchmove/touchend事件模拟出来的一些效果，没有现成的事件市场上有许多成熟的类库，我们直接使用即可1、fastclick.js:目的就是解决了移动端click事件300ms的延迟问题2、百度云touch手指事件库3、hammer.js4、zepto.js:提供移动端事件操作的板块，也是目前市场上使用率最高的 阻止事件的默认行为A标签的默认行为及阻止 1.超链接：点击A标签可以实现页面的跳转2、锚点定位：通过HASH值定位到当前页面的指定ID盒子位置- 首先URL地址栏末尾追加了一个HASH;- 如果地址栏包含hash值，浏览器在渲染页面后，会默认定位到hash值的位置 真实项目中我们想用A标签做一个普通按钮（优势：它的：hover样式是兼容所有浏览器的）此时，要把之前提到的两个默认行为阻止掉才可以 阻止A标签的默认行为 在HTML中阻止默认行为（常用） ; 在JS中阻止 单点击A标签时 首先会触发click事件 其次按照href中的地址页面进行跳转link.onclick=function(){ return false;}//阻止页面行为link.onclick=function(e){​ e=e||window.event;​ e.preventDefault?e.preventDefault():e.returnValue=false;​ } 事件的传播机制事件传播有三个阶段Event.prototype： 1234- 0 NONE:默认值，不代表任何意思- 1 `CAPTURING_PHASE 捕获阶段`- 2 ` AT_TARGET 目标阶段（当前事件源）`- 3 `BUBBLING _PHASE :冒泡阶段` 当前元素的某个事件行为被触发，它的所有的祖先元素（一直到document）的相关事件行为也会被触发执行（由里向外），我们把这种传播机制叫做冒泡传播 mouseover和mouseenter事件的区别mouseover：鼠标滑到元素上：存在事件的冒泡传播机制 mouseenter：鼠标进入元素里；浏览器阻止了它的冒泡传播机制； 不同点 区别 mouseover mouseenter 区别 1 存在冒泡传播机制 冒泡传播机制被浏览器阻止 区别 2 当鼠标从父元素进入到子元素时，首先会触发父元素的mouseout事件，再触发子元素的mouseover事件，由于冒泡传播机制，导致父元素的mouseover事件也被触发 当鼠标从父元素进入到子元素时,并不会触发父元素的mouseout事件，但是触发了子元素的mouseenter事件，由于浏览器阻止了它的冒泡传播，所以父元素的该事件不会被触发 事件委托（very important）原理：利用事件的冒泡传播机制完成（mouseenter不存在冒泡传播） 当一个容器内的很多元素都要为同一事件绑定方法，那么我们只需要给外层容器的该事件绑定方法，当里层元素的事件被出发时，会通过冒泡传播机制传到最外层容器那里，触发外层容器绑定的方法执行，在方法执行时，我们只需要根据判断事件源的不同而做不同的事情。（利用事件委托可提高50%左右的性能） 拖拽当中鼠标焦点丢失问题在拖拽登陆窗口的案例中（11.25） 当鼠标移动速度过快时，鼠标离开了h3，因为盒子跟不上奔跑的速度，所以导致以下几个问题 - 鼠标在h3之外飞，不会触发H3的mousemove，盒子就不动了； - 鼠标在h3之外抬起，也不会触发h3的mouseup，那么原有绑定的dragmove无法被移除，鼠标重新进入h3,此时不管鼠标是否按下，都会触发H3的dragmove； 原因：鼠标飞出h3,再怎么操作就和h3没有关系 解决方案： 1.把mouseup和mousemove事件绑定给document,原因：不管鼠标怎么飞，都飞不出document；（使用箭头函数）只要你鼠标还在文档中，那么mousemove和mouseup永远生效 2.setCapture（不兼容谷歌，支持Ie） DOM2事件绑定123456 //=&gt;标准浏览器 oBox.addEventLister('click',function(e)&#123; //this:obx &#125;,false) //false=&gt;让事件在冒泡传播时执行//true=&gt;让事件在捕获阶段执行（非常少见） 12345//=&gt;IE6-8浏览器 oBox.attachEvent('onclick',function(e)&#123; //e:事件对象，不同于DOM0级事件，浏览器会默认将事件对象传递进来，与window.event的值相同，因此对于：pageX/pageY/target...等依旧存在兼容； &#125;) //=&gt;绑定的方法都是在冒泡传播阶段执行 DOM1? 在DOM第一代升级迭代的时候，事件绑定依然沿用DOM0绑定的方式..so… DOM0于DOM2事件绑定的区别DOM0事件绑定的原理 给当前元素的某一私有属性（onXXX）赋值的过程；（之前属性默认值是null，如果我们赋值了一个函数，就相当于绑定了一个方法） 当我们赋值成功（赋值一个函数），此时浏览器会把DOM元素和赋值的的函数建立关联，以及建立DOM元素的行为监听，当某一行为被用户触发，浏览器会把赋值的函数执行； DOM0事件绑定的特点 只有DOM元素天生拥有这个私有属性（onxxx事件私有属性），我们赋值的方法才叫事件绑定，否则属于设置自定义属性 移除事件绑定的时候，我们只需要赋值为null； 在DOM0事件绑定中，只能给当前元素的某一个事件行为绑定一个方法，绑定多个方法，最后一次的绑定的会替换前面绑定的 DOM2事件绑定的原理 DOM2事件绑定使用的addEventListener/attachEvent方法都是在eventTarget这个内置类的原型上定义的，我们调用的时候，首先要通过原型链找到这个方法，然后执行完成事件绑定的效果 浏览器会给当前元素的某个事件行为开辟一个事件池（事件队列）【浏览器有一个统一的事件池，每个元素绑定的行为都放在这里，通过相关标志区分】，当我们通过 addEventListener/attachEvent进行事件绑定的时候，会把绑定的方法放在事件池中； 当元素的某一行为被触发，浏览器回到对应事件池中，把当前放在事件池的所有方法按序依次执行 特点 所有DOM0支持的行为，DOM2都可以用，DOM2还支持DOM0没有的事件行为（这样说比较笼统）（核心）【浏览器会把一些常用事件挂载到元素对象的私有属性上，让我们可以实现DOM0事件绑定，DOM2：凡是浏览器给元素天生设置的事件在DOM2中都可以使用】例如：onDOMContentLoaded（所有的DOM0和IE6-8的DOM2都不支持）​onDOMContentLoaded//当前浏览器中的DOM结构加载完成，就会触发这个事件 DOM2中可以给当前元素的某一事件行为绑定多个不同方法（因为绑定的所有方法都放在事件池中）； 事件的移除:事件类型、绑定的方法、传播阶段三个完全一致，才可以完成移除(因此在绑定方法时，尽量不要用匿名函数，否则不好移除) 12345678910111213141516171819//=&gt;ON:给当前元素的某个事件绑定某个方法 var on = function (curEle, type, fn) &#123; if (document.addEventListener) &#123; //=&gt;标准浏览器 curEle.addEventListener(type, fn, false); return; &#125; //=&gt;IE6~8 curEle.attachEvent('on' + type, fn);&#125;;//=&gt;OFF:移除当前元素某个事件绑定的某个方法13.var off = function (curEle, type, fn) &#123;14. if (document.removeEventListener) &#123;15. curEle.removeEventListener(type, fn, false);16. return;17. &#125;18. //=&gt;IE6~819. curEle.detachEvent('on' + type, fn);20.&#125;; xxx.removeEventLister(&#39;click&#39;,function(){},false) ==DOM0和DOM2绑定的方法是毫无联系的（因为是两套完全不同的机制），即使绑定的方法相同，也是执行两次，谁先绑定，就先执行谁== window.onload&amp;&amp;$(document).ready()的区别window.onload:当浏览器中的所有资源（DOM结构、文本内容、图片）都加载完成，触发load事件； 它是基于DOM0的事件绑定机制完成的，所以在同一页面中只能为他绑定一个方法，绑定多个，以最后一个为主； 如果想在一个页面中使用多次，应该是基于DOM2绑定的； 123456function fn1()&#123;&#125; function fn1()&#123;&#125;window.addEventListener('load',fn1,false);window.addEventListener('load',fn2,false); $(function(){})或者$(document).ready(function(){});当文档中的DOM结构加载完成，就会触发执行，在一个页面中可以使用多次 JQ中提供的方法，JQ是基于onDOMContentLoaded这个事件完成操作的 JQ中的事件绑定都是基于DOM2事件绑定的 onDOMContentLoaded在IE6-8下attachEvent也是不支持的，JQ在IE6-8下使用readystatechange来完成 DOM2事件的兼容处理 语法上的兼容标准： curEle.addEventListener（’type’,fn,false）;IE6-8: curEle.attachEvent（’on’+type,fn）; 顺序问题标准：按照绑定的顺序依次执行IE6-8:当事件行为被触发，IE6-8执行是乱序 重复问题标准：可以自动去重，已经存在的方法不允许再次添加IE6-8:在向事件池中增加方法时没有去重机制 this问题标准：当事件行为被触发，方法中的this指向当前元素本身IE6-8:当事件行为被触发，方法中的this指向window IE6-8事件池机制vs标准浏览器事件池机制（比较规范的回答） 1、向事件池中添加方法时，标准浏览器是使用addEventListener,IE6-8使用的是attachEvent；而且标准浏览器有自动去重的机制，已经添加的方法不允许再次添加。IE6-8没有去重机制；2、浏览器执行事件池中的方法时，不仅把方法执行，还把事件对象当作实参传递给给对应的方法，但是也是有区别的，IE6-8传递的事件对象的值和window.event是相同 的，因此存在兼容问题；3.当事件行为被触发，标准浏览器是依次执行，方法中的this指向当前元素；IE6-8下，是乱序执行，且方法中的this指向window； 不兼容的本质：IE6-8低版本浏览器对于他的内置事件池处理机制的不完善导致的。DOM2事件绑定兼容处理机制原理：自己创建一个类似于标准浏览器的自定义事件池（针对IE6-8） on :手动创建一个自定义事件池，把需要绑定的方法全部存在自定义事件池中 off: 把不需要绑定的方法从自定义事件池中移除 run：把run放在内置事件池中，当行为触发，需要浏览器把run执行，在run中把自定义事件池的方法执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//向事件池追加方法var on = function (curEle, type, fn) &#123; //标准浏览器无需处理 if (document.addEventListener) &#123; curEle.addEventListener(type, fn, false); return; &#125; //创建自定义事件池：创建到当前元素的自定义属性上，不受作用域限制，以后在其他方法中需要使用，可直接获取（不放在全局是防止全局污染） // 每一个事件都有一个独立的事件池 if (typeof curEle[type + 'pond'] === 'undefined') &#123; curEle[type + 'pond'] = []; //只要执行on,就说明当前方法已被绑定 //把run放到内置事件池中； // curEle.attachEvent('on'+type,run);//需要保证run中的 this是当前元素 curEle.attachEvent('on' + type, function () &#123; run.call(curEle, e);//将run放在一个匿名函数中，强制改变this &#125;); &#125; var aryPond = curEle[type + 'pond']; // 去重操作，当前事件池中是否有当前事件 for (var i = 0; i &lt; ary.length; i++) &#123; if (aryPond[i] === fn) &#123; return; &#125; &#125; aryPond.push(fn);&#125;;//移除事件池的某个方法var off = function (curEle, type, fn) &#123; if (document.removeEventListener) &#123; curEle.removeEventListener(type, fn, false); return; &#125; var aryPond = curEle[type + 'pond']; if (!aryPond) return; for (var i = 0; i &lt; ary.length; i++) &#123; if (aryPond[i] === fn) &#123; // aryPond.splice(i,1);此方法会导致原始数组索引改变，此时正在执行的run循环，索引和想要的索引不一致，数组塌陷 //我们不能让当前数组的索引改变； aryPond[i] = null;//置空，索引没变 &#125; &#125;&#125;;//把自定义事件池中的方法依次执行var run = function (e) &#123; // this=&gt;curEle //e:window.event，不兼容，需要处理 if (typeof e.target === 'undefined') &#123; e.target = e.srcElement; e.which = e.keyCode; e.pageX = e.clientX + document.documentElement.scrollLeft || document.body.scrollLeft; e.stopPropagation = e.cancelBubble = true; e.preventDefault = e.returnValue = false; &#125; var aryPond = curEle[type + 'pond']; if (!aryPond) return; for (var i = 0; i &lt; aryPond.length; i++) &#123; var itemFn = aryPond[i]; // itemFn();=&gt;这样执行itemFn里的this时window，须将他替换成函数里的this if (itemFn === null) &#123; //当前这一项在执行的时候，可以将off中置空的那一项删除 aryPond.slice(i, 1); i--; continue; &#125; itemFn.call(this, e); &#125;&#125;; Bind方法的封装123456789101112131415161718//ES5封装 BIND Function.prototype.myBind = function myBind(context) &#123; //this=&gt;当前需要处理的函数 //context=&gt;我们需要预先改变的this值（如果不传，默认window）； //arguments=&gt;存储包含context在内的所有实参； context = context || window; var outerArg = Array.prototype.slice.call(arguments, 1); var _this = this; if('bind' in this)&#123;//如果不是IE6-8，直接返回 return _this.bind.apply(_this,arguments) ; &#125; return function () &#123; var innerArg = Array.prototype.slice.call(arguments); outerArg = outerArg.contact(innerArg); _this.apply(context, outerArg); &#125; &#125; 123456789//ES6方法 Function.prototype.myBind = function myBind(context = window, ...outer) &#123; //使用ES6中的剩余运算符 if ('bind' in this) &#123; return this.bind(arguments); &#125; return function (...inner) &#123; this.apply(context, outer.concat(inner)); &#125; &#125;;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（九）定时器]]></title>
    <url>%2Fposts%2Fdb9fe196.html</url>
    <content type="text"><![CDATA[JS中的定时器&amp;&amp;动画&amp;&amp;同步异步编程定时器设置一个定时器并设定一个等待时间，当到达时间，执行指定要完成的事情；JS中的定时器一共有两种： window.setTimeout（执行一次） window.setTimeout(function,[interval]):设置了一个定时器，当到达指定时间后执行对应的方法（执行一次定时器就结束了）；（第一个参数是函数，第二个参数是时间，a单位都是毫秒，自己不需要加单位，17是个比较理想的时间） 123window.setTimeout(function()&#123;console.log('ok');//100ms后输出一次 ‘ok'，此时定时器结束，但是定时器并没有被清除；&#125;,100);//定时器等待时间设置为0也不是立马执行，浏览器也有一个最小反应时间（13MS-14ms）， [interval]：时间因子，需要等待的时间 window.setInterval（执行多次） window.setInterval(function,[interval])：设置一个定时器，当达到指定时间后执行对应的方法（以后每隔这么长时间就重新执行这个方法，直到定时器清除为止，执行很多次） 1234var n=0；window.setInterval(function()&#123;console.log(n++);//每隔100ms输出一次 ，1，2，3，4。。。。&#125;,100);//定时器等待时间设置为0也不是立马执行，浏览器也有一个最小反应时间（13MS-14ms）， 定时器的返回值定时器的返回值，不管是setTimeout还是setInterval都会有一个数字类型的返回值，代表当前是在浏览器中设置的第几个定时器（返回的是定时器的序号） setTimeout和setInterval虽然是处理不同需求的定时器，但是都是浏览器的定时器，所以设置的时候，返回的序号是依次排序setInterval：设置完成时定时器会有一个返回值，不管执行多少次，这个代表序号的的返回值不变（设置定时器就会有返回值，执行多少次是定时器的处理 定时器的清除定时器都需要手动清除，下面两个清除的方法没有区别 clearTimeout([定时器排队的序号])clearIterval（[定时器的排队序号]） 当方法执行完成后，我们清除定时器即可 eg: clearTimeout(1) ，这相当于在浏览器中将第一个定时器清除了。同时我们还需要将之前存储序号的变量赋值为null，例如t1=null，优化JS的内存空间 1234567891011var timer1=setInterval(function()&#123; &#125;,192);//timer1=1，是该定时器的返回值（即该定时器序号）var n=0；var timer2=setTimeout(function()&#123; n++;console.log(n); if(n&gt;=10)&#123; clearSetInterval(timer2);//手动清除 &#125;&#125;,192);//timer2=2，是该定时器的返回值 定时器的原理 当我们在JS中创建一个定时器后，浏览器会把计时执行方法的这个任务放在浏览器的等待任务队列（等待任务池）中，并且安排一个监控者（属于浏览器开辟的新线程），也就是记录当前已经走的时间，到达时间后，监控者会通知浏览器时间到了，浏览器（在把主任务队列的内容执行完后）会把之前放在等待任务队列中的方法拿出来执行； JS中动画实现的原理 浏览器实现动画有三种常用发方法CSS动画在CSS3中提供了transtation动画和animation动画两种动画，优势在于性能好，实现简单，（一般能用css写的绝不用其他方式），弊端在于不兼容IE或其他低版本浏览器（移动端的动画一般都是基于css来完成的）JS中的动画在JS中实现动画常用的有：=&gt;使用定时器驱动的动画=&gt;使用requestAnimationFrame来完成动画而所谓的CANVAS动画基本上也是基于站两种方式完成的（CANVAS本身是绘图）FLASH动画早期实现动画的方法，现在一些简单的DOM动画都告别了FLASH时代 基于定时器的动画 基于定时器实现的动画的两种解决方案- 固定步长的动画- 固定时间的动画（比较常用）我们最好封装一个方法，支持固定时间的多方向的匀速或飞匀速运动 如何实现多方向匀速 回调函数(callBack) 把一个函数当做实参传递给另一个函数，在另外一个函数中执行这个函数，这种处理机制叫做回调函数 1234567function fn(callBack) &#123; //=&gt;callBack:传递进来的匿名函数 callBack();&#125;fn(function () &#123; console.log('ok');&#125;); 凡是在当前方法执行的某个阶段，执行一个不确定的事情，我们可以将这件事情当做参数 JS中的同步编程和异步编程 JS是单线程的（一次只能执行一个任务，当前任务没有完成，下面的任务是不进行处理的）同步编程（sync）：当前任务是按照顺序一件件完成的，当前任务没有完成，下面的任务不进行处理异步编程（async）：当前任务在等待执行的时候，我们不去执行，继续完成下面的任务，当下面的任务完成后，也到达的等待的时间了，才去完成当前的任务 定时器都是异步编程的 所有的事件绑定也是异步的 AJAX中有异步编程 有些人把回调函数当做异步编程其余都是同步编程 1234567var startTime=new Date();//获取开始的时间 for (var i = 0; i &lt; 1000; i++) &#123;if(1===99)&#123; console.log(i);&#125;&#125;console.log(new date -startTime);//计算完成循环的时间 在项目中，要避免出现死循环，因为循环时同步编程，当前循环无法结束证明任务没有完成，后续任务无法进行 12345678var n = 0;//第一件任务：创建一个变量 // 第二件任务：创建一个定时器（等待任务，1000MS执行方法是一个等待执行的任务） setTimeout(function () &#123; n++； console.log(n);//再输出n=1 &#125;, 1000);//第三件任务：输出0console.log(n); //首先输出n=0; 同步异步编程的核心原理 JS中有两个任务队列（存放任务列表的空间） 1、主任务队列：同步执行任务（从上到下依次执行）2、等待任务队列：异步执行任务]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（八）盒子模型]]></title>
    <url>%2Fposts%2Fba5b0d45.html</url>
    <content type="text"><![CDATA[JS中DOM盒子模型深入分析CSS盒子模型传统盒子模型width height:不是盒子的宽高，而是盒子中的内容 盒子的宽度=width+border2+padding2//在一个对称的模型中 CSS3新增加的盒子模型增加该属性，width和height的数值就是盒子的宽高； 1box-sizing:border-box; JS盒子模型 提供一些属性和方法用来描述盒子的样式的 clientclientWidth / clientHeight 当前盒子可视区域的宽度和高度可视区域：内容的宽高+padding*2clientHeight=height+padding(top&amp;&amp;bottom)clientWidth=height+padding(left&amp;&amp;right)和内容是否溢出和我们是否设置了overflow:hidden没有关系 1document.documentElement.clientWidth||document.body.clientHight //获取当前页面一屏幕的宽度 在不知盒子宽高的情况下，让盒子居中 123456var winH=document.documentElement.clientHeight||document.body.clientHeight;var winW=document.documentElement.clientWigth||document.body.clientWigth;var boxW=box.clientWidth;var boxH=box.clientHeight;box.style.left=(winW-boxW)/2+'px';box.style.top=(winH-boxH)/2+'px'; clientTop 和 clientLeft 只有top和left，没有其他的clientTop：盒子上边框的高度clientLeft：盒子左边框的宽度通过JS盒子模型获取的结果是不带单位的，而且只能是整数，（他会自动四舍五入） offsetoffsetWidth 和 offsetHeight 在clientHeight和clientWidth的基础上加上了边框的长度；offsetWidth=clientWidth+左右边框(border)offsetHight=clienthight+上下边框真实项目中，如果想要得到盒子的宽度和高度一般都用offsetWidth和offsetHeight，这样就包含了盒子的边框 123456var winH=document.documentElement.offsetHeight||document.bodyElement.offsetHeight;var winW=document.documentElement.offsetWigth||document.bodyElement.offsetclientWigth;var boxW=box.offsetWidth;var boxH=box.offsetHeight;box.style.left=(winW-boxW)/2+'px';box.style.top=(winH-boxH)/2+'px'; offssetParent 当前和盒子的父级参照物（得到父级参照物元素） 父级参照物不等价于父级元素，与父级元素没有直接关系父级参照物：同一平面中最外层容器是所有里层盒子的父级参照物一般情况下，一个页面所有元素的父级参照物都是body，body没有父级参照物； 当我们给元素设置定位（会让元素脱离文档流）的时候，会改变父级参照物（不在一个平面上） offsetTop&amp;offsetLeft:当前元素外边框距离父级参照物的内边框的偏移量（标准IE8浏览器特殊性： 当前元素最外边框距离父级参照物的外边框的偏移里量 ）window.navigator.userAgent 获取浏览器的版本号 获取页面中任何一个元素距离body的左偏移和上偏移，不知道该元素的具体位置。思路： 首先获取自己的偏移量及父级参照物如果父级参照物不是body，我们加上父级参照物的边框和偏移量。。。一直加到父级参照物为body的元素为止 scrollscrollHeight &amp;&amp; scrollWidth 没有内容溢出：获取的结果和clientWidth、clientHeight的结果相同；有内容溢出：真实内容的宽度或高度，包含溢出内容的值，再加上padding或左padding的值scrollWidth&amp;&amp;scrollHeight获取的是约等于的值由于内容溢出，每个浏览器对于行高或文字的渲染不一样，回去的结果也不一样是否设置overflow：hidden对最后的结果也有影响 获取当前页面的真实高度（包含溢出） 1document.documentElement.scrollWidth||document.body.scrollHight scrollLeft &amp;&amp; scrollTop 横向或竖向滚动条卷去的宽度或高度(在拉动滚动条时，上面的内容会被卷去，就是scrollTop) 最小值：0 最大值：scrollHight-clientHight:真实页面高度-一屏幕的高度 前面的JS盒子模型的属性都是只读属性，只能获取，不能修改；而scrollTop&amp;&amp;scrollLeft是可读写属性，既可以获取，也可以修改； window.onscrollwindow.onscroll:浏览器滚动条滚动事件（只要滚动就会触发该事件） * 1、鼠标滚轮控制 或者 手动拖动滚动条 * 2、键盘按键控制 * 3、使用JS代码控制 * … * 不管什么方式,只要滚动条动了就会触发这个事件 在JS中获取元素的具体的样式值 通过JS盒子模型12个属性（不包含offsetParent）获取的结果都是整数，没有单位，如果有小数，浏览器会自动四舍五入通过JS盒子模型 属性获得的值都是组合值，不能单独获取某一个具体样式值 curEle.style.xxx; 获取当前元素所有写在行内样式上的样式值(如果样式没有设置在行内元素上 得到空字符串)特殊：只有把样式写在行内样式上，才可以通过这种方法获取到=》这种方法在真实项目中比较少见，因为我们很少在行内样式上写样式 window.getComputedStyle &amp;&amp; curEle.currentStyle 只要当前元素在页面中显示出来，我们就可以获得其样式值（不管是行内还是样式表），也就是获取所有经过浏览器计算过的值，包括你没有写浏览器默认设置的值。window.getComputedStyle:适用于标准浏览器，IE6-8不兼容，在IE6-8的Window全局对象中，没有提供getComputedStyle这个属性和方法，我们使用curEle.currentStyle来获取需要的样式值 //通过getComputedStyle获得的结果是一个对象,包含当前元素所有的样式属性和属性值 语法：window.getComputedStyle([当前需要操作的元素],[当前元素的伪类，一般写null])window.getComputedStyle(box,null).paddingleft; //通过 curEle.currentStyle来获取样式box.currentStyle.paddingleft; 封装一个公共的方法：getCss 1234567891011121314151617//getCSS：获取当前元素某一个样式的属性值//@parameter curEle:当前需要操作的元素//attr:要获取样式的属性名function getCss(curEle,attr)&#123;var value=null;var reg=null;try&#123;value=window.getComputedStyle(cueEle,null)[attr];&#125;catch(e)&#123;value=curEle.currentStyle&#125;reg=/^-?\d+(\.\d+)?(px|pt|em|rem)?$/i;//去除单位reg.test(value)?value=parseFloat(value):null;return value;&#125;console.log(getCss(box,'display')); 方法二： 1234567891011121314function getCss(curEle, attr) &#123;var value = null,reg = null;if ('getComputedStyle' in window) &#123;value = window.getComputedStyle(curEle, null)[attr];&#125; else &#123;value = curEle.currentStyle[attr];&#125;//=&gt;去除单位reg = /^-?\d+(\.\d+)?(px|pt|rem|em)?$/i;reg.test(value) ? value = parseFloat(value) : null;return value;&#125;console.log(getCss(box, 'display')); 设置元素的样式 curEle.style.xx=xxx;设置当前元素的行内样式；（JS设置样式一般都设置在行内样式上，因为行内样式优先级最大）（JS操作属性不支持-，所有-改成下一个单词大写）curEle.className=xxx;设置元素的样式类名； 1234567891011121314151617181920curEle['style'][attr]=value;//传递value值，如果没有单位，需要补单位//并不是所有的值都需要补单位，//传递的值带单位，不需要不单位 if(attr==='opacity')&#123;curEle.style.opacity=value;curEle.style.filter='alpha(opacity='+value*100%');&#125; !isNaN(value)&amp;&amp;!/^(zoom|lineHeight|zIndex|fontWeight)$/i.test(value)?value+='px':null;curEle['style'][attr]=value;&#125;setCss(box,'padding','20px');将3个方法封装在一个里面var css = function () &#123;var len = arguments.length,type = Object.prototype.toString.call(arguments[1]),fn = getCss;len &gt;= 3 ? fn = setCss : (len === 2 &amp;&amp; type === '[object Object]' ? fn = setGroupCss : null);return fn.apply(this, arguments);&#125;; children 不管在什么浏览器中，都可以获得当前元素的子节点,（元素节点）但在IE6-8下，也会将注释节点获取到，因此有所差别 123function children(curEle)&#123;&#125; 编程常用方法：假设法 排除法 JS中的动画 1、步长偿固定，完成时间不固定2、固定时间动画 12345678910111213141516171819function linear(t, b, c, d) &#123;return t / d * c + b;&#125;var oBox = document.getElementById('box');var time = 0,//已经运动的时间duration = 1000,//总时间begin = utils.css(oBox, 'left'),//左边距target = utils.winBox('clientWidth') - oBox.offsetWidth,//目的地change = target - begin;//总共需要走的距离var timer = setInterval(function () &#123;time += 17;if (time &gt;= duration) &#123;utils.css(oBox, 'left', target);clearInterval(timer);return;&#125;var curL = linear(time, begin, change, duration);utils.css(oBox, 'left', curL);&#125;, 17); 图片懒加载原理：1、IMG标签的SRC不存放图片的地址(如果存放真实的地址,页面一加载图片肯定就加载出来了),我们把真实图片的地址存储在当前IMG标签的自定义属性上(DATA-IMG)2、为了保证当前图片没有真实地址的时候,浏览器中不会出现叉叉或者出现ALT中的内容,我们一般都会把图片先隐藏(display:none opacity:0…)，等到后期把真实图片加载出来，在让当前图片展示3、看不到真实图片了，我们最好给一个占位图片（占位图：要求一定要很小,最好是1KB）：我们在IMG外面包一层DIV盒子,把占位图赋值给当前盒子的背景图片来处理 =&gt;开始IMG不显示,展示的是默认的背景图,当IMG真实地址加载完成后,我们让IMG显示,此时真实图片会覆盖住背景图]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础知识（七）正则]]></title>
    <url>%2Fposts%2Feda90d92.html</url>
    <content type="text"><![CDATA[正则正则的基础知识什么是正则？ 正则就是一个规则，用来处理字符串的规则1、正则匹配 编写一个规则，验证某个字符串是否匹配这个规则，用test方法 2、正则捕获 编写一个规则，在一个字符串中，把符合规则的内容都获取到，使用方法：正则的exec方法、字符串中的split、replace、match等方法都支持正则 var reg=/^$/;//两个斜杠之间包含的内容就是正则，两个斜杠之间的全部内容都是元字符 正则的元字符和修饰符 任何一个正则都是由元字符和修饰符组成的 修饰符 g(global):全局匹配 i(ignore):忽略大小写匹配 m(mutiline)：多行匹配 元字符[量词元字符] +：让前面的元字符出现1到多次 ？：出现0到1次 *：出现0到多次 {n}:出现n次 {n,}:出现n到多次 {n,m}:出现n到m次 [特殊意义的元字符]-\ ：转义字符-.：除了\n（换行符）以外的任意字符-\d：匹配一个0-9的任意字符 \D ：匹配一个非0-9的任意字符 \w ：匹配一个[0-9a-zA-Z_]之间的任意字符 \s ：匹配一个任意空白符 \b ：匹配一个边界符(单词的左右，-的左右两边) x|y：匹配两者中的其中一个 [a-z] ：匹配a-z中的任意一个字符 [^a-z] ：匹配非a-z中的任意一个字符 [xyz] ：匹配xyz中的其中一个 [^xyz]：匹配除了xyz以外的任意字符 ()：正则小分组 ^：以某一个元字符开始 $ ：以某一个元字符结束 ？： 只匹配不捕获 ？=：正向预查 ？！ ：负向预查 1234var reg=/^\d$/; //说明以数字开头，以数字结尾 ，且只包含一个数字 var reg=/^2.3$/;//.代表除了\n以外的任意字符 reg.test(2.3); true 12345678var reg=/^18|19$/;// x|y的情况// 18或19// 以1开头以9结尾，中间是8或1// 以18开头或以19结尾//var reg=/^（18|19）$/;//18或19 //（）正则里的分组，大正则里的小分组，我们可以使用它改变默认的优先级//此时只有18或者19符合规则 （） （）正则里的分组，大正则里的小分组，我们可以使用它变默认的优先级 小分组还有第二个作用：分组引用 小分组第三个作用： 分组捕获 分组引用：\1 表示出现和第1个分组一模一样的字符 1var reg=/^([a-z])([a-z])\2(a-z)$/;// 类似于food week feel oppo等都符合该正则 [ ] [xyz] [^xyz] [^a-z]var reg=/^[a-zA-Z0-9_]$/;//等同于\w[ ]中出现的元字符，一般都代表本身的含义var reg=/^[.?+]$/里面的.代表.本身//需求类的命名规则：数字字母下划线 _，（-不能作为开头）var reg=/^\w[\w-]*$///不要让-出现在中间就可代表其本身的含义，出现在中间表示范围链接符 var reg=/^[18-65]$/代表的意思：1或86或5中的任意一个字符 ，中括号出现的18不代表数字18而是1或者8，当前正则非法18-65岁份三阶段1819 (18|19)2059([2-5]\d)6065(6[0-5]) 验证是否为有效数字 可能正数，可能是负数整数或小数只要出现小数点，后面至少出现一位小数点前必须有数字var reg=/^-?(\d|([1-9]\d+)(\.\d+)?$/ 电话号码 1var reg=/^1\d&#123;10&#125;$/ 中文姓名 123 /^[\u4E00-\u9FA5]$/ :中文汉字的正则var reg = /^[\u4E00-\u9FA5]&#123;2,10&#125;(·[\u4E00-\u9FA5]&#123;2,10&#125;)?$/;尼古拉斯·王武 邮箱 1234567891011reg=/^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/分析需求： * 以数字字母下划线开头 * @前面可以是 数字、字母、下划线、-、. 这些符号 * 不能把 -和. 连续出现，出现一次后面必须跟数字字母下划线 * * @后面的部分支持 * 企业邮箱* .com.cn 多域名情况 *///这样写不仅可以匹配，而且以后捕获的时候，不仅可以把大正则匹配的结果捕获到，里面的每一个小分组也可以分别捕获到"分组捕获" 身份证号 1var reg=/^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d)(X|\d)$/ 正则捕获 把当前字符串中的符合规则的字符捕获到RegExp.prototype.exec实现正则捕获的方法当我们执行reg.exec(str)的时候， 1、先去验证当前字符串和正则是否匹配，如果不匹配则返回结果null； 2、如果匹配，从字符串最左边开始，向右查找匹配内容，并把匹配内容返回 exec捕获到的结果的格式：获取的是一个数组数组中的第一项是当前本次大正则匹配的结果index:记录了本次捕获到结果的起始的索引input：当前正则操作的原始字符串如果当前正则当中有分组，获取的数组中，从第二项开始，都是每个小分组执行一次exec只能把符合正则规则的一个内容捕捉到，若果还有其他符合规则的， 需要再次执行exec才有可能捕获到； 正则捕获的懒惰性正则为什么会存在懒惰性 正则本身有一个属性：lastIndex（下一次正则在字符串匹配查找时的开始索引）默认值：0，从字符串的第一个字符开始查找匹配的内容默认不管执行多少次exec，正则的lastIndex值都不会变，也就是还是从第一个字符开始查找并且当我们手动改变last Index的值时，不会起任何作用由此导致：执行一次exec捕获到第一个符合规定的内容，第二次执行exec，捕获到的依然是第一个匹配内容，后面的无论执行多少次都捕获不到 解决正则的懒惰性 在正则的末尾加修饰符g(全局匹配)加了修饰符g，每次exec结束后，浏览器会默认把lastIndex的值进行修改，下一次从上一次结束的位置开始查找，所以可以得到后面匹配的内容了 1var reg=/\d+/g;//开启全局匹配 exec有自己的局限性，执行一次exec只能捕获到一个结果，如果想要全部捕获到，就要执行多次，下面封装的myExecAll方法，可以将正则匹配的全部内容捕获到 12345678910111213141516RegExp.prototype.myExecAll=function()&#123;//this 是当前需要处理的正则//str是当前需要处理的字符串var str=agruments[0]||'';var result=[];//首先判断是否加了全局修饰符G，如果没有加，我们直接将第一次的结果返回即可if(!this.global)&#123; return this.exec(str);&#125;var ary=this.exec(str);while (ary)&#123;//(等同于ary!==null:可以捕获到内容，我们继续下一次捕获 result.push(ary[0]);//第一项为匹配到的结果 ary=this.exec(str);//继续执行下一次捕获&#125;return result;&#125;； 使用字符串中的match实现捕获 使用字符串match捕获， 如果正则加了g,会捕获到所有匹配结果 如果不加g,则只会捕获到第一个匹配结果 match的局限性 在加了修饰符g的情况下，·执行match只会把大正则匹配的结果捕获到，对于小分组里的匹配结果会自动忽略· 使用test实现捕获不管是正则的匹配还是捕获，在处理的时候是没有区别的，从字符串里的第一个字符开始查找符合规则的字符，如果可以找到，则返回true，exec捕获返回捕获的内容，如果没有找到，test返回false，exec捕获返回null 如果正则设置了修饰符g，不管是使用test还是exec的任何方法，都会改变lastIndex值，（下一次查找是基于上一次匹配结果向后查找的） 12345var str='my name is &#123;0&#125;~~';svar reg=/\&#123;(\d+)\&#125;/g;if(reg.test(str))&#123;//-&gt;lastIndex=0console.log(reg.exec(str));//-&gt;null lastIndex值被修改，向后查找，无匹配&#125; test不仅可以找到匹配的内容，也肯能将匹配的内容获取 1console.log(RegExp.$1);//获取当前匹配内容的第1个小分组; 所有支持正则的方法，都可以实现字符串的捕获（一般都是字符串方法） 字符串中常见的支持正则的方法 match ***split *var str=’name=”珠峰”&amp;age=8’;str.split(/(&amp;|=)/); //使用split进行字符串进行拆分的时候，如果正则包含小分组，会把小分组的内容捕获到，放在最后的数组中//本案例()只是为了改变优先级，但我们只想匹配不想捕获分组里的内容，?:可以解决str.split(/?:(&amp;|=)/);// 这样浏览器就不会把小分组的内容捕获到；要计算是第几个分组，从左到右数( =&gt;半括号即可**replace 字符串中原有字符的替换str.replace(old,new) 123var str='珠峰2011珠峰1021';str=str.replace('珠峰','珠峰培训');str.replace(/珠峰/g,'珠峰培训'); 在不使用正则的情况下，执行一次replace只能替换一个原有字符，第二次执行replace，依旧是从第一个字符开始查找，类似于正则的懒惰性 工作中，replace都是和正则一起搭配使用replace原理： 当replace方法执行，第一项传递一个正则 正则不加g,把当前第一个字符串中和正则匹配的内容捕获到，替换成新字符 正则加g,把当前所有和正则匹配的内容都捕获到，并替换成新字符 当replace执行，第二次参数传递的是一个函数（回调函数） 首先用正则在字符串中进行匹配，匹配到一个符合规则的，就把传递的函数执行一次 不仅执行这个函数，还把正则本次捕获的结果（同执行exec捕获的结果,包含小分组）当做实参传递给这个函数（这样就可以在函数中获得这些值，这些值就是正则每一次捕获的结果） 正则捕获方法统计 方法名 不加g 加g exec 懒惰性，只能到捕获第一个匹配值包括小分组 多次捕获可得所有匹配字符，包括小分组 match 懒惰性 同上 一次捕获到所有匹配字符，但不能匹配到小分组 test 懒惰性同上 多次捕获可得全部内容，每执行一次test，就console.log(RegExp.$1)，可得当前匹配字符 replace 懒惰性，只替换一个 全部替换 正则案例=&gt;单词首字母大写 12345678910var str='my name is zhu-feng-pei-xun,i am 8 years old,i am qian duan pei xun no1!';//先把混淆边界符的-替换为下划线 str=str.replace(/-/g,_);//通过边界符匹配到每个单词str=str.replace(/\b(\w)(\w*)\b/g,function()&#123; console.log(agruments); return agruments[1].toUpperCase()+agruments[2];&#125;)str=str.replace(/_/g,-); 12var str='2017-11-07 16:30';//改写成2017年11月07日16时30分//replace 模板匹配（） 1234567891011var template='&#123;0&#125;年&#123;1&#125;月&#123;2&#125;日 &#123;3&#125;时&#123;4&#125;分&#123;5&#125;秒';var reg=/\d+/g;var ary=str.match(reg)var str='2017-11-07 16:30';//先将str的有效数字匹配出来，得到一个数组（match）//其次 将template中的&#123;0&#125;与之数组对应索引替换（/\&#123;(\d)\&#125;）;var template=template.replace(（/\&#123;(\d)\&#125;）,function()&#123; var index=arguments[1];//有多少个匹配的字符串，函数就会被执行多少次，这是每次匹配的小分组，即0/1/2... var value=ary[index];//将数组中对应索引的值拿出来 return value;&#125;) 正则创建方式字面量方式 1var reg=/\d+/img; 构造函数创建 123new RegExp('元字符'，'修饰符') var reg= new RegExp('\\d+'，'g');//将一个\换成\\才是转义字符的意思，''里面放的都是字符串 构造函数可以动态加入一个变量的值 问号传参（面试题）1234567891011121314let url = 'http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e';//实现方法String.prototype.myQueryURLParameter = function myQueryURLParameter() &#123; let reg = /[?&amp;]([^?&amp;=]+)(?:=([^?&amp;=]*))?/g, obj = &#123;&#125;; this.replace(reg, (...arg) =&gt; &#123; let [, key, value] = arg; obj[key] = value; &#125;) return obj;&#125;;//方法调用let result = url.myQueryURLParameter();=》&#123; a: '1', b: '2', c: '', d: 'xxx', e: undefined &#125;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（六）关于面向对象的理解]]></title>
    <url>%2Fposts%2F2801c46e.html</url>
    <content type="text"><![CDATA[关于面向对象的理解(构造函数、原型链)OOP(面向对象编程思想) 它是一种编程思想，让我们基于类和实例的概念来编程开发和学习。 单例模式单例设计模式是一种把对象数据类型实现把描述同一件事物的属性或者特征归纳汇总在一起，以此避免全局变量冲突问题的方式和思想。把描述同一件事务的属性或者方法存放在某一个命名空间下，多个命名空间中的属性和方法是互不干扰的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//=&gt;单例模式//1、singleton不仅仅是对象名了，在单例模式中，singleton称之为 “命名空间(nameSpace)”var singleton=&#123; xxx:xxx, ...&#125;; var singleton=&#123; nameSpace1:&#123; xxx:xxx, ... &#125;, nameSpace2:&#123; xxx:xxx, ... &#125; ...&#125;;使用单例模式实现模块化开发模块化开发：把一个复杂页面按照具体功能划分成几大块，然后由不同的人分别去开发，这种模块划分的思想就是模块化开发功能。//=&gt;项目主管（开发人员）：公共模块 var utils=&#123; trim:function()&#123;&#125;&#125;; //=&gt;李雷：搜索模块var searchModel=&#123; submit:function()&#123; utils.trim(); &#125;, ...&#125;; //=&gt;韩梅梅：天气模块var weatherModel=&#123; setWeather:function()&#123;&#125;, ...&#125;;//=&gt;小红：频道模块var channelModel=&#123; show:function()&#123; //=&gt;在当前的命名空间下调取其它命名空间的方法：指定好对应的命名空间名字即可，使用 [NameSpace].[property] 就可以操作了 searchModel.submit(); //=&gt;调取本模块中的一些方法，可以直接使用THIS处理即可：此方法中的THIS一般都是当前模块的命名空间 this.setChannel(); &#125;, setChannel:function()&#123;&#125;, ... &#125;; 高级单例模式基于JS高阶编程技巧惰性思想，来实现的单例模式，并且可以把一些常用的设计模式（如：命令模式、发布订阅模式、promise设计模式等）融合进来，最后清晰的规划我们的业务逻辑代码，方便后期二次开发和维护，这种设计思想综合体就是高级单例模式，也是最常用的。 12345678910var serchModel=(function()&#123; function submit()&#123; &#125; return &#123; init:function()&#123; this.submit(); &#125; &#125; &#125;)(); searchModel.init(); 对象、类、实例对象：万物皆对象类：对象的具体细分（按照属性或特性细分的一些类别）实例：某一个类中的具体事物 JS常用的内置类数据类型的类Number：每个数字或者NaN是它的一个实例String：字符串类Boolean：布尔类NullUndefined：浏览器屏蔽了我们操作null和udnefined这个类Object：对象类，每个对象数据类型都是它的实例• Array：数组类• RegExp：正则类• Date：日期类Function：函数类，每个函数都是它的一个实例元素对象或者元素集合的类HTMLCollection：元素集合类• getElementsByTagName()• getElementsByClassName()• querySelectorAllNodeList：节点集合类• childNodes• getElementsByName()HTMLDivElementHTMLElementElement(标签类)Node(节点类，Element只是其中的一个元素节点) 为什么getElementById的上下文只能是document？(即getElementById为什么只能通过document来调用)？因为只有在Document这个类上才有getElementById这个方法，其他类上(如：HTMLDivElement类)没有getElementById这个方法，而document是HTMLDocument这个类的一个实例,能通过document.proto.proto找到Document这个类的原型上公有的getElementById方法。 基于面向对象创建数据创建方式：两种1.字面量创建方式• var obj={}；2.实例创建方式（构造函数方式）• var obj=new Array();如果传递的参数只是一个数值 1、对于引用数据类型来说，两种创建方式是大致相同的，只不过，两种方法创建的语法不同。两种创建方式在核心意义上没有差别，都是创建Array这个类的一个实例，但是在语法上是有区别的 2、构造函数创建方式new Array(10)：创建一个长度为10的数组,数组中的每一项都是空new Array(‘10’)：如果只传递一个实参，并且实参不是数字，相当于把当前值作为数组的第一项存储进来new Array(10,20,30)：如果传递多个实参，不是设置长度，而是把传递的内容当做数组中的每一项存储起来 2、对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果是有一定区别的，从严格意义上来讲，只有实例创建出来的结果才是标准的对象，数据类型值也是标准的对象数据类型，也是标准的内置类的实例；对于字面量方式创建出来的结果是基本数据类型的值，不是严格的实例，但是由于JS的松散特点，导致了可以使用 内置类.prototype上提供的方法； 构造函数设计模式使用构造函数方式，主要是为了创建类和实例的，也就是基于面向对象思想来实现一些需求在JS中，当我们使用new xxx()执行函数的时候，此时的函数就不是普通的函数了，而是变为一个类，返回的结果叫做当前类的实例，我们这种new xxx执行的方式称之为构造函数设计模式 12function fn()&#123; &#125;new fn();//new fn()是fn的一个实例 构造函数执行时new都干了些什么？在new Fn()，执行的时候，是先把函数执行了，后面的Fn()先执行，形成一个私有作用域，形参赋值变量提升，在变量提升完了之后，new操作符才起了作用，此时，浏览器开始创建一个新的对象，让Fn中的this指向这个新创建的对象（实例），然后让这个对象的proto指向Fn.prototype，然后JS代码才开始继续往下执行，开始往类中添加每个实例私有的属性和方法。JS代码执行完成后，会默认返回当前创建的这个对象。 普通函数执行与构造函数执行的区别 在代码从上而下执行之前，构造函数有特殊的操作：浏览器会在当前的作用域中默认创建一个对象数据类型的值，并且会让当前函数中的this指向创建的这个对象。然后JS代码再执行， 代码执行完成后，即使函数中没有写return，在构造函数模式中：浏览器会默认的把创建的对象返回到函数外面 总结： 构造函数执行期间，既具备函数执行的一面，也同时具备自己独有的操作：在构造函数执行期间，浏览器会默认创建一个对象，这个对象就是当前这个构造函数(类)实例，函数执行完成后，浏览器会默认的把这个实例返回。所以new Fn()执行，Fn是一个类，返回的结果就是Fn这个类的一个实例 构造函数执行后面的‘()’问题构造函数执行如果不需要传递参数，函数后面的()可省略，如new Fn()可写为new Fn；注意：• 如果要在new Fn之后直接调用实例的方法，则必须要加小括号，即必须写成new Fn().方法名 构造函数模式的返回值问题构造函数模式中默认返回值是当前的实例，如果有return,返回分2种情况：1、return 后面是一个基本数据类型的值，当前实例是不变的，例如return 100；我们的返回值还是当前类的实例；2、return 后面是一个引用数据类型的值(window除外)，当前实例会被返回的值给替换掉例如return {name:”李雷”}我们的返回值就不再是当前类的实例了，而是对象 {name:”李雷”}； A instanceof B 检测某一个实例是否属于这个类, 判断A实例是否属于B类 hasOwnProperty VS inin：用来检测当前这个属性是否隶属于对象（不管是对象私有的还是公有的属性，只要有返回的就是true） hasOwnProperty：用来检测当前这个属性是否是对象的私有属性（不仅要是对象的属性，而且需要是私有的才可以） 1234attr in object//检测attr是否是object的属性，不管是私有属性还是公有属性只要存在，用in来检测都是truea.hasOwnProperty(attr)//attr是否是A实例的私有属性 原型链模式基于构造函数模式的原型链模式解决了方法或者属性公有的问题，把实例之间公有的属性和方法写在当前类的prototype属性上； 每一个函数数据类型都有一个天生自带的属性：prototype（原型），并且这个属性的属性值是一个对象数据类型的值，浏览器默认为其开辟一个堆内存； 在浏览器给prototype开辟的这个堆内存上浏览器天生给它加了一个constructor属性（构造函数），属性值是当前函数（类）本身； 每一个对象数据类型(普通对象、数组、正则、实例、protoype..)也天生自带一个属性:proto，属性值指向当前实例所属类的原型(prototype);(IE中屏蔽了对象的proto属性，但是确实有，只是不让我们使用而已) Object是JS中所有对象数据类型的基类（最顶层的类）； 原型链模式中的this分两种情况原型模式中的this分两种情况： 在类中this.xxx=xxx;this-&gt;当前类的实例 原型链中提供的私有(公有)方法中的this问题： 总结：看执行的时候”.”前面是谁this就是谁。具体操作步骤如下 需要先确定this的指向（this） 把this替换成对应的的代码 按照原型链查找的机制，一步步的查找结果 重构原型让某个构造函数的原型指向自己开辟的堆内存，但是自己开辟的堆内存当中是没有constructor属性的，所以要往自己开辟的堆内存中添加constructor属性，属性值为当前构造函数本身； contrcutor:fn缺点：重构原型后，会导致之前添加的属性和方法都没有了，只能使用重构之后添加的属性和方法；注意：• 不要忘了重构之后要添加constructor属性指向当前构造函数；• 内置类的原型不能重构，浏览器不允许我们这么做； 类的继承、封装和多态 它是一种编程思想（Object Oriented Programming）,我们的编程和学习其实是按照类和实例来完成的 我们要学习类的继承、封装、多态 封装 把实现一个功能的代码封装在一个函数中，以后再要实现这个功能，只要执行函数方法即可，不需要重新编写代码低耦合高内聚减少页面代码冗余，提高代码利用率 多态一个类（函数）的多种形态：重载、重写 重载 后台JAVA等编程语言中，对于重载的概念：方法名相同，参数名不同，叫做方法的重载JS中没有类似于后台严格意义的重载，JS中，如果方法名相同了，最后只能保留一个（和实参没有关系）JS中的重载：同一个方法，通过传递实参的不同，（arguments）我们完成不同的功能，我们把这个也可以理解为重载 12345678function sum(num1,num2)&#123;return num1+num2;&#125;function sum()&#123;var ary=[].slice.call(arguments);return&#125;//只会执行后面那个sum 重写 不管是后台语言还是JS，都有重写，子类重写父类的方法； 继承 原理：子类继承父类的中的一些属性和方法 原型继承 让子类的原型指向父类的实例；child.prototype=new parent(); 我们首先让子类的原型指向父类的实例，然后在向子类原型上扩展方法，防止提前增加方法，等原型重新指向后，之前在子类原型上扩展的方法都没用了（子类原型已经指向新的空间地址了）； 让子类原型重新指向父类实例，子类原型上的原有constructor就没了，为了保证构造函数的完整性，我们需要重新手动设置constructor: child.protype.constructor.call(child) *原理 *原型继承并不是把父类的属性和方法copy一份给子类，而是给子类和父类之间搭建一个连接的桥梁，以后子类或者子类的实例，可以通过原型链的查找机制，找到父类原型的方法，从而调取这些方法。 特征 子类不仅可以继承父类原型上的公有属性方法，也可以继承父类提供给实例的私有属性和方法，并把其放在子类的公有属性和方法上。 call继承（继承私有的） 原理在子类的构造体中，把父类做普通方法执行，让父类方法中的this指向子类实例特点：把父类 构造体中的私有属性和方法，原封不动复制了一份给子类实例（继承完成后，子类和父类是没有关系的）注意我们一般把call放在第一行，就是创建子类实例的时候，首先继承，然后在给实例赋值自己私有的（好处：自己可以把继承的结果替换掉） 12345678function A()&#123; this.x=100;&#125;function B()&#123;//一般都把call继承放在子类函数体中的第一行,这样做的好处就是子类私有的可以替换掉继承过来的结果； A.call(this); this.y=200&#125; 寄生组合式继承 Object.create（[obj]）:创建一个空对象，把obj作为新对象的原型（继承公有）Object.create不兼容 123var obj=&#123;name:'李雷'&#125;;var newObj=Object.create(obj);newObj.__proto__===obj; child.protype= Object.create(parent.protorype); 利用Object.create创建一个的空对象； 该空对象指向parent.protorype； 将该对象的地址赋值给child.protype，从而导致child和child的实例都可以通过原型链找到parent的原型； 该方法只能继承parent的公有方法和属性 自己实现类似于Object.create的方法 12345Object.myCreate=function myCreate()&#123;var Fn = new Function();Fn.prototype = obj; return new Fn()&#125; ES6中的类及继承123456789101112131415161718192021222324252627282930313233343536class Fn &#123;//constructor就是当前函数本身=Fnconstructor()&#123; this.x='xxx';//给当前实例增加私有属性 .........&#125;//增加公有属性，相当于在原型上添加xxX()&#123; ......... &#125;//这些属性方法都是将Fn当做普通对象设置的私有属性和方法，和实例没有任何关系 static xxx()&#123;.............&#125;&#125; class A &#123; constructor() &#123; this.x = 100; &#125; getX() &#123; console.log(this.x);&#125; &#125; class B extends A &#123; constructor() &#123; super();//=&gt;CALL继承 this.y = 200;&#125; getY() &#123; console.log(this.y);&#125;&#125;var b = new B();]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（五）数组汇总]]></title>
    <url>%2Fposts%2F4834a967.html</url>
    <content type="text"><![CDATA[数组详解给数组开头增加新内容的方法:1234567unshift; ary.[0]=xxx; ary.splice(0,0,X); ary.slice(); //删除数组第一项： shift; splice(0,1); 12345//给数组末尾增加： push; splice(ary.length,0,x) //数组克隆； slice(); 数组的基础结构 数组是对象类型属性名是数字 类数组类似数组 但不是数组（以下是类数组） 通过getElementsByTagName等获取的元素集合 函数中的实参集合argument 记忆数组要按以下几个维度1、方法的意义2、方法的形参3、方法的返回值4、通过此方法，原来数组是否发生改变） 1数组的增加、修改、删除 12var ary=[12,34,5]; ary.push('sd'); 增加 push向数组末尾增加新内容参数：一个到多个，任何数据都可以，用逗号隔开返回值：新增数组后的长度原有的数组变了 unshift向数组开头增加新内容参数：一个到多个，任何数据都可以，用逗号隔开返回值：新增数组后的长度其余同push 把数组当做一个普通的对象，使用对象键值对操作，给其设置新的属性 ary[length]=xxx;向数组末尾添加一个新内容 删除 pop功能：删除数组最后一项参数：无返回值：被删除的那一项原有数组改变了 shift删除数组第一项（后面每一项索引都要向前进一位）参数：无返回值：被删除那一项原有数组改变 delete 把数组当做普通的对象操作 delete ary[索引]删除指定那一项，其余的索引不会改变，数组的length也不变 ary.length–;删除数组最后一项 splice: 数组中内置的方法，可以实现数组的增加、修改、删除 splice实现删除 splice(n,m):从索引n开始删除m个 （m不写是删除到末尾，都不写是不删除）ary.splice(0)全部删除 返回值：被删除的内容（以一个新数组来保存被删除的内容） 原有数组改变 splice实现修改 splice(n,m,x):用x代替删除的内容 splice 实现增加 splice(n,0,x);在修改的基础上，一项都不删除，将x放在n的前面 splice(0,0,x) 向数组开头增加一个 splice(ary.length,0,x) 向数组末尾增加一项 splice(0,1);删除数组第一项 splice(ary.length-1,1) 删除数组最后一项 数组查询slice:数组查询 参数：slice(n,m)从索引n开始找到索引m处（不包含m） 返回值：把找到的部分以一个新数组返回 原来数组不改变 slice(n);从n开始找到末尾 slice(0)/slice();数组克隆，克隆一份和原来一模一样的新数组； slice支持负数，解析时按照：总长度+负数索引 来处理 将两个数组进行拼接concat 将多个数组拼接在一起 参数：要拼接的内容放在原数组后面 返回：拼接后新数组 原有数组不变 concat(),什么都没有拼接，相当于把原有的数组克隆； 数组克隆后出现的是一个新数组，与原有数组不相同，拷贝一份 把数组转化为字符串toString 实现把数组转化为字符串，一逗号分隔 参数：无参数 返回：转换后的字符串 原有数组不变 join 把数组按照指定的分隔符转换为字符串，和字符串中的split相对应 参数：指定连接符 返回值：转化后的字符串 原有数组不变 eval:把字符串变为JS表达式执行var total=eval(ary.join(‘+’)); 可实现数组求和；(一般项目中尽量不要用eval，性能较差) 实现数组中每一项的排序和排列reverse 把数组倒过来排列 参数 ：无 返回值：排序后的数组 原有数组改变 sort 实现数组排序 参数：无或回调函数； 返回值：排序后的 原有数组改变不传参的情况下，只能识别10以内的数字，多位数只识别第一位 1234ary.sort(function(a,b)&#123;return a-b; //升序 a-b&gt;0,a和b交换位置 return b-a;//降序 &#125;) 遍历数组中每一项的方法（ 以下方法在IE6-8都不支持） 方法名 是否操作原数组 方法返回结果 回调函数返回结果 filter（过滤） 否 过滤后的新数组 true/false,若true则放到新数组中 map（映射） 否 新数组 return后的值 find 否 返回找到的那一项，没有返回-1 返回true表示找到了，并停止 some 否 boolean 找true，找不到返回false every 否 boolean 找false，找不到返回true reduce 否 累积后的结果 返回的是下一次的prev 遍历数组或类数组、字符串每一项 for …of 1234let arr = [2, 4, 1, 3]; for(let val of arr)&#123; console.log(val);//2，4，1，3&#125; find 用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12345let arr = [2, 4, 1, 3];res=arr.find((item)=&gt;&#123; return item&gt;1; &#125;) console.log(res);//2 findIndex find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 12345res=arr.find((item)=&gt;&#123; return item&gt;1; &#125;) console.log(res);//0=&gt;2的索引//find,findIndex都可以接受第二个参数，用来绑定回调函数的this对象 forEach（不支持return） 对数组中的每一项运行给定函数，没有返回值 1234let arr = [2, 4, 1, 3];arr.forEach(function (item, index) &#123; console.log(item);//2, 4, 1, 3&#125;) some 对数组中的每一项运行给定函数,只要一个条件成立，则返回true，条件都不成立才返回false; 12345let arr = [2, 4, 1, 3];res = arr.some((item, index) =&gt; &#123; return item &gt; 3;&#125;)console.log(res);//true every 对数组中的每一项运行给定函数,条件都成立才返回true，只要有一个不成立，则返回false 12345let arr = [2, 4, 1, 3];let res4 = arr.every((item, index) =&gt; &#123; return item &gt; 3;&#125;)console.log(res4);//false map()：（映射） 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 12345let ary = [2, 4, 1, 3];let res1=ary.map((item,index)=&gt;&#123; return item*2;&#125;);console.log(res1);//[4,8,2,6] 两个归并数组的方法:reduce,reduceRightreduce: 对数组中的每一项运行给定函数,计算数组每一项的累积值 prev:累积项，next当前项4个参数:[pre,next,index,ary] index：next的索引，ary：原数组 12345678910111213let arr = [2, 4, 1, 3];//实现每一项成员的累加let res5 = arr.reduce((prev, next) =&gt; &#123;//当没有第二个参数时，第一次prev是第一项，next是第二项，然后将他们的和赋值给prev，然后next值会等于第三项，prev就等于累加项，以此类推 return prev + next;&#125;,0)//0是给prev设置的默认值，可不加，当prev有默认值时，next从第一项开始console.log(res5);//10 eg2：let arr1= [&#123;price: 10, count: 2&#125;, &#123;price: 3, count: 6&#125;];//求总金额let res6 = arr.reduce((prev,next =&gt; &#123; return prev+next.price+next.count;&#125;), 0);//0是prev的默认值，此时next第一次就等于数组第一项;console.log(res6); reduceRight 使用 reduce()还是 reduceRight()，主要取决于要从哪头开始遍历数组。除此之外，它们完全相同。 filter （过滤） 对数组中的每一项运行给定函数, 筛选掉不符合条件的，返回匹配条件的 （返回的是一个新数组） 1234let res2 = ary2.filter((item,index)=&gt;&#123; //删除功能时用的多 return item&lt;4&#125;)console.log(res2);//[2,1,3] 数组方法，验证数组中是否包含某一项indexOf/lastIndexOf :获取当前项在数组中第一次或最后一次出现位置的索引 数组中这两个方法在IE6-8下不兼容 字符串中的这两个方法兼容所有的浏览器 如果当前数组中没有这一项，则返回-1； 数组去重方法一： 遍历数组将数组的每一项和上一项比较，如果相同，则删除这一项（for） 方法二 遍历数组每次将数组的某一项和剩下的比较indexOf，如果相同，就删除该项，那么最后留下来的就没有重复项了； 1234567891011var ary=[2,7,8,9,45,8,78,4,2,7]; for(var i;i&lt;ary.length;i++)&#123; var ary2=ary[i]; ary3=ary.splice(i+1); if (ary3.indexOf(ary2)&gt;-1)&#123; ary.splice（i,1); i--; &#125; &#125; console.log(ary); 方式三（键值对的方式） 遍历数组每一项把每一项作为新对象的属性名和属性值存起来，例如当前项1，则[1,1];所以以后如果出现相同的属性名，则删除该项，typeOf obj.[xxx]===undefined;则该项不是重复值在原型上添加一个数组去重的方法 123456789101112131415Array.prototype.myDistinct= function () &#123; let obj=&#123;&#125;; for (let i = 0; i &lt; this.length; i++) &#123; let item= this[i]; if(typeof obj[item]!=='undefined')&#123;//该项是重复的 this[i]=this[this.length-1];//用最后一项的值赋值给当前项， this.length--;//将最后一项删除（上一步已将最后一项保存至前面） i--; continue; &#125; obj[item]=item; &#125; obj=null; return this;&#125;; 123456789101112131415//另一种写法，不会改变原数组的相对顺序Array.prototype.myDistinct = function myDistinct() &#123; let obj = &#123;&#125;; for (let i = 0; i &lt; this.length; i++) &#123; let item = this[i]; if (obj[item] === this[i]) &#123; this.splice(i, 1); i--; continue; &#125; obj[item] = item; &#125; obj = null; return this;&#125;; 冒泡排序 原理：让数组中的当前项和后面的每一项进行比较，如果当前项大于后一项，我们让两者交换位置（小—大），就好像是气泡升到表面一样，因此得名总共比较：length-1次； 12345678910111213141516function bubble(ary) &#123; //-&gt;外层循环控制的是比较的轮数： for (var i = 0; i &lt; ary.length - 1; i++) &#123; //-&gt;里层循环控制每一轮比较的次数. for (var k = 0; k &lt; ary.length - 1 - i; k++) &#123; //ary[k]:当前本次拿出来这一项 //ary[k+1]:当前项的后一项 if (ary[k] &gt; ary[k + 1]) &#123; //当前项比后一项大,我们让两者交换位置 var temp = ary[k]; ary[k] = ary[k + 1]; ary[k + 1] = temp;//可用结构赋值[ary[k],ary[k+1]]=[ary[k+1],ary[k]]; &#125; &#125; &#125; return ary;&#125; 每一轮从前到后两两比较，虽然不一定实现最后的排序效果，但是可以把当前最大的放在末尾具体比较的轮数：ary.length-1 数组有多长，我们只需要把总长度-1个数分别放在末尾，即可实现最后的排序对于数组[12, 13, 23, 14, 16, 11]；第一轮比较5次：一共六个，不需要和自己比较第二轮比较4次：一共六个，不用和自己比，也不用和第一轮放在末尾的那个最大值比第三轮比较3次每一轮比较的次数 ary.length-1(不用和自己比)-当前已经执行的轮数(执行一轮向末尾放一个最大值,这些值不需要再比较) 数组中的深度克隆首先使用JSON.Stringfy将数组转化为无意义的字符串，在使用JSON.parse将字符串转化为对象]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（四）String和Math中常用的方法]]></title>
    <url>%2Fposts%2Fe28a6795.html</url>
    <content type="text"><![CDATA[字符串中常用的方法 索引特点，从0开始length属性，字符串的长度如果指定索引不存在，会得到undefined真实项目中,我们经常操作字符串，此时我们需要掌握一些常用方法console.dir(String,prototype) charAt&amp;&amp;charCodaAt【兼容所有浏览器】 str.charAt();返回索引指定的字符,当指定索引不存在时返回””,当指定索引不存在时str[100]返回undefined;str.charCodeAt(),在charAt的基础上，获取指定位置字符的unicode编码Str.fromcharCode()通过unicoed码 得到原有字符 与charCodeAt相反 substr&amp;&amp;substring&amp;&amp;slice str.substr(n,m):从索引n开始，截取m个字符（第一个参数支持负数）str.subtring(n,m):从索引n开始，截取到索引m处，不包含m;（不支持负数）str.slice(n,m):从索引n开始，截取到索引m处，不包含m,(支持负数)； 当索引时负数时，是用字符串的总长度加上索引，在按照正数操作注意：如果只传递1个参数n，则从n截取到末尾如果索引超过最大值，则能截取多少是多少如果没有传参数，则相当于把整个字符串都截取了（字符串克隆） toUperCase&amp;&amp;toLowerCase toUperCase():把字母全部大写 str.toUpperCase()toLowerCase():把字母全部小写 indexOf&amp;&amp;lastIndexOf【兼容所有浏览器】 indexOf:获取当前字符首次出现的位置lastIndexOf:获取当前字符最后一次出现的位置 *注意 *如果当前字符串没有出现过，结果为-1；由此可以借用此方法来检查是否具有某元素 split Str.split:按照某一元素将字符串划分为几组,返回的是一个数组若不存在，则保持原来的Str支持正则 12345678str='wedfg';str.split('d');//返回值是个数组(2) ["we", "fg"]0: "we"1: "fg"length: 2__proto__: Array(0) replace Str.replace:实现字符的替换Str.replace(a,b) //用b替换a执行一次只能替换一个，想替换多个的多次执行，真实项目中一般正和则一起使用； trim&amp;&amp;trimLeft&amp;&amp;trimRight Str.trimLeft:去除字符串左边兼容Str.trimRight:去除字符串右边空格Str.trim:去除字符串收尾空格 案例：queryURLParameter 获取地址栏中URL地址问号的传递参数值https://www.baidu.com/s?word=谷歌浏览器&amp;tn=93219212_hao_pg&amp;ie=utf-8问号后面就是我们传递的参数https://www.baidu.com/s?f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;word=小说&amp;tn=94076069_hao_pg 我们的目标：把问号传递的参数值给解析出来obj={word:’谷歌浏览器’,tn:93219212_hao_pg,ie:utf-8} 1234567891011121314151617181920212223&gt; function queryURLParameter(url)&#123;&gt; //=&gt;定义一个函数&gt; var quesIndex=url.indexOf('?');&gt; //获取？的位置&gt; var obj=&#123;&#125;;//定义一个空函数&gt; if(quesIndex===-1)&#123;&gt; //如果？不存在&gt; return obj;&gt; &#125;&gt; url=url.substr(quesIndex+1);&gt; //获取?后面的字符串&gt; var ary=url.split('&amp;');&gt; //用&amp;将字符串划分为数组&gt; for(var i=0;i&lt;ary.length;i++)&#123;&gt; var curAry=ary[i].split('=');&gt; //用=将字符串划分为长度为2的数组&gt; obj[curAry[0]]= curAry[1];&gt; //数组中第一个为属性，第二个为属性值&gt; return obj;&gt; &#125; &gt; &gt; &#125;&gt; Math中常用的方法 数学函数，但是他是对象类型Math 中为我们提供了很多常用操作数字的方法conlse.dir(Math)查看有很多方法 @[abs] Math.abs() 取绝对值 @[ceil/floor] Math.ceil() 向上取整Math.flloor() 向下取整 @[round] Math.round() 四舍五入 @[random] Math.random() 获取[0-1)之间的随机小数 1234//获取0-10之间的随机小数[0-10]Math.round(Math.random()*10)//获取[]3-15]的随机整数Math.round(Math.random())*12+3 注意规律 获取[n,m]之间的随机整数Math.round(Math.random())*(m-n)+n @[max/min] Matn.max:获取一组数据的最大值Math.min:获取一组数据的最小值 @[PI] Math,PI:获取圆周率 @[pow/sqrt] Math.pow:获取一个值的多少次幂Math.sqrt 开平方 案例：验证码基本功能实现 （结合Math和String） 一般是由后台处理，后台返回给客户端一张图片（图片中包含了验证码） （防止批量注册，前端容易被解析）验证码形式1、字母数字2、问答3、选择图片4、成语拼图5、图片拼图6、滑动拖拽 案例主要思想(获取4个字母和数字的组合) 获取文档中的元素(最后数字要放进去)定义一个空数组（用于存放随机获得的字符）定义一个取值区域（0-9，a-z,A-Z）共62个创建for循环获取一个0-61的随机整数（Math.round(Math.random*61)）利用这个整数获取该位置的字符，charAt()]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（三）数据类型汇总]]></title>
    <url>%2Fposts%2F4b7ffcca.html</url>
    <content type="text"><![CDATA[数据类型的转换汇总Number类型的转换把其他数据类型转换为number类型的方法 isNaN,Number,parsseIn,praseFloat在进行加减乘除运算时 12345'12px'=&gt;NaN; "主灯"=&gt;NaN[ ] /null /false / ' ' /=&gt;0&#123; &#125; /^$/ function()&#123;&#125;/ undefined /=&gt;NaN*注：引用类型在转化Number时，先转化为字符串（toString），再转变为数字(Nubber)。*parseFloat('');=&gt;NaN 与number不同 js中的数学运算 +、-、*、/、% 加减乘除取模除了加法有特殊性，其与运算遇到非数字类型时都要先转换为Number在进行运算 注：+有字符串拼接的作用(就是把其他值转化为 字符串再拼接)特殊：({ }).toString()==&gt;&#39;[object object ]&#39;//对象的{}要用（）包起来，否则报错，因为{}会被认为是代码块其余都直接转化为字符串 12345678910111213141516//加法的特殊性12+3+'2'=&gt;152'3'+4 =&gt;34null+'2' =&gt; 'null2'// 其余运算1-'1' =&gt;010*null =&gt;0 2+null+false+undefined+NaN+[1,2]+'珠 峰'+32+null =&gt;2+0=22+false =&gt;2+0=22+undefined =&gt;2+NaN=NaNNaN+NaN=NaNNaN+[1,2] =&gt;NaN+'1,2'=&gt;'NaN1,2'数组要先转化为字符串再转为数字再相加，但在转换为字符串时就会进行字符串的拼接'NaN1,2'+'珠峰'+3='NaN1,2珠峰3' 布尔类型的转换将其他数据转换为布尔类型(3种) Blooean / ! / !!判断语句除以下5种外，其余都为true0, null, ’ ‘, NaN, undefined, 注意 12345678910111213141516171819202122//对象和对象比较：比较的是空间地址,不是同一个空间，肯定是false[]==[] =&gt;false var a=&#123;&#125;;var b=a;a==b =&gt;true //(空间地址相同) //对象和数字比较，先调用toString方法[]==0 =&gt;true(&#123;&#125;)==NaN =&gt;false NaN和任何东西都不等，包括自己 //对象和字符串比较 (把两边都转化为字符串)[]=='' =&gt;true //对象和布尔：（把两边都转化为数字）[]==true =&gt;0==1 =&gt;false[]==false =&gt;true![]==false =&gt;true //![]把数组变为布尔再取反[]=true //字符串和数字：（把两边都转化为数字）//字符串和布尔： （把两边都转化为数字）//布尔和数字： （把两边都转化为数字） 规律，两个等于号比较时，左右两边的的数据类型不一样，浏览器会把两边类型都转为数字再比较（对象类型比较特殊，应该先转化为字符串，再转化为数字），但是null和undefined除外null和undefined和其他任何值都不相等 12null==undefined =&gt;true null===undefined =&gt; false 规律，两个等于号比较时，两边类型相同时，直接比较，对象和对象比较的是空间地址；{}！={}，另外NaN和任何值都不等 JS中的数据类型检测汇总typeof 用来检测数据类型的运算符语法：typeof [value]，typeof后面跟的都是值返回结果：首先是个字符串，字符串中包含了我们需要检测的数据类型typeof null=’object’ &gt;虽然时基本数据类型，但是它属于空对象指针，检测结果是对象（局限性）并且不能细分出当前对象是数组还是正则（局限性）typeof 1&gt;1?1:2; =&gt;2 //优先级，先计算typeof 1;再比较， instanceof&amp;constructor instanceof:检测某一实例是否属于当前类constructor:构造函数使用instanceof检测某个值是否属于某个数据类型 的内之类，从而检测出它是否是这个类型的值，对对象类型的值有明显的区分 instanceof检测的弊端基本类型的值无法基于它检测var num=12; typeof num =&gt; ‘Number’num instanceof Number =&gt;falsevar num2=Number(12); typeof num2 =&gt; ‘object’num2 instanceof Number =&gt;true不管是哪一种方式创建基本类型值，都是自己所属类的实例，只不过类型不一样而已 instanceof 是基于原型链来检测的，是要当前类的实例在原型链上，最后返回的结果都是true,这也是instanceof的弊端 constructor获取要检测数据类型的constructor属性，判断它是否为某个数据类型的内置类来检测ary.constructor===Array; =&gt;true;ary.constructor=’AA’;ary.constructor===”AA’; =&gt;true=&gt;由于constructor的值可以被修改，所以检测结果非常不可靠 Object.prototype.toString.call([value]) 获取Object.prototype的toString方法，将方法中的this改为需要检测数据类型的值，然后执行在Number String Boolean Array……这些类的原型上都有toString方法，这个方法就是把本身的值转换为字符串的在Object这个类的原型上也有一个toString方法，但是这个方法是返回当前值的所属类详细信息，固定结构：[Object 所属的类型]使用该方法检测，不管你是什么值，我们都可以正正常检测出我们需要的结果 1234567891011121314var obj=&#123;name:'珠峰'&#125;;obj.toString() //=&gt;"[object Object]" 调取的正是Object.prototype.toString /** obj.toString()* 首先执行Object.prototype.toString方法* 这个方法中的this就是我们操作的数据值obj* =&gt;总结：Object.prototype.toString执行的时候会返回当前方法中this的所属类信息** 也就是，我想知道谁的所属类信息，我们就把这个toString方法执行，并且让this变为我们检测的这个数据值，那么方法返回的结果就是当前检测这个值的所属类信息** Object.prototype.toString.call([value])* (&#123;&#125;).toString.call([value])*/ 因为alert弹出的都是字符串，所以会自动将（）中的内容调用toString,而对象类型调用toString,会出现[Object 所属的类型]]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（二）函数专题]]></title>
    <url>%2Fposts%2F9f7bba47.html</url>
    <content type="text"><![CDATA[函数专题函数是指一段在一起的、可以做某一件事儿的代码。可以随时运行，可以重复使用。 创建函数1234function fn[函数名]()&#123;//=&gt;[函数体]//实现功能的具体JS代码&#125; 函数执行fn(); //=&gt;把创建的函数执行，而且这个函数可以执行很多次 每一次执行都相当于把函数体中实现功能的JS代码重复执行了一遍 在真实项目中，我们一般都会把实现一个具体功能的代码封装在函数中：1、如果当前这个功能需要在页面中执行多次，不封装成为函数，每一次想实现这个功能，都需要重新把代码写一遍；而封装在一个函数中，以后想实现这个功能，只需要把函数重新的执行即可，提高了开发效率；2、封装在一个函数中，页面中就基本上很难出现重复一样的代码了，减少了页面中代码的冗余度，提高了代码的重复利用率：低耦合高内聚 我们把以上的特点称为函数封装（OOP面向对象编程思想，需要我们掌握的就是类的继承、封装、多态） JS中函数的核心原理函数作为JS中引用数据类型中的一种，也是按照引用地址来操作的 1、函数执行首先会形成一个新的私有作用域，目的是为函数体中的代码提供一个执行的环境（而且这个环境是私有的） 2、把创建时候存储的代码字符串copy一份到自己的私有作用域中，然后把字符串转换为JS表达式，再然后依次自上而下执行目的：把之前存储的实现具体功能的JS代码执行 函数执行步骤 形参赋值 私有作用域中的变量提升 把之前创建时候存储的那些JS代码字符串，拿到私有作用域中，然后把它们变为JS表达式从上到下执行 私有作用域是否销毁的问题[根据栈内存是否被占用] 函数中的变量提升 在当前作用域中，js代码自上而下执行之前，浏览器首先会把所有带var/function关键字的进行提前的声明或者定义 声明(declare)：var num; 在当前作用域中吼一嗓子我有num这个名了定义(defined)：num=11; 把声明的名字赋一个值 带var关键字的只是提前的声明一下；带function关键字的在变量提升阶段把声明和定义都完成了； 变量提升详解对于带var和function关键字在与解释的时候操作不一样 var 在预解释的时候只是提前声明 function 在预解释时提前将声明和定义都完成了； 1、.预解释只发生在当前作用域中，开始只对window下的预解释，只有在函数执行时，才会对函数体中的进行预解释2、在if判断中，在预解释时，不管你条件是否成立，都要将带var的进行预解释（在老版本浏览器中，函数会被声明和定义，新版本浏览器中，函数只会被声明）3、var fn=function(){},在匿名函数值函数表达式中只对等号左边进行预解释，右边是值，不参加预解释 真实项目中，应用这个原理，我们创建函数的时候可以使用函数表达式的方式：1、因为只能对等号左边的进行提升，所以变量提升完成后，当前函数只是声明了，没有定义，想要执行函数只能放在赋值的代码之后执行（放在前面执行相当于让undefined执行，会报错的）2、这样让我们的代码逻辑更加严谨，以后想要知道一个执行的函数做了什么功能，只需要向上查找定义的部分即可（不会存在定义的代码在执行下面的情况） 4、function fn（n）{};(10); 自执行函数，在全局作用域下不进行预解释，在执行到该位置是定义和执行一起完成。5、当函数中有return时，return下面的函数不执行，但是会预解释；return后面跟的是返回值，所以不进行预解释。6、在预解释中，如果名字已经声明过了，后面就不重新声明，但会重新赋值； 如何区分私有变量和全局变量 在全局作用域下声明的都是全局变量 在私有作用域下声明的变量和函数的形参都是私有 变量 在私有作用域中，我们代码执行的时候遇到一个变量，首先我们要确定他是否为私有变量，如果是私有变量，那么他和外面没有任何关系；如果不是私有变量，（不加var）那么就要向他的上级查找，一直到window为止； 看当前函数在哪个作用域定义，那么他的上级作用于就是谁，跟在哪里运行没有关系 在全局作用域中带var和不带var的区别 1、带var的可以先进行预解释，所以在赋值前执行不会报错；不带var的没有进行预解释，在前面执行会报错；2、num=12;console.log(num2); ==&gt;12 //含义：相当于给window增加一个属性，属性名=num，属性值=12；3、var num=12;console.log(num); =&gt; 12// 首先给全局作用域增加一个全局变量，而且也为window增加一个属性 in ：判断变量是否存在当前作用域中； ++i和i++的区别都是自增1的意思在运算中不同点i++是先进行运算，再自增++i是先自增1再运算 作用域链函数执行形成一个私有的作用域（保护私有变量），进入到私有作用域中，首先变量提升（声明过的变量是私有的），接下来代码执行1、执行的时候遇到一个变量，如果这个变量是私有的，那么按照私有处理即可2、如果当前这个变量不是私有的，我们需要向它的上级作用域进行查找，上级如果也没有，则继续向上查找，一直找到window全局作用域为止，我们把这种查找机制叫做作用域链1）如果上级作用域有这个变量，我们当前操作的都是上级作用域中的变量（假如我们在当前作用域把值改了，相当于把上级作用域中的这个值给修改了）2）如果上级作用域中没有这个变量(找到window也没有)：变量 = 值 ：相当于给window设置了一个属性，以后再操作window下就有了alert(变量)：想要输出这个变量，但是此时是没有的，所以会报错 闭包函数执行会形成一个私有的作用域，让里面的私有变量和外界互不影响（相互不干扰、外面的无法直接获取里面的变量值），此时我们可以理解为私有作用域把私有变量保护起来的，我们把这种保护机制称之为闭包闭包的作用：保护：私有作用域把私有变量保护起来的保存：函数执行形成一个私有作用域，函数执行完成，形成的这个栈内存一般情况下都会自动释放但是还有其他情况：函数执行完成，当前私有作用域（栈内存）中的某一部分内容被栈内存以外的其它东西（变量/元素的事件）占用了，当前的栈内存就不能释放掉，也就形成了不销毁的私有作用域（里面的私有变量也不会销毁） 堆内存所有的引用数据类型，它们需要存储的内容都在堆内存中（相当于一个仓库，目的是存储信息） 对象会把键值对存储进来函数会把代码当做字符串存储进来释放：如果当前的堆内存被变量（或者函数以及元素事件等）占用了（占用了：堆内存地址赋值给变量了），此时的堆内存是有用的，不能销毁；我们想要手动释放堆内存，只需要让存储地址的变量等于其它值即可（最好等于null，null是空对象指针，本意就是不指向任何的堆内存）； 函数中的形参和实参形参：相当于函数提供的入口，需要用户执行函数的时候把需要的值传递进来，形参是个变量，用来存储和接收这些值 实参：用户执行的时候传递给形参的具体值 在非严格模式下：函数的形参和实参有一一对应的映射关系；当没有传递实参时，这种映射关系被切断，严格模式下不存在映射关系 123456789//=&gt;随便求出两个数的和function sum(num1,num2)&#123;//=&gt;num1/num2就是形参变量(类似于var了一下)var total = num1+num2;total*=10;total=total.toFixed(2);console.log(total);&#125;sum(10,20);//-&gt;10/20是实参 num1=10 num2=20sum(10); //-&gt;num1=10 num2=undefined 定义了形参但是执行的时候没有传递实参，默认实参的值是undefined 此时num2与实参的映射关系被切断 123456789101112function sum(num1, num2) &#123;//=&gt;如果有一个值没有传递的话,我们为了保证结果不是NaN,我们为其设置一个默认的值:0//=&gt;容错处理num1 = num1 || 0;num2 = num2 || 0;var total = num1 + num2;total *= 10;total = total.toFixed(2);console.log(total);&#125;sum(10, 20);//在非严格模式下，函数的两个形参可以重名，但是函数只会接收后一个参数传的值，如果只传入一个实参，则如下图所示： 在严格模式下，形参不可以重名 arguments实参集合 当我们不知道用户具体要传递几个值的时候（传递几个值都行），此时我们无法设置形参的个数；遇到此类需求，需要使用函数内置的实参集合：arguments1、arguments只有函数才有2、不管执行函数的时候是否传递实参，arguments天生就存在，没有传递实参ARG是个空的集合，传递了ARG中包含了所有传递的实参值3、不管是否设置了形参，ARG中始终存储了所有的实参信息 arguments是一个类数组集合1、以数字作为索引(属性名)，从零开始arguments[0] 第一个实参信息arguments[2] 第三个实参信息2、有一个length的属性，存储的是当前几个的长度（当前传递实参的个数）arguments.lengtharguments[‘length’]arguments.callee：存储的是当前函数本身arguments.callee.caller：存储的是当前函数在哪执行的（宿主函数），在全局作用域下执行的，结果是null 在非严格模式下，agruments与形参有一一对应的关系，但当没有传入实参时，这种映射关系会被切断，在严格模式下，agruments与形参的映射关系也被切断了 123456"use strict"; //=&gt;在JS代码执行之前加入这句话：开启JS的严格模式function sum() &#123;console.log(arguments.callee);//=&gt;Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them&#125;sum(10, 20, '珠峰', &#123;name: '珠峰'&#125;);//=&gt;arguments.callee或者arguments.callee.caller一般真正项目中很少使用：因为在严格的JS模式下不允许我们使用这两个属性，然而现有项目大部分都是基于严格模式来的 JS中的返回值 return 返回值是函数提供的一个出口：我们如果想在外面使用函数私有的一些信息，那么就需要通过return，把这些信息返回出来供外面使用 - RETURN后面跟着的都是值（返回的都是值） 如果函数中没有写RETURN或者RETURN后面啥也没有,默认返回的结果就是undefined 在函数体中遇到RETURN后,RETURN后面的代码都不在执行了12345678function sum() &#123;var total = null;return total;//=&gt;RETURN后面跟着的都是值（返回的都是值）：此处不是把TOTAL变量返回，而是把TOTAL存储的值返回而已 &lt;=&gt; RETURN 60;//return 1+1; //&lt;=&gt; RETURN 2;&#125;console.log(sum(10, 20, 30));//=&gt;sum：代表的是函数本身//=&gt;sum()：让函数先执行,代表的是当前函数返回的结果(RETURN 后面是啥,相当于函数返回的是啥) 12345678910function sum() &#123;var total = null;for (var i = 0; i &lt; arguments.length; i++) &#123;var cur = Number(arguments[i]);!isNaN(cur) ? total += cur : null;&#125;return total;&#125;var total = sum(10, 20, 30);//=&gt;外面是全局下的TOTAL和函数中的TOTAL没有必然的联系console.log(total.toFixed(2)); JS中的匿名函数没有名字的函数 函数表达式:把一个函数作为值赋值给一个变量或某个事件（函数表达式右边的都是匿名函数） 自执行函数:创建函数和执行函数放在一起了，创建完成立马执行123oBox.onclick = function()&#123;//=&gt;把一个没有名字的函数(有名字也无所谓)作为值赋值给一个变量或者一个元素的某个事件等：`函数表达式`&#125; 123456789;(function(n)&#123;//=&gt;创建函数和执行函数放在一起了，创建。，完成立马执行：·自执行函数·//n形参 n=10&#125;)(10);//=&gt;以下都是自执行函数，符号只是控制语法规范，~function(n)&#123;&#125;(10);-function(n)&#123;&#125;(10);+function(n)&#123;&#125;(10);!function(n)&#123;&#125;(10); 函数的三种角色和call、apply、bind 第一种角色：普通函数栈内存(私有作用域)作用域链形参argumentsreturn 第二种角色：类类实例私有和公有属性prototypeproto 第三种角色：普通对象键值对操作 三种角色之间没有直接的关系 1234567function Fn()&#123;var name='珠峰培训';this.age=8;&#125;Fn.prototype.say=function()&#123;&#125;//原型上的方法Fn.eat=function()&#123;&#125;//普通函数的方法var f = new Fn(); 阿里超经典面试题 123456789101112131415161718function Foo() &#123;getName = function () &#123;console.log(1);&#125;;return this;&#125;Foo.getName = function () &#123;console.log(2);&#125;;Foo.prototype.getName = function () &#123;console.log(3);&#125;;var getName = function () &#123;console.log(4);&#125;;function getName() &#123;console.log(5);&#125; 1234567Foo.getName(); //执行Foo.getName 输出2getName(); // 执行var getName 输出4Foo().getName();//执行function Foo()，（getName是公有属性，相当于给getName重新赋值） 输出1getName(); //由于上一轮的重新赋值，输出1new Foo.getName();//返回Foo.getName()的一个实例，输出2new Foo().getName();//先new Foo()，返回foo的一个实例，在执行实例.getName()，=》3；new new Foo().getName();// 先new Foo()，返回foo的一个实例，再返回this.getName（）的一个实例 ，3； call apply bind都是天生自带的方法(Function.prototype)，所有的函数都可以调取这三个方法 三个方法都是改变THIS指向的 call fn.call(context,para1,…)把fn方法立即执行，并且让fn方法中的this变为context,而para1…都是给fn传递的实参 123456789101112131415161718192021//=&gt;非严格模式function fn(num1,num2)&#123;console.log(this);&#125;var obj=&#123;fn:fn&#125;;fn();//=&gt;this:windowobj.fn();//=&gt;this:objvar opp=&#123;&#125;;//opp.fn();//=&gt;报错:opp中没有fn这个属性fn.call(opp);//=&gt;this:opp num1&amp;&amp;num2都是undefinedfn.call(1,2);//=&gt;this:1 num1=2 num2=undefinedfn.call(opp,1,2);//=&gt;this:opp num1=1 num2=2//-&gt;CALL方法的几个特殊性fn.call();//=&gt;this:window num1&amp;&amp;num2都是undefinedfn.call(null);//=&gt;this:windowfn.call(undefined);//=&gt;this:window//=&gt;JS严格模式下"use strict";fn.call();//=&gt;this:undefinedfn.call(undefined);//=&gt;this:undefinedfn.call(null);//=&gt;this:null apply apply的语法和call基本一致，作用原理也基本一致，唯一的区别：apply把传递给函数的实参以数组形式存放（但是也相当于在给函数一个个的传递实参值） 1fn.call(null,10,20,30); 1fn.apply(null,[10,20,30]); //=&gt;传递给fn的时候也是一个个的传递进去的 bind 也是改变THIS的方法，它在IE6~8下不兼容；它和call(以及apply)改变this的原理不一样 12345678910111213141516fn.call(opp,10,20); //=&gt;把fn执行,让fn中的this变为opp,并且把10&amp;&amp;20分别传递给fnfn.bind(opp,10,20); //=&gt;预先让fn中的this指向opp,并且把10和20预先传递给fn,此时的fn没有被执行(只有当执行的时候this和实参才会起到应有的作用)//=&gt;需求：点击box这个盒子的时候，需要执行fn，并且让fn中的this指向oppoBox.onclick=fn; //=&gt;点击的时候执行了fn,但此时fn中的this是oBoxoBox.onclick=fn.call(opp); //=&gt;绑定事件的时候就已经把fn立即执行了(call本身就是立即执行函数),然后把fn执行的返回值绑定给事件oBox.onclick=fn.bind(opp);//=&gt;fn.bind(opp)：fn调取Function.prototype上的bind方法，执行这个方法返回了一个匿名函数/** function()&#123;* fn.call(opp);* &#125;*/oBox.onclick=function()&#123;//=&gt;this:oBoxfn.call(opp);&#125; 回调函数 凡是在函数执行的某一阶段需要完成某件不确定的事情，可以利用回到函数机制，把要处理的事情当做函数传进来，传进来的这个参数就是回调函数 我们可以在函数中根据需要随时使用回调函数 我们还可以给回调函数传递参数 我们还可以把回调函数中的this进行修改 我们还可以接收回调函数的返回值 回调函数的this指向回调函数中的this一般都是window（严格模式下是undefined）setTimeout&amp;&amp;setInterval默认执行主体都是window，（严格模式下也是同样的） forEach和map当传第二个参数时，会改变this指向，this会指向传递的第二个参数(some.filter,find,every这些方法的第二个参数都是改变this指向的) 我们一般在执行回调函数的时候，没有特意指定执行主体，所以默认一般都是window。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础（一）数据类型基本介绍，检测数据类型端方法简介]]></title>
    <url>%2Fposts%2Fd035ffec.html</url>
    <content type="text"><![CDATA[基础知识 ECMAScript(ES)：规定了JS的一些基础核心的知识（变量、数据类型、语法规范、操作语句等）DOM：document object model 文档对象模型，里面提供了一些属性和方法，可以让我们操作页面中的元素BOM：browser object model 浏览器对象模型，里面提供了一些属性和方法，可以让我们操作浏览器 常用浏览器内核浏览器的内核是分为两个部分的，一是渲染引擎，另一个是JS引擎。现在JS引擎比较独立，内核更加倾向于说渲染引擎。 webkit内核（V8引擎） 谷歌 大部分移动端浏览器 国内大部分浏览器 360 QQ UC 猎豹 搜狗 NODE基于V8来渲染JS Gecko 火狐浏览器 Presto 欧朋浏览器 Trident IE浏览器 数据类型的分类和检测 Number String bloean null:空对象指针基础 undefined:未定义 function 函数类型 object对象数据类型: {}普通对象 数组 /$/ 正则 [对象数据类型:是把描述同一事物的属性和方法放在一个内存空间中，起到了分组的作用] 检测数据类型 typeof:检测数据类型的运算符 instanceof:检测某个实例是否属于这个类 constructor:获取当前实例的构造器 Object.prototype.toString.call:获取当前实例所属的类信息 typeof：结果返回的是一个字符串，字符串内包含的是数据类型 typeof 的局限性 typeof null 的检测结果不是‘null’ 而是’object’: 而null是基本数据类型 ，并不是object 使用typeof 无法具体区分出到底是数组还是正则或普通对象 Boolean 把其他类型转换为布尔类型 只有0，NaN,空字符串、null、undefined为false;其余都是true; ! 或者 !!的意义 ! ：先将数据类型转化为布尔值，再取反 !! ：两次取反相当于没有取反，只是把数据类型转化为布尔类型12!null =&gt; true!!undefined =&gt;false Number[NaN] js中新增了一个数据类型：NaN（not a number 不是一个有效数字，但是属于number） typeof NaN =&gt;’number’ NaN!=NaN NaN和任何值都不等 [isNaN] isNaN:用来检测这个值是否是有效数字，如果不是，则为true,反之，则为false 当时使用isNaN检测时，（）中如果不是number类型： 基本数据类型：先将其他类型值转化为Number类型值再运算 对象数据类型：先将对其调用toString方法，再转化为Number类型值 [Number] 使用Number把字符串转换为数字的时候，空字符串是零，其它字符串中如果出现的字符代表纯数字可以转为正常的数字，如果出现了任何一个非有效数字的字符，最后的结果都是NaN 将引用类型转化数据类型时，先将其转化为字符串，后再转化为number; 123(&#123;name:'zxt'&#125;).toString() =&gt;"[object Object]"Number(undefined) =&gt;NaN[parseInt()] 将其他类型值转换number,和Number不同，提取规则：从左至右依次查找有效数字字符，直到遇见非有效字符为止(不管后面还有没数字) 123parseInt(‘12px’) =&gt;12parseInt(‘px1’) =&gt;NaN parseInt(‘122.3’) =&gt;122 [parseFloat()]与parseInt不同的是支持小数 parseFloat(‘12.34pxc’)= 12.34由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心 123450.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996[toFixed()] 控制数字保留小数点后面几位 12345678910var num = parseFloat('width:12.5px'); //=&gt;NaNif(num==12.5)&#123; alert(12.5); &#125;else if(num==NaN)&#123;//=&gt; NaN!=NaN alert(NaN); &#125;else if(typeof num=='number')&#123;//=&gt; typeof NaN-&gt;'number' alert(0);//=&gt;'0' &#125;else&#123; alert('啥也不是!'); &#125; null 和 undefinednull: 没有,没有开辟内存空间undefined: 未定义“” : 空字符串，什么都没有，但是开辟了内存空间 null：什么都没有，但一般都是自己手动赋值的，后期再自己赋值unfefined：完全不在预期之内 Object对象是由0到多组键值对组成的，每一组之间用逗号分离 每一个对象数据类型，都是有0到多组的属性名和属性值组成的属性名：描述当前对象具备的某些特征（数字/字符串格式）属性值：具体特征的值（任何数据类型）操作一个对象的属性有2种方式obj[‘key’]obj.key(属性名是数字不可以使用这种方法) 创建对象 字面量方式：var obj={}构造函数方式：var obj=new Object(); 对象键值对的操作：增、删、改、查 var obj = {};obj.name = ‘zxt’;//=&gt;增加一个叫做NAME的属性,属性值是:’zxt’obj[‘name’] = 29;//=&gt;修改NAME对应的属性值：一个对象的属性名是不能重复的，之前没有这个属性，我们的操作是增加操作，之前有这个属性，当前操作就是在修改现有属性名的属性值obj.age = null; //=&gt;假删除：把属性值设置为空，但是属性名是存在的 &lt;=&gt; obj[‘age’] = null =&gt;获取age的属性值结果是nulldelete obj.age;//=&gt;真删除：把属性名和属性值彻底从对象中移除掉 =&gt;获取age的属性值结果是undefined获取一个对象某一个属性名对应的属性值，如果当前这个属性在对象中并不存在，获取的结果是undefined obj[name]和obj[‘name’]的区别 //-&gt; age：变量名，代表的是它存储的值//-&gt; ‘age’：常量，字符串的具体值var age = ‘name’;var obj = {name:’zhufeng’,age:8};console.log(obj.age); =&gt;8console.log(obj[‘age’]); =&gt;8console.log(obj[age]); =&gt; obj[age变量] =&gt;obj[‘name’] =&gt;获取name属性名的属性值 =&gt;’zhufeng’ Object.keys: Object.keys 返回一个所有元素为字符串的数组，其元素来自于从给定的对象上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。可以用来判断对象是否为空：Object.keys(obj).length let obj = { 0 : “a”, 1 : “b”, 2 : “c”};console.log(Object.keys(obj));// [‘0’, ‘1’, ‘2’] 函数数据类型 函数数据类型也是按照引用地址来操作的 函数：具备一定功能的方法 基本数据类型和引用数据类型的区别 JS是运行在浏览器中的（内核引擎），浏览器会给JS提供一个赖以生存的环境，所以我们把这个环境叫做全局作用域 window(global是后台的) JS代码是自上而下依次执行的 基本数据类型是按值操作的：基本数据类型再赋值时，是直接把值赋值给变量即可 var a=12;var b=a; // b=12 把变量a存的值赋值给变量bb=13;alert(a); //a=12 引用数据类型是按空间地址（引用地址）来操作的： var n={name:’主动’}；1、先创建一个变量n;2.浏览器首先会开辟一个存储空间（内存空间），是把对象中需要存储的键值对分别存储在这个空间中，后期为了方便找到这个空间，浏览器会给空间设个地址（16进制）；3、把空间的地址赋值给变量;所以n存储的是一个引用地址，并不是一个具体的值 &amp;&amp;逻辑与||逻辑或 在条件判断中&amp;&amp;：所有都为真，才是真||：只要一个为真，就是真 在赋值操作中 (短路操作)||: a||b;看a的真假，a为真，则返回a的值，a为假，则返回b,不管b是什么&amp;&amp;：a&amp;&amp;b, a为假，则返回a的值，a为真，则返回b,不管b是什么真实项目中应用逻辑或实现默认值的设置操作 逻辑与的优先权高于逻辑或 JavaScript常用的操作语句 通过一系列的逻辑判断，来完成特定的事情for循环if循环:当在判断的操作中,很多条件都是符合的,执行完成第一个符合的条件后,后面的条件不管是否符合都不在处理了 for in 循环用来遍历（循环）对象键值对的, ‘循环数组中的每一项’, ‘条件？条件成立执行：条件不成执行；, 执行步骤： key存储的值都是字符串格式，key中存的是属性名在for in 循环遍历时，大部分浏览器都是先把对象中的键值对进行排序（整数数字在前，由小到大，其余按原来编写顺序排列）（小数算作字母，不算数字）for in循环会遍历对象原型上的方法itin [Tab] for in 循环快捷键 三元运算符 [‘条件？条件成立执行：条件不成执行；]是简单的if、else的另外一种写法如果某种情况并不需要做处理，我们可以用null,undefined,void 0占位即可某一情况执行多条操作，使用（）包起来，每一项处理的事情之间用逗号分隔在三元运算符中不能出现 break/continue/return会出现 SyntaxErrorr 语法错误 switch case 也是if else某种特定情况的简写，可以在switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。每一种case情况结束都需要加break，达到条件成立处理完成，跳出当前判断每一种case情况的比较都是使用===进行比较的：绝对相等 =：赋值，变量=值==：比较，值==值绝对比较，值=== 如果左右两边比较的值是相同类型的，那么直接比较内容是否一样即可；如果两边值的类型不一样，==和===是有区别的：===类型不一样，最后的结果就是false，更加的严谨==类型不一样，浏览器首先会默认的把类型转化为一样的，然后再比较内容，相对松散一些 for循环语句for(初始值;验证条件;步长累加){ 循环体} 设置初始值验证条件条件成立执行循环体，否则推出循环步长累加验证条件···············没有步长累加会陷入死循环 for循环与for in循环的区别：for in 循环可以遍历到原型上的公有属性，而for循环只能遍历私有的属性]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份非常完整的MySQL规范]]></title>
    <url>%2Fposts%2Ff4255724.html</url>
    <content type="text"><![CDATA[一、数据库命令规范 二、数据库基本设计规范 三、数据库字段设计规范 四、索引设计规范 五、常见索引列建议 六、如何选择索引列的顺序 七、避免建立冗余索引和重复索引 八、优先考虑覆盖索引 九、索引SET规范 十、数据库SQL开发规范 十一、数据库操作行为规范 一、数据库命令规范· 所有数据库对象名称必须使用小写字母并用下划线分割 · 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） · 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符 · 临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀 · 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低） 二、数据库基本设计规范1、所有表必须使用Innodb存储引擎 没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好 2、数据库和表的字符集统一使用UTF8 兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效 3、所有表和字段都需要添加注释 使用comment从句添加表和列的备注 从一开始就进行数据字典的维护 4、尽量控制单表数据量的大小，建议控制在500万以内 500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题 可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小 5、谨慎使用MySQL分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据 6、尽量做到冷热数据分离，减小表的宽度 MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作） 7、禁止在表中建立预留字段 预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定 8、禁止在数据库中存储图片，文件等大的二进制数据 通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息 9、禁止在线上做数据库压力测试 10、禁止从开发环境，测试环境直接连接生成环境数据库 三、数据库字段设计规范1、优先选择符合存储需要的最小的数据类型 · 原因 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差 · 方法 1）将字符串转换成数字类型存储，如：将IP地址转换成整形数据。 mysql提供了两个方法来处理ip地址： 12inet_aton // 把ip转为无符号整型(4-8位)inet_ntoa // 把整型的ip转为地址 插入数据前，先用inet_aton把ip地址转为整型，可以节省空间。显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可。 2）对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储 因为：无符号相对于有符号可以多出一倍的存储空间 12SIGNED INT -2147483648~2147483647UNSIGNED INT 0~4294967295 VARCHAR(N)中的N代表的是字符数，而不是字节数 使用UTF8存储255个汉字 Varchar(255)=765个字节。过大的长度会消耗更多的内存 2、避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据 · 建议把BLOB或是TEXT列分离到单独的扩展表中 Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。 而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。 如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。 · TEXT或BLOB类型只能使用前缀索引 因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。 3、避免使用ENUM类型 · 修改ENUM值需要使用ALTER语句 · ENUM类型的ORDER BY操作效率低，需要额外操作 · 禁止使用数值作为ENUM的枚举值 4、尽可能把所有列定义为NOT NULL 原因： · 索引NULL列需要额外的空间来保存，所以要占用更多的空间； · 进行比较和计算时要对NULL值做特别的处理 5、使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间 TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。 TIMESTAMP 占用4字节和INT相同，但比INT可读性高 超出TIMESTAMP取值范围的使用DATETIME类型存储。 经常会有人用字符串存储日期型的数据（不正确的做法）： · 缺点1：无法用日期函数进行计算和比较 · 缺点2：用字符串存储日期要占用更多的空间 6、同财务相关的金额类数据必须使用decimal类型 · 非精准浮点：float,double · 精准浮点：decimal Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。 四、索引设计规范1、限制每张表上的索引数量，建议单张表索引不超过5个 索引并不是越多越好！索引可以提高效率同样可以降低效率。 索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。 因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。 2、禁止给表中的每一列都建立单独的索引 5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好 3、每个Innodb表必须有个主键 Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。 每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。 主键建议使用自增ID值。 五、常见索引列建议· 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列 · 包含在ORDER BY、GROUP BY、DISTINCT中的字段 并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好 · 多表join的关联列 六、如何选择索引列的顺序建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 · 区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）； · 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）； · 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。 七、避免建立冗余索引和重复索引因为这样会增加查询优化器生成执行计划的时间。 · 重复索引示例：primary key(id)、index(id)、unique index(id) · 冗余索引示例：index(a,b,c)、index(a,b)、index(a) 八、优先考虑覆盖索引对于频繁的查询优先考虑使用覆盖索引。 覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引 覆盖索引的好处： · 避免Innodb表进行索引的二次查询 Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息， 如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。 · 可以把随机IO变成顺序IO加快查询效率 由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。 九、索引SET规范尽量避免使用外键约束 · 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引； · 外键可用于保证数据的参照完整性，但建议在业务端实现； · 外键会影响父表和子表的写操作从而降低性能。 十、数据库SQL开发规范1、建议使用预编译语句进行数据库操作 预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。 2、避免数据类型的隐式转换 隐式转换会导致索引失效。如：select name,phone from customer where id = ‘111’; 3、充分利用表上已经存在的索引 · 避免使用双%号的查询条件。 如a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的） · 一个SQL只能利用到复合索引中的一列进行范围查询 如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。 使用left join或 not exists来优化not in操作 因为not in 也通常会使用索引失效。 4、数据库设计时，应该要对以后扩展进行考虑 5、程序连接不同的数据库使用不同的账号，进制跨库查询 · 为数据库迁移和分库分表留出余地 · 降低业务耦合度 · 避免权限过大而产生的安全风险 6、禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询 原因： · 消耗更多的CPU和IO以网络带宽资源 · 无法使用覆盖索引 · 可减少表结构变更带来的影响 7、禁止使用不含字段列表的INSERT语句 如：insert into values (‘a’,’b’,’c’); 应使用insert into t(c1,c2,c3) values (‘a’,’b’,’c’); 8、避免使用子查询，可以把子查询优化为join操作 通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。 子查询性能差的原因： · 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响； · 特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大； · 由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。 9、避免使用JOIN关联太多的表 对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。 在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。 如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。 同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。 10、减少同数据库的交互次数 数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率 11、对应同一列进行or判断时，使用in代替or in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。 12、禁止使用order by rand() 进行随机排序 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式 13、WHERE从句中禁止对列进行函数转换和计算 对列进行函数转换或计算时会导致无法使用索引。 · 不推荐： 1where date(create_time)=&apos;20190101&apos; · 推荐： 1where create_time &gt;=&apos;20190101&apos; and create_time &lt;=&apos;20190102&apos; 14、在明显不会有重复值时使用UNION ALL而不是UNION · UNION会把两个结果集的所有数据放到临时表中后再进行去重操作 · UNION ALL不会再对结果集进行去重操作 15、拆分复杂的大SQL为多个小SQL · 大SQL：逻辑上比较复杂，需要占用大量CPU进行计算的SQL · MySQL：一个SQL只能使用一个CPU进行计算 · SQL拆分后可以通过并行执行来提高处理效率 十一、数据库操作行为规范1、超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作 · 大批量操作可能会造成严重的主从延迟 主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况 · binlog日志为row格式时会产生大量的日志 大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。 · 避免产生大事务操作 大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。 特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。 2、对于大表使用pt-online-schema-change修改表结构 · 避免大表修改产生的主从延迟 · 避免在对表字段进行修改时进行锁表 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。 pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。 把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。 把原来一个DDL操作，分解成多个小的批次进行。 3、禁止为程序使用的账号赋予super权限 当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。 4、对于程序连接数据库账号，遵循权限最小原则 程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有drop权限。]]></content>
      <categories>
        <category>Java</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀的程序员需要懂那些数学知识？]]></title>
    <url>%2Fposts%2Fdd6f5090.html</url>
    <content type="text"><![CDATA[安利一本书，专门讲程序员需要懂的数学。 一位科技博主Jeremy Kun花了4年时间，写成一本书《程序员数学入门》，在科技论坛Hack News引发热议。 这本书精简了大量数学内容，为程序员提供所需的基本数学知识。 书中主要内容有：多项式、集合、图论、微积分、线性代数、群论等。 好玩的不止这些，这位博主在个人网站中整理了很多数学知识，甚至做成了wiki的形式： https://jeremykun.com/primers/ 里面基本是程序员的大学数学课程内容：虽然没有高等数学（微积分），但是有抽象代数、离散数学、傅立叶分析、拓扑学等等。 这个网站叫做“站在数学和编程的十字路口”（Math ∩ Programming），所以当然不会只有数学课，还包括机器学习、图像生成、自然语言处理、加密学等计算机学方面的内容。 链接：https://www.zhihu.com/question/21425201/answer/615681300]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着9张思维导图学习Javascript]]></title>
    <url>%2Fposts%2Fd64e1f56.html</url>
    <content type="text"><![CDATA[学习的道路就是要不断的总结归纳，好记性不如烂笔头，so，下面将 po 出我收集的 9 张 javascript 相关的思维导图（非原创）。 JavaScript-Learn-MindMapping 思维导图小tips:思维导图又叫心智图，是表达发射性思维的有效的图形思维工具 ，它简单却又极其有效，是一种革命性的思维工具。思维导图运用图文并重的技巧，把各级主题的关系用相互隶属与相关的层级图表现出来，把主题关键词与图像、颜色等建立记忆链接，思维导图充分运用左右脑的机能，利用记忆、阅读、思维的规律，协助人们在科学与艺术、逻辑与想象之间平衡发展，从而开启人类大脑的无限潜能。思维导图因此具有人类思维的强大功能。 分别归类为： javascript变量 javascript运算符 javascript数组 javascript流程语句 javascript字符串函数 javascript函数基础 javascript基础DOM操作 文档对象模型DOM javascript正则表达式 能够认真看完就是一次对javascript的回顾与提升，可以很好的检验基础。 javascript变量 javascript运算符 javascript数组 javascript流程语句 javascript字符串函数 javascript函数基础 javascript基础DOM操作 文档对象模型DOM BOM浏览器对象模型 javascript正则表达式 是的，没有高深的知识，没有进阶的技巧。 只是，万丈高楼平地起；只是，千里之行始于足下；只是，千里长提溃于蚁穴。 能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享几个优质开源项目 | 电商类app，趣享 gif，研发助手DoraemonKit，github小程序]]></title>
    <url>%2Fposts%2Ff4e97b38.html</url>
    <content type="text"><![CDATA[非常方便的 github 小程序员 趣享 gif 开源版本 酷欧天气的Jetpack版本实现，采用了MVVM架构 充满设计感的电商类APP 滴滴开源的研发助手 非常方便的 github 小程序员经常想在手机上看一些最新的github项目，可以说这是我发现的最方便的小程序了。 GitHub Trending 是根据仓库的最近热门程度展示的，该小程序希望准确获取最近新出现的仓库集合，使用该小程序能够根据语言筛选，获取每天新出现的 Trending 仓库。 开源地址：https://github.com/ZhuPeng/mp-githubtrending 这个小程序已经上线了，可以扫码体验，相信会对你有帮助的 趣享 gif 开源版本这个相信就是老郭对外的开源版本了，相信不少同学早已体验过了，没有的话，可以在各大市场搜索“趣享 gif”体验一下，开源版本也是个非常棒的学习项目。 https://github.com/guolindev/giffun 老郭的MVVM项目酷欧天气的Jetpack版本实现，采用了MVVM架构。 功能比较少，不过老郭写代码一向非常注重代码风格，相信是一个非常值得学习的项目。项目使用语言是kotlin，应该也是为第一行代码第三版做准备。 分享个有意思的事情，之前我和老郭吹逼，我说去 github 搜索 wanandroid有几百个开源版本，一脸自豪… 然后老郭上了个，搜索“cool weather”的截图： 项目架构： https://github.com/guolindev/coolweatherjetpack* 充满设计感的电商类APP 项目涉及的技术要点：1. 组件化+Kotlin结合开发，如何管理第三方依赖 2. BaseActivity和BaseFragment等基类及通用布局的封装 3. MVP+Dagger 2+Retrofit+Rxjava（包括了多个BaseUrl请求的场景处理） 4. 组件化开发下ARouter的运用 5. EventBus的使用 6. Google原生数据库Room的使用 7. Glide的使用（封装加载图片工具类GlideUtils，圆形、圆角图片、背景图片加载等） 8. Kotlin下使用ButterKnife 9. CommonAdapter万能适配器（包括多类型布局的运用—首页的逛模块和视频分类详情都有运用） 10. GSYVideoPlayer实现视频播放（包括全屏切换功能） 11. 5.0新特性CoordinatorLayout +AppBarLayout效果实现（视频分类详情） 12. 沉浸式状态栏（Activity和在Fragment中的使用及不同手机的适配） 13. DataBinding的使用 14. 约束布局ConstraintLayout的使用这是一个来自投稿的项目，我也跑了一下，还有些问题，不过适合用于学习。 https://www.jianshu.com/p/12c09376fa97 https://github.com/GraceJoJo/Designer 研发助手滴滴开源的研发助手。 简称 “DoKit” 。一款功能齐全的客户端（ iOS 、Android ）研发助手，你值得拥有。 https://github.com/didi/DoraemonKit* 开源组件DoraemonKit之Android版本技术实现（一） https://juejin.im/post/5c4dcfe8518825261e1f2978 大家手机上或多或少有一些对学习有用的app，小程序吧？留言分享一下吧！]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>骨架屏</tag>
        <tag>加载优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github上10个开源免费且优秀的后台控制面板]]></title>
    <url>%2Fposts%2Fa81c9ec4.html</url>
    <content type="text"><![CDATA[Web 开发中几乎的平台都需要一个后台管理，但是从零开发一套后台控制面板并不容易，幸运的是有很多开源免费的后台控制面板可以给开发者使用，那么有哪些优秀的开源免费的控制面板呢？我在 Github 上收集了一些优秀的后台控制面板，并总结得出 Top 10。 AdminLTE vue-Element-Admin tabler Gentelella ng2-admin ant-design-pro blur-admin vue-admin iview-admin material-dashboard AdminLTEGithub Star 数 24969 ， Github 地址：https://github.com/almasaeed2010/AdminLTE。 非常流行的基于 Bootstrap 3.x 的免费的后台 UI 框架。 vue-Element-AdminGithub Star 数 19546， Github 地址： https://github.com/PanJiaChen/vue-element-admin。 一个基于 vue2.0 和 Eelement 的控制面板 UI 框架。 tablerGithub Star 数 15870， Github 地址：https://github.com/tabler/tabler。 构建在 BootStrap 4 之上的免费的 HTML 控制面板框架 GentelellaGithub Star 数 15654， Github 地址：https://github.com/puikinsh/gentelella。 一个基于 Bootstarp 的免费的后台控制面板。 ng2-adminGithub Star 数 13181， Github 地址：https://github.com/akveo/ngx-admin。 基于 Angular 2, Bootstrap 4 和 Webpack 的后台管理面板框架。 ant-design-proGithub Star 数 12707，Github 地址：https://github.com/ant-design/ant-design-pro。 开箱即用的中台前端/设计解决方案 blur-adminGithub Star 数 9241，Github 地址：https://github.com/akveo/blur-admin。 基于 Angular 和 Bootstrap 的后台管理面板框架。 vue-adminGithub Star 数 8676，Github 地址：https://github.com/vue-bulma/vue-admin。 基于 Vue 和 Bulma 的控制面板。 iview-adminGithub Star 数 8668，Github 地址：https://github.com/iview/iview-admin。 基于 iView 的 Vue 2.0 控制面板。 material-dashboardGithub Star 数 7111，Github 地址：https://github.com/creativetimofficial/material-dashboard。 基于 Bootstrap 4 和 Material 风格的控制面板。]]></content>
      <categories>
        <category>Java</category>
        <category>开源</category>
      </categories>
      <tags>
        <tag>后台控制面板</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些架构设计原则]]></title>
    <url>%2Fposts%2F5125d3e0.html</url>
    <content type="text"><![CDATA[《Clean Architecture》一书中对于软件架构目的的解释： The goal of software architecture is to miminize the human resources required to build and maintain the required system. 即：软件架构的目的就是将构建和维护系统需要的人力成本降到最低。 因此，可以得出架构设计的关键思维就是判断和取舍（程序设计的关键思维是逻辑和实现），即如何选择技术、组合技术使得需要的人力资源最少。 需要注意的一点是，脱离业务谈架构是不合理的，技术架构及其演进都是业务目标驱动的。 架构原则 避免过度设计：简单的架构就是最好的架构。最简单的方案最容易实现和维护，也可以避免浪费资源。但方案中需要包括扩展。 冗余设计：对服务、数据库的做结点冗余，保证服务的高可用。通过数据库主从模式、应用集群来实现。 多活数据中心：为了容灾，从根本上保障应用的高可用性。需要构建多活的数据中心，以防止一个数据中心由于不可控因素出现故障后，引起整个系统的不可用。 无状态设计：API、接口等的设计不能有前后依赖关系，一个资源不受其他资源改动的影响。无状态的系统才能更好地进行扩展。如果非得有状态，则要么客户端管理状态，要么服务端用分布式缓存管理状态。 可回滚：对于任何业务尤其是关键业务，都具有恢复机制。可以使用基于日志的WAL、基于事件的Event sourcing等来实现可回滚。 可禁用/自我保护：具有限流机制，当上游的流量超过自身的负载能力时，能够拒绝溢出的请求。可以通过手动开关或者自动开关（监测异常流量行为），在应用前端挡住流量。限流算法包括：令牌桶（支持突发流量）、漏桶（匀速流量）、计数器以及信号量（限制并发访问的数量）。此外永远不要信赖第三方服务的可靠性，依赖于第三方的功能务必有服务降级措施以及熔断管理，如：对于每一个网络操作，都需要设置超时时间，超过这个时间就放弃或者返回兜底响应。 问题可追踪：当系统出现问题时，能够定位请求的轨迹、每一步的请求信息等。分布式链路追踪系统即解决的此方面的问题。 可监控：可监控是保障系统能够稳定运行的关键。包括对业务逻辑的监控、应用进程的监控以及应用依赖的CPU、硬盘等系统资源的监控。每一个系统都需要做好这几个层面的监控。 故障隔离：将系统依赖的资源(线程、CPU)和服务隔离开来能够使得某个服务的故障不会影响其他服务的调用。通过线程池或者分散部署结点可以对故障进行隔离。此外，为不同的用户提供单独的访问通道，不仅仅能够做故障隔离，也有利于做用户权限控制。 成熟可控的技术选型：使用市面上主流、成熟、文档、支持资源多的技术，选择合适的而非最火的技术实现系统。如果面对自研和开源技术的选择，需要考虑契合度：如果功能需求契合度很高，那么选择开源即可；如果开源技术是需求的子集或者超集，那么要衡量吃透这个开源技术的成本和自研的成本那个高。 梯级存储：内存-&gt;SSD硬盘-&gt;传统硬盘-&gt;磁带，可以根据数据的重要性和生命周期对数据进行分级存储。 缓存设计：隔离请求与后端逻辑、存储，是就近原则的一种机制。包括客户端缓存（预先下发资源）、Nginx缓存、本地缓存以及分布式缓存。 异步设计：对于调用方不关注结果或者允许结果延时返回的接口，采用队列进行异步响应能够很大程度提高系统性能；调用其他服务的时候不去等待服务方返回结果直接返回，同样能够提升系统响应性能。异步队列也是解决分布式事务的常用手段。 前瞻性设计：根据行业经验和对业务量的预判，提前把可扩展性、后向兼容性、容量预警设计好。以防止超过系统容量后造成各种问题影响服务。 水平扩展：相比起垂直扩展，能够通过堆机器解决问题是最优先考虑的问题，系统的负载能力也才能接近无限扩展。此外，基于云计算技术根据系统的负载自动调整容量能够在节省成本的同时保证服务的可用性。 小步构建和发布：快速迭代项目，快速试错。不能有跨度时间过长的项目规划。 自动化：打包、测试的自动化称为持续集成，部署的自动化称为持续部署。自动化机制是快速迭代和试错的基础保证。 架构六步思考法 笔者对美团总架构师夏华夏一次分享提出的架构六步思考法的理解。 这里尤其需要注意的一点是在面对问题时，首先要试图将未知问题转化为已知问题，而不是创造新问题。 数据设计原则 注意存储效率 减少事务 减少联表查询 适当使用索引 考虑使用缓存 避免依赖于数据库的运算功能(函数、存储器、触发器等)，将负载放在更容易扩展的业务应用端 数据统计场景中，实时性要求较高的数据统计可以用Redis；非实时数据则可以使用单独表，通过队列异步运算或者定时计算更新数据。此外，对于一致性要求较高的统计数据，需要依靠事务或者定时校对机制保证准确性。 索引区分度法则：辨识度超过20%的属性，如果有查询需求，就应该建立索引。 对于数值型数据，可以使用保序压缩方式在保证顺序不变的前提下减少字符串长度。如：进行36进制转化即一种保序压缩方式。 大量数据的去重计数如果允许误差可以选择基数估计算法（Hyperhyperlog、Loglogcount）或者布隆过滤器。 系统响应性能提升五板斧 异步：队列缓冲、异步请求。 并发：利用多CPU多线程执行业务逻辑。 就近原则：缓存、梯度存储。 减少IO：合并细粒度接口为粗粒度接口、频繁的覆盖操作可以只做最后一次操作。这里一个需要特别注意的地方: 代码中尽量避免在循环中调用外部服务，更好的做法是使用粗粒度批量接口在循环外面只进行一次请求。 分区：频繁访问的数据集规模保持在合理的范围。 系统容量规划需要对系统/关键模块做好评估、量化，以防止超出容量时不至于压垮服务器，仍然能够服务于大部分用户。 根据流量模型、历史数据、预测算法预估未来某一个时间点的业务量：QPS、每日数据量等。 评估单点最大承载量（数据库的单点承载数据量、应用服务器的单点承载并发量）【通过性能测试】，根据业务量计算需要部署的结点数目，做1.5倍部署（DID原则）。 性能压测验证整个系统的负载能力。 设计达到容量预估值时的预警、限流、快速恢复措施以及后续扩展方案。 PS: 在容量预估中，机器数目的计算遵循DID原则：20倍设计、3倍实施/实现、1.5倍部署。即需要部署1.5倍的可承载预估业务流量的机器数目。 架构重构的原则一个系统的架构是随着业务而不断演化的，因此不可避免地会留下很多技术债。如果一味地不去管，那么总有一天技术债会爆发出来造成意想不到的破坏。因此很多时候对架构的重构是必须的。其需要遵循的原则如下： 确定重构的目的和必要性：为了业务需要；有无其他备选方案 定义“重构完成”的界限 渐进式重构 确定当前的架构状态 不要忽略数据 管理好技术债务 远离那些虚荣的东西 做好面对压力的准备 了解业务 做好面对非技术因素的准备 能够掌握代码质量 其他 系统扩展思路 通过克隆扩展-&gt;高可用 通过拆分不同的东西来扩展-&gt;垂直扩展 拆分类似的东西来扩展-&gt;水平扩展 讨论技术方案时，以是否合理为依据，而不要以工作量少为依据。]]></content>
      <categories>
        <category>Java</category>
        <category>架构设计与原则</category>
      </categories>
      <tags>
        <tag>架构设计与原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈架构的概念、架构的形式、架构设计原则]]></title>
    <url>%2Fposts%2Fba1b4470.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>架构设计与原则</category>
      </categories>
      <tags>
        <tag>架构设计与原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序原生高颜值组件库--ColorUI组件库]]></title>
    <url>%2Fposts%2F71ce4a1f.html</url>
    <content type="text"><![CDATA[简介ColorUI是一个Css类的UI组件库！不是一个Js框架。相比于同类小程序组件库，ColorUI更注重于视觉交互！ 浏览GitHub：https://github.com/weilanwl/ColorUI 如何使用？先下载源码包→ Github 引入到我的小程序将 /demo/ 下的 colorui.wxss 和 icon.wxss 复制到小程序的根目录下 在 app.wxss 引入两个文件 12@import "icon.wxss";@import "colorui.wxss"; 使用模板全新开发复制 /template/ 文件夹并重命名为你的项目，微信开发者工具导入为小程序就可以使用ColorUI了 体验沉浸式导航 App.js 获取系统参数并写入全局参数。 12345678910111213//App.jsApp(&#123; onLaunch: function() &#123; wx.getSystemInfo(&#123; success: e =&gt; &#123; this.globalData.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); this.globalData.Custom = custom; this.globalData.CustomBar = custom.bottom + custom.top - e.statusBarHeight; &#125; &#125;) &#125;&#125;) Page.js 页面配置获取全局参数。 123456789//Page.jsconst app = getApp()Page(&#123; data: &#123; StatusBar: app.globalData.StatusBar, CustomBar: app.globalData.CustomBar, Custom: app.globalData.Custom &#125; &#125;) Page.wxml 页面构造导航。更多导航样式请下载Demo查阅 操作条组件。 123456789&lt;view class="cu-custom" style="height:&#123;&#123;CustomBar&#125;&#125;px;"&gt; &lt;view class="cu-bar fixed bg-gradual-pink" style="height:&#123;&#123;CustomBar&#125;&#125;px;padding-top:&#123;&#123;StatusBar&#125;&#125;px;"&gt; &lt;navigator class='action border-custom' open-type="navigateBack" delta="1" hover-class="none" style='width:&#123;&#123;Custom.width&#125;&#125;px;height:&#123;&#123;Custom.height&#125;&#125;px;margin-left:calc(750rpx - &#123;&#123;Custom.right&#125;&#125;px)'&gt; &lt;text class='icon-back'&gt;&lt;/text&gt; &lt;text class='icon-homefill'&gt;&lt;/text&gt; &lt;/navigator&gt; &lt;view class='content' style='top:&#123;&#123;StatusBar&#125;&#125;px;'&gt;操作条&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 自定义系统Tabbar 按照官方 自定义 tabBar 配置好Tabbar (开发工具和版本库请使用最新版)。 使用ColorUI配置Tabbar只需要更改 Wxml 页的内容即可。 更多Tabbar样式请下载Demo查阅 操作条组件。 /custom-tab-bar/index.wxml 12345678 &lt;view class="cu-bar tabbar bg-white shadow"&gt; &lt;view class="action" wx:for="&#123;&#123;list&#125;&#125;" wx:key="index" data-path="&#123;&#123;item.pagePath&#125;&#125;" data-index="&#123;&#123;index&#125;&#125;" bindtap="switchTab"&gt; &lt;view class='icon-cu-image'&gt; &lt;image src='&#123;&#123;selected === index ? item.selectedIconPath : item.iconPath&#125;&#125;' class='&#123;&#123;selected === index ? "animation" : "animation"&#125;&#125;'&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class='&#123;&#123;selected === index ? "text-green" : "text-gray"&#125;&#125;'&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 作者叨叨ColorUI是一个高度自定义的Css样式库，包含了开发常用的元素和组件，元素组件之间也能相互嵌套使用。我也会不定期更新一些扩展到源码。 感谢阅读。 转自链接：https://juejin.im/post/5c773b746fb9a049f43bff0f]]></content>
      <categories>
        <category>前端</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ColorUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager要被废弃？官方ViewPager2升级版来临]]></title>
    <url>%2Fposts%2Fabf696ca.html</url>
    <content type="text"><![CDATA[从文档注释来看ViewPager2确实是用来替代ViewPager 的，顺带解决之前ViewPager的一些问题，并且加入了 RTL,竖向滚动支持，下面一起来详细看下吧。 ViewPager2 replaces ViewPager, addressing most of its predecessor’s pain-points, including right-to-left layout support, vertical orientation, modifiable Fragment collections, etc. 概述这两天浏览安卓开发者官网的时候，发现google悄然推出了一个新的控件：ViewPager2，一看名称就知道这是一个和我们常用的ViewPager功能相似的控件，算是ViewPager的升级版吧。目前还只是推出了第一个预览版，我们可以直接引入来使用了： 1implementation &apos;androidx.viewpager2:viewpager2:1.0.0-alpha01&apos; https://developer.android.google.cn/reference/androidx/viewpager2/widget/ViewPager2 我们先来看看有哪些功能和使用上的变化： 新功能： 支持RTL布局 支持竖向滚动 完整支持notifyDataSetChanged API的变动： FragmentStateAdapter替换了原来的 FragmentStatePagerAdapter RecyclerView.Adapter替换了原来的 PagerAdapter registerOnPageChangeCallback替换了原来的 addPageChangeListener 看了上面这些介绍，有一点比较吸引人的就是支持竖向滚动了，这是怎么实现的呢？ViewPager2的源码不长，我们来简单分析一下。 简单解析通过查看源码得知，ViewPager2是直接继承ViewGroup的，意味着和ViewPager不兼容，类注释上也写了它的作用是取代ViewPager，不过短时间内ViewPager应该还不会被废弃掉。 继续查看源码，发现了两个比较重要的成员变量： 12private RecyclerView mRecyclerView;private LinearLayoutManager mLayoutManager; 所以很清楚得知，ViewPager2的核心实现就是RecyclerView+LinearLayoutManager了，因为LinearLayoutManager本身就支持竖向和横向两种布局方式，所以ViewPager2也能很容易地支持这两种滚动方向了，而几乎不需要添加任何多余的代码。 其实在此之前也不乏有大神采用RecyclerView来实现轮播图效果的，具体实现发生略有不同，但大体思想是一致的。这次ViewPager2的推出意味着这种方法终于被扶正了。 为了让RecyclerView变得像原来的ViewPager，需要设置下SnapHelper： 1new PagerSnapHelper().attachToRecyclerView(mRecyclerView); 熟悉RecyclerView的同学都知道，SnapHelper用于辅助RecyclerView在滚动结束时将Item对齐到某个位置。PagerSnapHelper的作用让滑动结束时使当前Item居中显示，并且 限制一次只能滑动一页，不能快速滑动，这样就和viewpager的交互很像了。 另外和viewpager一样，viewpager2可以承载fragment，我们需要继承实现它提供的FragmentStateAdapter： 12public abstract class FragmentStateAdapter extends RecyclerView.Adapter&lt;FragmentViewHolder&gt; implements StatefulAdapter 这是一个包含FragmentManager和数据状态恢复功能的RecyclerView.Adapter，具体实现可以参看源码。所以大家也可以用TabLayout+ViewPager2+Fragment来实现联动展示效果。 使用通过android:orientation来指定滚动方向 12345&lt;androidx.viewpager2.widget.ViewPager2 android:id="@+id/viewpager2" android:layout_width="match_parent" android:layout_height="200dp" android:orientation="vertical" /&gt; 在代码中设置一个普通的RecyclerView.adapter： 123ViewPager2 viewPager2=findViewById(R.id.viewpager2);RecyclerviewAdapter adapter = new RecyclerviewAdapter(this);viewPager2.setAdapter(adapter); 这样竖直轮播图就大功告成了。 小结viewpager2利用recyclerview来实现viewpager的功能，无疑使使其可扩展性大大提升，代码也变得更优雅简洁，使用起来也更灵活。不过目前viewpager2只是第一个预览版，还存在稳定性方面的问题，不建议大家引入到正式项目中来，尝尝鲜就好。 PS：如果有谁愿意深入解析，示例对比演示等，欢迎火速联系我，投稿分享给大家。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 函数式编程和 lambda 表达式]]></title>
    <url>%2Fposts%2F81a39ed5.html</url>
    <content type="text"><![CDATA[为什么要使用函数式编程函数式编程更多时候是一种编程的思维方式，是种方法论。函数式与命令式编程的区别主要在于：函数式编程是告诉代码你要做什么，而命令式编程则是告诉代码要怎么做。说白了，函数式编程是基于某种语法或调用API去进行编程。例如，我们现在需要从一组数字中，找出最小的那个数字，若使用用命令式编程实现这个需求的话，那么所编写的代码如下： 1234567891011public static void main(String[] args) &#123; int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;; int min = Integer.MAX_VALUE; for (int num : nums) &#123; if (num &lt; min) &#123; min = num; &#125; &#125; System.out.println(min);&#125; 而使用函数式编程进行实现的话，所编写的代码如下： 123456public static void main(String[] args) &#123; int[] nums = new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;; int min = IntStream.of(nums).min().getAsInt(); System.out.println(min);&#125; 从以上的两个例子中，可以看出，命令式编程需要自己去实现具体的逻辑细节。而函数式编程则是调用API完成需求的实现，将原本命令式的代码写成一系列嵌套的函数调用，在函数式编程下显得代码更简洁、易懂，这就是为什么要使用函数式编程的原因之一。所以才说函数式编程是告诉代码你要做什么，而命令式编程则是告诉代码要怎么做，是一种思维的转变。 说到函数式编程就不得不提一下lambda表达式，它是函数式编程的基础。在Java还不支持lambda表达式时，我们需要创建一个线程的话，需要编写如下代码： 12345678public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("running"); &#125; &#125;).start();&#125; 而使用lambda表达式一句代码就能完成线程的创建，lambda强调了函数的输入输出，隐藏了过程的细节，并且可以接受函数当作输入（参数）和输出（返回值）： 123public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println("running")).start();&#125; 注：箭头的左边是输入，右边则是输出 该lambda表达式的作用其实就是返回了Runnable接口的实现对象，这与我们调用某个方法获取实例对象类似，只不过是将实现代码直接写在了lambda表达式里。我们可以做个简单的对比： 1234public static void main(String[] args) &#123; Runnable runnable1 = () -&gt; System.out.println("running"); Runnable runnable2 = RunnableFactory.getInstance();&#125; JDK8接口新特性1.函数接口，接口只能有一个需要实现的方法，可以使用@FunctionalInterface 注解进行声明。如下： 1234@FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i);&#125; 使用lambda表达式获取该接口的实现实例的几种写法： 1234567891011121314public static void main(String[] args) &#123; // 最常见的写法 Interface1 i1 = (i) -&gt; i * 2; Interface1 i2 = i -&gt; i * 2; // 可以指定参数类型 Interface1 i3 = (int i) -&gt; i * 2; // 若有多行代码可以这么写 Interface1 i4 = (int i) -&gt; &#123; System.out.println(i); return i * 2; &#125;;&#125; 2.比较重要的一个接口特性是接口的默认方法，用于提供默认实现。默认方法和普通实现类的方法一样，可以使用this等关键字： 12345678@FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125; 之所以说默认方法这个特性比较重要，是因为我们借助这个特性可以在以前所编写的一些接口上提供默认实现，并且不会影响任何的实现类以及既有的代码。例如我们最熟悉的List接口，在JDK1.2以来List接口就没有改动过任何代码，到了1.8之后才使用这个新特性增加了一些默认实现。这是因为如果没有默认方法的特性的话，修改接口代码带来的影响是巨大的，而有了默认方法后，增加默认实现可以不影响任何的代码。 3.当接口多重继承时，可能会发生默认方法覆盖的问题，这时可以去指定使用哪一个接口的默认方法实现，如下示例： 123456789101112131415161718192021222324252627@FunctionalInterfaceinterface Interface1 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125;@FunctionalInterfaceinterface Interface2 &#123; int doubleNum(int i); default int add(int x, int y) &#123; return x + y; &#125;&#125;@FunctionalInterfaceinterface Interface3 extends Interface1, Interface2 &#123; @Override default int add(int x, int y) &#123; // 指定使用哪一个接口的默认方法实现 return Interface1.super.add(x, y); &#125;&#125; 函数接口我们本小节来看看JDK8里自带了哪些重要的函数接口： 可以看到上表中有好几个接口，而其中最常用的是Function接口，它能为我们省去定义一些不必要的函数接口，减少接口的数量。我们使用一个简单的例子演示一下 Function 接口的使用： 123456789101112131415161718192021222324import java.text.DecimalFormat;import java.util.function.Function;class MyMoney &#123; private final int money; public MyMoney(int money) &#123; this.money = money; &#125; public void printMoney(Function&lt;Integer, String&gt; moneyFormat) &#123; System.out.println("我的存款: " + moneyFormat.apply(this.money)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999); Function&lt;Integer, String&gt; moneyFormat = i -&gt; new DecimalFormat("#,###").format(i); // 函数接口支持链式操作，例如增加一个字符串 me.printMoney(moneyFormat.andThen(s -&gt; "人民币 " + s)); &#125;&#125; 运行以上例子，控制台输出如下： 1我的存款: 人民币 99,999,999 若在这个例子中不使用Function接口的话，则需要自行定义一个函数接口，并且不支持链式操作，如下示例： 12345678910111213141516171819202122232425262728import java.text.DecimalFormat;// 自定义一个函数接口@FunctionalInterfaceinterface IMoneyFormat &#123; String format(int i);&#125;class MyMoney &#123; private final int money; public MyMoney(int money) &#123; this.money = money; &#125; public void printMoney(IMoneyFormat moneyFormat) &#123; System.out.println("我的存款: " + moneyFormat.format(this.money)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999); IMoneyFormat moneyFormat = i -&gt; new DecimalFormat("#,###").format(i); me.printMoney(moneyFormat); &#125;&#125; 然后我们再来看看Predicate接口和Consumer接口的使用，如下示例： 123456789public static void main(String[] args) &#123; // 断言函数接口 Predicate&lt;Integer&gt; predicate = i -&gt; i &gt; 0; System.out.println(predicate.test(-9)); // 消费函数接口 Consumer&lt;String&gt; consumer = System.out::println; consumer.accept("这是输入的数据");&#125; 运行以上例子，控制台输出如下： 12false这是输入的数据 这些接口一般有对基本类型的封装，使用特定类型的接口就不需要去指定泛型了，如下示例： 123456789public static void main(String[] args) &#123; // 断言函数接口 IntPredicate intPredicate = i -&gt; i &gt; 0; System.out.println(intPredicate.test(-9)); // 消费函数接口 IntConsumer intConsumer = (value) -&gt; System.out.println("输入的数据是：" + value); intConsumer.accept(123);&#125; 运行以上代码，控制台输出如下： 12false输入的数据是：123 有了以上接口示例的铺垫，我们应该对函数接口的使用有了一个初步的了解，接下来我们演示剩下的函数接口使用方式： 12345678910111213public static void main(String[] args) &#123; // 提供数据接口 Supplier&lt;Integer&gt; supplier = () -&gt; 10 + 1; System.out.println("提供的数据是：" + supplier.get()); // 一元函数接口 UnaryOperator&lt;Integer&gt; unaryOperator = i -&gt; i * 2; System.out.println("计算结果为：" + unaryOperator.apply(10)); // 二元函数接口 BinaryOperator&lt;Integer&gt; binaryOperator = (a, b) -&gt; a * b; System.out.println("计算结果为：" + binaryOperator.apply(10, 10));&#125; 运行以上代码，控制台输出如下： 123提供的数据是：11计算结果为：20计算结果为：100 而BiFunction接口就是比Function接口多了一个输入而已，如下示例： 12345678910111213141516171819202122class MyMoney &#123; private final int money; private final String name; public MyMoney(int money, String name) &#123; this.money = money; this.name = name; &#125; public void printMoney(BiFunction&lt;Integer, String, String&gt; moneyFormat) &#123; System.out.println(moneyFormat.apply(this.money, this.name)); &#125;&#125;public class MoneyDemo &#123; public static void main(String[] args) &#123; MyMoney me = new MyMoney(99999999, "小明"); BiFunction&lt;Integer, String, String&gt; moneyFormat = (i, name) -&gt; name + "的存款: " + new DecimalFormat("#,###").format(i); me.printMoney(moneyFormat); &#125;&#125; 运行以上代码，控制台输出如下： 1小明的存款: 99,999,999 方法引用在学习了lambda表达式之后，我们通常会使用lambda表达式来创建匿名方法。但有的时候我们仅仅是需要调用一个已存在的方法。如下示例： 1Arrays.sort(stringsArray, (s1, s2) -&gt; s1.compareToIgnoreCase(s2)); 在jdk8中，我们可以通过一个新特性来简写这段lambda表达式。如下示例： 1Arrays.sort(stringsArray, String::compareToIgnoreCase); 这种特性就叫做方法引用(Method Reference)。方法引用的标准形式是：类名::方法名。（注意：只需要写方法名，不需要写括号）。 目前方法引用共有以下四种形式： 类型 示例 代码示例 对应的Lambda表达式 引用静态方法 ContainingClass::staticMethodName String::valueOf (s) -&gt; String.valueOf(s) 引用某个对象的实例方法 containingObject::instanceMethodName x::toString() () -&gt; this.toString() 引用某个类型的任意对象的实例方法 ContainingType::methodName String::toString (s) -&gt; s.toString 引用构造方法 ClassName::new String::new () -&gt; new String() 下面我们用一个简单的例子来演示一下方法引用的几种写法。首先定义一个实体类： 1234567891011121314151617181920212223242526public class Dog &#123; private String name = "二哈"; private int food = 10; public Dog() &#123; &#125; public Dog(String name) &#123; this.name = name; &#125; public static void bark(Dog dog) &#123; System.out.println(dog + "叫了"); &#125; public int eat(int num) &#123; System.out.println("吃了" + num + "斤"); this.food -= num; return this.food; &#125; @Override public String toString() &#123; return this.name; &#125;&#125; 通过方法引用来调用该实体类中的方法，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940package org.zero01.example.demo;import java.util.function.*;/** * @ProjectName demo * @Author: zeroJun * @Date: 2018/9/21 13:09 * @Description: 方法引用demo */public class MethodRefrenceDemo &#123; public static void main(String[] args) &#123; // 方法引用，调用打印方法 Consumer&lt;String&gt; consumer = System.out::println; consumer.accept("接收的数据"); // 静态方法引用，通过类名即可调用 Consumer&lt;Dog&gt; consumer2 = Dog::bark; consumer2.accept(new Dog()); // 实例方法引用，通过对象实例进行引用 Dog dog = new Dog(); IntUnaryOperator function = dog::eat; System.out.println("还剩下" + function.applyAsInt(2) + "斤"); // 另一种通过实例方法引用的方式，之所以可以这么干是因为JDK默认会把当前实例传入到非静态方法，参数名为this，参数位置为第一个，所以我们在非静态方法中才能访问this，那么就可以通过BiFunction传入实例对象进行实例方法的引用 Dog dog2 = new Dog(); BiFunction&lt;Dog, Integer, Integer&gt; biFunction = Dog::eat; System.out.println("还剩下" + biFunction.apply(dog2, 2) + "斤"); // 无参构造函数的方法引用，类似于静态方法引用，只需要分析好输入输出即可 Supplier&lt;Dog&gt; supplier = Dog::new; System.out.println("创建了新对象：" + supplier.get()); // 有参构造函数的方法引用 Function&lt;String, Dog&gt; function2 = Dog::new; System.out.println("创建了新对象：" + function2.apply("旺财")); &#125;&#125; 类型推断通过以上的例子，我们知道之所以能够使用Lambda表达式的依据是必须有相应的函数接口。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上Lambda的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。 如果大家想学习以上路线内容，在此我向大家推荐一个架构学习交流群。交流学习群号874811168 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化、分布式架构等这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多 所以说 Lambda 表达式的类型是从 Lambda 的上下文推断出来的，上下文中 Lambda 表达式需要的类型称为目标类型，如下图所示： 接下来我们使用一个简单的例子，演示一下 Lambda 表达式的几种类型推断，首先定义一个简单的函数接口： 1234@FunctionalInterfaceinterface IMath &#123; int add(int x, int y);&#125; 示例代码如下： 12345678910111213141516171819202122232425262728public class TypeDemo &#123; public static void main(String[] args) &#123; // 1.通过变量类型定义 IMath iMath = (x, y) -&gt; x + y; // 2.数组构建的方式 IMath[] iMaths = &#123;(x, y) -&gt; x + y&#125;; // 3.强转类型的方式 Object object = (IMath) (x, y) -&gt; x + y; // 4.通过方法返回值确定类型 IMath result = createIMathObj(); // 5.通过方法参数确定类型 test((x, y) -&gt; x + y); &#125; public static IMath createIMathObj() &#123; return (x, y) -&gt; x + y; &#125; public static void test(IMath iMath)&#123; return; &#125;&#125; 变量引用Lambda表达式类似于实现了指定接口的内部类或者说匿名类，所以在Lambda表达式中引用变量和我们在匿名类中引用变量的规则是一样的。如下示例： 12345public static void main(String[] args) &#123; String str = "当前的系统时间戳是: "; Consumer&lt;Long&gt; consumer = s -&gt; System.out.println(str + s); consumer.accept(System.currentTimeMillis());&#125; 值得一提的是，在JDK1.8之前我们一般会将匿名类里访问的外部变量设置为final，而在JDK1.8里默认会将这个匿名类里访问的外部变量给设置为final。例如我现在改变str变量的值，ide就会提示错误： 至于为什么要将变量设置final，这是因为在Java里没有引用传递，变量都是值传递的。不将变量设置为final的话，如果外部变量的引用被改变了，那么最终得出来的结果就会是错误的。 下面用一组图片简单演示一下值传递与引用传递的区别。以列表为例，当只是值传递时，匿名类里对外部变量的引用是一个值对象： 若此时list变量指向了另一个对象，那么匿名类里引用的还是之前那个值对象，所以我们才需要将其设置为final防止外部变量引用改变： 而如果是引用传递的话，匿名类里对外部变量的引用就不是值对象了，而是指针指向这个外部变量： 所以就算list变量指向了另一个对象，匿名类里的引用也会随着外部变量的引用改变而改变： 级联表达式和柯里化在函数式编程中，函数既可以接收也可以返回其他函数。函数不再像传统的面向对象编程中一样，只是一个对象的工厂或生成器，它也能够创建和返回另一个函数。返回函数的函数可以变成级联 lambda 表达式，特别值得注意的是代码非常简短。尽管此语法初看起来可能非常陌生，但它有自己的用途。 级联表达式就是多个lambda表达式的组合，这里涉及到一个高阶函数的概念，所谓高阶函数就是一个可以返回函数的函数，如下示例： 123// 实现了 x + y 的级联表达式Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; function1 = x -&gt; y -&gt; x + y;System.out.println("计算结果为: " + function1.apply(2).apply(3)); // 计算结果为: 5 这里的 y -&amp;gt; x + y 是作为一个函数返回给上一级表达式，所以第一级表达式的输出是 y -&amp;gt; x + y这个函数，如果使用括号括起来可能会好理解一些： 1x -&gt; (y -&gt; x + y) 级联表达式可以实现函数柯里化，简单来说柯里化就是把本来多个参数的函数转换为只有一个参数的函数，如下示例： 12Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; function2 = x -&gt; y -&gt; z -&gt; x + y + z;System.out.println("计算结果为: " + function2.apply(1).apply(2).apply(3)); // 计算结果为: 6 如果大家想学习以上路线内容，在此我向大家推荐一个架构学习交流群。交流学习群号874811168 里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化、分布式架构等这些成为架构师必备的知识体系。还能领取免费的学习资源，目前受益良多 函数柯里化的目的是将函数标准化，函数可灵活组合，方便统一处理等，例如我可以在循环里只需要调用同一个方法，而不需要调用另外的方法就能实现一个数组内元素的求和计算，代码如下： 1234567891011121314public static void main(String[] args) &#123; Function&lt;Integer, Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt;&gt; f3 = x -&gt; y -&gt; z -&gt; x + y + z; int[] nums = &#123;1, 2, 3&#125;; for (int num : nums) &#123; if (f3 instanceof Function) &#123; Object obj = f3.apply(num); if (obj instanceof Function) &#123; f3 = (Function) obj; &#125; else &#123; System.out.println("调用结束, 结果为: " + obj); // 调用结束, 结果为: 6 &#125; &#125; &#125;&#125; 级联表达式和柯里化一般在实际开发中并不是很常见，所以对其概念稍有理解即可，这里只是简单带过，若对其感兴趣的可以查阅相关资料。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中字符串全部替换]]></title>
    <url>%2Fposts%2F5bf0344a.html</url>
    <content type="text"><![CDATA[在js中字符串全部替换可以用以下方法： 1str.replace(/需要替换的字符串/g，&quot;新字符串&quot;) 比如： 1234&quot;yyyy-MM-dd-hh-mm-ss&quot;.replace(/-/g,&quot;/&quot;)结果如下：&quot;yyyy/MM/dd/hh/mm/ss&quot; 原理请看JavaScript replace() 方法介绍 定义和用法replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 语法1stringObject.replace(regexp/substr,replacement) 参数 描述 regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。 replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 返回值一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。 说明字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 直接量符号。 注意：ECMAScript v3 规定，replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。 js字符串替换参考资料：http://www.w3school.com.cn/jsref/jsref_replace.asp js正则使用参考资料：http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取指定字符前/后的字符串简单实例]]></title>
    <url>%2Fposts%2F1dfc2d5c.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;script type="text/javascript"&gt;/* string 字符串; str 指定字符; split(),用于把一个字符串分割成字符串数组; split(str)[0],读取数组中索引为0的值（第一个值）,所有数组索引默认从0开始; */function getStr(string,str)&#123; var str_before = string.split(str)[0]; var str_after = string.split(str)[1]; alert('前：'+str_before+' - 后：'+str_after);&#125;&lt;/script&gt;&lt;body&gt;&lt;input type="button" onClick="getStr('string','r');" value="获取值" /&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles在线破解工具]]></title>
    <url>%2Fposts%2Fc05a8eb3.html</url>
    <content type="text"><![CDATA[点击在线生成破解后的charles.jar文件 用法 输入RegisterName(此名称随意，用于显示 Registered to xxx)，选择本地已安装的版本，点击生成，并下载charles.jar文件 替换本地charles.jar文件 macOS: /Applications/Charles.app/Contents/Java/charles.jar Windows: C:\Program Files\Charles\lib\charles.jar]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac端口被占用的解决办法（Hexo为例）]]></title>
    <url>%2Fposts%2F3a2cfc51.html</url>
    <content type="text"><![CDATA[查看端口 看看端口被哪个进程占用 lsof -i :4000 输入kill PID 记住要杀掉的进程PID，加在kill -9后面 kill -9 16149]]></content>
      <categories>
        <category>Mac</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js面试中常问知识点整理]]></title>
    <url>%2Fposts%2Fadbc7180.html</url>
    <content type="text"><![CDATA[看看面试题，只是为了查漏补缺，看看自己那些方面还不懂。切记不要以为背了面试题，就万事大吉了，最好是理解背后的原理，这样面试的时候才能侃侃而谈。不然，稍微有水平的面试官一看就能看出，是否有真才实学还是刚好背中了这道面试题（有空再把例子中代码补上）。 一、对于MVVM的理解？MVVM 是 Model-View-ViewModel 的缩写。 Model 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。 View 代表UI 组件，它负责将数据模型转化成UI 展现出来。 ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 二、Vue的生命周期beforeCreate（创建前），在数据观测和初始化事件还未开始 created（创建后），完成数据观测，属性和方法的运算，初始化事件， $el 属性还没有显示出来 beforeMount（载入前），在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted（载入后），在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。 beforeUpdate（更新前），在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated（更新后），在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前），在实例销毁之前调用。实例仍然完全可用。 destroyed（销毁后），在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 1、什么是vue生命周期？ 答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 2、vue生命周期的作用是什么？ 答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 3、vue生命周期总共有几个阶段？ 答：它可以总共分为8个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。 4、第一次页面加载会触发哪几个钩子？ 答：会触发下面这几个beforeCreate、created、beforeMount、mounted 。 5、DOM 渲染在哪个周期中就已经完成？ 答：DOM 渲染在 mounted 中就已经完成了。 三、 Vue实现数据双向绑定的原理：Object.defineProperty()vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty() 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令，最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 js实现简单的双向绑定： 1234567891011121314151617181920&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;p id=&quot;show&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;&#125; Object.defineProperty(obj, &apos;txt&apos;, &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById(&apos;txt&apos;).value = newValue document.getElementById(&apos;show&apos;).innerHTML = newValue &#125; &#125;) document.addEventListener(&apos;keyup&apos;, function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt; 四、Vue组件间的参数传递1、父组件与子组件传值 父组件传给子组件：子组件通过props方法接受数据； 子组件传给父组件： $emit 方法传递参数 2、非父子组件间的数据传递，兄弟组件传值 eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道）。 五、Vue的路由实现：hash模式 和 history模式hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 六、Vue与Angular以及React的区别？版本在不断更新，以下的区别有可能不是很正确。我工作中只用到vue，对angular和react不怎么熟。 1、与AngularJS的区别 相同点：都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。 不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 2、与React的区别 相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。 不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。 七、vue路由的钩子函数首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。 beforeEach主要有3个参数to，from，next。 to：route即将进入的目标路由对象。 from：route当前导航正要离开的路由。 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 八、vuex是什么？怎么使用？哪种功能场景使用它？只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。 在main.js引入store，注入。新建了一个目录store，… export 。 场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车 state：Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations：mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters：类似vue的计算属性，主要用来过滤一些数据。 action：actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 123456789101112131415const store = new Vuex.Store(&#123; //store实例 state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) modules：项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters，使得结构非常清晰，方便管理。 12345678910111213141516const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125; &#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125; &#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB&#125;) 九、其它小知识点1、css只在当前组件起作用 答：在style标签中写入scoped即可 例如： &lt;stylescoped&gt;&lt;/style&gt; 2、v-if 和 v-show 区别 答：v-if按照条件是否渲染，v-show是display的block或none； 3、$route和$router的区别 答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。 PS：缺少的案例代码，这几天再补上去。有些地方可能描述的不够清楚，如果有歧义，可能是我理解错了。]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidManifest.xml文件详解（application）]]></title>
    <url>%2Fposts%2F6f32c165.html</url>
    <content type="text"><![CDATA[语法（SYNATX）： 12345678910111213141516171819202122&lt;applicationandroid:allowTaskReparenting=["true" | "false"] android:backupAgent="string" android:debuggable=["true" | "false"] android:description="string resource" android:enabled=["true" | "false"] android:hasCode=["true" | "false"] android:hardwareAccelerated=["true" | "false"] android:icon="drawable resource" android:killAfterRestore=["true" | "false"] android:label="string resource" android:logo="drawable resource" android:manageSpaceActivity="string" android:name="string" android:permission="string" android:persistent=["true" | "false"] android:process="string" android:restoreAnyVersion=["true" | "false"] android:taskAffinity="string" android:theme="resource or theme" android:uiOptions=["none" | "splitActionBarWhenNarrow"] &gt; . . .&lt;/application&gt; 被包含于（CONTAINED IN）：** 1&lt;manifest&gt; 能够包含的元素（CAN CONTAIN）： 1234567891011&lt;activity&gt;&lt;activity-alias&gt;&lt;service&gt;&lt;receiver&gt;&lt;provider&gt;&lt;meta-data&gt; 说明（DESCRIPTION）： 这个元素用于应用程序的 声明。它包含了每个应用程序组件所声明的子元素，并且还有能够影响所有组件的属性。其中的很多属性（如icon、label、permission、 process、taskAffinity和allowTaskReparenting）会给组件元素中对应的属性设置默认值。其他的给是应用程序整体设 置的值（如debuggable、enabled、description、allowClearUserData），并且这些属性值不能被组件的属性所 覆盖。 属性（ATTRIBUTES）： Android:allowTaskReparenting 当一个与当前任务有亲缘 关系的任务被带到前台时，用这个属性来指定应用程序中定义的Activity能否从他们当前的任务中转移到这个有亲缘关系的任务中。如果设置为true， 则能够转移，如果设置为false，则应用程序中的Activity必须保留在它们所在的任务中。默认值是false。 1&lt;activity&gt;元素有它们自己的allowTaskReparenting属性，它能够覆盖&lt;application&gt;元素中的设置。 android:allowBackup Whether to allow the application to participate in the backup and restore infrastructure. If this attribute is set to false, no backup or restore of the application will ever be performed, even by a full-system backup that would otherwise cause all application data to be saved via adb. The default value of this attribute is true. 是否允许备份应用的数据，默认是true,当备份数据的时候，它的数据会被备份下来。如果设为false，那么绝对不会备份应用的数据，即使是备份整个系统。 android:backupAgent 这个属性用于定义应用程 序备份代理的实现类的名称，这个类是BackupAgent类的一个子类。它的属性值应该是完整的Java类的名称 （如，com.example.project.MyBackupAgent）。但是，也可以使用用”.”符号开头的简称 （如，.MyBackupAgent），系统会把元素中指定的包名追加到”.”符号的前面。 android:debuggable 这个属性用于指定应用程序是否能够被调试，即使是以用户模式运行在设备上的时候。如果设置为true，则能够被调试，否则不能调试，默认值是false。 android:description 这个属性用于定义应用程序相关的用户可读文本，它要比应用程序标签更长、更详细。它的的值必须被设置成一个字符串资源的引用。跟label属性不一样，label属性可以使用原生的字符串。这个属性没有默认值。 android:enabled 这个属性用于指定 Android系统能否实例化应用程序组件。如果设置为true，这个可以实例化其组件，否则不能够实例化。如果这个属性被设置为true，那么就会使用 每个组件自己enabled属性的设置来判断其是否能够被实例化。如果这个属性被设置为false，它会覆盖其所有组件自己指定的值，应用程序中的所有组 件都会被禁用。 默认值是true。 android:hasCode 这个属性用于设置应用程序是否包含了代码，如果设置为true，则包含代码，否则不包含任何代码。在这个属性被设置为false的时候，系统在加载组件的时候不会试图加载任何应用程序的代码。默认值是true。 如果应用程序没有使用任何应用内置组件类以外的组件，那么这个应用程序就不会有任何自己的代码，像使用AliasActivity类的Activity，是很少发生的。 android:hardwareAccelerated 这个属性用于设置能够给应用程序中的所有Activity和View对象启用硬件加速渲染。如果设置为true，则应该启用，如果设置为false，则不会启用。默认值是false。 从Android3.0 开始，应用程序可以使用硬件加速的OpenGL渲染器，来改善很多共同的2D图形操作的性能。当硬件加速渲染被启动的时候，在Canvas、Paint、 Xfermode、ColorFilter、Shader和Camera中的大多数操作都会被加速。这样会使动画、滚动更加平滑，并且会改善整体的响应效 果，即使应用程序没有明确的使用框架的OpenGL类库。 要注意的是，不是所有的OpenGL 2D操作都会被加速。如果启用了硬件加速渲染器，就要对应用程序进行测试，以确保使用渲染器时不发生错误。 android:icon 这个属性用于设置应用程 序的整个图标，以及每个应用组件的默认图标。对于、、、、 和元素，请看它们各自的icon属性。 设置这个属性时，必须要引用一个包含图片的可绘制资源（例如，“@drawable/icon”）。没有默认的图标。 android:killAfterRestore 这个属性用于指定在全系统的恢复操作期间，应用的设置被恢复以后，对应的问题程序是否应该被终止。单包恢复操作不会导致应用程序被关掉。全系统的复原操作通常只会发生一次，就是在电话被首次建立的时候。第三方应用程序通常不需要使用这个属性。 默认值是true，这意味着在全系统复原期间，应用程序完成数据处理之后，会被终止。 android:largeHeap Whether your application’s processes should be created with a large Dalvik heap. This applies to all processes created for the application. It only applies to the first application loaded into a process; if you’re using a shared user ID to allow multiple applications to use a process, they all must use this option consistently or they will have unpredictable results.Most apps should not need this and should instead focus on reducing their overall memory usage for improved performance. Enabling this also does not guarantee a fixed increase in available memory, because some devices are constrained by their total available memory.To query the available memory size at runtime, use the methods getMemoryClass() or getLargeMemoryClass().无论您的应用程序的进程应该是一个多大的Dalvik堆。这适用于为应用程序创建的所有进程。它只适用于加载到进程中的第一个应用程序，如果你使用一个共享的用户身份证，允许多个应用程序使用一个进程，他们都必须使用此选项一致或他们将有不可预测的结果。大多数应用程序不应该需要这个，而应该把重点放在减少对性能的整体内存使用上。启用此也不保证可用内存的固定增加，因为一些设备被其总可用内存限制。查询可用的内存大小在运行时，使用的方法getmemoryclass()或getlargememoryclass()。 android:label 这个属性用于设置应用程 序整体的用户可读的标签，并也是每个应用程序组件的默认标签。对于、、、和元素，请看它们各自的 label属性。 设置这个属性值时，应该引用一个字符串资源。以便它能够跟用户界面中的其他字符串一样能够被本地化。但是为了应用程序开发的便利，也能够用原生的字符串来设置。 android:logo 这个属性用于给整个应用程序设置一个Logo，而且它也是所有Activity的默认Logo。 设置这个属性时，必须要引用一个包含图片的可绘制资源（如：“@drawable/logo”）。没有默认的Logo。 android:manageSpaceActivity 这个属性定义了一个完整的Activity子类的名字，系统能够把这个名字加载到由用户管理被应用程序所占用的设备上的内存。这个Activity也应该用元素来声明。 android:name 这整个属性用完整的Java类名，给应用程序定义了一个Application子类的实现。当应用程序进程被启动时，这个类在其他任何应用程序组件被实例化之前实例化。 这个子类实现是可选的，大多数应用程序不需要一个子类的实现。如果没有实现自己的子类，Android系统会使用基本的Application类的一个实例。 android:permission 这个属性定义了一个权限，为了跟应用程序进行交互，客户端必须要有这个权限。这个属性是为给所有的应用程序组件设置权限提供了便利的方法。它能够被独立组件所设置的permission属性所覆盖。 android:persistent 这个属性用户设置应用程序是否应该时刻保持运行状态，如果设置为true，那么就保持，否则不保持。默认值是false。普通的应用程序不应该设置这个属性，持久运行模式仅用于某些系统级的应用程序。 android:process 这个属性用于定义一个进程名称，应用程序的所有组件都应该运行在这个进程中。每个组件都能够用它自己process属性的设置来覆盖这个元素中的设置。 默认情况下，当应用程序的第一个组件需要运行时，Android系统就会给这个应用程序创建一个进程。然后，应用中的所有组件都运行在这个进程中。默认的进程名是跟元素中设置的包名进行匹配的。 通过设置这个属性，能够跟另外一个应用程序共享一个进程名，能够把这两个应用程序中的组件都安排到同一个进程中运行—但是仅限于这两个应用程序共享一个用户ID，并且带有相同的数字证书。 如果这个进程名称用“：”开头，那么在需要的时候，就会给应用程序创建一个新的、私有的进程。如果进程名用小写字符开头，就会用这个名字创建一个全局的进程，这个全局的进程能够被其他应用程序共享，从而减少资源的使用。 android:restoreAnyVersion 设置这个属性表示应用程序准备尝试恢复任何备份的数据集，即使备份比设备上当前安装的应用程序的版本要新。这个属性设置为true，即使是在版本不匹配而产生数据兼容性提示的时候，也会允许备份管理来恢复备份的数据，所以要谨慎使用。 这个属性的默认值是false。 android:taskAffinity 这个属性给应用的所有的Activity设置了一个亲缘关系名，除了那些用它们自己的taskAffinity属性设置不同亲缘关系的组件。 默认情况下，应用程序中的所有Activity都会共享相同的亲缘关系，亲缘关系的名称跟由元素设置的包名相同。 android:theme 这个属性给应用程序中所有的Activity设置默认的主题，属性值要引用一个样式资源。每个独立的Activity的主题会被它们自己的theme属性所覆盖。 android:uiOptions 这个属性设置了Activity的UI的额外选项。它必须是下表中的一个值： 值 说明 none 默认设置，没有额外的UI选项。 splitActionBarWhenNarrow 在水平空间受到限制的时 候，会在屏幕的底部添加一个用于显示ActionBar中操作项的栏，例如：在纵向的手持设备上。而不是在屏幕顶部的操作栏中显示少量的操作项。它会把操 作栏分成上下两部分，顶部用于导航选择，底部用于操作项目。这样就会确保可用的合理空间不仅只是针对操作项目，而且还会在顶部给导航和标题留有空间。菜单 项目不能被分开到两个栏中，它们要显示在一起。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis,mysql,sequelize,node,linux,docker,索引优秀文章集锦]]></title>
    <url>%2Fposts%2F325455a3.html</url>
    <content type="text"><![CDATA[redis Redis 数据库入门指南 Redis 数据类型之字符串(String)类型 Redis 数据类型之哈希(Hash)类型 Redis 数据类型之列表(List)类型 Redis 数据类型之集合(Set)类型 Redis 数据类型之有序集合(Sorted Set) Redis 键(Key)的操作命令 redis - Node.js Redis客户端模块 mysql Linux 源码编译安装MySQL 5.7 MySQL 自定义函数和存储过程的使用 MySQL 事件调度器(Event Scheduler)创建定时任务 MySql视图view的使用：创建、修改、删除 MySql触发器trigger的使用 使用MySQL的DATE_FORMAT()函数进行日期/时间格式化 索引 参考1 参考2 Sequelize 定义索引 MySQL索引使用－创建、查看、删除MySQL索引 MySQL索引的优点和缺点及注意事项 sequelize Sequelize 中文API文档－1. 快速入门、Sequelize类 Sequelize 中文API文档－2. Model 的定义、使用与Model类的API Sequelize 中文API文档－3. 模型（表）之间的关系/关联 Sequelize 中文API文档－4. 查询与原始查询 Sequelize 中文API文档－5. 实例的使用、Instance类介绍 Sequelize 中文API文档－6. 事务的使用与Transaction类 Sequelize 中文API文档－8. 钩子函数的使用、Hooks相关API Sequelize 中文API文档－7. Scopes 作用域的使用 Sequelize 中文API文档－9. 数据类型类 DataTypes 及其API Sequelize 中文API文档－10. Migrations 数据迁移与QueryInterface对象 Sequelize 嵌套模型查询及嵌套模型字段排序 Sequelize 连接查询时include中model与association的区别 在Sequelize中使用group by分组聚合查询 Node.js Sequelize 实现数据库读写分离 Sequelize belongsToMany关系的使用及 is not associated with 问题的处理 Sequelize 中事务的使用－启动、提交、回滚 NODE Node.js 基于流将日志、错误分别写入不同文件 Node.js 核心(原生)模块整理 Node.js 中有哪些类型的错误 Node.js 事件循环（Event Loop）介绍 Node.js（npm）中的包和模块 Linux curl 命令行工具的使用及命令参数说明 ssh-keygen实现基于SSH密钥的SSH、SCP无密码登录 Linux命令ftp文件传输 搭建FTP服务器 Linux命令grep查找文件里符合条件的字符串 加快网页访问速度Nginx配置gzip压缩功能 docker Docker 的安装 MySQL 官方Docker镜像的使用 使用 Docker 部暑Node.js应用 Docker 容器数据卷(Data Volume)与数据管理 Docker镜像构建文件Dockerfile及相关命令介绍 构建自已的 Docker 镜像 Docker 镜像(Image)与仓库(Repository)基础 Docker 容器(Container)的管理]]></content>
      <categories>
        <category>awsome</category>
      </categories>
      <tags>
        <tag>awsome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[editorConfig编辑器配置]]></title>
    <url>%2Fposts%2F6d832a8b.html</url>
    <content type="text"><![CDATA[当多人团队进行一个项目开发时，每个人可能喜欢的编辑器不同，有人喜欢Webstrom、有人喜欢sublime、还有人喜欢Hbuilder。 这个时候，问题便迎面而来，如何使使用不同编辑器的开发者能够轻松惬意的遵守最基本的代码规范呢？ 最后终于找到了editorConfig这个东东，发现在这里配置的代码规范规则优先级高于编辑器默认的代码格式化规则。比如我使用的是Webstrom编辑器，我每一次写完代码之后，都习惯性的按下“Ctrl+Alt+L”快捷键去整理代码格式。如果我没有配置editorconfig，执行的就是编辑器默认的代码格式化规则；如果我已经配置了editorConfig，则按照我设置的规则来，从而忽略浏览器的设置。 下面说说它的常用配置和使用方法： 常用配置 （1）charset 编码格式 （2）indent_style 缩进方式 （3）indent_size 缩进大小 （4）insert_final_newline 是否让文件以空行结束 （5）trim_trailing_whitespace 自动删除文件末尾空白行 （6）max_line_length 疑似最大行宽 使用方法 （1）下载相关编辑器的editorconfig插件。 （2）在项目根目录下，新建.editorconfig文件。 （3）配置规范，如下图所示： 12345678910111213141516171819202122# http://editorconfig.orgroot = true[*]#缩进风格：空格indent_style = space#缩进大小2indent_size = 2#换行符lfend_of_line = lf#字符集utf-8charset = utf-8#是否删除行尾的空格trim_trailing_whitespace = true#是否在文件的最后插入一个空行insert_final_newline = true[*.md]trim_trailing_whitespace = false[Makefile]indent_style = tab 官方网站 atom网站：https://atom.io/packages/editorconfig GitHub：https://github.com/sindresorhus/atom-editorconfig 使用建议配合代码检查工具使用，比如说：ESLint和TSLint，统一代码风格。 支持的编辑器 虽然editor编辑器的可用配置并不多，但目前现有的一些配置也差不多能满足最基本格式需求。]]></content>
      <categories>
        <category>前端</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>editorConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webstorm激活破解方法大全]]></title>
    <url>%2Fposts%2F9468177.html</url>
    <content type="text"><![CDATA[webstorm 作为最近最火的前端开发工具,也确实对得起那个价格,但是秉着勤俭节约的传统美德,我们肯定是能省则省啊。 方法一：（更新时间：2018/4/8）v3.3 不一定长期有效注册时，在打开的License Activation窗口中选择“License server”，在输入框输入下面的网址： http://180.76.140.202:9123 (2018/07/20) http://idea.wrbugtest.tk/ (2018/06/16) 点击：Activate即可。 方法二：获取注册码（推荐）打开网址IntelliJ IDEA 注册码，我们能看到下面的界面，直接点击获取激活码，将生成的激活码粘贴到WebStorm激活对话框中的Lisence Code输入框，点击OK即可破解。 方法三：使用破解补丁（推荐）首先下载补丁，看图！ 最新版本下载地址：IntelliJ IDEA 注册码 第一步:将补丁复制到安装目录的bin目录下 1\...\WebStorm\bin PS：一定要把这个jar包复制到这个bin目录，不然后面操作可能无法进行。 *第二步：修改同目录下的 WebStorm.vmoptions * 用文本编辑器打开之后，在文件最上面加一行代码 ： 1-javaagent: D:/Program Files (x86)/JetBrains/WebStorm/bin/破解补丁名字.jar 第三步：配置好之后，保存文件。在此再次启动WebStorm，选择activation code，并将-javaagent:你的WebStorm路径前缀/WebStorm/bin/破解补丁名字.jar 方法四:自己搭建IntelliJ IDEA授权服务器这个比较繁琐,喜欢折腾的人可以试试: IntelliJ IDEA License Server本地搭建教程 ilanyu’s大牛的博客里有详细的步骤 如果有更好的方法,欢迎留言交流。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome的控制台,Console命令的各种用法你真的都已经了解了吗？]]></title>
    <url>%2Fposts%2F8910c6e9.html</url>
    <content type="text"><![CDATA[前言作为前端工程师，我们每天都离不开用控制台调试代码，console.log也成了我们最常用的命令，那除了用console.log，还有许多console的方法可以使用，熟练掌握它们，可以让我们在控制台看到的信息更美观准确，也会大大提高我们的开发效率哦，下面就跟小肆一起来看看吧. Chrome的控制台大部分常用浏览器都有各自的控制台，不过小肆用着最习惯的还是Chrome的控制台，打开chrome，win系统按F12，mac系统按command+option+J就可以呼出控制台了，切换到Console标签就能看到如下信息： 我们可以看到，baidu还在控制台给我们留了个小彩蛋，我想这个彩蛋也是为我们程序员同学留的吧。让我们先学第一个命令清除控制台来开始吧。 清除控制台在chorme下清除控制台的方法有很多： 输入console.clear()命令或clear()命令 使用快捷键 Control + J 或 Command + K 点击控制台左上角第二个图标 🚫 显示信息的命令12345console.log('技术放肆聊') // 输出普通信息console.info('技术放肆聊') // 输出提示信息console.warn('技术放肆聊') // 输出警告信息console.error('技术放肆聊') // 输出错误信息console.debug('技术放肆聊') // 输出调试信息 console.log、console.info、console.debug这三个命令可以理解为一个，我们只需要用console.log就行，并且chrome还不支持console.debug命令。 console.warn命令输出警告信息，信息前带有黄色警告符号。console.error输出错误信息，信息前带有红色错误符号，表示出错，同时会显示错误发生的堆栈。上段代码在chrome控制台输出效果如下: 在safari输出效果如下: 占位符console上述的命令支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）: 占位符 作用 %s 字符串 %d or %i 整数 %f 浮点数 %o 可展开的DOM %O 列出DOM的属性 %c 根据提供的css样式格式化字符串 123456//字符(%s)console.log("%s","技术放肆聊");//整数(%d或%i)console.log("%d年%d月%d日",2019,1,6); //浮点数(%f)console.log("PI=%f",3.1415926); 显示效果如下： %o、%O 都是用来输出 Object 对象的，对普通的 Object 对象，两者没区别，但是打印dom节点时就不一样了： %c 占位符是最常用的。使用 %c 占位符时，对应的后面的参数必须是 CSS 语句，用来对输出内容进行 CSS 渲染。常见的输出方式有两种：文字样式、图片输出。 信息分组console.group()用于将显示的信息分组，可以把信息进行折叠和展开。console.groupEnd()结束内联分组 将对象以树状结构展现console.dir()可以显示一个对象所有的属性和方法. 显示某个节点的内容console.dirxml()用来显示网页的某个节点(node)所包含的html/xml代码 判断变量是否是真console.assert()用来判断一个表达式或变量是否为真，此方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 计时功能console.time()和console.timeEnd()，用来显示代码的运行时间 12345console.time("控制台计时器");for(var i = 0; i &lt; 10000; i++)&#123; for(var j = 0; j &lt; 10000; j++)&#123;&#125; &#125;console.timeEnd("控制台计时器"); 性能分析performance profileconsole.profile()和console.proileEnd()用来分析程序各个部分的运行时间，找出瓶颈所在。 123456789101112131415 function All()&#123; for(var i = 0; i &lt; 10; i++)&#123; funcA(100); &#125; funcB(1000); &#125; function funcA(count)&#123; for(var i = 0; i &lt; count; i++)&#123;&#125;; &#125;function funcB(count)&#123; for(var i = 0; i &lt; count; i++)&#123;&#125;;&#125;console.profile("性能分析器");All();console.profileEnd(); 详细的信息在chrome控制台里的”profile”选项里查看 console.count()统计代码被执行的次数123456function myFunction()&#123; console.count("myFunction 被执行的次数");&#125;myFunction(); //myFunction 被执行的次数: 1myFunction(); //myFunction 被执行的次数: 2myFunction(); //myFunction 被执行的次数: 3 console.table表格显示方法 总结合理的利用console的各种方法，会使我们的调试过程更加愉悦，今天的分享就到这里了，记得右下角点好看呦！ 转自：https://mp.weixin.qq.com/s/8jcqYIPZGQVsLo3fou41Zw]]></content>
      <categories>
        <category>前端</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强力推荐！那些你不能错过的GitHub插件和工具]]></title>
    <url>%2Fposts%2Ff033121.html</url>
    <content type="text"><![CDATA[以代码托管平台起家的 GitHub 网站，已然成为全球程序员工作和生活中不可或缺的一份子。从优秀的企业，到优秀的程序员，都将自己最优秀的代码作品存放在这片开源净土里，供彼此学习交流。 GitHub Trending 栏目甚至已经成为 IT 从业人员的新闻日报，每日必读。 既然 GitHub 这么重要，又被我们使用得这么频繁，那关于 GitHub 的一些优秀浏览器插件或者其他工具，我们就一定不可错过啦。本文就来整理一些，都是我平常使用最得心应手的东西，全都倾力推荐出来，绝对干货！ Chrome 扩展程序 备注：这个分类的部分均可以在 Chrome 应用商店 搜索得到，也可以直接点击小标题直接跳转至插件详情页。 Octotree 很好奇的是，GitHub 作为代码托管平台，竟然没有提供项目目录，方便用户在线快速浏览项目结构。所以，在线分析项目源码就会变得很繁琐，必须一层一层点击，然后再一次一次地向上返回。要知道，本来 GitHub 网站在中国区的访问就已经很慢了。最无奈的做法就是，下载到本地，再使用 Sublime 等编辑器打开。 Octotree 作为 Chrome 浏览器的一款插件，刚好解决这个使用痛点。他能够像 IDE 一样提供项目目录，快捷导航，方便浏览。同时支持 GitHub 和 GitLab 两个常用的代码托管网站。更贴心的是，你可以自行选择是否显示目录。 GitHub Plus 同样作为 Chrome 的插件，GitHub Plus 提供的功能也是非常实用。能够显示代码仓库的大小，以及其中每个文件的大小和下载链接。使用这款插件，我们再也不用因为需要某个单一文件而被迫下载整个项目源码，尤其是在网速不给力的时候。 GitHub Hovercard 使用这款插件，当你将鼠标停留在 GitHub 网站的用户头像或者仓库链接地址上时，会自动弹出一个悬浮框，带你提前预览基本信息。有点类似 StackOverflow 网站的用户头像的鼠标悬停效果。Hovercard 插件支持的悬停位置更多，包括用户头像，仓库地址，Issue 链接，个人主页等。咱们还是用图说话比较直接： Sourcegraph for GitHub 代码搜索，查看引用，自动跳转，项目目录导航，这些 IDE 上常用的功能操作，借助 Sourcegraph 插件，都能帮你直接在线使用。如图： Octo Mate 这款插件提供的功能与前面提到的 GitHub Plus 有点类似，展示项目大小，任意文件点击下载等。如图： Awesome Autocomplete for GitHub GitHub 智能搜索插件。有点类似自动补全功能，实时监听输入的搜索关键字，自动列出相关内容。正如官方介绍那样，致力于打造 GitHub 上最好的搜索引擎，助你在搜索仓库和用户方面，比以往更快人一步。 Isometric Contributions 3D 像素立体展示 GitHub 上的仓库提交记录。相比传统的方块图表，更有美感。当然，使用这款插件之后，你可以自由切换展示方式，而不是一刀切。 高效率管理工具 前面提到的都是 Chrome 的插件系列，基本上可以解决平时我们使用 GitHub 在线搜索或者浏览某一仓库时所遇到的痛点问题。但是还有一个很重要的痛点没有解决，那就是我们 Star 过的仓库管理问题。 任何一个 IT 领域，GitHub 网站都有成千上万个优秀开源项目可供参考学习。所以，收藏关注几十几百个项目是再平常不过的一件事了。没有标签，没有便捷的检索功能，如何高效率地管理这些关注过的项目呢？也许你可以尝试这些网站提供的工具。 OhMyStar2 强力推荐 OhMyStar2 客户端，号称是管理 GitHub Stars 最好的方式。自动同步 GitHub 账号的 Stars，拥有标签和评分两种分类方式助你分组管理项目，根据名称、日期等指标自动排序，三方分享功能，甚至提供每日 Trending 浏览，说是最好，名符其实！ Astral 也是提供标签式的方式管理 GitHub 账号关注的项目。只不过，通过网站在线管理，没有提供 PC 版客户端。免费试用。 Insight.io 这个工具使用起来有点类似 IDE，提供开发中常用的快速导航、代码搜索功能、查看引用和点击跳转等功能。 我想，有了这些工具，一定能大幅提高我们程序员使用 GitHub 时的效率。工欲善其事，必先利其器。站在巨人的肩膀上，更容易事半功倍。利用好工具，换种角度来看，也是一种不可忽视的能力。 从事 IT 行业以来，越发觉得，互联网对于我们每个人来说，都是公平的，如何开拓视野，利用网络平台提升自己的学习能力和工作效率，显得尤为重要。很庆幸，我们都在这个最潮流的行业，共同学习，一起进步。 备注：更多开发中的优秀 Chrome 插件，可访问我的 GitHub 仓库地址：https://github.com/zhangmiaocc/powerful-chrome-plugins]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MediaMetadataRetriever获取网络/本地视频第一帧图片]]></title>
    <url>%2Fposts%2Ff0cf7486.html</url>
    <content type="text"><![CDATA[获取视频第一帧图片，这种需求不多，项目中用到了这个功能踩了点坑，很骚。 获取网络视频123MediaMetadataRetriever mmr = new MediaMetadataRetriever();//后面这个是传请求Headers，如果有需要可以添加mmr.setDataSource(url, new HashMap()); 获取本地视频(setDataSource中不需要传第二个参数，直接传路径就好)123MediaMetadataRetriever mmr = new MediaMetadataRetriever();//后面这个是传请求Headers，如果有需要可以添加mmr.setDataSource(path, new HashMap()); 封装的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class MediaUtils &#123; public static final int MEDIA_TYPE_IMAGE = 1; public static final int MEDIA_TYPE_VIDEO = 2; public static File file; /** * Create a file Uri for saving an image or video */ public static Uri getOutputMediaFileUri(Context context, int type) &#123; Uri uri = null; //适配Android N if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; return FileProvider.getUriForFile(context, context.getApplicationContext().getPackageName() + ".provider", getOutputMediaFile(type)); &#125; else &#123; return Uri.fromFile(getOutputMediaFile(type)); &#125; &#125; /** * Create a File for saving an image or video */ public static File getOutputMediaFile(int type) &#123; // To be safe, you should check that the SDCard is mounted // using Environment.getExternalStorageState() before doing this. File mediaStorageDir = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), "image"); // This location works best if you want the created images to be shared // between applications and persist after your app has been uninstalled. // Create the storage directory if it does not exist if (!mediaStorageDir.exists()) &#123; if (!mediaStorageDir.mkdirs()) &#123; return null; &#125; &#125; // Create a media file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); File mediaFile; if (type == MEDIA_TYPE_IMAGE) &#123; mediaFile = new File(mediaStorageDir.getPath() + File.separator + "IMG_" + timeStamp + ".jpg"); &#125; else if (type == MEDIA_TYPE_VIDEO) &#123; mediaFile = new File(mediaStorageDir.getPath() + File.separator + "VID_" + timeStamp + ".mp4"); &#125; else &#123; return null; &#125; file = mediaFile; return mediaFile; &#125; /** * 获取视频的第一帧图片 */ public static void getImageForVideo(String videoPath, OnLoadVideoImageListener listener) &#123; LoadVideoImageTask task = new LoadVideoImageTask(listener); task.execute(videoPath); &#125; public static class LoadVideoImageTask extends AsyncTask&lt;String, Integer, File&gt; &#123; private OnLoadVideoImageListener listener; public LoadVideoImageTask(OnLoadVideoImageListener listener) &#123; this.listener = listener; &#125; @Override protected File doInBackground(String... params) &#123; MediaMetadataRetriever mmr = new MediaMetadataRetriever(); String path = params[0]; if (path.startsWith("http")) //获取网络视频第一帧图片 mmr.setDataSource(path, new HashMap()); else //本地视频 mmr.setDataSource(path); Bitmap bitmap = mmr.getFrameAtTime(); //保存图片 File f = getOutputMediaFile(MEDIA_TYPE_IMAGE); if (f.exists()) &#123; f.delete(); &#125; try &#123; FileOutputStream out = new FileOutputStream(f); bitmap.compress(Bitmap.CompressFormat.JPEG, 90, out); out.flush(); out.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mmr.release(); return f; &#125; @Override protected void onPostExecute(File file) &#123; super.onPostExecute(file); if (listener != null) &#123; listener.onLoadImage(file); &#125; &#125; &#125; public interface OnLoadVideoImageListener &#123; void onLoadImage(File file); &#125;&#125; 因为考虑到处理视频比较耗时，上面代码使用了AsycTask+Callback的方式来实现，先保存到本地后在加载本地的图片。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷炫的Activity切换动画，打造更好的用户体验]]></title>
    <url>%2Fposts%2F908dd83e.html</url>
    <content type="text"><![CDATA[毫无疑问，动画效果能提高用户体验。我们平时使用最多的动画基本上是属性动画和补间动画了，属性动画很强，基本能定制我们想要的动画，但是你是否知道，API 21（5.0）后系统内置了Activity之间的切换动画，而且非常酷炫，今天我跟大家一起分享一下。 我们知道，在两个Activity之间切换，我们一般会写出类似下面的代码： 123Intent intent=new Intent(this,SecondActivity.class);startActivity(intent);overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim); 在API 21以后，我们可以使用内置的Activity切换动画啦。但是这样也就意味着只能兼容5.0之后的系统，我们先看一个效果图来压压惊： ​ 先看看第一个Activity，退出时用的是Explode效果，第二个Activity进入时用的是Slide效果。这些效果无需我们自己去实现，都是内置的效果，我们所编写的代码几乎为零，接下来我们一一看看内置了哪些效果。 1 使用内置Activity之间切换动画代码步骤Activity之间的切换期间，对于某个Activity来说，无非就是“进入”和“退出”两种情景下的动画。而“进入”分为“第一次进入Activity”和“返回当前Activity”这两种情况。另外系统还提供了一种动画，即共享元素，这是让两个Activity中的View有个过渡切换的效果。执行动画的状态如下所示： enter：用于决定第一次打开当前Activity时的动画 exit : 用于决定退出当前Activity时的动画 reenter: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画 shared elements:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果 那么应该怎么去使用Activity切换动画呢？我们看看使用步骤： 1.首先在setContentView()之前执行，用于告诉Window页面切换需要使用动画 1getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 2.接下来就是加载切换动画 其中R.transition.explode就是要执行的动画，是在res/transition目录下的xml文件，我们使用的是系统内置的Explode效果动画，关于怎么去写explode.xml，我们接下来小节去讲解。 1Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode); 3.告诉Window，当前的Activity在什么情况下使用上面的动画 上面我们创建好了切换动画，接下来就是要告诉当前窗口，在什么情况下去使用动画效果啦，你可以根据你的需求在不同的切换情景中选择不同的效果： 123456//退出时使用getWindow().setExitTransition(explode);//第一次进入时使用getWindow().setEnterTransition(explode);//再次进入时使用getWindow().setReenterTransition(explode); 当然了，你也可以不使用代码的方式，直接在你使用的主题&lt;style&gt;标签里添加类似如下代码： 123&lt;item name="android:windowExitTransition"&gt;@transition/explode&lt;/item&gt;&lt;item name="android:windowEnterAnimation"&gt;@transition/explode&lt;/item&gt;&lt;item name="android:windowReenterTransition"&gt;@transition/explode&lt;/item&gt; 4.调用startActivity 跟我们之前使用的startActivity(Intent intent);不同，这里多了一个参数Bundle，我们是先通过makeSceneTransitionAnimation函数创建一个ActivityOptions对象，再将其转为Bundle对象: 1startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); 整体使用步骤就是以上这些，是不是很简单？接下来我们去学习如何使用内置动画~ 2 Explode效果Explode即爆炸效果，使用Explode效果很简单，在res/transition目录下新建一个xml文件(如explode.xml)，内容如下： 12&lt;explode xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" /&gt; 其中duration表示Explode动画持续时间，由于是Activity之间的切换，最好不要把动画时间设置过大，一般取200500毫秒比较合适。我们看看效果吧 3 Slide效果即滑动效果，使用Slide跟Explode类似，都是在res/transition目录下新建一个xml文件(如slide.xml)，内容如下： 123&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot; android:slideEdge=&quot;end&quot;/&gt; 其中，slideEdge表示起始滑动的侧边位置，end表示右侧，start表示左侧，top表示顶部，bottom表示底侧，各种效果你可以亲自试试~，一起看看滑动效果吧 GIF 效果看的比较死板，可以下载我的源码实际运行一下~ 如果你不希望顶部的状态栏以及底部的导航栏一起执行动画，可以在xml中指定： 12345678&lt;slide xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@android:interpolator/decelerate_cubic" android:slideEdge="end"&gt; &lt;targets&gt; &lt;target android:excludeId="@android:id/navigationBarBackground" /&gt; &lt;target android:excludeId="@android:id/statusBarBackground" /&gt; &lt;/targets&gt;&lt;/slide&gt; 4 Fade效果Fade效果即淡化效果，使用淡化效果依然是很简单，在res/transition目录下新建一个xml文件(如fade.xml)，内容如下： 12&lt;fade xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" /&gt; Fade效果就是将View逐步淡化，这里不再贴效果啦，想看效果的可以下载我的源码运行看看~ 5 Shared Element效果即共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果，我们先看看动态图感受一下： 从动态图中看到，第一个Activity的小绿色方块到第二个Activity大绿色方块有个过渡效果~ 接下来我们看看如何实现这个效果： 1.将两个Activity中需要过渡的View加上android:transitionName属性 两个View的android:transitionName属性取值要一致，比如： 第一个Activity布局： 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:id="@+id/firstSharedView" android:layout_width="100dp" android:layout_height="100dp" android:background="#00cc00" android:onClick="onClick" android:transitionName="sharedView" /&gt;&lt;/RelativeLayout&gt; 第二个Activity布局： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:layout_width="match_parent" android:layout_height="300dp" android:layout_alignParentBottom="true" android:background="#00cc00" android:onClick="onClick" android:transitionName="sharedView" /&gt;&lt;/RelativeLayout&gt; 两个绿色的View都添加android:transitionName属性，并且取名一致。 2.调用startActivity ActivityOptions的makeSceneTransitionAnimation函数第一个参数Activity没啥解释的，第二个参数就是第一个Activity中的View对象，第三个参数就是两个Activity的View的 android:transitionName属性的值。 1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, firstSharedView, "sharedView").toBundle()); 现在就可以实现这种Shared Element效果啦，但是可能你会想实现同时让两个View有这样的效果，可是makeSceneTransitionAnimation函数却只能让我们设置一个View和一个transitionName属性。如何添加多个呢？接下来我们一起学习让多个View同时有切换效果。 除了需要将两个Activity中需要过渡的View对应取相同的名称外，还需将需要过渡的View和transitionName取值对应的String这两个对象封装到一个Pair对象中： 123Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView)); 然后调用ActivityOptionsCompat类的makeSceneTransitionAnimation的另一个重载函数makeSceneTransitionAnimation(Activity activity, Pair&lt;View, String&gt;... sharedElements)，第一个参数不解释，后面参数为不定长度的形参，即你可以传递任意多个Pair对象。 12ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, first, second); 最后调用startActivity 12ActivityCompat.startActivity(this, intent, transitionActivityOptions.toBundle()); 说了这么多步骤，我们来看看效果吧~ 多个子View的过渡效果 5.1 自定义 Shared Element切换动画如果你对内置的 Shared Element还不够满意，你还可以定制View的过渡切换效果。步骤如下： 1.创建一个View的过渡移动的轨迹路径PathMotion类 我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看【ArcMotion官方文档】 123ArcMotion arcMotion = new ArcMotion();arcMotion.setMinimumHorizontalAngle(50f);arcMotion.setMinimumVerticalAngle(50f); 2.定义ChangeBounds类 我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数： 1.ViewGroup sceneRoot：屏幕根View，即DecorView，第二个Activity的DecorView。 TransitionValues startValues ：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数captureStartValues里放置，因此你可以重写captureStartValues函数，并把你自定义的属性动画中的属性放进去。 TransitionValues endValues ：与startValues类似，表示属性动画结束时的属性值。可以通过重写captureEndValues函数，并把你自定义的属性动画里面的最终属性值放进去。 我们先看一个最简单的示例： 1234567891011121314151617181920212223242526package com.zm.util;import android.animation.Animator;import android.transition.ChangeBounds;import android.transition.TransitionValues;import android.view.ViewGroup;import android.view.animation.AnimationUtils;public class CustomChangeBounds extends ChangeBounds &#123; @Override public Animator createAnimator(final ViewGroup sceneRoot, TransitionValues startValues, final TransitionValues endValues) &#123; Animator changeBounds = super.createAnimator(sceneRoot, startValues, endValues); if (startValues == null || endValues == null || changeBounds == null) return null; changeBounds.setDuration(300); changeBounds.setInterpolator(AnimationUtils.loadInterpolator(sceneRoot.getContext(), android.R.interpolator.fast_out_slow_in)); return changeBounds; &#125;&#125; 看看效果吧~ 参考资料：https://labs.ribot.co.uk/exploring-meaningful-motion-on-android-1cd95a4bc61d#.cf6pub9xu https://github.com/hitherejoe/animate]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity切换动画常用实现方式]]></title>
    <url>%2Fposts%2Fa8391ded.html</url>
    <content type="text"><![CDATA[一. overridePendingTransition()：此方式只需要在启动另一个activity和退出activity的时候调用就行，这个方法接收两个参数，一个是新启动的activity进入时的动画，另一个是当前activity消失时的动画。 启动： 12startActivity(newIntent(MainActivity.this,TestActivityWithTheme.class));overridePendingTransition(R.anim.open_in, R.anim.open_out); 退出： 12345@Override public void finish() &#123; super.finish(); overridePendingTransition(R.anim.close_in, R.anim.close_out); &#125; 二. ActivityOptionsCompat：这个类是supportv4中新加的一个类，可以为activity添加各种动画效果，这里面的api至少要求4.0以上的系统，部分要求5.0以上，谷歌为我们封装好了的一些拉伸扩散动画，共享元素动画等等，下面只介绍一种简单效果的实现方式， 启动： 12ActivityOptionsCompat compat = ActivityOptionsCompat.makeCustomAnimation(MainActivity.this, R.anim.open_in, R.anim.open_out);ActivityCompat.startActivity(MainActivity.this,intent, compat.toBundle()); 退出： 12345Overridepublic void onBackPressed() &#123; super.onBackPressed(); ActivityCompat.finishAfterTransition(this);&#125; 注意：该退出方法不能达到预期的动画效果，还需要使用第一种方式实现退出overridePendingTransition(R.anim.close_in, R.anim.close_out); 三.AppTheme: 直接在主题中修改activity动画样式：我们可以在 AndroidManifest.xml 文件中，通过Android:theme 属性设置 Activity 的主题。主题中可以定义 Activity 的切换动画。这是应用 Activity 切换动画的一种方法。下面是通过主题来设置 Activity 间的切换动画的实现方式。 3.1、定义包含动画的 Activity 主题res/values/styles.xml 123&lt;style name="AnimActivityTheme" parent="@android:style/Animation.Activity"&gt; &lt;item name="android:windowAnimationStyle"&gt;@style/MyWindowAnimTheme&lt;/item&gt;&lt;/style&gt; 就是使用 windowAnimationStyle 这个属性，指定切换动画的style即可。 3.2、定义切换动画 styleres/values/styles.xml 123456&lt;style name="MyWindowAnimTheme"&gt; &lt;item name="android:activityOpenEnterAnimation"&gt;@anim/top_to_bottom_in&lt;/item&gt; &lt;item name="android:activityOpenExitAnimation"&gt;@anim/top_to_bottom_out&lt;/item&gt; &lt;item name="android:activityCloseEnterAnimation"&gt;@anim/bottom_to_top_in&lt;/item&gt; &lt;item name="android:activityCloseExitAnimation"&gt;@anim/bottom_to_top_out&lt;/item&gt;&lt;/style&gt; 下面具体介绍这4个属性的意思，假设我们有 2 个 Activity，分别是 A 和 B： A 启动 B 时，A 从屏幕上消失，这时执行的是A的 android:activityOpenExitAnimation A 启动 B 时，B 出现在屏幕上，这时执行的是B的 android:activityOpenEnterAnimation 从 B 返回A时，B从屏幕上消失，这时执行的是B的 android:activityCloseExitAnimation 从 B 返回A时，A 出现在屏幕上，这时执行的是A的 android:activityCloseEnterAnimation 3.3、定义具体动画文件 res/anmi/res/top_to_bottom_in.xml res/anmi/res/top_to_bottom_out.xml res/anmi/res/bottom_to_top_in.xml res/anmi/res/bottom_to_top_out.xml 这里不再介绍动画文件的实现。 3.4、应用到对应 ActivityAndroidMenifest.xml 12&lt;activity android:name=".MainActivity" android:theme="@style/AnimActivityTheme”&gt; 3.5、另外在使用AppTheme设置动画时发现了两个问题，3.5.1、添加动画后，出现从黑屏到新activity的过度。原因：没有设置相应的消失动画。 解决方法：设置相应的消失动画，如果不想设置消失动画，可以使用写一个假动画，这个动画是没有任何效果，只是为了避免出现黑屏，运行效果为原acticity静止不动，新启动的activity执行进入动画。 3.5.2、没有动画，或动画与设置不一致原因：当页面切换时需要进入和消失两个动画，当没有进入动画时，消失动画也不会执行，会执行系统动画，如果没有系统动画则没有动画，或者某个页面使用第一或第二种方式设置了动画（动画执行优先级，系统动画 &lt; AppTheme &lt; (overridePendingTransition\ActivityOptionsCompat)）。 解决方法：为了保证进入和消失都有动画，要将动画主题设置到两个Activity上。也可以将主题设置到application上，这样整个应用都是用该切换动画。如果是某个页面使用第一或第二种方式设置了动画，那么在启动和退出时最好都要设置，不然会造成启动和退出不一致的情况。 总结：第一种方式：灵活可以随意控进入消失动画，但是实现不方便。第二种方式：与第一种方式类似，但是该种方式为我们提供了多种特殊动画。第三种方式：使用方便，只需要配置主题，不需要添加过多代码，但是不够灵活 建议：定义一种动画主题，并设置到application上，将整个应用的切换动画统一，如果某个页面有特殊要求，再根据不用需求使用第一或第二种类型单独处理。]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android横竖屏切换]]></title>
    <url>%2Fposts%2Fa6a76007.html</url>
    <content type="text"><![CDATA[Android开发中，大多APP可能根据实际情况直接将APP的界面方向设死了，或竖屏或横屏。但是，我们还是会遇到横竖屏切换的功能需求，不管是通过物理重力感应触发，还是用户手动触发。所以，我们有必要去弄清楚Android中横竖屏切换到底做了什么。 Follow me …… 一、android:screenOrientation &amp; android:configChanges android:screenOrientation是用来设置 activity在设备上的显示方向的，只能是下面的唯一值： 值 描述 unspecified 默认值。系统自动选择屏幕方向 behind 跟activity堆栈中的下面一个activity的方向一致 landscape 横屏方向，显示的宽比高长 portrait 竖屏方向，显示的高比宽长 sensor 由设备的物理方向传感器决定，如果用户旋转设备，这屏幕就会横竖屏切换 nosensor 忽略物理方向传感器，这样就不会随着用户旋转设备而横竖屏切换了（”unspecified”设置除外） user 用户当前首选的方向 reverseLandscape API 9 以上，反向横屏 reversePortrait API 9 以上，反向竖屏 sensorLandscape API 9 以上，横屏，但是可以根据 物理方向传感器来切换正反向横屏 sensorPortrait API 9 以上，竖屏，但是可以根据 物理方向传感器来切换正反向竖屏 fullSensor API 9 以上，上下左右四个方向，由物理方向传感器决定 locked API 18 以上，锁死当前屏幕的方向 如果你上传应用到 Google Play，需要注意以下提示： Note: When you declare one of the landscape or portrait values, it is considered a hard requirement for the orientation in which the activity runs. As such, the value you declare enables filtering by services such as Google Play so your application is available only to devices that support the orientation required by your activities. For example, if you declare either”landscape”, “reverseLandscape”, or “sensorLandscape”, then your application will be available only to devices that support landscape orientation. However, you should also explicitly declare that your application requires either portrait or landscape orientation with the element. For example, . This is purely a filtering behavior provided by Google Play (and other services that support it) and the platform itself does not control whether your app can be installed when a device supports only certain orientations. android:configChanges用来设置 activity配置改变（不仅仅是屏幕方向，还有语言、地区等等）的集合。当一个配置改变在运行中发生时，activity默认情况下会先销毁然后重新创建。但是，如果通过这个属性声明了某个配置后，将可以避免上面的情况，而是依然运行，并回调 onConfigurationChanged() 方法。该属性可以设置多个值： 值 描述 mcc IMSI移动台的国家代码（MCC）发生变化——一个SIM被探测到并且更新MCC mnc IMSI移动台的网络代码（MNC）发生变化——一个SIM被探测到并且更新MNC locale 区域发生变化——用户选择了一个文本需要显示的新语言 keyboard 键盘类型发生变化——例如：用户插入了外接键盘。 keyboardHidden 键盘的可访问性发生变化——例如：用户发现了硬件键盘。 screenLayout 屏幕布局发生变化——这个会导致显示不同的Activity。 orientation 屏幕方向发生变化——用户旋转了屏幕。注意：如果应用程序的目标API级别是13或更高（通过属性minSdkVersion和属性targetSdkVersion声明），你也需要声明配置项screenSize，因为这将在设备选择肖像和屏幕方向时发生改变。 screenSize 当前可用屏幕大小发生变化。这代表一个当前可用大小的变化，和当前的比率相关，因此当用户选择不同的画面和图像，会发生变化。然而，如果你的程序目标API级别是12或更低，你的Activity总是会自己处理这个配置变化（这个变化不会引起Activity的重启，甚至在Android 3.2或更新的设备上）。在API级别13里加入的。 smallestScreenSize 物理屏幕大小的变化。不管方向的变化，仅仅在实际物理屏幕打包变化的时候，如：外接显示器。这个配置项的变化引起在smallestWidth configuration里的变化。然而，如果你的程序目标API级别是12或更低，你的Activity将自己处理这个变化（这个变化不会引起Activity的重启，甚至在Android 3.2或更新的设备上）在API级别13里加入的。 layoutDirection 布局方向变化。例如书写方式从左向右（LTR）转换为从右向左（RTL） 想了解更多就看官方文档。 二、横竖屏切换对Activity生命周期的影响通过打印Activity各个生命周期的执行情况，我们根据以下几种情况来分析： 1. 不配置 configChanges2. 配置 android:configChanges=&quot;orientation&quot;3. 配置android:configChanges=&quot;orientation|keyboardHidden&quot; 竖屏切横屏 1234567811-02 20:17:44.898 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-02 20:17:45.008 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-02 20:17:45.008 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-02 20:17:45.018 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-02 20:17:45.038 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-02 20:17:45.088 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 横屏切竖屏： 1234567811-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-02 20:19:00.268 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-02 20:19:00.318 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-02 20:19:00.338 13324-13324/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 从上面的 3种方式配置 打印的 Log （三种方式 Log是一样的，故合并显示），我们可以总结如下： 不设置Activity的android:configChanges时，或 设置Activity的android:configChanges=&quot;orientation&quot;时，或设置Activity的android:configChanges=&quot;orientation|keyboardHidden&quot;时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次方法。 而我们经常在其他地方看到的结论如下： 1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 4. 所以是什么原因导致我们的结论不一样呢？需要说明的是：** 我的测试环境是 targetSdkVersion 24，测试模拟器是 系统API 5.0！** 查看官方文档，发现有如下提示： 注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本系统的应用时，若要避免由于设备方向改变而导致运行时重启（正如 minSdkVersion 和 targetSdkVersion 属性中所声明），则除了”orientation”值以外，您还必须添加 “screenSize”值。即，您必须声明 android:configChanges=”orientation|screenSize”。但是，如果您的应用是面向 API 级别 12 或更低版本的系统，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重启 Activity）。 我们现在测试第四种配置方式。 5. 配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; 竖屏切横屏 111-02 20:44:06.568 7792-7792/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 横屏切竖屏 111-02 20:44:52.918 7792-7792/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 结论： 从 API 13开始，配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，才不会销毁 activity，且只调用 onConfigurationChanged方法。 6. 横竖屏切换小结 （一）、Android 3.2 （API 级别 13）以前1、不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。2、设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。3、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法。 注意： 不设置Activity的android:configChanges时，切换竖屏activity的各个生命周期执行两次，有人说是 在API 2.x下，我未测试，大家可以考证下。 （二）、从 Android 3.2 (API级别 13)开始1、不设置Activity的android:configChanges，或设置Activity的android:configChanges=&quot;orientation&quot;，或设置Activity的android:configChanges=&quot;orientation|keyboardHidden&quot;，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行一次。2、配置 android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，才不会销毁 activity，且只调用 onConfigurationChanged方法。 三、代码中动态切换横竖屏在代码中切换屏幕的方向主要调用 setRequestedOrientation（int requestedOrientation） 方法，此方法的作用等同于在 AndroidManifest.xml设置Activity 的android:screenOrientation，所以，其可传递的参数如 android:screenOrientation表格中一样。 示例代码： 1234567891011121314findViewById(R.id.btn_click).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Log.d(TAG,"被点击了"); //判断当前屏幕方向 if(getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &#123; //切换竖屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125;else&#123; //切换横屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125; &#125;&#125;); 非重启Activity模式：即设置了android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，Log输出（横竖屏切换一样） 1211-03 10:38:33.998 20317-20317/com.ys.yoosir.screenconfigchange D/MainActivity: 被点击了11-03 10:38:34.108 20317-20317/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 重启Activity模式：即没有设置android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;，Log输出（横竖屏切换一样） 12345678911-03 10:59:23.268 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: 被点击了11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-03 10:59:23.368 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-03 10:59:23.428 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-03 10:59:23.458 7724-7724/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 注意： 通过 setRequestedOrientation（int requestedOrientation） 修改了屏幕方向后，就类似于设置了android:screenOrientation，效果是一样的，比如：调用setRequestedOrientation（ActivityInfo.SCREEN_ORIENTATION_PORTRAIT），无论屏幕怎么旋转，都不会切换屏幕方向。如果要恢复为响应横竖屏随物理方向传感器设备变换，那么就需要手动调用类似setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);代码进行恢复。 四、横竖屏切换我们需要做的事 重启Activity模式在重启Activity模式下，横竖屏切换的时候会导致数据丢失，我们可以通过如下代码来保正数据不丢失： 1234567891011121314151617181920 @Overrideprotected void onSaveInstanceState(Bundle outState) &#123; Log.d(TAG," -- onSaveInstanceState"); Log.d(TAG," -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture"); outState.putString("name","yoosir"); outState.putInt("age",24); outState.putBoolean("handsome",true); super.onSaveInstanceState(outState);&#125;.... @Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); Log.d(TAG," -- onRestoreInstanceState"); if(savedInstanceState != null) &#123; String name = savedInstanceState.getString("name"); int age = savedInstanceState.getInt("age"); boolean isHandsome = savedInstanceState.getBoolean("handsome"); Log.d(TAG, " -- onRestoreInstanceState get: name = " + name + ",age = " + age + ",handsome = " + isHandsome); &#125;&#125; 横竖屏切换Log 输出： 123456789101111-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onPause11-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState11-03 12:03:31.678 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture11-03 12:03:31.688 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStop11-03 12:03:31.688 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onDestroy11-03 12:03:31.758 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate - orientation11-03 12:03:31.758 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onCreate get: name = yoosir,age = 24,handsome = true11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onStart11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onRestoreInstanceState get: name = yoosir,age = 24,handsome = true11-03 12:03:31.788 3663-3663/com.ys.yoosir.screenconfigchange D/MainActivity: -- onResume 如上，大家可以看到在 onCreate() 中也是可以拿到我们之前保存的数据的。 补充一点： 如果大家在资源目录res 中添加了 layout-land（横向布局文件夹） 和 layout-port （竖想布局文件夹），重启Activity模式的横竖屏切换，系统会自动帮我们显示正确方向的布局UI。 非重启Activity模式非重启Activity模式下横竖屏切换，我们的Activity 不会销毁重建，数据也不会丢失。但是，如果我们想根据不同的屏幕方向来展示不同UI或做不同的事，应该怎么做呢？直接上代码： 12345678910111213141516171819@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.d(TAG," -- onConfigurationChanged"); if(newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)&#123; //切换到竖屏 //修改布局文件 setContentView(R.layout.activity_main); //findViewById .... //TODO something Log.d(TAG," -- onConfigurationChanged 可以在竖屏方向 to do something"); &#125;else&#123; //切换到横屏 //修改布局文件 setContentView(R.layout.activity_main); //findViewById .... //TODO something Log.d(TAG," -- onConfigurationChanged 可以在横屏方向 to do something"); &#125;&#125; 横竖屏切换Log 输出： 1211-03 14:56:50.465 28612-28612/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged11-03 14:56:50.495 28612-28612/com.ys.yoosir.screenconfigchange D/MainActivity: -- onConfigurationChanged 可以在横屏方向 to do something 大家可以看到，在非重启Activity模式下，横竖屏切换修改UI布局文件时，其实挺麻烦的（我是这样的看法，^_~），需要重新初始化一遍UI。不过，不需要我们手动保存数据倒是挺方便的。 五、横竖屏切换对Fragment的影响打印 Activity 和 Fragment 各个生命周期，并在Activity 的 onCreate() 中添加如下代码： 12345678910//是否已经 add 了 Fragmentif(getSupportFragmentManager().findFragmentByTag("child") == null) &#123; Log.d(TAG, " -- onCreate has no child "); FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction(); blankFragment = BlankFragment.newInstance("one", "two"); fragmentTransaction.add(R.id.root_view, blankFragment, "child"); fragmentTransaction.commit();&#125;else&#123; Log.d(TAG, " -- onCreate has child ");&#125; 重建Activity模式Log： 带有 BlankFragment 即为 Fragment 的打印，其他则为 Activity 的打印进入Activity的Log： 我们可以关注下第 2 行log——-- onCreate has no child 1234567891011121311-03 17:56:19.465 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate - orientation11-03 17:56:19.525 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate has no child 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- newInstance 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onAttach 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreate 11-03 17:56:19.545 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreateView 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStart 11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStart11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onResume11-03 17:56:19.585 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onResume 11-03 17:57:02.285 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- one btn click 11-03 17:57:05.705 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- two btn click 横竖屏切换的Log： 1、我们关注一下 第17行 onCreate has child ，所以** Fragment 本身是没有被 destroy，它的views 是被destroy 的** 2、关注一下 第5、6、19 和 20 行，Fragment 的局部变量数据被销毁了，我们可以在onSaveInstanceState 保存数据，虽然 Fragment 不像 Activity 拥有 onRestoreInstanceState 方法，但是我们可以在 onActivityCreated 中获取之前保存的数据。 123456789101112131415161718192021222324252611-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onPause 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onPause11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onSaveInstanceState11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onSaveInstanceState save: name = yoosir,age = 24,handsome = ture11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onSaveInstanceState 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onSaveInstanceState save str11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStop 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStop11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDestroyView 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDestroy 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onDetach 11-03 17:57:40.095 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onDestroy11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onAttach 11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreate 11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate - orientation11-03 17:57:40.165 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate get: name = yoosir,age = 24,handsome = true11-03 17:57:40.175 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onCreate has child 11-03 17:57:40.175 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onCreateView 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onActivityCreated get 我设置了参数11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onStart 11-03 17:57:40.185 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onStart11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onRestoreInstanceState11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onRestoreInstanceState get: name = yoosir,age = 24,handsome = true11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onResume11-03 17:57:40.195 26990-26990/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onResume 非重建Activity模式：横竖屏切换Log(进入Activity的Log 与 重建Activity模式一样 )：横竖屏切换时，Fragment 和 Activity 都只会调用 onConfigurationChanged 方法。 12345611-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onConfigurationChanged 11-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged11-03 18:31:21.725 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged 可以在横屏方向 to do something11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: BlankFragment -- onConfigurationChanged 11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged11-03 18:31:36.545 27309-27309/com.ys.yoosir.screenconfigchange D/Main2Activity: -- onConfigurationChanged 可以在竖屏方向 to do something 六、其他小技巧如果我们应用是手机和平板都可用的，且手机的只能是竖屏不可切换，平板的只能是横屏不可切换。首先，我们要区分设备是手机还是平板，然后设置屏幕方向。代码如下： 123456789101112131415161718/** * 判断是否平板设备 * @param context * @return true:平板,false:手机 */private boolean isTabletDevice(Context context) &#123; return (context.getResources().getConfiguration().screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) &gt;= Configuration.SCREENLAYOUT_SIZE_LARGE;&#125;//设置屏幕方向private void setScreenOrientation(Context context)&#123; if(!isTabletDevice(context))&#123; //手机，竖屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125;else&#123; //平板，横屏 MainActivity.this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125;&#125; 参考学习的文章：The Real Best Practices to Save/Restore Activity’s and Fragment’s state 《===== 重点推荐阅读 [译] 保存/恢复 Activity 和 Fragment 状态的最佳实践 《=== 上面一篇文章的译文 如何在Android设备旋转时暂存数据以保护当前的交互状态？ Android横竖屏切换小结 附图两张： 小小总结通过一步一步代码验证，我们终于明白了横竖屏切换时发生了什么，又可以愉快的写代码了，啦啦啦…，I AM CODER！若有错误的地方，欢迎大家指正和评论，谢谢！:-)]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awesome-comment神级注释]]></title>
    <url>%2Fposts%2F86664ecf.html</url>
    <content type="text"><![CDATA[一时兴起就收集了以下神注释，希望能为广大ITer带来快乐，缓解你们工作中的压力，下面开车，先自爆头像，下文会给出制作链接。 魔性图 123456789101112131415161718192021222324252627282930313233343536/** * 瓦瓦 十 * 十齱龠己 亅瓦車己 * 乙龍龠毋日丶 丶乙己毋毋丶 * 十龠馬鬼車瓦 己十瓦毋毋 * 鬼馬龠馬龠十 己己毋車毋瓦 * 毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己 * 乙龠龍龍鬼龍瓦 十瓦毋乙瓦龠瓦亅 * 馬齱龍馬鬼十丶日己己己毋車乙丶 * 己齱馬鬼車十十毋日乙己己乙乙 * 車馬齱齱日乙毋瓦己乙瓦日亅 * 亅車齺龖瓦乙車龖龍乙乙十 * 日龠龠十亅車龍毋十十 * 日毋己亅 己己十亅亅 * 丶己十十乙 丶丶丶丶丶 * 亅己十龍龖瓦 丶 丶 乙十 * 亅己十龠龖毋 丶丶 丶己鬼鬼瓦亅 * 十日十十日亅丶亅丶 丶十日毋鬼馬馬車乙 * 十日乙十亅亅亅丶 十乙己毋鬼鬼鬼龍齺馬乙 * 丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十 * 乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶 * 亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅 * 十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車 * 亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車 * 亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼 * 丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼 * 亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼 * 亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦 * 丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日 * 十乙己日十 丶己鬼龍齱齺齱龍馬馬馬車毋己 * 丶十己乙亅丶 亅瓦馬龠龍龠龠馬毋瓦乙 * 丶十十乙亅十 亅己瓦車馬龠鬼車瓦乙 * 丶十乙十十丶 丶丶亅十瓦鬼車瓦己 * 丶亅亅丶 亅日瓦日 * 丶 */ 就不卖关子了，图片转字符可以上这个传送门，白底的话会按空格补全，否则都为字符。 前面的传送门貌似出了点问题，下面再补上个新的传送门，也是很好用的，可以选择质量。 这不，下面的两只doge和一头滑稽就是产自于它，have fun，快去制作专属的字符注释吧。 再补上一个好玩的网站Ascii World，由于这网站的图形太多了，我就不贴上来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738/** * .,:,,, .::,,,::. * .::::,,;;, .,;;:,,....:i: * :i,.::::,;i:. ....,,:::::::::,.... .;i:,. ......;i. * :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i. * ;;..,::::;;;;ri,,,. ..,,:;s1s1ssrr;,.;r, * :;. ,::;ii;:, . ................... .;iirri;;;,,;i, * ,i. .;ri:. ... ............................ .,,:;:,,,;i: * :s,.;r:... ....................................... .::;::s; * ,1r::. .............,,,.,,:,,........................,;iir; * ,s;........... ..::.,;:,,. ...............,;1s * :i,..,. .,:,,::,. .......... .......;1, * ir,....:rrssr;:, ,,.,::. .r5S9989398G95hr;. ....,.:s, * ;r,..,s9855513XHAG3i .,,,,,,,. ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r: * :r;..rGGh, :SAG;;G@BS:.,,,,,,,,,.r83: hHH1sXMBHHHM3..,,,,.ir. * ,si,.1GS, sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8 3@HXHBMBHBBH#X,.,,,,,,rr * ;1:,,SH: .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS, 3@MHABM&amp;59M#As..,,,,:,is, * .rr,,,;9&amp;1 hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s; r9&amp;BMHBHMB9: . .,,,,;ri. * :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr. ...,:rs. * ;s. .:sS8G8GG889hi. ....,,:;:,.:irssrriii:,. ...,,i1, * ;1, ..,....,,isssi;, .,,. ....,.i1, * ;h: i9HHBMBBHAX9: . ...,,,rs, * ,1i.. :A#MBBBBMHB##s ....,,,;si. * .r1,.. ,..;3BMBBBHBB#Bh. .. ....,,,,,i1; * :h;.. .,..;,1XBMMMMBXs,.,, .. :: ,. ....,,,,,,ss. * ih: .. .;;;, ;;:s58A3i,.. ,. ,.:,,. ...,,,,,:,s1, * .s1,.... .,;sh, ,iSAXs;. ,. ,,.i85 ...,,,,,,:i1; * .rh: ... rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr .....,,,,,,,ih; * .s5: ..... i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r: ........,,,,:,,sh; * . ihr, ... . .. ........,,,,,;11:. * ,s1i. ... ..,,,..,,,.,,.,,.,.. ........,,.,,.;s5i. * .:s1r,...................... ..............;shs, * . .:shr:. .... ..............,ishs. * .,issr;,... ...........................,is1s;. * .,is1si;:,....................,:;ir1sr;, * ..:isssssrrii;::::::;;iirsssssr;:.. * .,::iiirsssssssssrri;;:. */ /** * ii. ;9ABH, * SA391, .r9GG35&amp;G * &amp;#ii13Gh; i3X31i;:,rB1 * iMs,:,i5895, .5G91:,:;:s1:8A * 33::::,,;5G5, ,58Si,,:::,sHX;iH1 * Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG * .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8 * :SB9s:,............................,,,.,,,SASh53h,1G. * .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX, * ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi * i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1 * 59;.....,. .,,,,,,,,,,,... .............,..:1;.:&amp;s * s8,..;53S5S3s. .,,,,,,,.,.. i15S5h1:.........,,,..,,:99 * 93.:39s:rSGB@A; ..,,,,..... .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83 * G5.G8 9#@@@@@X. .,,,,,,..... iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh * Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX: * ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M; ....,,,,,,,,S8 * X3 iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs ...,,,,,,,:Gs * r8, ,,,...,,,,,,,,,,..... ,h8XABMMHX3r. .,,,,,,,.rX: * :9, . .:,..,:;;;::,.,,,,,.. .,,. ..,,,,,,.59 * .Si ,:.i8HBMMMMMB&amp;5,.... . .,,,,,.sMr * SS :: h@@@@@@@@@@#; . ... . ..,,,,iM5 * 91 . ;:.,1&amp;@@@@@@MXs. . .,,:,:&amp;S * hS .... .:;,,,i3MMS1;..,..... . . ... ..,:,.99 * ,8; ..... .,:,..,8Ms:;,,,... .,::.83 * s&amp;: .... .sS553B@@HX3s;,. .,;13h. .:::&amp;1 * SXr . ...;s3G99XA&amp;X88Shss11155hi. ,;:h&amp;, * iH8: . .. ,;iiii;,::,,,,,. .;irHA * ,8X5; . ....... ,;iihS8Gi * 1831, .,;irrrrrs&amp;@ * ;5A8r. .:;iiiiirrss1H * :X@H3s....... .,:;iii;iiiiirsrh * r#h:;,...,,.. .,,:;;;;;:::,... .:;;;;;;iiiirrss1 * ,M8 ..,....,.....,,::::::,,... . .,;;;iiiiiirss11h * 8B;.,,,,,,,.,..... . .. .:;;;;iirrsss111h * i@5,:::,,,,,,,,.... . . .:::;;;;;irrrss111111 * 9Bi,:,,,,...... ..r91;;;;;iirrsss1ss1111 *//** * .,, .,:;;iiiiiiiii;;:,,. .,, * rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS, * r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1, * .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii: * :rsriii;;r::::::::::::::::::::::;;,;;iiirsi, * .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,. * ,9BM&amp;, .,:;;:,,,,,,,,,,,hXA8: ..,,,. * ,;&amp;@@#r:;;;;;::::,,. ,r,,,,,,,,,,iA@@@s,,:::;;;::,,. .;. * :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,.. * .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri * iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir; * ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir. * iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir: * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir. * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir. * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir. * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri * ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir: * .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri * ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir, * irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir: * irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir: * ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr: * :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri, * .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr: * .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:. * .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;, * .:irrrriiiiii;;;;;;;;iiiiiirrrr;,. * .,:;iirrrrrrrrrrrrrrrrri;:. * ..,:::;;;;:::,,. */ /** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ *//** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ____/`---'\____ * . ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * * ............................................. * 佛祖保佑 永无BUG *//** * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ *//** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ___/`---'\____ * . ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * ............................................. * 佛曰：bug泛滥，我已瘫痪！ *//** * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ *//** * .::::. * .::::::::. * ::::::::::: FUCK YOU * ..:::::::::::' * '::::::::::::' * .:::::::::: * '::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::' .:::. * ::::' ':::::' .::::::::. * .::::' :::: .:::::::'::::. * .:::' ::::: .:::::::::' ':::::. * .::' :::::.:::::::::' ':::::. * .::' ::::::::::::::' ``::::. * ...::: ::::::::::::' ``::. * ```` ':. ':::::::::' ::::.. * '.:::::' ':'````.. *//** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! *//** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ &gt; &lt; │ * │ │ * │ ... ⌒ ... │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! *//** * ┌─┐ ┌─┐ + + * ┌──┘ ┴───────┘ ┴──┐++ * │ │ * │ ─── │++ + + + * ███████───███████ │+ * │ │+ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ + + * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ + + + + * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ + + + + * 神兽保佑 * 代码无BUG! *//** * ___====-_ _-====___ * _--^^^#####// \\#####^^^--_ * _-^##########// ( ) \\##########^-_ * -############// |\^^/| \\############- * _/############// (@::@) \\############\_ * /#############(( \\// ))#############\ * -###############\\ (oo) //###############- * -#################\\ / VV \ //#################- * -###################\\/ \//###################- * _#/|##########/\######( /\ )######/\##########|\#_ * |/ |#/\#/\#/\/ \#/\##\ | | /##/\#/ \/\#/\#/\#| \| * ` |/ V V ` V \#\| | | |/#/ V ' V V \| ' * ` ` ` ` / | | | | \ ' ' ' ' * ( | | | | ) * __\ | | | | /__ * (vvv(VVV)(VVV)vvv) * 神兽保佑 * 代码无BUG! *//** * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \_|// |||\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \/ ||| \\ _/~~- * __---~~~.==~||\=_ -_--~/_-~|- |\\ \\ _/~ * _-~~ .=~ | \\-_ '-~7 /- / || \ / * .~ .~ | \\ -_ / /- / || \ / * / ____ / | \\ ~-_/ /|- _/ .|| \ / * |~~ ~~|--~~~~--_ \ ~==-/ | \~--===~~ .\ * ' ~-| /| |-~\~~ __--~~ * |-~~-_/ | | ~\_ _-~ /\ * / \ \__ \/~ \__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-&gt;/~ '.|||' -_| ~~-/ , . _|| * -_ ~\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\ * 神兽保佑 * 代码无BUG! *//** _ * _._ _..._ .-', _.._(`)) * '-. ` ' /-._.-' ',/ * ) \ '. * / _ _ | \ * | a a / | * \ .-. ; * '-('' ).-' ,' ; * '-; | .' * \ \ / * | 7 .__ _.-\ \ * | | | ``/ /` / * /,_| | /,_/ / * /,_/ '`-' *//** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-" "-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; "=._ | )(__/ \__)( | _.=" &lt; | * * | (_/"=._"=._ |/ /\ \| _.="_.="\_) | * * | "=._"(_ ^^ _)"_.=" | * * | "=\__|IIIIII|__/=" | * * | _.="| \IIIIII/ |"=._ | * * | _ _.="_.="\ /"=._"=._ _ | * * | ( \_.="_.=" `--------` "=._"=._/ ) | * * | &gt; _.=" "=._ &lt; | * * | (_/ \_) | * * | | * * '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=' * * * * LASCIATE OGNI SPERANZA, VOI CH'ENTRATE * ************************************************************** *//** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * 又看源码，看你妹妹呀！ *//** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ *//** * ,%%%%%%%%, * ,%%/\%%%%/\%% * ,%%%\c "" J/%%% * %. %%%%/ o o \%%% * `%%. %%%% _ |%%% * `%% `%%%%(__Y__)%%' * // ;%%%%`\-/%%%' * (( / `%%%%%%%' * \\ .' | * \\ / \ | | * \\/ ) | | * \ /_ | |__ * (___________))))))) 攻城湿 * * _ _ * __ _(_)_ _(_) __ _ _ __ * \ \ / / \ \ / / |/ _` |'_ \ * \ V /| |\ V /| | (_| | | | | * \_/ |_| \_/ |_|\__,_|_| |_| *//** * https://gold.xitu.io/ * １１１ １ * １１１ １１１１１１１１１１１１ １１１ * １１ １１１１１１１１１１１１ １１１１１ * １１ １１１ １１ １１１１１１１ * １１１１ １ １１１１１１１１１１１ １１１ １１１１ * １１１１１１ １１１１１１１１１１１ １１１１ １１１１１ * １１１１１１ １１ １１１１ １１１１１１ * １１ １１１１１１１１ １１ １１１１１１１１１１１１１１１１１１ * １１ １１１１１１１１１１１ １１１１１１１１１１１１１１１１１１１ * １１１１１１１１１ １１ １１ １１ １１ * １１１１１１１１１１１１１１１１１１ １１ * １１１１ １１１１１１１１１１１１ １１１１１１１１１１１１１１ * １１１１ １１ １１ １１１１１１１１１１１１１１ * １１ １１ １１ １１ １１１ １１ １１ １１１ * １１ １１ １１ １１ １１ １１１ １１ １１１ * １１ １１１ １１ １１ １１ １１１ １１ １１１ * １１１１ １１１ １１１１１１１１１ １１ １１１ １１ １１１１１１１ * １１１１１１ １１１１１１１１１１ １１１１１１１１１１１１１１１１１ * １１ １１１ １１１ １１１１１１１１１１１１１１１１１ *//** * https://www.zhihu.com/ * _____ _____ _____ _____ * /\ \ /\ \ /\ \ /\ \ * /::\____\ /::\ \ /::\ \ /::\ \ * /:::/ / \:::\ \ /::::\ \ /::::\ \ * /:::/ / \:::\ \ /::::::\ \ /::::::\ \ * /:::/ / \:::\ \ /:::/\:::\ \ /:::/\:::\ \ * /:::/____/ \:::\ \ /:::/__\:::\ \ /:::/__\:::\ \ * /::::\ \ /::::\ \ /::::\ \:::\ \ /::::\ \:::\ \ * /::::::\ \ _____ ____ /::::::\ \ /::::::\ \:::\ \ /::::::\ \:::\ \ * /:::/\:::\ \ /\ \ /\ \ /:::/\:::\ \ /:::/\:::\ \:::\____\ /:::/\:::\ \:::\ \ * /:::/ \:::\ /::\____\/::\ \/:::/ \:::\____\/:::/ \:::\ \:::| |/:::/__\:::\ \:::\____\ * \::/ \:::\ /:::/ /\:::\ /:::/ \::/ /\::/ |::::\ /:::|____|\:::\ \:::\ \::/ / * \/____/ \:::\/:::/ / \:::\/:::/ / \/____/ \/____|:::::\/:::/ / \:::\ \:::\ \/____/ * \::::::/ / \::::::/ / |:::::::::/ / \:::\ \:::\ \ * \::::/ / \::::/____/ |::|\::::/ / \:::\ \:::\____\ * /:::/ / \:::\ \ |::| \::/____/ \:::\ \::/ / * /:::/ / \:::\ \ |::| ~| \:::\ \/____/ * /:::/ / \:::\ \ |::| | \:::\ \ * /:::/ / \:::\____\ \::| | \:::\____\ * \::/ / \::/ / \:| | \::/ / * \/____/ \/____/ \|___| \/____/ *//** * http://www.freebuf.com/ * _.._ ,------------. * ,' `. ( We want you! ) * / __) __` \ `-,----------' * ( (`-`(-') ) _.-' * /) \ = / ( * /' |--' . \ * ( ,---| `-.)__` * )( `-.,--' _`-. * '/,' ( Uu", * (_ , `/,-' ) * `.__, : `-'/ /`--' * | `--' | * ` `-._ / * \ ( * /\ . \. freebuf * / |` \ ,-\ * / \| .) / \ * ( ,'|\ ,' : * | \,`.`--"/ &#125; * `,' \ |,' / * / "-._ `-/ | * "-. "-.,'| ; * / _/["---'""] * : / |"- ' * ' | / * ` | *//** * https://campus.alibaba.com/ * `:::::::::::, * `::;:::::::;:::::::, ` * `::;;:::::::@@@@;:::::::` * ,:::::::::::::@ #@':::::` * :::::::::::::::'@@ @;:::: * ::::::::::::'@@@@'``` .+:::` * ::::::::::;@@@#. ,:::, * .::::::::+@#@` :::: * :::::::+@@' :::: * `:::::'@@: `:::. * ,::::@@: ` :::: * ;::::::@ .:::; * :;:::::;@` ` :::; * :::::::::@` @ ;:::: * :::::::::#` @` ,:::: * :::::::::@` +@ @ .::::` * .::::::'@@` `@@' @ ::::, * :::::::++@@@@@@@@@@. ::::; * ;:::::::+, `..` ::::: * ,::::::::', ::::: * :::::::::+, :::::` * :::::::::+@. ,::::.` `, * ::::::;;@+ .::;:: `; * :::::::@@ `:::;: `::`` * ::::::#@ ;:::: .::` * :::::;@ :::::` .;::` * :::::@ `:;::: `::::; * :::::# :::::. `,;::::: * :::::: ` ::::::,.,::::::::::. * ,::::::` .:: ::::::::::::::::;` * ;::::::::,````.,:::::, ::::::::::::::. * :::::::::::::::::: ` `::::::::::` * `::::::::::::, .:::. * `..` *//** * http://www.flvcd.com/ * .--, .--, * ( ( \.---./ ) ) * '.__/o o\__.' * &#123;= ^ =&#125; * &gt; - &lt; * / \ * // \\ * //| . |\\ * "'\ /'"_.-~^`'-. * \ _ /--' ` * ___)( )(___ * (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。 *//** * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂 * 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂 * 頂頂頂頂 頂頂頂頂 頂頂頂頂 *//** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 *//** * /88888888888888888888888888\ * |88888888888888888888888888/ * |~~____~~~~~~~~~"""""""""| * / \_________/"""""""""""""\ * / | \ \ * / | 88 88 \ \ * / | 88 88 \ \ * / / \ | * / | ________ \ | * \ | \______/ / | * /"\ \ \____________ / | * | |__________\_ | | / / * /""""\ \_------' '-------/ -- * \____/,___________\ -------/ * ------* | \ * || | \ * || | ^ \ * || | | \ \ * || | | \ \ * || | | \ \ * \| / /"""\/ / * ------------- | | / * |\--_ \____/___/ * | |\-_ | * | | \_ | * | | \ | * | | \_ | * | | ----___ | * | | \----------| * / | | ----------""\ * /"\--"--_| | | \ * |_______/ \______________/ ) * \___/ *//** * d*##$. * zP"""""$e. $" $o * 4$ '$ $" $ * '$ '$ J$ $F * 'b $k $&gt; $ * $k $r J$ d$ * '$ $ $" $~ * '$ "$ '$E $ * $ $L $" $F ... * $. 4B $ $$$*"""*b * '$ $. $$ $$ $F * "$ R$ $F $" $ * $k ?$ u* dF .$ * ^$. $$" z$ u$$$$e * #$b $E.dW@e$" ?$ * #$ .o$$# d$$$$c ?F * $ .d$$#" . zo$&gt; #$r .uF * $L .u$*" $&amp;$$$k .$$d$$F * $$" ""^"$$$P"$P9$ * JP .o$$$$u:$P $$ * $ ..ue$" "" $" * d$ $F $ * $$ ....udE 4B * #$ """"` $r @$ * ^$L '$ $F * RN 4N $ * *$b d$ * $$k $F * $$b $F * $"" $F * '$ $ * $L $ * '$ $ * $ $ *//** * ,----------------, ,---------, * ,-----------------------, ," ,"| * ," ,"| ," ," | * +-----------------------+ | ," ," | * | .-----------------. | | +---------+ | * | | | | | | -==----'| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\&gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ," * | `-----------------' |," .;'| |(((( | ," * +-----------------------+ ;; | | |," * /_)______________(_/ //' | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \,"----------- * / ==ooooooooooooooo==.o. ooo= // ,`\--&#123;)B ," * /_==__==========__==_ooo__ooo=_/' /___________," * *//** * .-~~~~~~~~~-._ _.-~~~~~~~~~-. * __.' ~. .~ `.__ * .'// \./ \\`. * .'// | \\`. * .'// .-~"""""""~~~~-._ | _,-~~~~"""""""~-. \\`. * .'//.-" `-. | .-' "-.\\`. * .'//______.============-.. \ | / ..-============.______\\`. * .'______________________________\|/______________________________`. * *//** 无可奉告 一颗赛艇 * uJjYJYYLLv7r7vJJ5kqSFFFUUjJ7rrr7LLYLJLJ7 * JuJujuYLrvuEM@@@B@@@B@B@B@@@MG5Y7vLjYjJL * JYjYJvr7XM@BB8GOOE8ZEEO8GqM8OBBBMu77LLJ7 * LJLY7ru@@@BOZ8O8NXFFuSkSu25X0OFZ8MZJ;vLv * YvL7i5@BM8OGGqk22uvriiriii;r7LuSZXEMXrvr * vv7iU@BMNkF1uY7v7rr;iiii:i:i:ii7JEPNBPir * L7iL@BM8Xjuujvv77rr;ri;i;:iiiii:iLXFOBJ: * 7ri@B@MOFuUS2Y7L7777rii;:::::i:iirjPG@O: * 7:1B@BBOPjXXSJvrL7rr7iiii:i::::i;iv5MBB, * r:0@BBM8SFPX2Y77rri::iirri:::::iii75O@G. * 7:SB@BBGqXPk0122UJL::i::r:::i:i;i:v2@Bk. * ri:MB@BBEqEMGq2JLLL1u7.iX51u77LF27iSB@r, * ri,v@B@MB8@qqNEqN1u:5B8BOFE0S7ii7qMB@F:: * ii,J80Eq1MZkqPPX5YkPE@B@iXPE52j7:vBjE7:: * ii:7MSqkS0PvLv7rrii0@L.Z1iLr::ir:rO,vi:: * ii::EZXPSkquLvii:iF@N:.,BUi7ri,::UY;r::: * i::.2ONXqkPXS5FUUEOPP;..iSPXkjLYLLrr:::, * :::,iMXNP0NPLriiLGZ@BB1P87;JuL7r:7ri:::, * :::,.UGqNX0EZF2uUjUuULr:::,:7uuvv77::::. * ::::..5OXqXNJ50NSY;i:.,,,:i77Yvr;v;,,::. * :::,:.jOEPqPJiqBMMMO8NqP0SYLJriirv:.:,:. * ,:,,,.,Zq0P0X7vPFqF1ujLv7r:irrr7j7.,,::. * ,,,....0qk0080v75ujLLv7ri:i:rvj2J...,,,. * ......8@UXqZEMNvJjr;ii::,:::7uuv...,.,,. * .....B@BOvX88GMGk52vririiirJS1i.......,. * .JEMB@B@BMvL0MOMMMO8PE8GPqSk2L:......... * @B@@@B@M@B@L:7PGBOO8MOMOEP0Xri@B@Mk7,... * B@B@BBMBB@B@0::rJP8MO0uvvu7..,B@B@B@B@Z7 * MMBM@BBB@B@B@Br:i,..:Lur:....7@OMMBM@B@@ * 8OOMMMOMMMMBB@B:....,PZENNi..JBOZ8GMOOOO */ 神注释 1234/** * 这个公司没有年终奖的,兄弟别指望了,也别来了,我准备辞职了 * 另外这个项目有很多*Bug* 你坚持不了多久的,拜拜! */ 123456789101112131415161718192021222324252627282930313233/** * 1只羊 == one sheep * 2只羊 == two sheeps * 3只羊 == three sheeps * 4只羊 == four sheeps * 5只羊 == five sheeps * 6只羊 == six sheeps * 7只羊 == seven sheeps * 8只羊 == eight sheeps * 9只羊 == nine sheeps * 10只羊 == ten sheeps * 11只羊 == eleven sheeps * 12只羊 == twelve sheeps * 13只羊 == thirteen sheeps * 14只羊 == fourteen sheeps * 15只羊 == fifteen sheeps * 16只羊 == sixteen sheeps * 17只羊 == seventeen sheeps * 18只羊 == eighteen sheeps * 19只羊 == nineteen sheeps * 20只羊 == twenty sheeps * 21只羊 == twenty one sheeps * 22只羊 == twenty two sheeps * 23只羊 == twenty three sheeps * 24只羊 == twenty four sheeps * 25只羊 == twenty five sheeps * 26只羊 == twenty six sheeps * 27只羊 == twenty seven sheeps * 28只羊 == twenty eight sheeps * 29只羊 == twenty nine sheeps * 30只羊 == thirty sheeps * 现在瞌睡了吧，好了，不要再改下面的代码了，睡觉咯~~ */ 12345678910111213/** * You may think you know what the following code does. * But you dont. Trust me. * Fiddle with it, and youll spend many a sleepless * night cursing the moment you thought youd be clever * enough to "optimize" the code below. * Now close this file and go play with something else. *//** * 你可能会认为你读得懂以下的代码。但是你不会懂的，相信我吧。 * 要是你尝试玩弄这段代码的话，你将会在无尽的通宵中不断地咒骂自己为什么会认为自己聪明到可以优化这段代码。 * 现在请关闭这个文件去玩点别的吧。 */ 12345678/** * somedev1 - 6/7/02 Adding temporary tracking of Login screen * somedev2 - 5/22/07 Temporary my ass *//** * 一些修改1 - 2002/6/7 增加临时的跟踪登录界面 * 一些修改2 - 2007/5/22 我临时的犯傻 */ 1234567/** * 程序员1（于2010年6月7日）：在这个坑临时加入一些调料 * 程序员2（于2011年5月22日）：临你个屁啊 * 程序员3（于2012年7月23日）：楼上都是狗屎，鉴定完毕 * 程序员4（于2013年8月2日）：fuck 楼上，三年了，这坑还在！！！ * 程序员5（于2014年8月21日）：哈哈哈，这坑居然坑了这么多人，幸好我也不用填了，系统终止运行了，you're died */ 1234567891011121314/** * For the brave souls who get this far: You are the chosen ones, * the valiant knights of programming who toil away, without rest, * fixing our most awful code. To you, true saviors, kings of men, * I say this: never gonna give you up, never gonna let you down, * never gonna run around and desert you. Never gonna make you cry, * never gonna say goodbye. Never gonna tell a lie and hurt you. *//** * 致终于来到这里的勇敢的人： * 你是被上帝选中的人，是英勇的、不敌辛苦的、不眠不休的来修改我们这最棘手的代码的编程骑士。 * 你，我们的救世主，人中之龙，我要对你说：永远不要放弃，永远不要对自己失望，永远不要逃走，辜负了自己， * 永远不要哭啼，永远不要说再见，永远不要说谎来伤害自己。 */ 123456789101112131415161718/** * Dear maintainer: * * Once you are done trying to 'optimize' this routine, * and have realized what a terrible mistake that was, * please increment the following counter as a warning * to the next guy: * * total_hours_wasted_here = 42 *//** * 亲爱的维护者： * * 如果你尝试了对这段程序进行'优化' * 下面这个计数器的个数用来对后来人进行警告 * * 浪费在这里的总时间 = 42h */ 12Exception up = new Exception("Something is really wrong.");throw up; //ha ha 12345678/** * When I wrote this, only God and I understood what I was doing * Now, God only knows *//*** 写这段代码的时候，只有上帝和我知道它是干嘛的* 现在，只有上帝知道*/ 1stop(); // Hammertime! 1// Autogenerated, do not edit. All changes will be undone. 12// sometimes I believe compiler ignores all my comments// 有时候我相信编译器忽略了我所有的注释 12345/** * I dedicate all this code, all my work, to my wife, Darlene, who will * have to support me and our three children and the dog once it gets * released into the public. */ 12// drunk, fix later// 有点晕了，以后再修改 12// Magic. Do not touch.// 麻鸡。勿动。 1#define TRUE FALSE// Happy debugging suckers 1// I'm sorry. 1return 1; # returns 1 123456/** * Always returns true. */public boolean isAvailable() &#123; return false;&#125; 12&lt;!-- Here be dragons --&gt;&lt;!-- 前方高能 --&gt; 12double penetration; // ouch// 自行了解，不方便解释 123456// To understand recursion, see the bottom of this fileAt the bottom of the file:// To understand recursion, see the top of this file// 想要明白递归须看文件末尾到了文末// 想要明白递归须看文件顶部 1/* Please work */ 12long long ago; /* in a galaxy far far away */// 很久很久以前 在一个遥远的银河中（出自星球大战） 1234// This code sucks, you know it and I know it. // Move on and call me an idiot later.// 你我都知道这代码很烂// 先不要骂我2B了，请先继续往下看 12// I am not sure why this works but it fixes the problem.// 虽然我不知道为什么这样管用，但它却是修复了问题 12// If this comment is removed the program will blow up// 如果删了此处注释程序就炸了 12// This function has been here since 1987. DON'T FXXKING TOUCH IT// 这函数1987年就这在了，别他娘动它 12// if i ever see this again i'm going to start bringing guns to work// 如果要是再让我看见这样的代码，也许我会带着一把枪来上班 1234// no comments for you// it was hard to write// so it should be hard to read// 难写的代码，肯定很难读。因此，我没有注释留给你。 12// I will give you two of my seventy-two virgins if you can fix this.// 要是你能修正这个问题的话，我会在我的七十二个处女中挑两个送你 123// I am not responsible of this code.// They made me write it, against my will.// 下面的代码，我不负责。因为是他们逼我写的，违背了我的意愿。 12/* You are not expected to understand this *//* 你绝不会明白的 */ 12// I have to find a better job// 看来我需要找份更好的工作了 123/** * 这个类是Object的子类 */]]></content>
      <categories>
        <category>Android</category>
        <category>注释模板</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>注释模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码重构，如何巧妙设计？]]></title>
    <url>%2Fposts%2Fda9c2260.html</url>
    <content type="text"><![CDATA[重构不止是代码整理，它提供了一种高效且受控的代码整理技术 （一）重构原则1、何谓重构对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 另一种解释是：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。 2、为何重构改进软件设计：如果没有重构，程序的设计会逐渐变质，重构很像是在整理代码，你所做的就是让所有的东西回到应处的位置上。帮助找到bug：对代码进行重构，可以深入理解代码的作为，在搞清楚程序结构的同时，想不把bug揪出来都难。提高编程速度：良好的设计是快速开发的根本，改善设计、提高可读性，减少错误，这些都是提高质量。 3、何时重构任何情况下我都反对专门拨出时间进行重构。重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地的进行。 三次法则 第一次做某件事情是只管去做；第二次做类似的事情会产生反感；第三次再做类似的事，你就应该重构 最常见的重构时机是想给软件添加新特性的时候； 重构的另个一原动力是：代码的设计无法帮助我轻松的添加所需要的特性 修改错误的时候，review代码的时重构 间接层和重构 计算机科学是这样一门科学：它相信所有的问题都可以通过增加一个间接层来解决。 大多数重构都为程序引入了更多的间接层，重构往往把大型的对象拆成多个小型的对象，把大型的函数拆成多个小型的函数。但是，间接层是一把双刃剑。每次把一个东西分成两份，你就需要多管理一个东西。如果某个对象委托另一个对象，后者又委托另一个对象，程序会愈加难以阅读。 何时不该重构：有时候既有代码实在太混乱，重构它还不如重新写一个来得简单。 重写而非重构的一个清楚讯号是：现有代码根本不能正常运作。 （二）代码的坏味道1、重复代码如果你在一个以上的地点看到相同的程序结构，那么可以肯定：设法将它们合二为一，程序会变得更好 。 同一个类中有相同的表达式：提炼出重复的代码，然后让两个地方都调用被提炼出来的那一段代码； 两个互为兄弟的子类内含有相同的表达式：提炼出相同代码，将它推入超类内； 两个毫不相干的类中出现：将重复的代码提炼到一个独立的类中。 2、过长的类拥有短函数的对象活得比较好、比较长。 间接层所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型函数支持的。 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中。 如何确定提炼哪一段代码？寻找注释是一个很好的技巧。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是提醒你：可以将这段代码替换成一个函数。 条件表达式和循环常常也是提炼的信号。 3、过大的类如果想利用单个类做太多的事情，其内往往就会出现太多实力变量。类内如果有太多代码，也是代码重复、混乱病最终走向死亡的源头。 4、过长参数列太长的参数列难以理解，太多的参数会造成前后不一致、不容易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给函数，大多数修改都将没有必要。 5、发散式变化如果某个类经常因为不同的原因在不同的方向上发生变化，那么此时也许将这个对象分成两个会更好，这么一来每个对象就可以只因为一种变化而需要修改。 6、散弹式修改如果没遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是散弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。 把所有需要修改的代码放进同一个类中，如果眼下没有合适的类可以安置这些代码就创造一个。 7、依恋情结对象技术的要点在于：将数据和对数据的操作行为包装在一起.有一种经典的气味是：函数对某个类的兴趣高过对自己所处类的兴趣。某个函数为了计算某个值，从另一个对象那调用几乎半打的取值函数。 一个函数往往会用到几个类的功能，那么它该置于何处？我们的原则是：判断哪个类拥有最大被此函数使用的数据，然后就把这个函数和那些数据放在一起。 8、数据泥团很多地方看到相同的三四项数据一起出现。这些总是绑在一起出现的数据应该拥有属于他们自己的对象。 首先找到这些数据以字段形式出现的地方，将它们提炼到一个独立的对象中。这么做的直接好处是可以将很多参数列缩短简化函数调用。 9、基本类型偏执对象的一个极大价值在于：它们模糊了横旦与基本数据和体积较大的类之间的界限 对象技术的新手通常不愿意在小任务上运用小对象——结合数值和比重的money类、有一个起始值和一个结束值组成的range类。将原本单独存在的数值替换成对象，从而走出传统的洞窟，进入炙手可热的对象世界。 10、switch惊悚现身面向对象的一个最明显的特征是：少用switch语句一看到switch语句，就应该考虑以多态来替换它。 如果只是在单一函数中有些选择实例，且并不想改动它们，那么多态就有点杀鸡用牛刀了。 11、平行集成体系每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。 12、冗余类某个类原本对得起自己的身价，但重构使它身形缩水，不再做那么多工作，这个时候请让这个类庄严赴义吧。 13、夸夸其谈未来性企图以各种各样的钩子和特殊情况来处理一些非必要的事情，这种怀味道就出现了。如果用到了那就值得去做，如果用不到那就不值得，只会挡你的路，所以把它挪开吧。 如果你的某个抽象类其实没有起到太大的作用，函数上的某些参数未被使用…可以移除它们了。 14、令人迷惑的暂时字段某个实例变量仅为某种特定的情况而设。这样的代码让人不易理解。在变量未被使用的情况下猜测当初其设置目的，会让你发疯的。 15、过度耦合消息链如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另个一对象……..这就是消息链。采用这种方式，意味着客户代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应的修改。 16、中间人封装往往伴随着委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。 17、狎昵关系有时会看到两个类过于亲密，话费太多的时间去探究彼此的private成分。过分狎昵的类必须拆散，帮它们划清界线，从而减少狎昵行径。继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让孩子独立生活了，让他离开继承。 18、异曲同工的类两个函数做同一件事，却有着不同的签名。 19、不完美的类库类库函数构造的不够好，又不能修改它们： 如果只想修改类的一两个函数，可以引入外加函数。如果想要添加一大堆额外行为，建立一个新类包含这些额外行为，让其成为子类。 20、纯稚的数据类纯稚的数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。 封装public字段; 恰当封装容器类字段; 移除不应修改的字段的设置函数; 提炼调用函数以隐藏取值/设值函数; 21、被拒绝的遗赠子类只运用了父类的一部分函数和数据。 为子类建立一个兄弟类,将所有用不到的字段/函数下移至兄弟类,保证超类的纯粹; 22、过多的注释注释之所以存在是因为代码很糟糕 。注释的最高境界——代码即注释。 当你感觉需要撰写注释时，请先尝试重构，试着让所有的注释都变得多余。 （三）重新组织函数1、提炼函数动机：看到一个过长的函数或者一段需要注释才能让人理解用途的代码，将这段代码放一个独立的函数中；做法： 创造一个新函数，根据这个函数的意图来命名它； 只要新函数的名称能够以更好的方式昭示代码意图，你也应该提炼它。但如果想不到一个更有意义的名称就别动 将提炼的代码从原函数复制到新建的目标函数中；将被提炼代码段中需要读取的局部变量，当作参数传递给目标函数；在源函数中，将被提炼代码段替换为目标函数调用。 2、内联函数一个函数的本体与名称同样清楚易懂。在函数调用点插入函数本体，然后移除该函数。动机： 一群组织不甚合理的函数。你可以将它们都内联到一个大函数中，再从中提炼出组织合理的小型函数。使用的太多的间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在委托动作之间晕头转向。 做法： 1、检查函数，确定不具备多态；如果子类继承了这个函数，就不要将此函数内联，因为子类无法复写一个根本不存在的函数。 2、找出这个函数的所有调用点；3、将这个函数的所有调用点都替换成函数本体。3、内联临时变量有一个临时变量，只被一个简单的表达是赋值一次，而它妨碍了其他重构手法。将所有对该变量的引用动作，替换为对它赋值的那个表达式自身double basePrice = anOrder.basePrice();return (base &gt; 10000 ); 替换为： return (anOrder.basePrice &gt; 1000); 4、以查询取代临时变量你的程序以一个临时变量保存某一表达式的运算结果。将这个表达式提炼到一个独立的函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。 123456double basePrice = quantity * timePrice;if(basePrice &gt; 1000)&#123; return basePrice * 09.5;&#125; else &#123; return basePrice * 0.98;&#125; 替换为： 12345678if(basePrice() &gt; 1000)&#123; return basePrice * 09.5;&#125; else &#123; return basePrice * 0.98;&#125;double basePrice()&#123; return quantity * timePrice;&#125; 临时变量只在所属的函数中可见，如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个份信息，这将带给你极大的帮助，使你能够为这个类编写更清晰的代码。 5、引入注释性变量你有一个复杂的表达式。将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。 123if ((platform.toUpperCase().indexOf("MAC") &gt; -1) &amp;&amp; (browser.toUpperCase().indexOf("IE") &gt; -1) &amp;&amp; wasInitialized() &amp;&amp; resize &gt;0)&#123; //do smothing&#125; 替换为： 123456final boolean isMacOs = platform.toUpperCase().indexOf("MAC") &gt; -1;final boolean isIEBrowser = browser.toUpperCase().indexOf("IE") &gt; -1;final boolean wasResized = resize &gt;0;if(isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123; //do smothing&#125; 表达式有可能非常复杂难以理解。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。 在条件逻辑中，你可以用这项重构将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义。另一种情况是：在较长的算法中，可以运用临时变量来解释每一步运算的意义。 6、分解临时变量你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。 针对每次赋值，创造一个独立、对应的临时变量。 1234double temp = 2 * (height + width);System.out.println(temp);temp = height * width;System.out.println(temp); 替换为： 1234double perimeter = 2 * (height + width);System.out.println(perimeter);double area = height * width;System.out.println(area); 如果临时变量被赋值超过一次，就意味着它们在函数中承担了一个以上的责任。如果临时变量承担多个责任，它就应该被替换为多个临时变量。每个变量只承担一个责任，同一个临时变量承担两件不同的事情会令代码阅读者糊涂 7、移除对参数的赋值代码对一个参数进行复制。以一个临时变量取代该参数的位置。 123int discount (int inputVal, int quantity, int yearToData)&#123; if(inputVal &gt; 50) inputVal -= 2;&#125; 替换为： 1234int discount (int inputVal, int quantity, int yearToData)&#123; int result = inputVal; if(inputVal &gt; 50) result -= 2;&#125; 如果代码的语义是按引用传递的，请在调用段检查调用后是否还使用了这个参数。 8、替换算法想要把某个算法替换为另一个更清晰的算法。将函数本体替换成为另一个算法。 1234567891011121314String foundPerson(String[] people)&#123; for(int i = 0;i &lt; people.length; i++)&#123; if(people[i].equals("Don"))&#123; return "Don"; &#125; if(people[i].equals("John"))&#123; return "John"; &#125; if(people[i].equals("Kent"))&#123; return "Kent"; &#125; &#125; return "";&#125; 替换为： 123456789String foundPerson(String[] people)&#123; List candidates = Arrays.asList(new String[]&#123;"Don", "John", "Kent"&#125;); for(int i = 0;i &lt; people.length; i++)&#123; if(candidates.contains(people[i]))&#123; return prople[i]; &#125; &#125; return "";&#125; （四）在对象之间搬移特性在对象设计过程中，决定把责任放在哪儿是即使不是最重要的事，也是最重要的事之一。 常常只使用搬移函数和搬移字段简单地移动对象行为，就可以解决这些问题。如果这两个重构手法都需要用到，我会首先使用搬移字段，再使用搬移方法。 如果一个类承担了太多责任而变得臃肿不堪，这种情况下会使用提炼类将一部分责任分离出去。如果一个类变得太不负责任，使用将类内联化将它融入到另一个类中。 1、搬移函数你的程序中，有个函数与其所驻类之外的另个一类进行跟过的交流：调用后者或被后者调用。在该函数最长引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或者将旧函数完全移除。如果一个类有太多行为，或如果一个类与另一个类有太多合作而高度耦合，就需要搬移函数。可以是系统中的类更简单 2、搬移字段程序中，某个字段被其所驻类之外的另一个类更多的用到。在目标类新建一个字段，修改原字段的所有用户，令他们改用新字段 3、提炼类某个类做了应该由两个类做的事。建立一个新类，将相关字段和函数从就类搬到新类。 4、将类内联化某个类没有做太多的事情，不在承担足够责任，不再有的那单独存在的理由。将这个类的所有特性搬移到另一个类中，然后移除原类。 5、隐藏“委托关系”客户通过一个委托类来调用另一个对象。在服务类上建立客户所需要的所有函数，用来隐藏委托关系。 封装意味每个对象都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的对象就会比较少。 如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数。那么客户就必须知晓这一层委托关系。万一委托关系变化，客户也要相应变化。 6、移除中间人某个类做了过多的简单委托。让客户直接调用委托类。每当客户要使用手委托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受委托类的特性越来越多，这一过程会让你很痛苦。 7、引入外加函数你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。 1Date newStart = new Date(year, month, date + 1); 替换为： 1234Date newStart = nextDay(nowDate);private static Date nextDay(Date arg)&#123; retrun new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);&#125; 如果可以修改源码，你可以自行添加一个新函数；如果不能，你就得在客户端编码，补足你要的那个函数 8、引入本地扩展你需要为服务类踢狗一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。 ##（五）重新组织数据 1、自封装字段直接访问一个字段。为这个字段建立取值/设值函数，并且只以这些函数来访问字段。 1234private int low, high;boolean includes(int arg)&#123; retrun arg &gt;= low &amp;&amp; arg &lt;= high;&#125; 替换为： 12345678910private int low, high;boolean includes(int arg)&#123; retrun arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();&#125;int getLow()&#123; retrun low;&#125;int getHigh()&#123; return high;&#125; 在“字段访问方式”这个问题上，存在两种截然不同的观点： 在该变量定义所在的类中，你可以自由的访问。 即使在这个类中你也应该只使用访问函数间接访问。*间接访问的好处是：子类可以通过复写一个函数而改变获取数据的途径；它支持更灵活的数据管理方式，例如延迟初始化。 2、以对象取代数据值你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变为对象。 一开始你肯能会用一个字符串来表示“电话号码”概念，但是随后你会发现，电话号码需要“格式化”、“区号”之类的行为。这时候就需要为带替换的数值新建一个类。 3、将值对象改为引用对象你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变成引用对象。 4、将引用对象改为值对象你有一个引用对象，很小且不可改变，而且不易管理。将它变成一个值对象。 5、以对象取代数组你有一个数组，其中的元素各自代表不同的东西。以对象替换数组。对于数组中的每个元素，以一个字段来表示 6、复制“被监视数据”你有一些领域数据置身GUI控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。 7、将单向关联改为双向关联两个类都需要使用对方特性，但其间只有一条单向连接。添加一个反向指针，并使修改函数能够同时更新两条连接。 8、将双向关联改为单向关联两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。 9、以字面常量取代魔数你有一个字面数值，带有特别含义。 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为常量。 10、封装字段你的类中存在一个public字段。将它声明为private，并提供相应的访问函数。 11、封装集合有个函数返回一个集合。让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。 ##（六）简化条件表达式 1、分解条件表达式有一复杂的条件语句。从if、then、else三个段落中分别提炼出独立函数。 2、合并表达式你有一系列条件测试，都得到相同结果。将这些测试合并为一个条件表达式，并将这个条件表达式提炼成一个独立函数。 3、合并重复的条件代码在表达式的每个分支上都执行了相同的一段代码。 将这段重复代码搬移到条件表达式之外。 4、移除控制标记在一系列布尔表达式中,某个变量带有”控制标记”的作用。 以break/return语句取代控制标记。 5、以多态取代条件表达式有个条件表达式根据对象类型的不同而选择不同的行为。 将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数 （七）简化函数调用1、函数改名函数的名称未能揭示其用途。 修改函数名称。 2、添加参数某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带仅函数所需信息。 3、移除参数函数本体不再需要某个参数。 去除参数。 4、分离查询函数和修改函数某个函数既返回对象状态值，又修改对象值。 建立两个不同函数,其中一个负责查询,另一个负责修改。 5、令函数携带参数若干函数做了类似的工作，但在函数本体中包含了不同的值。建立单一函数,以参数表达那些不同的值。有这样两个函数：它们做着类似的工作，但因少数几个值致使行为略有不同。在这种情况下，你可以将这些各自分离的函数同一起来，并通过参数来处理那些变化情况，用以简化问题。 6、以明确函数取代参数你有一个函数，其中完全取决于参数值而采用不同行为。 针对该参数的每一个可能值，建立一个独立函数。如果某个参数有多种可能的值，而函数内又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为，那么就应该使用本项重构。 7、保持对象完整从某个对象中取出若干值，将它们作为某一次函数调用时的参数。改为传递整个对象。 8、以函数取代参数对象调用某个函数，并将所得结果作为参数，传递给另一函数，而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该参数，直接调用前一个函数。 9、引入参数对象某些参数总是很自然的同时出现。以一个对象取代这些参数。 10、移除设值函数类中某个字段在对象创建时被设值，然后不再改变。去掉该字段的所有设值函数。 11、隐藏函数某个函数，从来没有被其他任何类用到 。将函数修改为private。 12 、以工厂函数取代构造函数希望在创建对象时不仅仅是做简单的建构动作 。 将构造函数替换为工厂函数。 ##（八）处理概括关系 1、字段上移两个子类拥有相同的字段。将该字段移至超类。 2 、函数上移有些函数在各子类中产生完全相同的结果。将该函数移至超类。 3 、构造函数本体上移各个子类中有一些构造函数本体几乎完全一致 。在超类中新建一个构造函数，并在子类构造函数中调用它。 4、函数下移超类中的某个函数只与部分(而非全部)子类用到。 将函数移到相关的子类中。 5、字段下移超类中的某个字段只被部分(而非全部)子类用到。 将字段移到需要它的子类中。 6、提炼子类类中的某些特性只被某些(而非全部)实例用到。 新建一个子类，将上述部分的特性移到子类中。 7、提炼超类两个类有相似特性。 为这两个类建立一个超类,将相同特性移至超类。 8、提炼接口若干客户使用类接口中的同一子集，或两个类的接口有部分相同。将相同的子集提炼到一个独立接口中。 9、折叠继承体系超类和子类之间无太大区别。 将它们合为一体。 10、塑造模板函数子类中某些函数以相同顺序执行类似操作，但各操作细节略有不同。将操作放进独立函数(保持签名相同)，然后将它们移至超类。 11、以委托取代继承某个子类只使用超类接口中的一部分或根本不需要继承而来的数据。子类新建字段保存超类，调整子类函数为委托超类，取消继承关系。 12、以继承取代委托你在两个类中使用委托关系，并经常为整个接口编写许多极简单的委托函数。`让委托类继承受托类。]]></content>
      <categories>
        <category>Android</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UUID通用唯一识别码]]></title>
    <url>%2Fposts%2Fb4fbe497.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526import java.util.UUID; public class UploadUtils &#123; /** * 传入文件的名称，返回的唯一的名称 * 例如：gril.jpg 返回sdjsljfsjdl.jpg * @param filename * @return */ public static String getUUIDName(String filename)&#123; // 先查找 int index = filename.lastIndexOf("."); // 截取 String lastname = filename.substring(index, filename.length()); // 唯一 字符串 fsd-sfsdf-sfsd-sdfsd String uuid = UUID.randomUUID().toString().replace("-", ""); return uuid+lastname; &#125; public static void main(String[] args) &#123; String filename = "girl.jpg"; String uuid = getUUIDName(filename); System.out.println(uuid); &#125;&#125; UUID含义是通用唯一识别码 (Universally Unique Identifier)，这 是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部份。UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。目前最广泛应用的 UUID，即是微软的 Microsoft’s Globally Unique Identifiers (GUIDs)，而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。 UUID.randomUUID().toString()是javaJDK提供的一个自动生成主键的方法。UUID(Universally Unique Identifier)全局唯一标识符,是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的，是由一个十六位的数字组成,表现出来的形式。由以下几部分的组合：当前日期和时间(UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同)，时钟序列，全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡以其他方式获得），UUID的唯一缺陷在于生成的结果串会比较长。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android:label=REPLACE and android:label=REPLACE]]></title>
    <url>%2Fposts%2Fc46aabc2.html</url>
    <content type="text"><![CDATA[Multiple entries with same key: 尝试从tools:replace列表中删除空格。 1tools:replace=&quot;android:label,theme,allowBackup,android:icon,android:supportsRtl&quot; 这为我修复了构建错误，但我仍在试图找出为什么忽略空格后的条目.]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习]]></title>
    <url>%2Fposts%2Fd3a7443d.html</url>
    <content type="text"><![CDATA[JavaScript权威指南第6版中文版JavaScript高级程序设计（第3版）中文你不知道的 JavaScript（上卷）你不知道的 JavaScript（中卷）你不知道的 JavaScript（下卷）]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 主题 next 添加图片背景]]></title>
    <url>%2Fposts%2F60e96c42.html</url>
    <content type="text"><![CDATA[前言next 主题默认背景是白色, 看多了难免感觉乏味. 我们可以通过自定义样式为其添加背景图片. 操作流程我们直接在 NEXT 预留的自定义样式文件 “themes/next/source/css/_custom/custom.styl” 中添加自己的样式即可, 在自定义样式文件中写入以下代码: 12345678910111213141516171819// 添加背景图片body &#123; background: url(https://source.unsplash.com/random/1600x900?wallpapers); background-size: cover; background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%;&#125;// 修改主体透明度.main-inner &#123; background: #fff; opacity: 0.8;&#125;// 修改菜单栏透明度.header-inner &#123; opacity: 0.8;&#125; 其中: background: url() 中填写的是背景图片的 url 地址, 这里调用了 Unsplash 的 API, 随机选用该网站的高清美图作为博客背景. 该网站所有图片都是免费商用的, 所以无须担心侵权问题;网站 API 还有很多有趣的玩法, 参见: Documentation opacity 指定了对应元素的透明度, 这里是 “0.8”, 可以按需更改.]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo修改永久链接的默认格式]]></title>
    <url>%2Fposts%2F36589e41.html</url>
    <content type="text"><![CDATA[Hexo的永久链接的默认格式是:year/:month/:day/:title/，比如访问站点下某一篇文章时，其路径是 2018/04/12/xxxx/，如果我们的文章标题是中文的，那么该路径就会出现中文字符。在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取。 *解决办法就是利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，而不会导致原本的链接失效而造成站点下存在大量的死链。 * 安装插件在站点根目录使用 git bash 执行命令： 1npm install hexo-abbrlink --save 修改站点配置文件打开根目录下的_config.yml 文件，修改如下配置： 123456# permalink: :year/:month/:day/:title/# permalink_defaults:permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 这里将页面都添加了.html的后缀，用来伪装成静态页面(虽说Hexo的页面本身就是静态页面)，这样可以直接从路径就知道这是个静态页面，方便seo。 接下来重新部署三连，可以看到我们的文章路径变成了/posts/xxxxx.html，接下来就算我们将文字标题命名为中文也没问题了。]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Animation位移渐变组合动画了解一下]]></title>
    <url>%2Fposts%2F91718fcd.html</url>
    <content type="text"><![CDATA[一：需求分析最近要实现一个view上下循环滚动的动画，需要带有位置移动和透明度转变的动画。类似于从A到B发生位移动画，且view逐渐显示。而从B到C发生位移动画，且view渐变暗消失。实现效果如图所示： 二：需求拆分接到这个需求后，首先将需求进行细分，分为位移动画和逐渐变量（变暗）两个部分。对应的Android的动画类分别是TranslateAnimation(位移动画)和AlphaAniamtion(透明度变化动画)。首先先熟悉一下这两种动画。 1：TranslateAnimation 位移动画123456789101112131415private void startTranslateAnimation() &#123; /** * 进行位移动画，标准步骤 * 1. 创建位移动画对象 * 构造函数 TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) * 参数含义：相对于原图位置 fromXDelta X轴起点相对于原图偏移 toXDelta X轴终点相对于原图偏移 * fromYDelta Y轴起点相对于原图偏移 toYDelta Y轴终点相对于原图偏移 * 2. 设置动画终点是否保持 setFillAfter ： true 动画结束后留在终点 false:动画结束后返回起点 */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -200.0f); translateAnimation.setFillAfter(true); translateAnimation.setDuration(1000); mTextView.startAnimation(translateAnimation);&#125; 这里需要注意的一个小点：设置FillAfter的值，为true代表动画后View停留在终点位置处，false代表动画结束后返回起点。 2：AlphaAnimation 透明度转变动画123456789101112private void startAlphaAnimation() &#123; /** * 进行透明度变化动画，标准步骤 * 1. 创建AlphaAnimation动画 * 构造函数 AlphaAnimation fromAlphaVal toAlphaVal */ AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); alphaAnimation.setFillAfter(true); alphaAnimation.setDuration(1000); mTextView.startAnimation(alphaAnimation);&#125; 3：同时完成位移和透明度动画需求1234567891011121314151617private void startAppearanceAnimation() &#123; /** * 核心类 AnimationSet 顾名思义，可以简单理解为将多种动画放在一个set集合里面 * 产生渐渐显示+位移动画，将加速小火箭渐渐显示出来; * */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -200.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); mTextView.startAnimation(animationSet);&#125; 实现叠加的动画效果：这里一定要注意的是，对AnimationSet动画，fillAfter和duration需要在AniamtionSet对象中设置，不要设置单个动画对象上。 4：完成的动画过程（位移+渐渐显示 停留 位移+渐渐隐藏）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.zm.animationdemo;import android.os.Bundle;import android.os.Handler;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.animation.AlphaAnimation;import android.view.animation.Animation;import android.view.animation.AnimationSet;import android.view.animation.TranslateAnimation;import android.widget.Button;import android.widget.TextView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; TextView tv_text; Button btn; List&lt;String&gt; textList = new ArrayList&lt;String&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_text = findViewById(R.id.tv_text); btn = findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startAppearanceAnimation(); &#125; &#125;); textList.add("Hello World!"); textList.add("Welcome to my blog!"); textList.add("https://zhangmiao.cc"); textList.add("Knowledge is power."); textList.add("Learn and live."); textList.add("可以不成功，但不可以不成长！"); textList.add("加油💪"); &#125; private void startAppearanceAnimation() &#123; /** * 核心类 AnimationSet 顾名思义，可以简单理解为将多种动画放在一个set集合里面 * 产生渐渐显示+位移动画 * */ TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, 0.0f, -50.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(0.0f, 1.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); animationSet.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; startDisappearanceAnimation(); &#125; &#125;, 1500); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); tv_text.startAnimation(animationSet); int index = (int) (Math.random() * textList.size()); tv_text.setText(textList.get(index)); &#125; private void startDisappearanceAnimation() &#123; TranslateAnimation translateAnimation = new TranslateAnimation(0.0f, 0.0f, -50.0f, -100.0f); AlphaAnimation alphaAnimation = new AlphaAnimation(1.0f, 0.0f); AnimationSet animationSet = new AnimationSet(true); animationSet.setFillAfter(true); animationSet.setDuration(1000); animationSet.addAnimation(translateAnimation); animationSet.addAnimation(alphaAnimation); animationSet.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; startAppearanceAnimation(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); tv_text.startAnimation(animationSet); &#125;&#125; 总结 位移动画TranslateAnimation实现位移，SetFIllAfter=true可让View停留在动画终点处,false返回动画起点 透明度动画 AlphaAnimation实现透明度变化，可实现View的渐显或者渐隐效果 动画效果可以叠加展示，通过AnimationSet实现。整个动画的fillAfter和duration需要设置在AnimationSet对象上，而不是单个对象单独设置（单独设置不会有效果）]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种获取栈顶Activity的方法]]></title>
    <url>%2Fposts%2F104e2eeb.html</url>
    <content type="text"><![CDATA[有时候，需要获取当前位于栈顶的activity的实例。这里介绍2种方法，以及各自适用的场景。 第一种方法：获取栈顶activity的实例应用场景：项目中，activity都继承于一个BaseActivity，在这个base中，有个广播接收器，收到广播，就弹出一个dialog。现打开多个activity，这个时候，通过三方推送等方法，发出一个广播，base接收到。因为只需要在栈顶的activity弹出，而不是每个activity都弹出，所以，需要获取栈顶activity的实例（即上下文，传给dialog的构造方法），而不能简单的传个this，否则，会导致每个activity都有dialog弹出。 获取方法：在application中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MyApplication extends Application &#123; private static MyApplication mInstance; private Activity app_activity = null; @Override public void onCreate() &#123; super.onCreate(); mInstance = this; initGlobeActivity(); &#125; private void initGlobeActivity() &#123; registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; app_activity = activity; Log.e("onActivityCreated===", app_activity + ""); &#125; @Override public void onActivityDestroyed(Activity activity) &#123; app_activity = activity; Log.e("onActivityDestroyed===", app_activity + ""); &#125; /** Unused implementation **/ @Override public void onActivityStarted(Activity activity) &#123; app_activity = activity; Log.e("onActivityStarted===", app_activity + ""); &#125; @Override public void onActivityResumed(Activity activity) &#123; app_activity = activity; Log.e("onActivityResumed===", app_activity + ""); &#125; @Override public void onActivityPaused(Activity activity) &#123; app_activity = activity; Log.e("onActivityPaused===", app_activity + ""); &#125; @Override public void onActivityStopped(Activity activity) &#123; app_activity = activity; Log.e("onActivityStopped===", app_activity + ""); &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; &#125;); &#125; /** * 获取实例 * @return */ public static MyApplication getInstance() &#123; return mInstance; &#125; /** * 公开方法，外部可通过 MyApplication.getInstance().getCurrentActivity() 获取到当前最上层的activity */ public Activity getCurrentActivity() &#123; return app_activity; &#125;&#125; 注意：initGlobeActivity()、getInstance()、getCurrentActivity() 这3个方法 使用方法：在base的展示dialog方法中123Activity currentActivity = MyApplication.getInstance().getCurrentActivity();Dialog dialog = new Dialog(currentActivity, R.style.PushDialog); 第二种方法：获取栈顶activity的完整包名应用场景：仅仅为了判断当前activity是不是在栈顶，以便决定要不要弹toast等等。注意：获取到的仅仅是完整包名，判断当前activity在不在栈顶，需要用到String方法中的contains方法等。这个时候需要注意，以免出错。如：栈顶activity名为AB，里面包含A，就认为A是在栈顶，就出错了。最好这个activity的名字很特殊，和其他的没有重合部分 在工具类中创建方法：123456789101112131415/** * 获得栈中最顶层的Activity * * @param context * @return */public static String getTopActivity(Context context) &#123; android.app.ActivityManager manager = (android.app.ActivityManager) context.getSystemService(context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = manager.getRunningTasks(1); if (runningTaskInfos != null) &#123; return (runningTaskInfos.get(0).topActivity).toString(); &#125; else return null; &#125; 使用：12String topActivity_1 = Util.getTopActivity(this);Log.e("topActivity_1", topActivity_1);]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Viewpager+Fragment动态处理（添加、删除）]]></title>
    <url>%2Fposts%2Fbcdbaf4f.html</url>
    <content type="text"><![CDATA[问题在进行Fragment的添加和删除时，适配器刷新之后发现并没有什么变化，这是为什么呢？ 理解FragmentPagerAdapter 适合少量的页面显示。该类每一个生成的Fragment对象都会储存在内存中，所以适合相对静态、页面少的情况，如果是页面多，且Fragment的处理相对动态（添加、删除等）时，使用FragmentStatePagerAdapter较为适合。 FragmentStatePagerAdapter 适合大量的页面显示，当页面处于不可见时，可能会被销毁，只保留该片段的保存状态。与FragmentPagerAdapter切换页面产生的大量开销对比，这允许了适配器保持与每个被访问页面相关联的更少的存储器。 分析在切换页面时，FragmentPagerAdapter与FragmentStatePagerAdapter对于上上页（预加载默认1，所以取上上页）的处理是不相同的，FragmentPagerAdapter只是销毁对应Fragment的视图，而FragmentStatePagerAdapter则是把Fragment的实例和视图都销毁了。 当我们对页面进行动态处理时，添加（或删除）是对适配器所持有的list对象进行长度的变化，操作完之后就进行适配器的刷新，也就是notifyDataSetChanged方法，先看看该方法： 12345678910//PagerAdapter.classpublic void notifyDataSetChanged() &#123; synchronized (this) &#123; if (mViewPagerObserver != null) &#123; //根据源码可知mViewPagerObserver的对象是ViewPager里面PagerObserver类的实例 mViewPagerObserver.onChanged(); &#125; &#125; mObservable.notifyChanged(); &#125; 123456789101112131415//ViewPager.classprivate class PagerObserver extends DataSetObserver &#123; PagerObserver() &#123; &#125; @Override public void onChanged() &#123; //调用的是该方法 dataSetChanged(); &#125; @Override public void onInvalidated() &#123; dataSetChanged(); &#125; &#125; 对FragmentPagerAdapter（或FragmentStatePagerAdapter）执行的方法大概进行注释一下，方便理解， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//ViewPager.classvoid dataSetChanged() &#123; // This method only gets called if our observer is attached, so mAdapter is non-null. final int adapterCount = mAdapter.getCount(); mExpectedAdapterCount = adapterCount; boolean needPopulate = mItems.size() &lt; mOffscreenPageLimit * 2 + 1 &amp;&amp; mItems.size() &lt; adapterCount; int newCurrItem = mCurItem; boolean isUpdating = false; //遍历所有item for (int i = 0; i &lt; mItems.size(); i++) &#123; final ItemInfo ii = mItems.get(i); //先调用adapter的getItemPosition方法，获得newPos值 final int newPos = mAdapter.getItemPosition(ii.object); if (newPos == PagerAdapter.POSITION_UNCHANGED) &#123; continue; &#125; if (newPos == PagerAdapter.POSITION_NONE) &#123; mItems.remove(i); i--; if (!isUpdating) &#123; mAdapter.startUpdate(this); isUpdating = true; &#125; //newPos值为PagerAdapter.POSITION_NONE的时候才会执行destroyItem方法 mAdapter.destroyItem(this, ii.position, ii.object); needPopulate = true; if (mCurItem == ii.position) &#123; // Keep the current item in the valid range newCurrItem = Math.max(0, Math.min(mCurItem, adapterCount - 1)); needPopulate = true; &#125; continue; &#125; if (ii.position != newPos) &#123; if (ii.position == mCurItem) &#123; // Our current item changed position. Follow it. newCurrItem = newPos; &#125; ii.position = newPos; needPopulate = true; &#125; &#125; if (isUpdating) &#123; //finishUpdate方法主要是对事务的操作进行commit mAdapter.finishUpdate(this); &#125; Collections.sort(mItems, COMPARATOR); if (needPopulate) &#123; // Reset our known page widths; populate will recompute them. final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = getChildAt(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (!lp.isDecor) &#123; lp.widthFactor = 0.f; &#125; &#125; // setCurrentItemInternal(newCurrItem, false, true); requestLayout(); &#125; &#125; Adapter.getItemPosition方法默认返回的是PagerAdapter.POSITION_UNCHANGED值，如果我们不重写getItemPosition方法，使其返回PagerAdapter.POSITION_NONE的话，那么默认是不操作destroyItem方法的，而在destroyItem方法中，FragmentPagerAdapter和FragmentStatePagerAdapter 对Fragment对象的操作也不一样，上面有说过，FragmentPagerAdapter是只销毁视图，FragmentStatePagerAdapter 是把实例和视图都销毁，就是在destroyItem方法实现的，贴代码： 123456789101112131415161718192021222324252627282930//FragmentPagerAdapter@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Detaching item #" + getItemId(position) + ": f=" + object + " v=" + ((Fragment)object).getView()); //这里是对fragment进行detach操作，fragmentManager中还保存该实例 mCurTransaction.detach((Fragment)object); &#125;//FragmentStatePagerAdapter @Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object + " v=" + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) &#123; mSavedState.add(null); &#125; mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); //而这里是对fragment进行remove，直接在fragmentManager中移除掉 mCurTransaction.remove(fragment); &#125; 解决根据上面的分析，在进行添加删除的时候，我采用了FragmentStatePagerAdapter的子类，进行方法的重写，主要是对该类的两个方法（instantiateItem和destroyItem）进行重写，替换父类的实现，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.voctex.adapter;import android.os.Parcelable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentStatePagerAdapter;import android.support.v4.view.PagerAdapter;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;public class DynamicFragmentAdapter extends FragmentStatePagerAdapter &#123; private FragmentManager mFragmentManager; private List&lt;Fragment&gt; mFragments = new ArrayList&lt;&gt;(); public DynamicFragmentAdapter(FragmentManager fm, List&lt;Fragment&gt; list) &#123; super(fm); this.mFragmentManager = fm; if (list == null) return; this.mFragments.addAll(list); &#125; public void updateData(List&lt;Fragment&gt; mlist) &#123; if (mlist == null) return; this.mFragments.clear(); this.mFragments.addAll(mlist); notifyDataSetChanged(); &#125; @Override public Fragment getItem(int arg0) &#123; return mFragments.get(arg0);// &#125; @Override public int getCount() &#123; return mFragments.size();// &#125; @Override public Parcelable saveState() &#123; return null; &#125; @Override public int getItemPosition(Object object) &#123; if (!((Fragment) object).isAdded() || !mFragments.contains(object)) &#123; return PagerAdapter.POSITION_NONE; &#125; return mFragments.indexOf(object); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; Fragment instantiateItem = ((Fragment) super.instantiateItem(container, position)); Fragment item = mFragments.get(position); if (instantiateItem == item) &#123; return instantiateItem; &#125; else &#123; //如果集合中对应下标的fragment和fragmentManager中的对应下标的fragment对象不一致，那么就是新添加的，所以自己add进入；这里为什么不直接调用super方法呢，因为fragment的mIndex搞的鬼，以后有机会再补一补。 mFragmentManager.beginTransaction().add(container.getId(), item).commitNowAllowingStateLoss(); return item; &#125; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; //如果getItemPosition中的值为PagerAdapter.POSITION_NONE，就执行该方法。 if (mFragments.contains(fragment)) &#123; super.destroyItem(container, position, fragment); return; &#125; //自己执行移除。因为mFragments在删除的时候就把某个fragment对象移除了，所以一般都得自己移除在fragmentManager中的该对象。 mFragmentManager.beginTransaction().remove(fragment).commitNowAllowingStateLoss(); &#125; &#125; 结束语 在不断的看源码，查资料，调试程序中，终于是把该问题解决了，网上的资料都说得模棱两可，很多时候都得自己操刀，理解了才是自己的，特别是Fragment在FragmentManager中的mIndex值，有点坑，这里没拿出来说，以后有机会再补补。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Viewpager</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能不知道的 Mac 技巧 - 截图，Gif 制作及 App 推荐]]></title>
    <url>%2Fposts%2Fae0ce15d.html</url>
    <content type="text"><![CDATA[概述首先要说明的是，我不可能，也不打算把所有快捷键都列出来。写这篇博文的目的是列出来那些我经常使用的，而且我认为可以显著的提高工作效率的快捷键。所以多少会有些主观色彩 Anyway，老规矩，如果大家有任何疑问、意见或者建议，请在下方留言评论 截图macOS 系统内置了截图功能，每次截图都会发出声音，当然这个声音可以关，后面会提到。基础操作有以下四种（快捷键也可以自定义，后面也会提到）： 1. 截图并保存至桌面123Cmd + Shift + 3 截取整个屏幕，并保存截图至桌面Cmd + Shift + 4 截取区域，并保存截图至桌面 激活区域截图之后，鼠标指针会变成下图这样，然后按住拖动就可以了 2. 截图并复制有些时候，截图内容只是我们临时要用一下的，而不打算保存下来。我们只需要： 123Cmd + Ctrl + Shift + 3 截取整个屏幕并复制Cmd + Ctrl + Shift + 4 截取区域并复制 以上两个快捷键，截图之后，我们只需要 “Cmd” + “v” 就可以随意粘贴了 3. 关于新版 MacBook 的 Touch Bar新版的 MacBook 加入了 Touch Bar，同时系统也为我们提供了截取 Touch Bar 屏幕的快捷键： 123Cmd + Shift + 6 截取 Touch Bar 显示内容，并保存至桌面Cmd + Ctrl + Shift + 6 截取 Touch Bar 显示内容并复制 4. 一些高级操作a. 截取窗口一个比较常用的功能就是截取某个窗口，不需要用截取区域的快捷键然后拉满整个窗口，只需要在 “Cmd” + [“Ctrl” +] “Shift” + “4” 之后按一下 空格，然后鼠标和窗口就会变成这样： 鼠标会变成红色箭头指的那个照相机形状，要截取的窗口也会变成“选中”模式的颜色。这时候只要单击一下鼠标就可以了直接截取窗口了，要取消的话就按 “ESC”。同样道理，快捷键加上了 “Ctrl” 就会复制这个窗口的截图。如果没加，那就会把这个窗口截图保存至桌面 可能有些人会问，为什么上面的“选中”模式是这么漂（nan）亮（kan）的颜色，在这里就可以设置，颜色是我自己调的，非系统默认： b. 实时调整大小还有一些高级操作，都是在开启区域模式并选中一个区域，松开鼠标按键前可以执行的，这里就简单提一下，感兴趣的朋友可以自己试试： 这时候按住 “空格” 并移动鼠标，就可以保持区域大小不变，同时移动区域 这时候按住 “Shift” 并移动鼠标，就可以保持区域的其他三个边不变，移动一个边的位置 这时候按住 “Alt” 并移动鼠标，就可以对称地调整区域大小 就我个人而言，空格那个我偶尔会用下，不过 “Shift” 和 “Alt” 这两个，我是用的真不多 3. 截图标注我们只需要用自带的 Preview（预览）就可以完成截图标注 对于保存到桌面的截图，首先我们在桌面上单击一下图片，然后直接按下 “空格”。空格键是 macOS 上的 Quick View（快速预览），以后的文章中我们会细说。然后只需要点击下图箭头指的这个 Open with Preview： 然后再点一下箭头指的这个工具箱图标，就可以进行标注了。macOS 为我们提供的标注功能有选取（圆形、矩形及套索）、亮度选取、画笔、几何图形标注（圆形、矩形、箭头等）、文字、签名、调色以及裁剪： 这里不得不提一下亮度选取，这个功能可以根据亮度智能选取背景。举个例子，上面的截图，点击亮度选取，然后按住鼠标，左右（或上下）拖动，就能看到选取区域的变化。选好背景后，我们反转一下选取（快捷键 “Cmd” + “Shift” + “i”），然后直接 “delete”，就得到了这个： 4. 延时截图及 Grab 应用a. Grab有时候我们需要延时截图，macOS 为我们提供了这个功能，只是藏的比较深。我们可以直接用 Alfred 或者 macOS 自带的 Spotlight 搜索到，直接输入 Grab 即可： 回车之后没有打开任何窗口，你可能觉得刚刚是打开了假的 App。但其实，这个 App 本身就是没有 UI 的，只会在 Menu Bar 上面显示一条菜单。我们可以在这里找到延时截图的选项： 点击之后，按照提示操作就好，默认的延时时间是 10 秒。要注意的是，延时截图会截取整个屏幕，不能截区域。我们可以先把图片保存下来，然后再打开 Preview（预览）App 裁剪就好了 b. 个性化默认的延时时间和保存路径都是可以更改的。只要打开 Terminal（终端），然后输入这个命令并执行： 1screencapture -T 10 screenshot1.jpg 其中，10 就表示延时十秒，”screenshot1” 就是默认的文件名，你可以把它改成其他文件名，也可以给它加上一个文件夹路径用于设置默认的保存位置 5. 截图功能的配置a. 禁用提示音截图提示音是可以关闭的，大家只需要打开 System Preferences，然后选择 Sound (声音)，然后只要把红色箭头指的这个关掉就行： b. 快捷键设置可能有朋友觉得系统自带快捷键好麻烦，讲真，习惯几天就好了。原则上我不是很建议大家自己改，因为如果快捷键设置的不当，就很可能会在某些 App 中产生快捷键冲突。比如，你把截图快捷键改成了 “Ctrl” + “c”，那么恭喜你，以后关闭 Server 只能 “kill ${pid}” 了?。当然，如果你足够熟悉快捷键，改改倒是也无妨，大不了弄乱了直接恢复成默认 我们可以在 “系统设置 -&gt; 键盘 -&gt; 快捷键” 中设定快捷键，先定位到 Services （服务），然后就可以找到设置截图的快捷键了： 就算把这些都关掉，像上图那样，文中之前提到的那些快捷键也都是能用的，因为那些都是系统默认的快捷键。同时，我们注意到这里也提供了延时截图的快捷键，如果你常用这个功能，那不妨也绑定一个快捷键吧，比如 “Cmd” + “Shift” + “5”，方便又好记 c. 截图默认保存路径设置同样，我也不推荐改这个设置，虽然改一下也不会炸。比如你想把截图放到桌面的 myScreenshot 文件夹，那么打开 Terminal（终端），输入： 1defaults write com.apple.screencapture location ~/Desktop/myScreenshot 然后，记得要重启一下系统的 UI 服务，执行这个命令： 1killall SystemUiServer 之后，如果你再通过 “Cmd” + “Shift” + “3/4” 截图，图片就会保存在这个文件夹里 macOS 上截图相关的快捷键就介绍到这里，能想到的也就这些了。以下为 App 推荐环节，写给有需要的朋友 截图 App 推荐经常会被问到，Mac 上如何制作 Gif，以及有什么截图 App 可以替代原生的截图工具。这里推荐以下几款，从免费到收费的都有。顺便提一句，Windows 系统自带的截图工具就很方便了，另外 PicPick 也是极好的。可以一直免费试用，不需要去找破解，只是这款 App 没有 Mac 版本 1. 系统截图 App 替代品以下提到的三款软件均免费，至少在标注方面比原生的略胜一筹，详情请点击链接查看 a. 浏览器插件 Awesome ScreenshotAwesome Screenshot 是一款免费的截图工具，非本地 App，只是一个浏览器插件。它支持延时截图区域截图等常用功能。也内置了一个网页版的标注工具 b. Evernote 旗下的 SkitchSkitch | Evernote 也是一款免费的截图 App，标注功能相比 Awesome Screenshot 会稍好一些。如果你用 Evernote（印象笔记），经常需要截图并保存到自己的笔记中，那么这款 App 可能会比较适合你。同时，Skitch 也有 iOS 版本 c. JingJing 同样是一款免费的截图 App，来自 TechSmith 公司，这家公司出品的另一款更为强大的截图工具 SnagIt 会在后文详细说明 2. 制作 Gif经常会被问到，如何在 macOS 上制作 Gif。这里给大家推荐以下几个不错的 App a. LICEcap (收费)LICEcap 是一款老牌的 macOS 系统 Gif 制作工具，不免费。相比其他 App，LICEcap 本身并不提供分享和上传功能，所以我本人并不是很推荐 b. Giphy Capture (免费)GIPHY Capture 是由一个很火的 Gif 分享网站 GIPHY 开发的。一个很方便的功能就是可以直接上传至 giphy.com（可能需要 VPN 才能访问），然后把链接 Share 给朋友就可以了。同样，保存至本地也没问题 3. SnagIt - 全套解决方案我一般的习惯是，如果截图只是为了粘贴到聊天框之类的地方，而且不需要标注的话，就会用系统截图。如果需要标注，或者想要留下来，就会用一个第三方的 App：Snagit)。虽然是付费软件，价格也有点儿高，但我觉得还是很值得购买的。目前我的博客和 GitHub 上的截图、动图都是用这个做的 a. 截图功能SnagIt 在截图方面提供了区域延时截图、全景截图、Expose 模式截图甚至摄像头输入内容截图这些很实用的功能。个人觉得，它 Menu Bar 的 Panel（面板）本身颜值就很高： 而且自带一个颜值更高，功能也更多的图片编辑器： 保存的图片格式也可以自己选择，还可以保存为感人的 Retina 清晰度 b. 编辑功能作为一款付费 App，它确实为我们提供了相比 macOS 原生 Preview 更多的编辑功能。暂且不去比较已有的箭头之类的功能，虽然我还是觉得 SnagIt 里面的元素更好看些，SnagIt 还提供了打码功能，效果嘛，大家可以参考下上面 Grab 那里的配图。放大镜功能也是极好的，突出重点的时候很有用。还有 Stamp（图章），有茫茫多的图章选择，从 PC 键盘按键图章，到 Emoji 表情，再到数学符号和花体英文字母，都可以直接扔到截图上。虽然没有提供直接的拼图工具，但拼起来也不麻烦，裁好图，加上分割线，粘贴到一起就可以了 c. 视频功能首先，SnagIt 可以录制很高清的视频，时长也是没有限制的。支持全屏和区域录制两种模式，同时也可以录制摄像头输入和麦克风输入，这个功能用来录制会议视频应该也是极好的。另一个应用场景就是，我们在一些网站上看到喜欢的视频想留下来，而网站又不提供下载，那我们就可以直接选好视频播放的区域来自己录成视频 d. 上传与同步功能TechSmith 自己提供了 http://screencast.com 和 TechSmith relay 服务，当然我们也可以选择上传到 Google Drive 或者 Dropbox。也以配置自己的 FTP，或者直接扔到 iCloud 文件夹也是没问题的。同样，也可以选择本地文件夹保存，支持命名规则等方面的设置]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基础控件ViewFlipper的使用，垂直滚动广告条]]></title>
    <url>%2Fposts%2Fced0f833.html</url>
    <content type="text"><![CDATA[学习，学习，学以致用ViewFlipper是安卓自带的控件，很多人可能很少知道这个控件，这个控件很简单，也很好理解。 从源码可以看出，其实ViewFlipper间接的继承了FrameLayout，也可以说ViewFlipper其实就是个FrameLayout，只不过在内部封装了动画实现和Handler实现一个循环而已。 ViewFlipperDemo ###一、ViewFlipper的布局实现布局的编写很简单，跟普通布局一样的 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ViewFlipper android:id="@+id/marqueeView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginTop="10dip" android:layout_marginBottom="30dip" android:autoStart="true" android:background="#fff" android:flipInterval="3000" android:inAnimation="@anim/anim_marquee_in" android:outAnimation="@anim/anim_marquee_out" android:paddingLeft="30dp"/&gt;&lt;/LinearLayout&gt; 这里介绍ViewFlipper用到的属性，这些属性其实都可以使用代码实现，只不过这里为了代码看上去美观，才放在布局里的 android:autoStart：设置自动加载下一个View android:flipInterval：设置View之间切换的时间间隔 android:inAnimation：设置切换View的进入动画 android:outAnimation：设置切换View的退出动画 下面是ViewFlipper常用的方法介绍，除了可以设置上面的属性之外，还提供了其他方法 isFlipping： 判断View切换是否正在进行 setFilpInterval：设置View之间切换的时间间隔 startFlipping：开始View的切换，而且会循环进行 stopFlipping：停止View的切换 setOutAnimation：设置切换View的退出动画 setInAnimation：设置切换View的进入动画 showNext： 显示ViewFlipper里的下一个View showPrevious：显示ViewFlipper里的上一个View 这里还涉及到两个动画其实就是一个平移的动画，它们都保存在anim文件夹中 anim_marquee_in.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="1500" android:fromYDelta="100%p" android:toYDelta="0"/&gt;&lt;/set&gt; anim_marquee_out.xml 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="1500" android:fromYDelta="0" android:toYDelta="-100%p"/&gt;&lt;/set&gt; 当然，如果你对动画xml比较熟悉，自己可以实现更多好看的效果 ###二、自定义ViewFlipper的广告条当我们准备好了ViewFlipper之后，就应该在ViewFlipper里面添加我们的广告条了，下面是其中一个广告条的布局文件，另外两个雷同，只不过改了文字而已 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content" android:layout_height="25dip" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/iv_image" android:layout_width="25dip" android:layout_height="25dip" android:src="@mipmap/ic_launcher"/&gt; &lt;TextView android:id="@+id/tv_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:layout_marginLeft="10dip" android:text="华为王牌亮相，5G+4000万徕卡"/&gt;&lt;/LinearLayout&gt; ###三、代码为ViewFlipper添加广告条所有的准备条件都准备好了，该开始使用代码将准备好的东西黏在一起了，代码很简单，这里就不多解释了 12345678910111213141516171819202122232425262728293031323334353637package com.zm.viewflipperdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.LayoutInflater;import android.view.View;import android.widget.TextView;import android.widget.ViewFlipper;public class MainActivity extends AppCompatActivity &#123; private ViewFlipper marqueeView; private String[] textArray = &#123;"华为王牌亮相，5G+4000万徕卡", "圣诞来袭，扫码关注领取大礼！", "2018即将过去，说说您的心里话"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); initData(); &#125; private void initView() &#123; marqueeView = findViewById(R.id.marqueeView); &#125; private void initData() &#123; LayoutInflater inflater = LayoutInflater.from(this); for (int i = 0; i &lt; textArray.length; i++) &#123; View view = inflater.inflate(R.layout.marquee_scroll_content, null); TextView text = view.findViewById(R.id.tv_text); text.setText(textArray[i]); marqueeView.addView(view); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewFlipper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View获取width和height的四种方法]]></title>
    <url>%2Fposts%2Fdd1673d3.html</url>
    <content type="text"><![CDATA[很经常当我们动态创建某些View时，需要通过获取他们的width和height来确定别的view的布局，但是在onCreate()获取view的width和height会得到0.view.getWidth()和view.getHeight()为0的根本原因是控件还没有完成绘制，你必须等待系统将绘制完View时，才能获得。这种情况当你需要使用动态布局（使用wrap_content或match_parent）就会出现。一般来讲在Activity.onCreate(…)、onResume()方法中都没有办法获取到View的实际宽高。所以，我们必须用一种变通的方法，等到View绘制完成后去获取width和Height。下面有一些可行的解决方案。 1、监听Draw/Layout事件：ViewTreeObserverViewTreeObserver监听很多不同的界面绘制事件。一般来说OnGlobalLayoutListener就是可以让我们获得到view的width和height的地方.下面onGlobalLayout内的代码会在View完成Layout过程后调用。 12345678910view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; mScrollView.post(new Runnable() &#123; public void run() &#123; view.getHeight(); //height is ready &#125; &#125;); &#125;&#125;); 但是要注意这个方法在每次有些view的Layout发生变化的时候被调用（比如某个View被设置为Invisible）,所以在得到你想要的宽高后，记得移除onGlobleLayoutListener： 在 SDK Lvl &lt; 16时使用public void removeGlobalOnLayoutListener (ViewTreeObserver.OnGlobalLayoutListener victim) 在 SDK Lvl &gt;= 16时使用public void removeOnGlobalLayoutListener (ViewTreeObserver.OnGlobalLayoutListener victim) 2、将一个runnable添加到Layout队列中：View.post()这个解决方案是我最喜欢的，但是几乎没人知道有这个方法。简单地说，只要用View.post()一个runnable就可以了。runnable对象中的方法会在View的measure、layout等事件后触发，具体的参考Romain Guy： UI事件队列会按顺序处理事件。在setContentView()被调用后，事件队列中会包含一个要求重新layout的message，所以任何你post到队列中的东西都会在Layout发生变化后执行。 12345678final View view=//smth;...view.post(new Runnable() &#123; @Override public void run() &#123; view.getHeight(); //height is ready &#125; &#125;); 这个方法比ViewTreeObserver好：1、你的代码只会执行一次，而且你不用在在每次执行后将Observer禁用，省心多了。2、语法很简单参考：http://stackoverflow.com/a/3602144/774398http://stackoverflow.com/a/3948036/774398 3、重写View的onLayout方法这个方法只在某些场景中实用，比如当你所要执行的东西应该作为他的内在逻辑被内聚、模块化在view中，否者这个解决方案就显得十分冗长和笨重。 1234567view = new View(this) &#123; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); view.getHeight(); //height is ready &#125;&#125;; 需要注意的是onLayout方法会调用很多次，所以要考虑好在这个方法中要做什么，或者在第一次执行后禁用掉你的代码。 4、获取固定宽高如果你要获取的view的width和height是固定的，那么你可以直接使用： 12View.getMeasureWidth()View.getMeasureHeight() 但是要注意，这两个方法所获取的width和height可能跟实际draw后的不一样。官方文档解释了不同的原因： View的大小由width和height决定。一个View实际上同时有两种width和height值。 第一种是measure width和measure height。他们定义了view想要在父View中占用多少width和height（详情见Layout）。measured height和width可以通过getMeasuredWidth() 和 getMeasuredHeight()获得。 第二种是width和height，有时候也叫做drawing width和drawing height。这些值定义了view在屏幕上绘制和Layout完成后的实际大小。这些值有可能跟measure width和height不同。width和height可以通过getWidth()和getHeight获得。 参考链接 https://stackoverflow.com/questions/3591784/getwidth-and-getheight-of-view-returns-0/24035591#24035591]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpannableString之富文本显示效果]]></title>
    <url>%2Fposts%2F9e398b2.html</url>
    <content type="text"><![CDATA[TextViewSpannableString一：简介SpannableString其实和String一样，都是一种字符串类型，SpannableString可以直接作为TextView的显示文本，不同的是SpannableString可以通过使用其方法setSpan方法实现字符串各种形式风格的显示,重要的是可以指定设置的区间，也就是为字符串指定下标区间内的子字符串设置格式。 setSpan(Object what, int start, int end, int flags)方法需要用户输入四个参数，what表示设置的格式是什么，可以是前景色、背景色也可以是可点击的文本等等，start表示需要设置格式的子字符串的起始下标，同理end表示终了下标，flags属性就有意思了，共有四种属性： Spanned.SPAN_INCLUSIVE_EXCLUSIVE 从起始下标到终了下标，包括起始下标Spanned.SPAN_INCLUSIVE_INCLUSIVE 从起始下标到终了下标，同时包括起始下标和终了下标Spanned.SPAN_EXCLUSIVE_EXCLUSIVE 从起始下标到终了下标，但都不包括起始下标和终了下标Spanned.SPAN_EXCLUSIVE_INCLUSIVE 从起始下标到终了下标，包括终了下标 SpannableString的setSpan()方法可以同时使用多个，实现多种效果叠加。 二：Span常用的格式2.1：ForegroundColorSpan ForegroundColorSpan，为文本设置前景色，效果和TextView的setTextColor()类似，实现方法如下： 1234SpannableString spannableString = new SpannableString("设置文字的前景色为淡蓝色");ForegroundColorSpan colorSpan = new ForegroundColorSpan(Color.parseColor("#0099EE"));spannableString.setSpan(colorSpan, 9, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE); textView.setText(spannableString); 设置的区间是9到字符串的最后，也就是图中“淡蓝色”三字。 2.2：BackgroundColorSpan BackgroundColorSpan，为文本设置背景色，效果和TextView的setBackground()类，实现方法如下： 1234SpannableString spannableString = new SpannableString("设置文字的背景色为淡绿色");BackgroundColorSpan colorSpan = new BackgroundColorSpan(Color.parseColor("#AC00FF30"));spannableString.setSpan(colorSpan, 9, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.3：RelativeSizeSpan RelativeSizeSpan，设置文字相对大小，在TextView原有的文字大小的基础上，相对设置文字大小，实现方法如下： 123456789101112131415161718SpannableString spannableString = new SpannableString("万丈高楼平地起");RelativeSizeSpan sizeSpan01 = new RelativeSizeSpan(1.2f);RelativeSizeSpan sizeSpan02 = new RelativeSizeSpan(1.4f);RelativeSizeSpan sizeSpan03 = new RelativeSizeSpan(1.6f);RelativeSizeSpan sizeSpan04 = new RelativeSizeSpan(1.8f);RelativeSizeSpan sizeSpan05 = new RelativeSizeSpan(1.6f);RelativeSizeSpan sizeSpan06 = new RelativeSizeSpan(1.4f);RelativeSizeSpan sizeSpan07 = new RelativeSizeSpan(1.2f);spannableString.setSpan(sizeSpan01, 0, 1, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan02, 1, 2, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan03, 2, 3, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan04, 3, 4, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan05, 4, 5, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan06, 5, 6, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(sizeSpan07, 6, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.4：StrikethroughSpan StrikethroughSpan，为文本设置中划线，也就是常说的删除线，实现方法如下： 1234SpannableString spannableString = new SpannableString("为文字设置删除线");StrikethroughSpan strikethroughSpan = new StrikethroughSpan();spannableString.setSpan(strikethroughSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.5：UnderlineSpan UnderlineSpan，为文本设置下划线，具体实现方法如下： 1234SpannableString spannableString = new SpannableString("为文字设置下划线");UnderlineSpan underlineSpan = new UnderlineSpan();spannableString.setSpan(underlineSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.6：SuperscriptSpan SuperscriptSpan，设置上标，具体实现方法如下： 1234SpannableString spannableString = new SpannableString("为文字设置上标");SuperscriptSpan superscriptSpan = new SuperscriptSpan();spannableString.setSpan(superscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 从效果图可以看出，被设置为上标的文字大小和下面的文本文字大小一样，只要我们稍加修饰，结合RelativeSizeSpan设置小字体文本作为上标，分分钟实现指数公式有木有，再也不用2^2+3^2=13这样缺乏审美的数学公式了，是不是超实用？ 2.7：SubscriptSpan SubscriptSpan，设置下标，功能与设置上标类似，不做过多描述，具体实现方法如下： 1234SpannableString spannableString = new SpannableString("为文字设置下标");SubscriptSpan subscriptSpan = new SubscriptSpan();spannableString.setSpan(subscriptSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 2.8：StyleSpan StyleSpan，为文字设置风格（粗体、斜体），和TextView属性textStyle类似，实现方法如下： 1234567SpannableString spannableString = new SpannableString("为文字设置粗体、斜体风格");StyleSpan styleSpan_B = new StyleSpan(Typeface.BOLD);StyleSpan styleSpan_I = new StyleSpan(Typeface.ITALIC);spannableString.setSpan(styleSpan_B, 5, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);spannableString.setSpan(styleSpan_I, 8, 10, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setHighlightColor(Color.parseColor("#36969696"));textView.setText(spannableString); 2.9：ImageSpan ImageSpan，设置文本图片，实现方法如下： 123456SpannableString spannableString = new SpannableString("在文本中添加表情（表情）");Drawable drawable = getResources().getDrawable(R.mipmap.a9c);drawable.setBounds(0, 0, 42, 42);ImageSpan imageSpan = new ImageSpan(drawable);spannableString.setSpan(imageSpan, 6, 8, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setText(spannableString); 这一个是不是很炫酷？再加一个解析算法，将文本中特定的文本转换成特定的表情图片，分分钟实现聊天表情显示效果有木有啊朋友们！ 3.0：ClickableSpanClickableSpan，设置可点击的文本，设置这个属性的文本可以相应用户点击事件，至于点击事件用户可以自定义，就像效果图显示一样，用户可以实现点击跳转页面的效果，具体实现方法如下： 123456SpannableString spannableString = new SpannableString("为文字设置点击事件");MyClickableSpan clickableSpan = new MyClickableSpan("https://zhangmiao.cc/");spannableString.setSpan(clickableSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor("#36969696")); textView.setText(spannableString); 12345678910111213141516171819202122class MyClickableSpan extends ClickableSpan &#123; private String content; public MyClickableSpan(String content) &#123; this.content = content; &#125; @Override public void updateDrawState(TextPaint ds) &#123; ds.setUnderlineText(false); &#125; @Override public void onClick(View widget) &#123; Intent intent = new Intent(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString("content", content); intent.putExtra("bundle", bundle); startActivity(intent); &#125;&#125; 代码中我们自定义MyClickableSpan类，继承至ClickableSpan，并重写其中一些方法。ds.setUnderlineText()控制是否让可点击文本显示下划线，很明显，在上面代码中我选择了false，不显示下滑写。onClick点击事件的具体实现方法写在其中。如上代码，我们重写ClickableSpan的onClick方法实现Activity的跳转效果，并传递跳转数据。 注意：使用ClickableSpan的文本如果想真正实现点击作用，必须为TextView设置setMovementMethod方法，否则没有点击相应，至于setHighlightColor方法则是控制点击是的背景色。 URLSpanURLSpan，设置超链接文本，其实聪明的小伙帮在讲到ClickableSpan的时候就能实现超链接文本的效果了，重写onClick点击事件就行，也确实看了URLSpan的源码，URLSpan就是继承自ClickableSpan，也和想象中一样，就是重写了父类的onClick事件，用系统自带浏览器打开链接，具体实现方法如下： 123456SpannableString spannableString = new SpannableString("为文字设置超链接");URLSpan urlSpan = new URLSpan("https://zhangmiao.cc/");spannableString.setSpan(urlSpan, 5, spannableString.length(), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);textView.setMovementMethod(LinkMovementMethod.getInstance());textView.setHighlightColor(Color.parseColor("#36969696"));textView.setText(spannableString); URLSpanonClick事件的源码如下： 123456789101112@Overridepublic void onClick(View widget) &#123; Uri uri = Uri.parse(getURL()); Context context = widget.getContext(); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.putExtra(Browser.EXTRA_APPLICATION_ID, context.getPackageName()); try &#123; context.startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; Log.w("URLSpan", "Actvity was not found for intent, " + intent.toString()); &#125;&#125; 除此之外，还有MaskFilterSpan可以实现模糊和浮雕效果，RasterizerSpan可以实现光栅效果，因为以上两个使用频率不高，而且效果也不是很明显，就不做详细说明，有兴趣的小伙伴不妨去试一试。 SpannableStringBuilder应该有不少开发的小伙伴知道StringBuilder，可以使用append()方法实现字符串拼接，非常方便。同样，SpannableString中也有SpannableStringBuilder，顾名思义，就是实现对，SpannableString的一个拼接效果，同样是append()方法，可以实现各种风格效果的SpannableString拼接，非常实用。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SpannableString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android跳转权限设置界面的终极适配（支持各大定制ROM）]]></title>
    <url>%2Fposts%2F559aa4a0.html</url>
    <content type="text"><![CDATA[前言： 当我们的用户使用App时不小心拒绝了某项必要权限，而导致无法正常使用。这时候希望重新去打开该权限，那么问题来了，Android厂家定制的room五花八门，很多时候却发现找不到权限管理的入口。为了解决这一问题，如果我们应用中直接提供权限管理入口给用户，是不是会很方便的解决用户这一困扰呢?经过一番研究，整理出了大部分国产手机直接打开权限管理界面的方法 权限界面的跳转一般项目中我们都会通过一个类来管理我们的Permission，即PermissionPageUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245/** * 权限请求页适配，不同手机系统跳转到不同的权限请求页 * * @author Donkor */public class PermissionPageUtils &#123; private final String TAG = "PermissionPageManager"; private Context mContext; //自己的项目包名 private String packageName="com.zm.demo"; public PermissionPageUtils(Context context) &#123; this.mContext = context; &#125; public void jumpPermissionPage() &#123; String name = Build.MANUFACTURER; L.e(TAG, "jumpPermissionPage --- name : " + name); switch (name) &#123; case "HUAWEI": goHuaWeiMainager(); break; case "vivo": goVivoMainager(); break; case "OPPO": goOppoMainager(); break; case "Coolpad": goCoolpadMainager(); break; case "Meizu": goMeizuMainager(); break; case "Xiaomi": goXiaoMiMainager(); break; case "samsung": goSangXinMainager(); break; case "Sony": goSonyMainager(); break; case "LG": goLGMainager(); break; default: goIntentSetting(); break; &#125; &#125; private void goLGMainager()&#123; try &#123; Intent intent = new Intent(packageName); ComponentName comp = new ComponentName("com.android.settings", "com.android.settings.Settings$AccessLockSummaryActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private void goSonyMainager()&#123; try &#123; Intent intent = new Intent(packageName); ComponentName comp = new ComponentName("com.sonymobile.cta", "com.sonymobile.cta.SomcCTAMainActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private void goHuaWeiMainager() &#123; try &#123; Intent intent = new Intent(packageName); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); ComponentName comp = new ComponentName("com.huawei.systemmanager", "com.huawei.permissionmanager.ui.MainActivity"); intent.setComponent(comp); mContext.startActivity(intent); &#125; catch (Exception e) &#123; Toast.makeText(mContext, "跳转失败", Toast.LENGTH_LONG).show(); e.printStackTrace(); goIntentSetting(); &#125; &#125; private static String getMiuiVersion() &#123; String propName = "ro.miui.ui.version.name"; String line; BufferedReader input = null; try &#123; Process p = Runtime.getRuntime().exec("getprop " + propName); input = new BufferedReader( new InputStreamReader(p.getInputStream()), 1024); line = input.readLine(); input.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); return null; &#125; finally &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return line; &#125; private void goXiaoMiMainager() &#123; String rom = getMiuiVersion(); L.e(TAG,"goMiaoMiMainager --- rom : "+rom); Intent intent=new Intent(); if ("V6".equals(rom) || "V7".equals(rom)) &#123; intent.setAction("miui.intent.action.APP_PERM_EDITOR"); intent.setClassName("com.miui.securitycenter", "com.miui.permcenter.permissions.AppPermissionsEditorActivity"); intent.putExtra("extra_pkgname", packageName); &#125; else if ("V8".equals(rom) || "V9".equals(rom)) &#123; intent.setAction("miui.intent.action.APP_PERM_EDITOR"); intent.setClassName("com.miui.securitycenter", "com.miui.permcenter.permissions.PermissionsEditorActivity"); intent.putExtra("extra_pkgname", packageName); &#125; else &#123; goIntentSetting(); &#125; mContext.startActivity(intent); &#125; private void goMeizuMainager() &#123; try &#123; Intent intent = new Intent("com.meizu.safe.security.SHOW_APPSEC"); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.putExtra("packageName", packageName); mContext.startActivity(intent); &#125; catch (ActivityNotFoundException localActivityNotFoundException) &#123; localActivityNotFoundException.printStackTrace(); goIntentSetting(); &#125; &#125; private void goSangXinMainager() &#123; //三星4.3可以直接跳转 goIntentSetting(); &#125; private void goIntentSetting() &#123; Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts("package", mContext.getPackageName(), null); intent.setData(uri); try &#123; mContext.startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void goOppoMainager() &#123; doStartApplicationWithPackageName("com.coloros.safecenter"); &#125; /** * doStartApplicationWithPackageName("com.yulong.android.security:remote") * 和Intent open = getPackageManager().getLaunchIntentForPackage("com.yulong.android.security:remote"); * startActivity(open); * 本质上没有什么区别，通过Intent open...打开比调用doStartApplicationWithPackageName方法更快，也是android本身提供的方法 */ private void goCoolpadMainager() &#123; doStartApplicationWithPackageName("com.yulong.android.security:remote"); /* Intent openQQ = getPackageManager().getLaunchIntentForPackage("com.yulong.android.security:remote"); startActivity(openQQ);*/ &#125; private void goVivoMainager() &#123; doStartApplicationWithPackageName("com.bairenkeji.icaller"); /* Intent openQQ = getPackageManager().getLaunchIntentForPackage("com.vivo.securedaemonservice"); startActivity(openQQ);*/ &#125; /** * 此方法在手机各个机型设置中已经失效 * * @return */ private Intent getAppDetailSettingIntent() &#123; Intent localIntent = new Intent(); localIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if (Build.VERSION.SDK_INT &gt;= 9) &#123; localIntent.setAction("android.settings.APPLICATION_DETAILS_SETTINGS"); localIntent.setData(Uri.fromParts("package", mContext.getPackageName(), null)); &#125; else if (Build.VERSION.SDK_INT &lt;= 8) &#123; localIntent.setAction(Intent.ACTION_VIEW); localIntent.setClassName("com.android.settings", "com.android.settings.InstalledAppDetails"); localIntent.putExtra("com.android.settings.ApplicationPkgName", mContext.getPackageName()); &#125; return localIntent; &#125; private void doStartApplicationWithPackageName(String packagename) &#123; // 通过包名获取此APP详细信息，包括Activities、services、versioncode、name等等 PackageInfo packageinfo = null; try &#123; packageinfo = mContext.getPackageManager().getPackageInfo(packagename, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; if (packageinfo == null) &#123; return; &#125; // 创建一个类别为CATEGORY_LAUNCHER的该包名的Intent Intent resolveIntent = new Intent(Intent.ACTION_MAIN, null); resolveIntent.addCategory(Intent.CATEGORY_LAUNCHER); resolveIntent.setPackage(packageinfo.packageName); // 通过getPackageManager()的queryIntentActivities方法遍历 List&lt;ResolveInfo&gt; resolveinfoList = mContext.getPackageManager() .queryIntentActivities(resolveIntent, 0); Log.e("PermissionPageManager", "resolveinfoList" + resolveinfoList.size()); for (int i = 0; i &lt; resolveinfoList.size(); i++) &#123; Log.e("PermissionPageManager", resolveinfoList.get(i).activityInfo.packageName + resolveinfoList.get(i).activityInfo.name); &#125; ResolveInfo resolveinfo = resolveinfoList.iterator().next(); if (resolveinfo != null) &#123; // packageName参数2 = 参数 packname String packageName = resolveinfo.activityInfo.packageName; // 这个就是我们要找的该APP的LAUNCHER的Activity[组织形式：packageName参数2.mainActivityname] String className = resolveinfo.activityInfo.name; // LAUNCHER Intent Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER); // 设置ComponentName参数1:packageName参数2:MainActivity路径 ComponentName cn = new ComponentName(packageName, className); intent.setComponent(cn); try &#123; mContext.startActivity(intent); &#125; catch (Exception e) &#123; goIntentSetting(); e.printStackTrace(); &#125; &#125; &#125;&#125; 另外：当前已适配测试的机型包括小米，华为，三星，锤子。代码仅供参考。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>代码片段</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Omniplan 5分钟入个门]]></title>
    <url>%2Fposts%2F3df11d4f.html</url>
    <content type="text"><![CDATA[https://xclient.info/s/omni-plan.html 00:00 什么要用omniplan？最近工作当中，对项目交付的要求越来越高了。 这意味着不能像之前那样，做完方案就丢给开发，然后到了指定时间再收获了。 那么怎么掌握项目全部的进度呢，用万能的excel画格子吗？ 画格子 当然在产品经理面前，Excel无所不能，上到画原型，下到数据库管理。但是在面对一个较大的项目的时候，仍然会有一些问题： 我的项目进度到哪了？ 项目瓶颈是什么？ 还有没有更好的项目组织的方案？ 这些问题的答案就是 omniplan。 00:30 打开omniplan看看什么，才过了30秒？是的。 安装下载omniplan可以直接到官网或者mac app store购买下载，对于一个生产力工具来说，价格不算贵。 当然你要是找到了别的渠道来下载……那我是管不着的。 界面 恩，这些红字加的很不优雅，但不重要。 左边是任务列表，可以加分组，中间是时间的甘特图，可以拖拽。上边是面板的切换。 右边是信息列表，可以填写一些更仔细的信息。 相信我，5分钟时间里，你基本是用不到右侧的这些内容的。 01:00 录入任务，分组点击左边的列表，就可以录入任务，打完之后按回车，快速新建下一个任务。 分组 另一个很有用的功能是多选多个任务，新建一个群组。群组的时间和进度会根据子任务计算。 同样的，你也可以拖拽任务上下移，排序，剪切，复制什么的。 01:20 给任务安排时间给任务安排时间很简单，鼠标放到蓝条的最右边，然后拖拽拉长就行。 我们都知道，任务实际上是存在逻辑顺序的，比如得先完成原型，才能做视觉，才能开始开发。 所以我们需要给这些任务加上关联关系： 拖拽这个右边的箭头关联到下一个任务上，就完成了 A任务完成时-B任务开始的逻辑。 omniplan会根据你的任务逻辑关系自动安排时间，看起来不错！ 02:00 节奏好像不对？所有的项目都安排好了时间，但是现在有两个时间上的问题： web上线好像是一个节点而不是一个时间段。 app发版是按固定节奏来的，并不是做完就上线，只有在发版之后，才算是开发完毕。 为了解决这个问题，我们需要另外两个表现任务节点的工具。 里程碑 弹性任务（omniplan中叫做吊床任务） 里程碑是一种没有时间消耗的任务，用来标记一个项目的状态变化，或者把一个大项目拆成若干阶段都是很好用的。 弹性任务很有意思，它自己本身的起点和终点都取决于前后的任务。在这个例子中，直到发版之前，工程师都可以继续对性能调优。 想要切换任务状态很简单，在右边信息面板中切换就行（怎么感觉打自己脸了）。 03:00 谁来负责？完成了所有项目节奏之后，接下来要解决的问题是人员安排的问题（当然你可以先把人员确定之后再安排时间节奏。） 点第二个视图，切换到下一个界面。 这里是资源列表（资源可以是人，也可以是设备，素材等。）考虑到我们的例子是个开发的项目，我添加一些工程师进去吧。 好像全是犬科动物……后面的单位表示这个人是全职（100%工时）。 接下来给他们把工作都分配一下，很简单，用拖动的办法。 这时返回任务面板看一下： 看起来不错！ 04:00 项目在运行项目开始运行起来之后，我们需要时刻关注其中的进度变化。 比如田园犬完成了自己的原型，我们需要在甘特图中标识出来。 拖动这个进度指示器来展示工作的进度。 如果任务建了分组，那么分组的进度也会变化。 04:30 糟糕，项目延误了！这大概是大家都不愿意遇到的问题，项目遇到了一些不按预期进展的情况。 这里假设一下，产品经理这几天状态不好，比实际上用时晚了一天。 本来23号设计师就开始工作了，但是因为产品经理不给力，导致24号才开始。这里我们需要将产品经理的用时拉长一天，其他的任务会一起后移。 怎么体现出来产品经理确实延误了呢？ 我们需要讲一下今天最后一个功能：基线。 这个功能是将当前的项目进度保存一份，方便与实际的进度进行比对。 点击面板切换右边的基线比对选项，直接选择 拆分：实际 vs 基线。 这么一比对就很清晰了 都是产品经理的锅！！ 05:00 结语五分钟时间带着大家飞快的过了一下核心的功能，但是omni家的这些软件其实功能都很强大，还有很多值得研究学习的。 希望大家都能把项目跑的平稳，吃好喝好不加班！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
        <tag>omniplan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Genymotion上不能安装APK软件的问题]]></title>
    <url>%2Fposts%2Ff1cdd64c.html</url>
    <content type="text"><![CDATA[Genymotion模拟器不能安装APK的原因官网给出的解释：Genymotion模拟器使用的是x86架构，在第三方市场上的应用有部分不采用x86这么一种架构，所以在编译的时候不通过，报“APP not installed”，可以下载Genymotion提供的ARM转换工具包，将应用市场中的ARM架构的apk转换成Genymotion可以编译的x86架构； 直接安装报错如下图：An error occured while deploying the file.This probably means that the app contains ARM native code and your Genymotion device cannot run ARM instructions. You should either build your native code to x86 or install an ARM translation tool in your device.部署文件时出错。这可能意味着应用程序包含本地ARM代码和你的genymotion设备无法运行ARM指令。你可以建立你的原生代码的x86或在您的设备上安装一个臂的翻译工具。 解决方法1.用Android Studio 创建一个ARM的虚拟机；（当然这个不是你想要的）2.下载Genymotion-ARM-Translation-Librarities工具转换包；下载路径： 链接:https://pan.baidu.com/s/1OOj72JqNnTtSZJnCXCoFzA 密码:p8c4 将下载号的工具包直接拖拽到Genymotion中，然后提示重启模拟器；]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Genymotion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完美解决Genymotion无法使用adb命令的问题]]></title>
    <url>%2Fposts%2Fc3520239.html</url>
    <content type="text"><![CDATA[我在运行Genymotion虚拟机进行android应用调试的时候，无法用Powershell(cmd)进入adb shell，显示的界面是这样的： 导致无法正常进行adb调试，找了很多方法都没用，后来修改了genymotion中的settings 中的ADB选项中的SDK路径，保持跟你当前应用的eclipse或者android studio中的SDK库一致，然后问题就解决了；]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Genymotion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活计划]]></title>
    <url>%2Fposts%2Fa5f172c4.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp3源码分析二]]></title>
    <url>%2Fposts%2F9c0f9a31.html</url>
    <content type="text"><![CDATA[1.前言 Android开发过程中，使用第三方的框架库已成家常便饭，使用第三方好处避免重复造轮子、降低成本、提升效率、降低风险等等，当遇到框架库不能满足现有业务、框架库设计缺陷或者漏洞、API使用深度不够时，如果停留只会使用层面，就会增加修改过程的难度，所以对于使用的框架库最好还是有个系统的认识； 本文带大家深入讲解 OkHttp； 2.目录 3.定义 一款处理网络请求的开源项目，由Square公司贡献。 4.作用 通过建造者模式（Builder Pattern）方式，完成复杂的网络请求。 5.特点 1.同时支持HTTP1.1与支持HTTP2.0； 2.同时支持同步与异步请求； 3.同时具备HTTP与WebSocket功能； 4.拥有自动维护的socket连接池，减少握手次数； 5.拥有队列线程池，轻松写并发； 6.拥有Interceptors(拦截器)，轻松处理请求与响应额外需求(例：请求失败重试、响应内容重定向等等)； 6.OkHttp系统图 7.OkHttpClient(封装请求参数) OkHttpClient通过建造者模式方式，完成请求参数配置。常用如下： connectTimeout ：连接超时 readTimeout：读取超时 writeTimeout：写入超时 pingInterval：websocket情况下连接心跳间隔 interceptors：自定义拦截器 networkInterceptors：自定义网络连接成功的拦截器 OkHttpClient 除了完成请求参数的配置之外，还提供获取WebSocket、Call(Call实现类为RealCall，下文会介绍)相关类； 7.1 WebSocket WebSocket是一种在单个TCP连接上进行全双工通信的协议，支持服务器想客户端的发送请求，由OkHttpClient创建，源码如下： 12345678/** * Uses &#123;@code request&#125; to connect a new web socket. */@Override public WebSocket newWebSocket(Request request, WebSocketListener listener) &#123; RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);// 1 webSocket.connect(this); return webSocket;&#125; 注释1：WebSocket是一个接口，它的实现类RealWebSocket，该类完成WebSocket的连接、数据请求与接收功能。 7.2 Call初始化1234567891011//OkHttpClient 初始化Call的函数@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125;// RealCall 初始化函数static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call;&#125; 8.RealCall同步异步 RealCall 是真正触发网络请求的类(实现Call接口，一次请求 = 一个RealCall实例)，它提供了同步请求、异步请求； 8.1 同步请求12345678910111213141516171819202122232425262728293031323334353637 @Override public Response execute() throws IOException &#123; // 处理不能重复请求，因为一个RealCall对应一个请求。 synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); try &#123; client.dispatcher().executed(this);//1 Response result = getResponseWithInterceptorChain();//2 if (result == null) throw new IOException("Canceled"); return result; &#125; catch (IOException e) &#123; eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis());//3 return chain.proceed(originalRequest);//4 &#125; 注释1：将RealCall实例添加至Dispatcher中(下文会介绍Dispatcher)。注释2：通过getResponseWithInterceptorChain()获取响应。注释3：通过封装好的拦截器集合，获取第一个拦截器的任务。注释4：触发第一个拦截器的任务，该任务就触发一下拦截器的任务，以此类推，原理(Android事件传递机制)如下图： 8.2 异步请求123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));//1&#125; 注释1：把AsyncCall请求对象传递进Dispatcher线程池管理； AsyncCall 将请求业务放入到Runnable中。 1234567891011121314151617181920212223242526final class AsyncCall extends NamedRunnable &#123; // ...... @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain();//2 if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125;&#125; 注释2：通过getResponseWithInterceptorChain()获取响应; 9.Dispatcher线程池 Dispatcher 管理网络请求的线程池，其实就是把同步(RealCall)与异步(AsyncCall)的请求放进集合中统一管理，然后通过线程池执行AsyncCall的请求。 9.1 Dispatcher中同步(RealCall) RealCall在Dispatcher中，其实主要就是一个存储功能(即用一个集合把RealCall的请求进行存储)。 9.2 Dispatcher中异步(AsyncCall) AsyncCall在Dispatcher中，除了使用集合存储AsyncCall的请求，Dispatcher还初始化了一个线程池(ThreadPoolExecutor)处理AsyncCall的网络请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public final class Dispatcher &#123; //最大请求数量 private int maxRequests = 64; //相同host的最大请求数据 private int maxRequestsPerHost = 5; // ...... public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false));//1 &#125; return executorService; &#125; // ...... synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;//2 runningAsyncCalls.add(call);//3 executorService().execute(call);//4 &#125; else &#123; readyAsyncCalls.add(call);//5 &#125; &#125; /** Used by &#123;@code AsyncCall#run&#125; to signal completion. */ void finished(AsyncCall call) &#123; finished(runningAsyncCalls, call, true); &#125; /** Used by &#123;@code Call#execute&#125; to signal completion. */ void finished(RealCall call) &#123; finished(runningSyncCalls, call, false);//6 &#125; private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls();//7 runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125; &#125; private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125; &#125; // ......&#125; 注释1：获取自定义线程池；注释2：判断正在执行的异步请求数量与请求集合中相同host的数量是否满足，如果满足就添加到执行中的集合中，并添加至线程池中执行请求；如果不满足就添加至待执行请求的集合中，等待执行中的请求完成之后，再执行相同host数量判断满足才添加至线程池中执行请求；注释3：将请求对象AsyncCall添加进请求执行的集合中；注释4：将请求对象AsyncCall添加进线程池中执行；注释5：当不满足执行条件时(注释2)，把请求对象添加至待执行的集合中；注释6：每当一个请求执行完毕时，就会调用finished()去掉对应集合中的存储对象，并在次判断待执行的集合中是否有满足条件的请求，若满足就添加至执行的集合与线程池中执行，若不满足继续等待下一个请求完成再次判断。注释7：判断待执行的集合中是否满足可执行的对象。 10.Interceptor拦截器及调用链 Interceptor 拦截器，供使用者可在请求过程或者响应过程中自定义额外的业务处理(例如：最常见的请求失败重试、响应数据的重定向等等)。 OkHttp3中，除了可自定义额外的拦截器之外，它内部也存储一些固定的拦截器处理其内部业务逻辑，下面就会介绍它们(RetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、CallServerInterceptor)； 10.1 RetryAndFollowUpInterceptor 定义：重定向拦截器； 作用：在无法请求服务器或者请求失败时，服务器会告诉客户端可以处理请求的url，然后重定向拦截器承当重新请求新url的作用(服务器返回3XX错误码为重定向，可以通过响应头的Location获取新请求的url); 10.2 BridgeInterceptor 定义：桥拦截器； 作用：封装请求头(Content-Type、Connection、Cookie…)与响应头(“Content-Encoding…)的信息。 10.3 CacheInterceptor 定义：缓存拦截器； 作用：为网络请求提供缓存功能，加快相同请求的访问速度，减少资源损耗。 10.4 ConnectInterceptor 定义：连接拦截器； 作用：与服务器建立通讯连接。 10.5 CallServerInterceptor 定义：请求服务器拦截器； 作用：与服务器进行数据通讯(包含请求头、请求内容)。 10.6 调用链 上文也提到任务链结构图(责任链模式)： 其实它的原理类似于(Android 事件传递机制)，向下传递请求，向上反馈响应，在调用RealInterceptorChain的proceed()时，创建下一个拦截器的任务，并通过拦截器中intercept()把任务传递至当前拦截器进行关联，然后以此类推，相关代码如下： 12345678910111213141516public final class RealInterceptorChain implements Interceptor.Chain &#123; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; // ...... // 创建下一个拦截器的任务 RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); // 获取当前任务中的拦截器 Interceptor interceptor = interceptors.get(index); // 将下一个任务传递至当前拦截器中进行关联，并在拦截器中传入的任务触发执行下一个拦截器 Response response = interceptor.intercept(next); // ...... return response; &#125;&#125; 11.缓存机制CacheInterceptor 看看缓存机制CacheInterceptor的实现原理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public final class CacheInterceptor implements Interceptor &#123; // .... @Override public Response intercept(Chain chain) throws IOException &#123; // 根据请求内容通过Cache类判断是否已经存在响应的缓存信息 Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); // 通过请求对象与缓存对象获取缓存策略，根据请求头的内容(Date、Expires、Last-Modified....)制定缓存策略 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; // 记录请求过程的相关数据（请求次数、缓存次数....） if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // 当请求头中包含only-if-cached时，networkRequest 与 cacheResponse 都为空，表示不进行网络请求 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // 不进行网络请求，并请求头包含缓存标识时，构建缓存内容. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; // 执行下一个拦截器任务 networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // 如果本地有缓存，并且响应结果为没有修改时，直接从本地缓存获取相关信息数据 if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // 更新响应对象至缓存中 cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; // 没有响应缓存时，封装请求返回的响应并添加至本地缓存中 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // 添加本地缓存中 CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; // 去掉（POST\PUT\DELETE\MOVE\PATCH）请求方法的本地缓存 if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125;&#125; 12.连接与请求（StreamAllocation，RealConnection，HttpCodec） OkHttp3把网络连接、请求数据通讯过程封装StreamAllocation，RealConnection，HttpCodec中； StreamAllocation：负责初始化RealConnection、HttpCodec，并将前2者与RealCall进行关联；1.StreamAllocation初始化(在RetryAndFollowUpInterceptor进行实例化) 12345678910public final class RetryAndFollowUpInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; //...... // 实例化 StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; //...... &#125;&#125; 2.RealConnection与HttpCodec初始化(RealConnection在ConnectInterceptor中通过StreamAllocation的newStream()初始化，而HttpCodec在RealConnection中被初始化) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final class ConnectInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); boolean doExtensiveHealthChecks = !request.method().equals("GET"); // 获取HttpCodec 对象 HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125;public final class StreamAllocation &#123; //...... public HttpCodec newStream( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; int connectTimeout = chain.connectTimeoutMillis(); int readTimeout = chain.readTimeoutMillis(); int writeTimeout = chain.writeTimeoutMillis(); int pingIntervalMillis = client.pingIntervalMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; // 初始化RealConnection，最后会调用RealConnection的connect函数建立网络连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); // 通过RealConnection 实例化HttpCpdec HttpCodec resultCodec = resultConnection.newCodec(client, chain, this); synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125; &#125;&#125;public final class RealConnection extends Http2Connection.Listener implements Connection &#123; public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation) throws SocketException &#123; //判断HTTP是否为Http2，如果是实例化Http2Codec，否则实例化Http1Codec if (http2Connection != null) &#123; return new Http2Codec(client, chain, streamAllocation, http2Connection); &#125; else &#123; socket.setSoTimeout(chain.readTimeoutMillis()); source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS); sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS); return new Http1Codec(client, streamAllocation, source, sink); &#125; &#125;&#125; RealConnection：真正的负责完成网络连接； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class RealConnection extends Http2Connection.Listener implements Connection &#123;public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) &#123; if (protocol != null) throw new IllegalStateException("already connected"); RouteException routeException = null; List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs(); ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs); if (route.address().sslSocketFactory() == null) &#123; if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123; throw new RouteException(new UnknownServiceException( "CLEARTEXT communication not enabled for client")); &#125; String host = route.address().url().host(); if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw new RouteException(new UnknownServiceException( "CLEARTEXT communication to " + host + " not permitted by network security policy")); &#125; &#125; else &#123; if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123; throw new RouteException(new UnknownServiceException( "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS")); &#125; &#125; while (true) &#123; try &#123; if (route.requiresTunnel()) &#123; connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) &#123; // We were unable to connect the tunnel but properly closed down our resources. break; &#125; &#125; else &#123; // 最后会调用socket.connect()进行网络连接 connectSocket(connectTimeout, readTimeout, call, eventListener); &#125; establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener); eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol); break; &#125; catch (IOException e) &#123; closeQuietly(socket); closeQuietly(rawSocket); socket = null; rawSocket = null; source = null; sink = null; handshake = null; protocol = null; http2Connection = null; eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e); if (routeException == null) &#123; routeException = new RouteException(e); &#125; else &#123; routeException.addConnectException(e); &#125; if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123; throw routeException; &#125; &#125; &#125; if (route.requiresTunnel() &amp;&amp; rawSocket == null) &#123; ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: " + MAX_TUNNEL_ATTEMPTS); throw new RouteException(exception); &#125; if (http2Connection != null) &#123; synchronized (connectionPool) &#123; allocationLimit = http2Connection.maxConcurrentStreams(); &#125; &#125; &#125;&#125; HttpCodec： 负责完成发送请求头与数据内容(使用okio完成数据的写入与读出)； Http1Codec：处理HTTP1.1协议的数据传递。 Http2Codec：处理HTTP2.0协议的数据传递。 13.实例 编写一个简单GET请求： 12345678910111213141516171819public void get()&#123; OkHttpClient okHttpClient = new OkHttpClient() .newBuilder()// .addInterceptor() .readTimeout(30, TimeUnit.SECONDS) .build(); Request request = new Request.Builder()// .header() .url("http://www.baidu.com") .build(); okHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; &#125; &#125;);&#125; 14.总结 到此，Android OkHttp3就讲解完毕。]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp3源码分析一]]></title>
    <url>%2Fposts%2F1eadb261.html</url>
    <content type="text"><![CDATA[一、OkHttp3流程图 二、源码整体架构 上图是OkHttp3的整体框架，大致可以分为以下几层： Interface——接口层：接收用户的网络访问请求（同步请求/异步请求），发起实际的网络访问 Protocol——协议层：处理协议逻辑 Connection——连接层：管理网络连接，发送新的请求，接收服务器访问 Cache——缓存层：管理本地缓存 I/O——I/O层：实际数据读写实现 Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑 2.1 Interface——接口层接口层接收用户的网络访问请求（同步请求/异步请求），发起实际的网络访问 OkHttpClient：是OkHttp框架的客户端，更确切的说是一个用户面板。用户使用OkHttp进行各种设置，发起各种网络请求都是通过OkHttpClient完成的。每个OkHttpClient内部都维护了属于自己的任务队列，连接池，Cache，拦截器等，所以在使用OkHttp作为网络框架时应该全局共享一个OkHttpClient实例。 Call：Call是描述一个实际的访问请求，用户的每一个网络请求都是一个Call实例。Call本身只是一个接口，定义了Call的接口方法，实际执行过程中，OkHttp会为每一个请求创建一个RealCall,每一个RealCall内部有一个AsyncCall，AsyncCall是RealCall的一个内部类并且继承NamedRunnable，那么首先看NamedRunnable类是什么样的，如下： 1234567891011121314public abstract class NamedRunnable implements Runnable &#123; ...... @Override public final void run() &#123; ...... try &#123; execute(); &#125; ...... &#125; protected abstract void execute();&#125; NamedRunnable实现了Runnable接口并且是一个抽象类，有一个抽象方法execute()，这个方法在run()中被调用。这也就意味着NamedRunnable是一个线程，并且其子类应该实现execute方法。下面再看AsyncCall的实现： 1234567891011121314151617181920212223242526272829final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super("OkHttp %s", redactedUrl()); this.responseCallback = responseCallback; &#125; ......final class RealCall implements Call &#123; @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; ...... responseCallback.onFailure(RealCall.this, e);&#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; AsyncCall继承NamedRunnable，实现了抽象方法execute（），所以每一个Call就是一个线程，而执行Call的过程就是执行其execute（）方法的过程。 Dispatcher(调度器)是OkHttp的任务队列，其内部维护了一个线程池，当有接收到一个Call时，Dispatcher负责在线程池中找到空闲的线程并执行其execute方法。 针对异步请求，Dispatcher使用了两个Deque，一个保存准备执行的请求，一个保存正在执行的请求，为什么要用两个呢？因为Dispatcher默认支持最大的并发请求是64个，单个Host最多执行5个并发请求，如果超过，则Call会先被放入到readyAsyncCall中，当出现空闲的线程时，再将readyAsyncCall中的线程移入到runningAsynCalls中，执行请求。 如果正在执行的请求总数&lt;=64 &amp;&amp; 单个Host正在执行的请求&lt;=5，则将请求加入到runningAsyncCalls集合中，紧接着就是利用线程池执行该请求，否则就将该请求放入readyAsyncCalls集合中。 2.2 Protocol——协议层Protocol层负责处理协议逻辑，OkHttp支持Http1/Http2/WebSocket协议，并在3.7版本中放弃了对Spdy协议，鼓励开发者使用Http/2。在早期的版本中，OkHttp支持Http1.0,1.1,SPDY协议，但是Http2协议的问世，导致OkHttp也做出了改变，OkHttp鼓励开发者使用HTTP2，不再对SPDY协议给予支持。另外，新版本的OkHttp还有一个新的亮点就是支持WebScoket，这样我们就可以非常方便的建立长连接了。在安全方便，OkHttp目前支持了TLS版本，以确保一个安全的Socket连接。 2.3 Connection——连接层：管理网络连接，发送新的请求，接收服务器访问连接层顾名思义就是负责网络连接。在连接层中有一个连接池，统一管理所有的Socket连接，当用户新发起一个网络请求时，OkHttp会首先从连接池中查找是否有符合要求的连接，如果有则直接通过该连接发送网络请求；否则新创建一个网络连接。虽然你只需要提供URL,但OkHttp计划它连接到您的网络服务器需要使用三种类型:URL,地址和路线. RealConnection：描述一个物理Socket连接，连接池中维护多个RealConnection实例。StreamAllocation： 由于Http/2支持多路复用，一个RealConnection可以支持多个网络访问请求，所以OkHttp又引入了StreamAllocation来描述一个实际的网络请求开销（从逻辑上一个Stream对应一个Call，但在实际网络请求过程中一个Call常常涉及到多次请求。如重定向，Authenticate等场景。所以准确地说，一个Stream对应一次请求，而一个Call对应一组有逻辑关联的Stream），一个RealConnection对应一个或多个StreamAllocation,所以StreamAllocation可以看做是RealConenction的计数器，当RealConnection的引用计数变为0，且长时间没有被其他请求重新占用就将被释放。 2.4 Cache——缓存层Cache层负责维护请求缓存，当用户的网络请求在本地已有符合要求的缓存时，OkHttp会直接从缓存中返回结果，从而节省网络开销。 缓存策略：提到缓存策略，就要提到CacheInterceptor拦截器，如下图 CacheStrategy实现缓存策略，CacheStrategy使用Factory模式进行构造，该类决定是使用缓存还是使用网络请求 Cache是封装了实际的缓存操作；DiskLruCache:Cache基于DiskLruCache； 2.5 I/O层I/O层负责实际的数据读写。OkHttp的另一大有点就是其高效的I/O操作，这归因于其高效的I/O库okio。 2.6 Inteceptor——拦截器层拦截器是一种强大的机制,可以监视、重写和重试调用。拦截器层提供了一个类AOP接口，方便用户可以切入到各个层面对网络访问进行拦截并执行相关逻辑。 三、为什么okHttp3 好用呢？OkHttp是一个精巧的网络请求库,有如下特性: 支持http2，对一台机器的所有请求共享同一个socket 内置连接池，支持连接复用，减少延迟 支持透明的gzip压缩响应体 通过缓存避免重复的请求 请求失败时自动重试主机的其他ip，自动重定向 好用的API 四、实现网络请求方法:OkHttp3的最底层是Socket，而不是URLConnection，它通过Platform的Class.forName()反射获得当前Runtime使用的socket库 socket发起网络请求的流程一般是：(1). 创建socket对象;(2). 连接到目标网络;(3). 进行输入输出流操作。 (1)(2)的实现，封装在connection接口中，具体的实现类是RealConnection。(3)是通过stream接口来实现，根据不同的网络协议，有Http1xStream和Http2xStream两个实现类由于创建网络连接的时间较久(如果是HTTP的话，需要进行三次握手)，而请求经常是频繁的碎片化的，所以为了提高网络连接的效率，OKHttp3实现了网络连接复用 五、运用到的设计模式：单例模式：（建议用单例模式创建okHttpClient）OkHttpClient， 可以通过 new OkHttpClient() 或 new OkHttpClient.Builder() 来创建对象， 但是—特别注意， OkHttpClient() 对象最好是共享的， 建议使用单例模式创建。 因为每个 OkHttpClient 对象都管理自己独有的线程池和连接池。 这一点很多同学，甚至在我经历的团队中就有人踩过坑， 每一个请求都创建一个 OkHttpClient 导致内存爆掉 *外观模式 : *OKHttpClient 里面组合了很多的类对象。其实是将OKHttp的很多功能模块，全部包装进这个类中，让这个类单独提供对外的API，这种设计叫做外观模式（外观模式：隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口） Builder模式 : OkHttpClient 比较复杂， 太多属性， 而且客户的组合需求多样化， 所以OKhttp使用建造者模式（Build模式：使用多个简单的对象一步一步构建成一个复杂的对象，一个 Builder 类会一步一步构造最终的对象） 工厂方法模式：Call接口提供了内部接口Factory(用于将对象的创建延迟到该工厂类的子类中进行，从而实现动态的配置，工厂方法模式。（工厂方法模式：这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。） 享元模式：在Dispatcher的线程池中，所用到了享元模式，一个不限容量的线程池 ， 线程空闲时存活时间为 60 秒。线程池实现了对象复用，降低线程创建开销，从设计模式上来讲，使用了享元模式。（享元模式：尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象，主要用于减少创建对象的数量，以减少内存占用和提高性能） 责任链模式：很明显，在okhttp中的拦截器模块，执行过程用到。OkHttp3 的拦截器链中， 内置了5个默认的拦截器，分别用于重试、请求对象转换、缓存、链接、网络读写（责任链模式：为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。） 策略模式 ：CacheInterceptor 实现了数据的选择策略， 来自网络还是来自本地？ 这个场景也是比较契合策略模式场景， CacheInterceptor 需要一个策略提供者提供它一个策略（锦囊）， CacheInterceptor 根据这个策略去选择走网络数据还是本地缓存。缓存的策略过程：1、 请求头包含 “If-Modified-Since” 或 “If-None-Match” 暂时不走缓存2、 客户端通过 cacheControl 指定了无缓存，不走缓存3、客户端通过 cacheControl 指定了缓存，则看缓存过期时间，符合要求走缓存。 4、 如果走了网络请求，响应状态码为 304（只有客户端请求头包含 “If-Modified-Since” 或 “If-None-Match” ，服务器数据没变化的话会返回304状态码，不会返回响应内容）， 表示客户端继续用缓存。 （策略模式：一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。） 六、源码中用到的几个重要的类及作用解释：OkhttpClient :对外的API，OKHttp的很多功能模块，全部包装进这个类；创建分为两种：一种是new OkHttpClient()的方式，另一种是使用建造者（Builder）模式 – new OkHttpClient.Builder()….Build()。那么这两种方式有什么区别呢？ 第一种：new OkHttpClient()，OkHttp做了很多工作，很多我们需要的参数在这里都获得默认值,也就是默认值设定。 第二种：默认的设置和第一种方式相同，但是我们可以利用建造者模式单独的设置每一个属性；注意事项：OkHttpClient强烈建议全局单例使用，因为每一个OkHttpClient都有自己单独的连接池和线程池，复用连接池和线程池能够减少延迟、节省内存。 RealCall类：集成Call类，从源代码中，可看到使用Call类，发送出（同步／异步）请求.RealCall的主要作用：发送请求，当中还有拦截器的建立过程，异步回调。 Dispatcher类（调度器，多线程）：保存同步和异步Call的地方，并负责执行异步AsyncCall 拦截器链：有用户自定义的interceptor、retryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、 networkInterceptors、CallServerInterceptor。依次通过以上拦截器，传递给RealCall中的ApplicationInterceptorChain。拦截器之所以可以依次调用，并最终再从后先前返回Response，都依赖于ApplicatiionInterceptorChain的proceed方法. HttpEngine类：OKhttp底层的实现]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android各系统版本新特性]]></title>
    <url>%2Fposts%2F50d707a8.html</url>
    <content type="text"><![CDATA[一. 低版本SDK如何实现高版本api？平时如果你的minSdk比较小，但是想调用高版本的一些API，android studio会提醒该方法在XX版本上才有，当前项目minSdk是多少。很多低版本的系统上就会找不到这个方法。 那怎么做呢？可以去support包中找相应的方法。 例如5.0才出的background tint，那么如果你的minSdk是小于5.0的话，那么studio就报错了，你可以去使用support-v4包中的DrawableCompat类。 例如：在5.0上如下调用 12Drawable d = getContext().getResources().getDrawable(R.drawable.defalut_icon_big);d.setTint(0xffffffff); 那么使用DrawableCompat可以这样调用： 12Drawable d = getContext().getResources().getDrawable(R.drawable.defalut_icon_big);DrawableCompat.setTint(d,0xffffffff); 在新的SDK上总是会出现让人眼前一亮非常方便好用的API。但是这些新的API呢在低版本的SDK上是没有的，所以当我们的minSdkVersion的版本低于新API所在的版本时，我们直接使用新API在编译时会出现报错。如果只是想解决编译报错的问题呢，Android给我们提供了两种注解的方式避免编译时报错： @SuppressLint @TargetApi 这两种方法又有什么区别呢？ .SupressLint 和 TargetApi SupressLint很显然的意思是忽略Lint检查，对于我们使用高版本API来说，可以使用@SuppressLint(“NewApi”)的方式让Lint在编译时忽略所调用API对版本的要求。而@TargetApi是忽略特定版本的API调用报错。 举个栗子：当你的项目minSdkVersion=9，你想使用API 11的新的方法时。此时，使用@TargetApi(11)和@SuppressLint(“NewApi”）的效果一样，代码都不会报错。但是如果你使用了Api 19才出现的新的方法时，在使用@TargetApi的方法中还是会给你报错，而在另一个方式中依然不会报错。 那这么讲使用@SuppressLint(“NewApi”)就更好了？ 二. Android 各版本特点Android 1.5（Cupcake纸杯蛋糕）： 智能虚拟键盘；使用widgets实现桌面个性化；在线文件夹(Live Folder)快速浏览在线数据；视频录制和分享；图片上传； 更快的标准兼容浏览器；Voice search 语音搜索；立体声蓝牙和免提电话 Android 1.6（Donut甜甜圈）： 完全重新设计的Android Market，可以显示更多的屏幕截图；手势支持，可以让开发者生成针对某个应用程序的手势库； 支持CDMA网络：中国电信的用户可以期待EVDO的Android手机了； TXT-2-Speech，支持了更多语言的发音，包括英语、法语、德语、意大利语等 快速搜索框，可直接搜索括联系人，音乐，浏览历史，书签等手机内容； 全新的拍照界面：新版相机程序启动速度快了39%，拍照间的延迟减少了28%； 应用程序耗电查看：这下好了，哪个软件耗多少电，现在一见了然了； 新增面向视觉或听觉困难人群的易用性插件； Linux内核升级到2.6.29； 其他：支持更多的屏幕分辨率，如WVGA，QVGA等 Android 2.0 （2.0~2.1 Eclair松饼（闪电泡芙））: 由于文件结构的改动优化，使得整个操作流畅性得到了很大的提升; 自带的Chrome Lite浏览器现在加入了对双击屏幕进行缩放的支持; 加强了网络社交功能，比如Facebook好友整合至联系人功能; 强化了语音识别的搜索控制。整个系统多处都支持语音控制，并拥有独立的控制面板; 谷歌地图服务更新，加入了全新的导航系统，甚至比转业的导航软件更为先进; 加入了原生微软Exchange邮件服务支持; 提供了多个不同帐户，统一的邮件收件箱; 只需双击就能上传图片至YouTube; 优化了驾车时的体验，新的“Car Home”应用程序为各功能提供了易于操作的快捷链接，还能方便地使用语音控制功能，便于用户驾车时使用 Android 2.1 可以同时绑定多个Google账号; 无线控件里有了VPN设置; 增加了连接到PC设置; 增强了语言和声音的转换功能，并加入了文字到语音转换; 全新的拨号界面，按键更大，更易于操作; 更多桌面Widget; 新的Google地图可以使用谷歌地图导航功能; 新的浏览器版本，加强了稳定性和网页渲染能力; 全局搜索功能加强; 全新的Market程序，搜索更快布局更合理 Android 2.2(Froyo冻酸奶): 全面支持Flash 10.1; 应用程序自动升级，让升级更加人性化; 支持应用程序安装在外置内存上; Linux内核将升级为最新的2.6.32版本，系统更加稳定; 对系统性能进一步优化，让手机有更多的运行内存; 增加了轨迹球LED指示灯变色这个新功能; 增加了对3D性能的优化，3D性能更加强大; FM功能也将在新系统中得到全面支持 Android 2.3(2.3 Gingerbread姜饼) 用户界面更美观; 提升游戏体验; 提升多媒体能力; 增加官方进程管理; 改善电源管理; NFC近场通信; 全局下载管理; 全新虚拟键盘; 原生支持前置前置摄像头; SIP网络电话 Android3.0到3.1(3.0 Honeycomb 蜂巢)：安卓3.0系统主要用于安卓的平板产品，画面动感，可操控性更强，代表有摩托罗拉的平板产品XOOM，3.1也已经发布，也主要用于平板产品。 Android4.0(4.0 Ice CreamSandwich)1、单一系统 Android 4.0将只提供一个版本，同时支持智能手机、平板电脑、电视等设备。2、一流的新UI3、开源 此前Android 3.0曾一度宣布不采取开源措施，然而谷歌深知Android系统一大成功特性就是开源。平板上吃到的苦头势必在全新的Android 4.0上避免，用户为中心的刷机资源一定会让Android 4.0锦上添花。 Android5.01、android 5.0 Hello 5.0 5.0的版本号就能告诉我们，这是一个大的升级版本。 2、基于Linux内核3.0 Linux刚刚发布Linux 3.0内核没多久，后来又更新到了3.0.1 。 3、通过Android Market购买音乐谷歌已经试水性质的推出了Google Music Beta ，允许上传2万首音乐到Google的云端服务器，自动创建播放列表在任何支持flash的设备上回放，我们有理由相信这种在Appstore影响下的数字视频、音频服务内容的提供也将会出现在Android上。 4、多核处理器优化现在各厂商都在推双核的智能手机，实际的效果如何我们不予评说，但Android 4.0将特别为使用双核乃至多核处理器的手机进行专门的优化。 5、运行速度比3.1提高1.8倍Google的人员只是这么一说，并没有提及这个性能具体体现在什么方面，因此我们不知道这是关于浏览器、GPU还是整体性能，只有等待。 6、集成Google电视和Chrome OS的智能停放 7、为OEM提供了官方的主题引擎 有了这个引擎，便可通过Google的升级程序更新到这些第三方的主题。 8、苹果游戏中心的一个真正的竞争者 9、支持现有的智能手机 据称现行所有运行Android 2.3的手机都有可能升级到4.0版本，这条消息是我喜闻乐见的，而Google官方的Nexus One和Nexus S将是第一批升级到4.0的手机。 10、新的摄影技巧以及虚拟摄像机 这将为开发者提供更丰富的摄像头控制API。 android 6.0锁屏下语音搜索 用户可以直接在锁屏状态下进行语音搜索，虽然现在的一些安卓手机支持语音唤醒功能，但这些语音唤醒都是第三方厂商开发的，而此次的Android 6.0在系统层面加入锁屏下语音搜索，这无疑会在体验上有一个明显的提升。 指纹识别 说到指纹识别，很多用户都会觉得现在的中高端安卓手机都支持，但事实上这些安卓手机的指纹识别都是各个厂商自行开发的并没有系统底层的支持。Android 6.0则在系统层面加入指纹识别，能提供原生指纹识别API，这不但降低了厂商开发指纹识别模块的成本，最重要的是原生指纹识别将会大大提升安卓手机的指纹识别支付安全性。 更完整的应用权限管理 在此前的原生安卓系统中有应用通知管理功能，但更为深入的应用权限管理只能靠第三方应用实现。Android 6.0进一步强化应用权限管理，应用权限管理也成为系统级的功能，不过这对于那些权限管理软件来说并不是什么好消息。 Doze电量管理 Android 6.0自带Doze电量管理功能，在“Doze”模式下，手机会在一段时间未检测到移动时，让应用休眠清杀后台进程减少功耗，谷歌表示，当屏幕处于关闭状态，平均续航时间提高30%。 Now on Tap功能 Now on Tap功能是和Google搜索紧密结合的功能，它可以让谷歌从任何应用中进行搜索。例如，在微信中聊天的时候提到餐馆，那么就可以在不跳转的情况下进行谷歌搜索。 App Links 通过App Links功能，Android平台能够向网络服务器提出申请，自主识别链接内容。直接跳转到App客户端中，改善用户体验，有利于让用户在体验更完善的App客户端完成更多操作。 此外，在Android 6.0谷歌还加入了Android Pay进一步强化移动支付，同时也是为了对抗Apple Pay。在发布会上谷歌表示Android 6.0将在下周开始推送，Nexus5/6/7/9以及Nexus Player将能够在第一时间得到升级。 Android7.0分屏多任务 进入后台多任务管理页面，然后按住其中一个卡片，然后向上拖动至顶部即可开启分屏多任务，支持上下分栏和左右分栏，允许拖动中间的分割线调整两个APP所占的比例。目前，安卓7.0开发者预览版支持全部第三方应用尝试分屏操作，但个别应用适配可能存在问题，分屏后可能导致界面显示不全等问题. 全新下拉快捷开关页 在安卓7.0中，下拉打开通知栏顶部即可显示5个用户常用的快捷开关，支持单击开关以及长按进入对应设置。如果继续下拉通知栏即可显示全部快捷开关，此外在快捷开关页右下角也会显示一个“编辑”按钮，点击之后即可自定义添加/删除快捷开关，或拖动进行排序。 通知消息快捷回复 安卓7.0加入了全新的API，支持第三方应用通知的快捷操作和回复，例如来电会以横幅方式在屏幕顶部出现，提供接听/挂断两个按钮；信息/社交类应用通知，还可以直接打开键盘，在输入栏里进行快捷回复。 通知消息归拢 安卓7.0会将同一应用的多条通知提示消息归拢为一项，点击该项即可展开此前的全部通知，允许用户对每个通知执行单独操作。 夜间模式 安卓7.0中重新加入了夜间深色主题模式，该功能依然需要在系统调谐器中开启，从顶部下划打开快捷设置页，然后长按其中的设置图标，齿轮旋转10秒钟左右即可提示已开启系统调谐器，之后用户在设置中即可找到“系统调谐器”设置项。点开其中的“色彩和外观”，即可找到夜间模式，开启后即可使用全局的深色主题模式，同时亮度和色彩也会进行一定的调整，该功能可以基于时间或地理位置自动开启。另外，系统调谐器中也提供了RGB红绿蓝三色调节滑动条，允许用户手动精细调节，例如减少蓝色或增加红色以提供类似护眼模式的效果。 流量保护模式 安卓7.0新增的流量保护模式不仅可以禁止应用在后台使用流量，还会进一步减少该应用在前台时的流量使用。其具体实现原理目前尚不清楚，推测其有可能使用了类似Chrome浏览器的数据压缩技术。此外，谷歌还扩展了ConnectivityManager API的能力，使得应用可以检测系统是否开启了流量保护模式，或者检测自己是否在白名单中。安卓7.0允许用户单独针对每个应用，选择是否开启数据保护模式。 全新设置样式 安卓7.0启用了全新的设置样式，首先每个分类下各个子项之间的分割线消失了，只保留分类之间的分割线。全新的设置菜单还提供了一个绿色的顶栏，允许用户通过后方的下拉箭头，快速设定勿扰模式等。除了勿扰模式外，顶栏菜单还可以显示诸多其他的设置状态，例如数据流量的使用情况，自动亮度是否开启等。谷歌也在安卓7.0的设置中加入了汉堡菜单，在二级设置界面中的左上角，你就会看到这个汉堡菜单，点击后即可看到所有设置项，方便用户快速跳转。 改进的Doze休眠机制 谷歌在安卓7.0中对Doze休眠机制做了进一步的优化，在此前的安卓6.0中，Doze深度休眠机制对于改善安卓的续航提供了巨大的作用。而在安卓7.0中，谷歌对Doze进行了更多的优化，休眠机制的使用规则和场景有所扩展，例如只要手动在后台删掉应用卡片，关屏后该应用就会被很快深度休眠。 系统级电话黑名单功能 安卓7.0将电话拦截功能变成了一个系统级功能。其它应用可以调用这个拦截名单，但只有个别应用可以写入，包括拨号应用、默认的短信应用等。被拦截号码将不会出现在来电记录中，也不会出现通知。另外用户也可以通过账户体系备份和恢复这个拦截名单，以便快速导入其它设备或账号。 菜单键快速应用切换 双击菜单键，就能自动切换到上一个应用。此外，如果你不停地点击菜单键的话，就会在所有应用中不间断地轮换，应用窗口会自动放大，顶部还会出现倒计时条，停止点击且倒计时结束后，当前应用会自动放大并返回到前台。 Android8.0的正式版 Android Oreo（奥利奥）1.通知中心 用户在通知界面可以发现顶部的快捷键有了更充裕的空间，并且根据网络大数据的用户使用频繁度调整了这几个快捷键的顺序；并且长按推送消息可以看到一个开关，操作它可以开启和关闭这个该应用的未来所有通知。 2.设置菜单 在新的AndroidO系统中，设置的界面有了大幅变化，主菜单的覆盖性变得更广，更多的功能将在子菜单中体现，并且在菜单界面中重新设计了很多图标。 3.PinnedShortcuts 安卓创造出了PinnedShortcuts功能，类似苹果的3DTouch，长按一个软件后可以弹出子菜单，然后就可以通过这个方式快捷的使用该应用的部分功能。 4.图标形状 新的系统中开发者可以使用不同的应用图标，比如圆角矩形或者圆形图标，不过所有的图标需要保证是同一个形状，不能有一个方一个圆这样“个性”的样式出现。 5.后台限制 AndroidO将进一步优化后台程序，减少应用在没完全退出后占用系统的资源，并且减少电量的消耗。 6.安装限制 新系统中用户可以在权限设置中添加安装限制功能，这样可以有效的避免带有中国特色的“全家桶”行为。 7.TensorFlowLite 这个新功能并不会直接体现在手机和系统中，它是谷歌的一项新技术，用来把人工智能在更多的软件上继续拓展，并提高工作处理的效率，让你的手机更“聪明”。 8.分屏 在AndroidO中，分屏画中画功能得到了强化，变得更加流畅，而且悬浮窗可以随意拖动位置，然后在主屏幕中继续工作 NotificationDots 在谷歌的Pixel手机上，安卓8还新加了通知功能Notification Dots，会标出用户的行程、信息等，有些通知还可以被设定为稍后提醒。此外长按某个应用图标现在可以显示一些信息，与iOS上的3D Touch类似，这项功能在安卓7.0上已经有所体现 10.SmartTextSelection 系统将会预测用户将使用某些电话或者其他选项出现在将会用到的应用中，举个例子就是如果邀请朋友来吃饭，系统会根据发送的地址来开启地图并且导航 。 11.自动保存密码 这个功能将会保存用户的部分帐号和密码，用于在网站或者应用中的快速登录，效率提升了不少 。 12.GooglePlayProtect 这个功能主要用于GooglePlay中，下载的应用和游戏将会经过它的排查，来看看是否是有害甚至携带病毒的应用，不过国内用户可能不能访问GooglePlay 。 13.应用加速 在AndroidO中，大部分应用的启动速度将会快上一倍，这个要归功于新系统的优化，使后台占用资源减少，并且对并发进程等问题的处理更加出色，也是个相当有用的功能 。 14.字体优化 AndroidO中谷歌还增加了对系统字体的更多支持，开发者可以自行更改字体样式，让用户有了更多字体的选择 。 15.表情符号 安卓8还带来了符合Unicode 10标准的表情符号，比原来新加超过60个表情符，这也是比较明显的改变之一 AndroidP 9.0新功能包括：谷歌统一推送升级、深度集成Project Treble模式、更加封闭、原生支持通话录音等。 1.全面屏的全面支持 2.通知栏的多种通知 3.多摄像头的更多画面 4.GPS定位之外的WiFi定位 5.网络还有神经网络 6.Material Design迎来2.0时代 新设计： Android 9.0将会新增支持类似于iPhone X的刘海屏设计，具体体现为优化屏幕内容显示，能够让系统或者应用充分利用整块屏幕，尤其是两只“猫耳朵”位置。在Android 9.0系统当中，谷歌还会进一步将谷歌助手集成到应用中、进一步优化电池续航、支持多屏和可折叠屏等。 新特性： 全局黑夜模式 为具备Always-on display（屏幕常显）功能手机加入原生的天气支持。 AndroidQ 10.0暗黑模式 Android Q 的暗黑模式和 Android Pie 的暗黑模式不同，在 Android Q 中，暗黑模式适用于任何地方，如果应用不支持暗黑模式，那么系统将自动设置一个暗黑模式。 隐私增强 Android Q 还将更多地使用 Android Pie 中推出的隐私功能。 在 Android Q中，您可以选择应用程序在后台运行时是否可以访问该位置。 运营商锁定 如果你从运营商那里购买锁定的 Android Q 设备，他们将有能力阻止你使用其他特定运营商的SIM卡。 多显示器支持 系统底层支持将设备连接到外接的显示器，并可以同时使用两个屏幕显示。如手机/平板电脑或独立显示器，实际效果可以参考已经从第三方获得支持的华为Mate 10、三星Galaxy Note 9。 Vulkan API 系统底层支持用于 UI 呈现的 Vulkan API 接口规范，基于这项技术原理的更多扩展，将完成更强的系统及程序优化，以更好的获得延长电池寿命、实现更流畅的动画展现和菜单转换效果。 面部识别 XDA 团队发现了一串字符串，这些字符串表明 Android 10 将具有内部面部识别功能。 这意味着谷歌官方支持面部解锁系统。 桌面模式 Android Q 将支持桌面模式，类似三星 Dex 和华为的投影模式。它提供类似一个类似于 PC 的体验，但是远远不能代替 PC。 屏幕录制 得益于OPPO、三星和华为等第三方OEM厂商，我们以前在安卓手机上见过录屏功能。遗憾的是，原生安卓系统还缺少这个功能，但看起来我们在Android Q系统上终于要看到它了。 更安全Smart Lock 谷歌早在Android Lollipop时代就引入了Smart Lock功能，本质上就是当你的手机不在身边时，你可以把远程它锁起来。这个功能还可以让用户根据位置(比如家和二公司)、不同的蓝牙设备(比如运动手环)，或者不同的使用时间来自动解锁设备。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android权限大全]]></title>
    <url>%2Fposts%2Fcf915ee9.html</url>
    <content type="text"><![CDATA[概述Android安全架构规定：默认情况下，任何应用都没有权限执行对其他应用、操作系统或用户有不利影响的任何操作。这包括读写用户的私有数据（如联系人或电子邮件等）、读写其他应用的文件、执行网络访问、使设备保持唤醒状态等等。如果要使用这些受保护的设备功能，首先要在应用的清单文件(AndroidManifest.xml)中添加一个或多个 标记： 12345&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.android.app.myapp" &gt; &lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt; ...&lt;/manifest&gt; 概述 权限 说明 访问登记属性 android.permission.ACCESS_CHECKIN_PROPERTIES 读取或写入登记check-in数据库属性表的权限 获取错略位置 android.permission.ACCESS_COARSE_LOCATION 通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米 获取精确位置 android.permission.ACCESS_FINE_LOCATION 通过GPS芯片接收卫星的定位信息，定位精度达10米以内 访问定位额外命令 android.permission.ACCESS_LOCATION_EXTRA_COMMANDS 允许程序访问额外的定位提供者指令 获取模拟定位信息 android.permission.ACCESS_MOCK_LOCATION 获取模拟定位信息，一般用于帮助开发者调试应用 获取网络状态 android.permission.ACCESS_NETWORK_STATE 获取网络信息状态，如当前的网络连接是否有效 访问Surface Flinger android.permission.ACCESS_SURFACE_FLINGER Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 获取WiFi状态 android.permission.ACCESS_WIFI_STATE 获取当前WiFi接入的状态以及WLAN热点的信息 账户管理 android.permission.ACCOUNT_MANAGER 获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 验证账户 android.permission.AUTHENTICATE_ACCOUNTS 允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 电量统计 android.permission.BATTERY_STATS 获取电池电量统计信息 绑定小插件 android.permission.BIND_APPWIDGET 允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 绑定设备管理 android.permission.BIND_DEVICE_ADMIN 请求系统管理员接收者receiver，只有系统才能使用 绑定输入法 android.permission.BIND_INPUT_METHOD 请求InputMethodService服务，只有系统才能使用 绑定RemoteView android.permission.BIND_REMOTEVIEWS 必须通过RemoteViewsService服务来请求，只有系统才能用 绑定壁纸 android.permission.BIND_WALLPAPER 必须通过WallpaperService服务来请求，只有系统才能用 使用蓝牙 android.permission.BLUETOOTH 允许程序连接配对过的蓝牙设备 蓝牙管理 android.permission.BLUETOOTH_ADMIN 允许程序进行发现和配对新的蓝牙设备 变成砖头 android.permission.BRICK 能够禁用手机，非常危险，顾名思义就是让手机变成砖头 应用删除时广播 android.permission.BROADCAST_PACKAGE_REMOVED 当一个应用在删除时触发一个广播 收到短信时广播 android.permission.BROADCAST_SMS 当收到短信时触发一个广播 连续广播 android.permission.BROADCAST_STICKY 允许一个程序收到广播后快速收到下一个广播 WAP PUSH广播 android.permission.BROADCAST_WAP_PUSH WAP PUSH服务收到后触发一个广播 拨打电话 android.permission.CALL_PHONE 允许程序从非系统拨号器里输入电话号码 通话权限 android.permission.CALL_PRIVILEGED 允许程序拨打电话，替换系统的拨号器界面 拍照权限 android.permission.CAMERA 允许访问摄像头进行拍照 改变组件状态 android.permission.CHANGE_COMPONENT_ENABLED_STATE 改变组件是否启用状态 改变配置 android.permission.CHANGE_CONFIGURATION 允许当前应用改变配置，如定位 改变网络状态 android.permission.CHANGE_NETWORK_STATE 改变网络状态如是否能联网 改变WiFi多播状态 android.permission.CHANGE_WIFI_MULTICAST_STATE 改变WiFi多播状态 改变WiFi状态 android.permission.CHANGE_WIFI_STATE 改变WiFi状态 清除应用缓存 android.permission.CLEAR_APP_CACHE 清除应用缓存 清除用户数据 android.permission.CLEAR_APP_USER_DATA 清除应用的用户数据 底层访问权限 android.permission.CWJ_GROUP 允许CWJ账户组访问底层信息 手机优化大师扩展权限 android.permission.CELL_PHONE_MASTER_EX 手机优化大师扩展权限 控制定位更新 android.permission.CONTROL_LOCATION_UPDATES 允许获得移动网络定位信息改变 删除缓存文件 android.permission.DELETE_CACHE_FILES 允许应用删除缓存文件 删除应用 android.permission.DELETE_PACKAGES 允许程序删除应用 电源管理 android.permission.DEVICE_POWER 允许访问底层电源管理 应用诊断 android.permission.DIAGNOSTIC 允许程序到RW到诊断资源 禁用键盘锁 android.permission.DISABLE_KEYGUARD 允许程序禁用键盘锁 转存系统信息 android.permission.DUMP 允许程序获取系统dump信息从系统服务 状态栏控制 android.permission.EXPAND_STATUS_BAR 允许程序扩展或收缩状态栏 工厂测试模式 android.permission.FACTORY_TEST 允许程序运行工厂测试模式 使用闪光灯 android.permission.FLASHLIGHT 允许访问闪光灯 强制后退 android.permission.FORCE_BACK 允许程序强制使用back后退按键，无论Activity是否在顶层 访问账户Gmail列表 android.permission.GET_ACCOUNTS 访问GMail账户列表 获取应用大小 android.permission.GET_PACKAGE_SIZE 获取应用的文件大小 获取任务信息 android.permission.GET_TASKS 允许程序获取当前或最近运行的应用 允许全局搜索 android.permission.GLOBAL_SEARCH 允许程序使用全局搜索功能 硬件测试 android.permission.HARDWARE_TEST 访问硬件辅助设备，用于硬件测试 注射事件 android.permission.INJECT_EVENTS 允许访问本程序的底层事件，获取按键、轨迹球的事件流 安装定位提供 android.permission.INSTALL_LOCATION_PROVIDER 安装定位提供 安装应用程序 android.permission.INSTALL_PACKAGES 允许程序安装应用 内部系统窗口 android.permission.INTERNAL_SYSTEM_WINDOW 允许程序打开内部窗口，不对第三方应用程序开放此权限 访问网络 android.permission.INTERNET 访问网络连接，可能产生GPRS流量 结束后台进程 android.permission.KILL_BACKGROUND_PROCESSES 允许程序调用killBackgroundProcesses(String).方法结束后台进程 管理账户 android.permission.MANAGE_ACCOUNTS 允许程序管理AccountManager中的账户列表 管理程序引用 android.permission.MANAGE_APP_TOKENS 管理创建、摧毁、Z轴顺序，仅用于系统 高级权限 android.permission.MTWEAK_USER 允许mTweak用户访问高级系统权限 社区权限 android.permission.MTWEAK_FORUM 允许使用mTweak社区权限 软格式化 android.permission.MASTER_CLEAR 允许程序执行软格式化，删除系统配置信息 修改声音设置 android.permission.MODIFY_AUDIO_SETTINGS 修改声音设置信息 修改电话状态 android.permission.MODIFY_PHONE_STATE 修改电话状态，如飞行模式，但不包含替换系统拨号器界面 格式化文件系统 android.permission.MOUNT_FORMAT_FILESYSTEMS 格式化可移动文件系统，比如格式化清空SD卡 挂载文件系统 android.permission.MOUNT_UNMOUNT_FILESYSTEMS 挂载、反挂载外部文件系统 允许NFC通讯 android.permission.NFC 允许程序执行NFC近距离通讯操作，用于移动支持 永久Activity android.permission.PERSISTENT_ACTIVITY 创建一个永久的Activity，该功能标记为将来将被移除 处理拨出电话 android.permission.PROCESS_OUTGOING_CALLS 允许程序监视，修改或放弃播出电话 读取日程提醒 android.permission.READ_CALENDAR 允许程序读取用户的日程信息 读取联系人 android.permission.READ_CONTACTS 允许应用访问联系人通讯录信息 屏幕截图 android.permission.READ_FRAME_BUFFER 读取帧缓存用于屏幕截图 读取收藏夹和历史记录 com.android.browser.permission.READ_HISTORY_BOOKMARKS 读取浏览器收藏夹和历史记录 读取输入状态 android.permission.READ_INPUT_STATE 读取当前键的输入状态，仅用于系统 读取系统日志 android.permission.READ_LOGS 读取系统底层日志 读取电话状态 android.permission.READ_PHONE_STATE 访问电话状态 读取短信内容 android.permission.READ_SMS 读取短信内容 读取同步设置 android.permission.READ_SYNC_SETTINGS 读取同步设置，读取Google在线同步设置 读取同步状态 android.permission.READ_SYNC_STATS 读取同步状态，获得Google在线同步状态 重启设备 android.permission.REBOOT 允许程序重新启动设备 开机自动允许 android.permission.RECEIVE_BOOT_COMPLETED 允许程序开机自动运行 接收彩信 android.permission.RECEIVE_MMS 接收彩信 接收短信 android.permission.RECEIVE_SMS 接收短信 接收Wap Push android.permission.RECEIVE_WAP_PUSH 接收WAP PUSH信息 录音 android.permission.RECORD_AUDIO 录制声音通过手机或耳机的麦克 排序系统任务 android.permission.REORDER_TASKS 重新排序系统Z轴运行中的任务 结束系统任务 android.permission.RESTART_PACKAGES 结束任务通过restartPackage(String)方法，该方式将在外来放弃 发送短信 android.permission.SEND_SMS 发送短信 设置Activity观察器 android.permission.SET_ACTIVITY_WATCHER 设置Activity观察器一般用于monkey测试 设置闹铃提醒 com.android.alarm.permission.SET_ALARM 设置闹铃提醒 设置总是退出 android.permission.SET_ALWAYS_FINISH 设置程序在后台是否总是退出 设置动画缩放 android.permission.SET_ANIMATION_SCALE 设置全局动画缩放 设置调试程序 android.permission.SET_DEBUG_APP 设置调试程序，一般用于开发 设置屏幕方向 android.permission.SET_ORIENTATION 设置屏幕方向为横屏或标准方式显示，不用于普通应用 设置应用参数 android.permission.SET_PREFERRED_APPLICATIONS 设置应用的参数，已不再工作具体查看addPackageToPreferred(String)介绍 设置进程限制 android.permission.SET_PROCESS_LIMIT 允许程序设置最大的进程数量的限制 设置系统时间 android.permission.SET_TIME 设置系统时间 设置系统时区 android.permission.SET_TIME_ZONE 设置系统时区 设置桌面壁纸 android.permission.SET_WALLPAPER 设置桌面壁纸 设置壁纸建议 android.permission.SET_WALLPAPER_HINTS 设置壁纸建议 发送永久进程信号 android.permission.SIGNAL_PERSISTENT_PROCESSES 发送一个永久的进程信号 状态栏控制 android.permission.STATUS_BAR 允许程序打开、关闭、禁用状态栏 访问订阅内容 android.permission.SUBSCRIBED_FEEDS_READ 访问订阅信息的数据库 写入订阅内容 android.permission.SUBSCRIBED_FEEDS_WRITE 写入或修改订阅内容的数据库 显示系统窗口 android.permission.SYSTEM_ALERT_WINDOW 显示系统窗口 更新设备状态 android.permission.UPDATE_DEVICE_STATS 更新设备状态 使用证书 android.permission.USE_CREDENTIALS 允许程序请求验证从AccountManager 使用SIP视频 android.permission.USE_SIP 允许程序使用SIP视频服务 使用振动 android.permission.VIBRATE 允许振动 唤醒锁定 android.permission.WAKE_LOCK 允许程序在手机屏幕关闭后后台进程仍然运行 写入GPRS接入点设置 android.permission.WRITE_APN_SETTINGS 写入网络GPRS接入点设置 写入日程提醒 android.permission.WRITE_CALENDAR 写入日程，但不可读取 写入联系人 android.permission.WRITE_CONTACTS 写入联系人，但不可读取 写入外部存储 android.permission.WRITE_EXTERNAL_STORAGE 允许程序写入外部存储，如SD卡上写文件 写入Google地图数据 android.permission.WRITE_GSERVICES 允许程序写入Google Map服务数据 写入收藏夹和历史记录 com.android.browser.permission.WRITE_HISTORY_BOOKMARKS 写入浏览器历史记录或收藏夹，但不可读取 读写系统敏感设置 android.permission.WRITE_SECURE_SETTINGS 允许程序读写系统安全敏感的设置项 读写系统设置 android.permission.WRITE_SETTINGS 允许读写系统设置项 编写短信 android.permission.WRITE_SMS 允许编写短信 写入在线同步设置 android.permission.WRITE_SYNC_SETTINGS 写入Google在线同步设置]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的绘制流程]]></title>
    <url>%2Fposts%2Fbfd836fe.html</url>
    <content type="text"><![CDATA[Android 中 Activity 是作为应用程序的载体存在，代表着一个完整的用户界面，提供了一个窗口来绘制各种视图，当 Activity 启动时，我们会通过 setContentView 方法来设置一个内容视图，这个内容视图就是用户看到的界面。 PhoneWindow 是 Android 系统中最基本的窗口系统，每个 Activity 会创建一个。PhoneWindow 是 Activity 和 View 系统交互的借口。DecorView 本质上是一个 FrameLayout，是 Activity 中所有 View 的祖先。 绘制的整体流程当一个应用启动时，会启动一个主 Activity，Android 系统会根据 Activity 的布局来对它进行绘制。绘制会从根视图 ViewRoot 的 performTraversals() 方法开始，从上到下遍历整个视图树，每个 View 控制负责绘制自己，而 ViewGroup 还需要负责通知自己的子 View 进行绘制操作。视图操作的过程可以分为三个步骤，分别是测量(Measure)、布局(Layout)和绘制(Draw)。performTraversals 方法在类 ViewRootImpl 内，其核心代码如下。 1234567891011int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);...// 测量performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);...// 布局performLayout(lp, mWidth, mHeight);...// 绘制performDraw(); MeasureSpecMeasureSpec 表示的是一个 32 位的整数值，它的高 2 位表示测量模式 SpecMode，低 30 位表示某种测量模式下的规格大小 SpecSize。MeasureSpec 是 View 类的一个静态内部类，用来说明应该如何测量这个View。 三种测量模式。 UNSPECIFIED：不指定测量模式，父视图没有限制子视图的大小，子视图可以是想要的任何尺寸，通常用于系统内部，应用开发中很少使用到。 EXACTLY：精确测量模式，当该视图的 layout_width 或者 layout_height 指定为具体数值或者 match_parent 时生效，表示父视图已经决定了子视图的精确大小，这种模式下 View 的测量值就是 SpecSize 的值。 AT_MOST：最大值模式，当前视图的 layout_width 或者 layout_height 指定为 wrap_content 时生效，此时子视图的尺寸可以是不超过父视图运行的最大尺寸的任何尺寸。 对 DecorView 而言，它的 MeasureSpec 由窗口尺寸和其自身的 LayoutParams 共同决定；对于普通的 View，它的 MeasureSpec 由父视图的 MeasureSpec 和其本身的 LayoutParams 共同决定。 MeasureMeasure 用来计算 View 的实际大小。页面的测量流程从 performMeasure 方法开始。 1234567891011private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 具体操作是分发给 ViewGroup 的，由 ViewGroup 在它的 measureChild 方法中传递给子 View。ViewGroup 通过遍历自身所有的子 View，并逐个调用子 View 的 measure 方法实现测量操作。 123456789101112131415161718192021222324// 遍历测量 ViewGroup 中所有的 Viewprotected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125;// 测量某个指定的 Viewprotected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; View (ViewGroup) 的 Measure 方法，最终的测量是通过回调 onMeasure 方法实现的，这个通常由 View 的特定子类自己实现，可以通过重写这个方法实现自定义 View。 1234567891011121314151617181920212223242526272829public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... onMeasure(widthMeasureSpec, heightMeasureSpec); ....&#125;// 如果需要自定义测量，子类需重写这个方法protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125;// 如果 View 没有重写onMeasure 方法，默认会直接调用 getDefaultSize public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; LayoutLayout 过程用来确定 View 在父容器的布局位置，他是父容器获取子 View 的位置参数后，调用子 View 的 layout 方法并将位置参数传入实现的。ViewRootImpl 的 performLayout 代码如下。 123456private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; ... host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...&#125; View 的 layout 方法代码。 1234567public void layout(int l, int t, int r, int b) &#123; onLayout(changed, l, t, r, b);&#125;// 空方法，子类如果是 ViewGroup 类型，则重写这个方法，实现 ViewGroup 中所有 View 控件布局protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; DrawDraw 操作用来将控件绘制出来，绘制的流程从 performDraw 方法开始。performDraw 方法在类 ViewRootImpl 内，其核心代码如下。 123456789101112131415161718private void performDraw() &#123; boolean canUseAsync = draw(fullRedrawNeeded);&#125;private boolean draw(boolean fullRedrawNeeded) &#123; ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) &#123; return false; &#125;&#125;private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets) &#123; ... mView.draw(canvas); ...&#125; 最终调用到每个 View 的 draw 方法绘制每个具体的 View，绘制基本上可以分为六个步骤。 123456789101112131415161718192021222324public void draw(Canvas canvas) &#123; ... // Step 1, draw the background, if needed if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; ... // Step 2, save the canvas' layers saveCount = canvas.getSaveCount(); ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers canvas.drawRect(left, top, right, top + length, p); ... canvas.restoreToCount(saveCount); ... // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas);&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中RelativeLayout和LinearLayout性能分析]]></title>
    <url>%2Fposts%2Fe61a64df.html</url>
    <content type="text"><![CDATA[Optimizing Layout HierarchiesIt is a common misconception that using the basic layout structures leads to the most efficient layouts. However, each widget and layout you add to your application requires initialization, layout, and drawing. For example, using nested instances of LinearLayout can lead to an excessively deep view hierarchy. Furthermore, nesting several instances ofLinearLayout that use the layout_weight parameter can be especially expensive as each child needs to be measured twice. This is particularly important when the layout is inflated repeatedly, such as when used in a ListViewor GridView. 这句话是对减少布局层次的描述。 有一个误解就是，使用基类布局可用产生更有效的布局方式。然而每一个你添加到application里面的控件和布局，都需要初始化，布局，绘制。例如，布局复杂的时候使用LinearLayout，会导致深层次的布局嵌套问题，而进一步来说，使用LinearLayout的weight属性给每个子view去分配位置的时候，会导致每一个子view被绘制两次，而LinearLayout嵌套LinearLayout使用weight会更加严重。如果布局被重复的inflated的话，当我们使用ListView或者GridView的时候就会特别明显的影响绘制效率。 先看一些现象吧：用eclipse或者Android studio，新建一个Activity自动生成的布局文件都是RelativeLayout，或许你会认为这是IDE的默认设置问题，其实不然，这是由 android-sdk\tools\templates\activities\BlankActivity\root\res\layout\activity_simple.xml.ftl 这个文件事先就定好了的，也就是说这是Google的选择，而非IDE的选择。那SDK为什么会默认给开发者新建一个默认的RelativeLayout布局呢？当然是因为RelativeLayout的性能更优，性能至上嘛。但是我们再看看默认新建的这个RelativeLayout的父容器，也就是当前窗口的顶级View——DecorView，它却是个垂直方向的LinearLayout，上面是标题栏，下面是内容栏。那么问题来了，Google为什么给开发者默认新建了个RelativeLayout，而自己却偷偷用了个LinearLayout，到底谁的性能更高，开发者该怎么选择呢？ View的一些基本工作原理先通过几个问题，简单的了解写android中View的工作原理吧。 View是什么？简单来说，View是Android系统在屏幕上的视觉呈现，也就是说你在手机屏幕上看到的东西都是View。 View是怎么绘制出来的？View的绘制流程是从ViewRoot的performTraversals（）方法开始，依次经过measure（），layout（）和draw（）三个过程才最终将一个View绘制出来。 View是怎么呈现在界面上的？Android中的视图都是通过Window来呈现的，不管Activity、Dialog还是Toast它们都有一个Window，然后通过WindowManager来管理View。Window和顶级View——DecorView的通信是依赖ViewRoot完成的。 View和ViewGroup什么区别？不管简单的Button和TextView还是复杂的RelativeLayout和ListView，他们的共同基类都是View。所以说，View是一种界面层控件的抽象，他代表了一个控件。那ViewGroup是什么东西，它可以被翻译成控件组，即一组View。ViewGroup也是继承View，这就意味着View本身可以是单个控件，也可以是多个控件组成的控件组。根据这个理论，Button显然是个View，而RelativeLayout不但是一个View还可以是一个ViewGroup，而ViewGroup内部是可以有子View的，这个子View同样也可能是ViewGroup，以此类推。 RelativeLayout和LinearLayout性能PK基于以上原理和大背景，我们要探讨的性能问题，说的简单明了一点就是：当RelativeLayout和LinearLayout分别作为ViewGroup，表达相同布局时绘制在屏幕上时谁更快一点。上面已经简单说了View的绘制，从ViewRoot的performTraversals（）方法开始依次调用perfromMeasure、performLayout和performDraw这三个方法。这三个方法分别完成顶级View的measure、layout和draw三大流程，其中perfromMeasure会调用measure，measure又会调用onMeasure，在onMeasure方法中则会对所有子元素进行measure，这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程，接着子元素会重复父容器的measure，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw也分别完成perfromMeasure类似的流程。通过这三大流程，分别遍历整棵View树，就实现了Measure，Layout，Draw这一过程，View就绘制出来了。那么我们就分别来追踪下RelativeLayout和LinearLayout这三大流程的执行耗时。如下图，我们分别用两用种方式简单的实现布局测试下 LinearLayoutMeasure：0.738ms Layout：0.176ms draw：7.655ms RelativeLayoutMeasure：2.280ms Layout：0.153ms draw：7.696ms 从这个数据来看无论使用RelativeLayout还是LinearLayout，layout和draw的过程两者相差无几，考虑到误差的问题，几乎可以认为两者不分伯仲，关键是Measure的过程RelativeLayout却比LinearLayout慢了一大截。 Measure都干什么了RelativeLayout的onMeasure()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768View[] views = mSortedHorizontalChildren; int count = views.length; for (int i = 0; i &lt; count; i++) &#123; View child = views[i]; if (child.getVisibility() != GONE) &#123; LayoutParams params = (LayoutParams) child.getLayoutParams(); int[] rules = params.getRules(layoutDirection); applyHorizontalSizeRules(params, myWidth, rules); measureChildHorizontal(child, params, myWidth, myHeight); if (positionChildHorizontal(child, params, myWidth, isWrapContentWidth)) &#123; offsetHorizontalAxis = true; &#125; &#125; &#125; views = mSortedVerticalChildren; count = views.length; final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion; for (int i = 0; i &lt; count; i++) &#123; View child = views[i]; if (child.getVisibility() != GONE) &#123; LayoutParams params = (LayoutParams) child.getLayoutParams(); applyVerticalSizeRules(params, myHeight); measureChild(child, params, myWidth, myHeight); if (positionChildVertical(child, params, myHeight, isWrapContentHeight)) &#123; offsetVerticalAxis = true; &#125; if (isWrapContentWidth) &#123; if (isLayoutRtl()) &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; width = Math.max(width, myWidth - params.mLeft); &#125; else &#123; width = Math.max(width, myWidth - params.mLeft - params.leftMargin); &#125; &#125; else &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; width = Math.max(width, params.mRight); &#125; else &#123; width = Math.max(width, params.mRight + params.rightMargin); &#125; &#125; &#125; if (isWrapContentHeight) &#123; if (targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) &#123; height = Math.max(height, params.mBottom); &#125; else &#123; height = Math.max(height, params.mBottom + params.bottomMargin); &#125; &#125; if (child != ignore || verticalGravity) &#123; left = Math.min(left, params.mLeft - params.leftMargin); top = Math.min(top, params.mTop - params.topMargin); &#125; if (child != ignore || horizontalGravity) &#123; right = Math.max(right, params.mRight + params.rightMargin); bottom = Math.max(bottom, params.mBottom + params.bottomMargin); &#125; &#125; &#125; 根据源码我们发现RelativeLayout会对子View做两次measure。这是为什么呢？首先RelativeLayout中子View的排列方式是基于彼此的依赖关系，而这个依赖关系可能和布局中View的顺序并不相同，在确定每个子View的位置的时候，就需要先给所有的子View排序一下。又因为RelativeLayout允许A，B 2个子View，横向上B依赖A，纵向上A依赖B。所以需要横向纵向分别进行一次排序测量。 LinearLayout的onMeasure()方法12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; 与RelativeLayout相比LinearLayout的measure就简单明了的多了，先判断线性规则，然后执行对应方向上的测量。随便看一个吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; mTotalLength += measureNullChild(i); continue; &#125; if (child.getVisibility() == View.GONE) &#123; i += getChildrenSkipCount(child, i); continue; &#125; if (hasDividerBeforeChildAt(i)) &#123; mTotalLength += mDividerHeight; &#125; LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); totalWeight += lp.weight; if (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123; // Optimization: don't bother measuring children who are going to use // leftover space. These views will get measured again down below if // there is any leftover space. final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin); &#125; else &#123; int oldHeight = Integer.MIN_VALUE; if (lp.height == 0 &amp;&amp; lp.weight &gt; 0) &#123; // heightMode is either UNSPECIFIED or AT_MOST, and this // child wanted to stretch to fill available space. // Translate that to WRAP_CONTENT so that it does not end up // with a height of 0 oldHeight = 0; lp.height = LayoutParams.WRAP_CONTENT; &#125; // Determine how big this child would like to be. If this or // previous children have given a weight, then we allow it to // use all available space (and we will shrink things later // if needed). measureChildBeforeLayout( child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0); if (oldHeight != Integer.MIN_VALUE) &#123; lp.height = oldHeight; &#125; final int childHeight = child.getMeasuredHeight(); final int totalLength = mTotalLength; mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); if (useLargestChild) &#123; largestChildHeight = Math.max(childHeight, largestChildHeight); &#125; &#125; 父视图在对子视图进行measure操作的过程中，使用变量mTotalLength保存已经measure过的child所占用的高度，该变量刚开始时是0。在for循环中调用measureChildBeforeLayout（）对每一个child进行测量，该函数实际上仅仅是调用了measureChildWithMargins(),在调用该方法时，使用了两个参数。其中一个是heightMeasureSpec，该参数为LinearLayout本身的measureSpec；另一个参数就是mTotalLength，代表该LinearLayout已经被其子视图所占用的高度。 每次for循环对child测量完毕后，调用child.getMeasuredHeight()获取该子视图最终的高度，并将这个高度添加到mTotalLength中。在本步骤中，暂时避开了lp.weight&gt;0的子视图，即暂时先不测量这些子视图，因为后面将把父视图剩余的高度按照weight值的大小平均分配给相应的子视图。源码中使用了一个局部变量totalWeight累计所有子视图的weight值。处理lp.weight&gt;0的情况需要注意，如果变量heightMode是EXACTLY，那么，当其他子视图占满父视图的高度后，weight&gt;0的子视图可能分配不到布局空间，从而不被显示，只有当heightMode是AT_MOST或者UNSPECIFIED时，weight&gt;0的视图才能优先获得布局高度。最后我们的结论是：如果不使用weight属性，LinearLayout会在当前方向上进行一次measure的过程，如果使用weight属性，LinearLayout会避开设置过weight属性的view做第一次measure，完了再对设置过weight属性的view做第二次measure。由此可见，weight属性对性能是有影响的，而且本身有大坑，请注意避让。 小结从源码中我们似乎能看出，我们先前的测试结果中RelativeLayout不如LinearLayout快的根本原因是RelativeLayout需要对其子View进行两次measure过程。而LinearLayout则只需一次measure过程，所以显然会快于RelativeLayout，但是如果LinearLayout中有weight属性，则也需要进行两次measure，但即便如此，应该仍然会比RelativeLayout的情况好一点。 RelativeLayout另一个性能问题对比到这里就结束了嘛？显然没有！我们再看看View的Measure（）方法都干了些什么？ 12345678910111213public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123; ...... &#125; mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension &#125; View的measure方法里对绘制过程做了一个优化，如果我们或者我们的子View没有要求强制刷新，而父View给子View的传入值也没有变化（也就是说子View的位置没变化），就不会做无谓的measure。但是上面已经说了RelativeLayout要做两次measure，而在做横向的测量时，纵向的测量结果尚未完成，只好暂时使用myHeight传入子View系统，假如子View的Height不等于（设置了margin）myHeight的高度，那么measure中上面代码所做得优化将不起作用，这一过程将进一步影响RelativeLayout的绘制性能。而LinearLayout则无这方面的担忧。解决这个问题也很好办，如果可以，尽量使用padding代替margin。 结论1.RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure 2.RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。 3.在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。 最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWord Vue项目创建]]></title>
    <url>%2Fposts%2F55860431.html</url>
    <content type="text"><![CDATA[准备 node &amp; npm 1$ brew install node 检查 node &amp; npm 12$ node -v$ npm -v vue-cli 1$ npm install -g vue-cli 或 1$ npm install -g @vue/cli @vue/cli-init @vue/cli-service-global 初始化 1$ vue create hello-world 根据提示依次输入相关信息↓ 最后出现finished安装完成 ↓ 在终端中运行 ↓ 即可查看初始化完成的效果 12cd hello-world/npm run serve 添加依赖项目初始化完成后添加项目常用依赖包 12npm install --save vuex axios qsnpm install --save-dev node-sass sass-loader pug pug-loader 包含vuex、axios、qs、sass、pug等，其他依赖包根据项目需求自己选择vue-router在脚手架 init 的时候会提示是否选择安装 完善项目结构添加views文件夹 src 下添加 views 文件夹主要存放页面级的 vue 组件src 下的 components 文件夹主要用于存放通用的组件 在 views 文件夹中创建Home.vue作为主页 删除App.vue中无用的内容，只保留router-view 12345&lt;template&gt; &lt;div id="app"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 如果是移动端项目用 rem 作为单位，可以在src/main.js中添加如下代码做自适应 ↓ 1234567891011121314if (window.addEventListener) &#123; const html = document.documentElement function setFont() &#123; const k = 750 html.style.fontSize = (html.clientWidth / k) * 100 + 'px' &#125; setFont() setTimeout(function() &#123; setFont() &#125;, 300) document.addEventListener('DOMContentLoaded', setFont, false) window.addEventListener('resize', setFont, false) window.addEventListener('load', setFont, false)&#125; 调整router配置 更多路由相关使用方法请访问：https://router.vuejs.org/zh-cn/ 目录结构 ↓ 123456router ├── index.js # 我们组装模块并导出 store 的地方 └── modules ├── home.js # 首页模块 ├── cart.js # 购物车模块 └── products.js # 产品模块 修改路由主文件router/index.js 使用require.context实现路由去中心化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import Vue from 'vue'import Router from 'vue-router'Vue.use(Router)let router = new Router(&#123; base: '/', // 应用的基路径 mode: 'hash', // "hash" (URL hash 模式) | "history"(HTML5 History 模式) | "abstract" (Node.js 环境) scrollBehavior(to, from, savedPosition) &#123; // 路由切换的滚动行为，只在 HTML5 history 模式下可用 if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125; &#125;, routes: (r =&gt; &#123; // 去中心化 // console.log('r', r); // __webpack_require__ let sourceMap = [] let res = r.keys().map(key =&gt; &#123; let rKey = r(key) sourceMap.push(...rKey.default) // console.log('key', key, rKey); // ./modules/home/route.js // &#123;default: Array(3), __esModule: true&#125; return rKey &#125;) return sourceMap &#125;)(require.context('./', true, /^\.\/modules\/\w+\.js$/)),&#125;)router.beforeEach((to, from, next) =&gt; &#123; // console.log('router beforeEach=&gt;', to, from) // 全局路由切换前执行 // 是否有用户信息，并且用户ID是否存在 // if (window.localStorage.getItem("loginInfo") &amp;&amp; JSON.stringify(window.localStorage.getItem("loginInfo")).userId) &#123; // next(&#123;path: '/login'&#125;)//重定向到登录页面 // &#125; else &#123; // next()//正常跳转 // &#125; next()&#125;)router.afterEach((to, from) =&gt; &#123; // console.log('router afterEach=&gt;', router)&#125;)export default router 在 router 文件夹下添加 modules 文件夹 在 modules 文件夹下添加 home.js ，这个 home.js 对应首页业务模块，首页相关的路由页面都可以写到 home.js 文件里。 如果以后添加其他业务模块，只需要在 modules 文件夹添加相对应的业务模块文件，并在其中添加业务相关的路由页面。这样所有不同业务线的开发人员就可以互不干扰 ↓ 1234567891011121314import Home from '../../views/Home'const routes = [ &#123; path: '/', name: 'index', redirect: '/home', &#125;, &#123; path: '/home', name: 'home', component: Home, &#125;,]export default routes 对于不需要即时加载的非一级页面可以使用异步路由组件 123456789101112// region 异步组件 - 路由地址demo// ES 提案的 import（推荐）&#123; name: 'index', path: '/', component: () =&gt; import('../views/index')&#125;,// ES 提案的 import，带分组，指定webpackChunkName，相同的name打包到一个js文件&#123; name: 'index', path: '/', component: () =&gt; import(webpackChunkName:'viewsIndex','../views/index')&#125;,// Webpack 风格的异步组件&#123; name: 'index', path: '/', component: resolve =&gt; require.ensure(['views/Foo.vue'], () =&gt; resolve(require('views/Foo.vue')))&#125;,// Webpack 风格的异步组件，带分组&#123; name: 'index', path: '/', component: resolve =&gt; require.ensure([], () =&gt; resolve(require('views/index.vue')), 'group-index')&#125;,// AMD 风格的异步组件&#123; name: 'index', path: '/', component: resolve =&gt; require(['views/index.vue'], resolve)&#125;,// endregion 添加store文件夹 src 下的 store 文件夹主要是存放 vuex 相关信息的更多 vuex 相关使用方法请访问：https://vuex.vuejs.org/zh-cn/ 在 store 文件夹下创建目录结构 ↓ 12345678910store ├── index.js # 我们组装模块并导出 store 的地方 ├── getters.js # 根级别的 getter ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation ├── mutation-types.js # 定义链接 action 和 mutation 的方法名常量 └── modules ├── base.js # 首页模块 ├── cart.js # 购物车模块 └── products.js # 产品模块 下面开始改造 store 文件夹 ↓ 在mutation-types.js中添加一个常量 123export const BASE = &#123; SET_USER_INFO: 'SET_USER_INFO',&#125; 在action-types.js中添加一个常量 123export const BASE = &#123; login: 'login',&#125; 修改modules/base.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from 'vue'import &#123; base &#125; from '../mutation-types'import axios from 'axios'import qs from 'qs'const state = &#123; version: '', token: null, user: &#123; userID: '', userName: '', name: '', tel: '', email: '', head: '', &#125;,&#125;const getters = &#123; versionGetter(state, getters) &#123; return state.version &#125;,&#125;const mutations = &#123; [BASE.SET_USER_INFO](state, userInfo) &#123; userInfo.userID &amp;&amp; (state.user.userID = userInfo.userID) userInfo.USERNAME &amp;&amp; (state.user.userName = userInfo.USERNAME) userInfo.NAME &amp;&amp; (state.user.name = userInfo.NAME) userInfo.TEL &amp;&amp; (state.user.tel = userInfo.TEL) userInfo.EMAIL &amp;&amp; (state.user.email = userInfo.EMAIL) userInfo.HEAD &amp;&amp; (state.user.head = userInfo.HEAD) &#125;,&#125;const actions = &#123; async login(&#123; commit, dispatch, state &#125;, &#123; userName, password &#125;) &#123; let userInfo = await axios.post('/api/login', qs.stringify(&#123; userName, password &#125;)) commit(BASE.SET_USER_INFO, userInfo) &#125;,&#125;export default &#123; // namespaced: true, // https://vuex.vuejs.org/zh/guide/modules.html#命名空间 state, mutations, actions, getters,&#125; 修改 vuex 主文件index.js，组合所有状态模块 12345678910111213141516171819202122232425262728293031import Vue from 'vue'import Vuex from 'vuex'import getters from './getters'import actions from './actions'import mutations from './mutations'import base from './modules/base'import cart from './modules/cart'import products from './modules/products'// import createLogger from 'vuex/dist/logger' //vuex内置的Logger日志插件const debug = process.env.NODE_ENV !== 'production' // 发布品种时需要用 Webpack 的 DefinePlugin 来转换 process.env.NODE_ENV !== 'production' 的值为 falseVue.use(Vuex)const state = &#123;&#125;export default new Vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; base, cart, products, // https://vuex.vuejs.org/zh/guide/modules.html#模块动态注册 &#125;, strict: debug, // 开发阶段使用 // plugins: debug ? [createLogger()] : []//vuex插件,https://vuex.vuejs.org/zh/guide/plugins.html&#125;) 修改main.js，引入 vuex 123456789101112//...import store from './store/index'//...new Vue(&#123; el: '#app', router, store, // components: &#123; App &#125;, // template: '&lt;App/&gt;', render: h =&gt; h(App), // https://cn.vuejs.org/v2/guide/render-function.html#JSX&#125;) https://juejin.im/post/5bcd967b6fb9a05d07197b1e Vuex 实战：如何在大规模 Vue 应用中组织 Vuex 代码 super-vuex 添加mixins文件夹目录结构 ↓ 12mixins ├── index.js # 全局mixin 添加filters文件夹目录结构 ↓ 12filters ├── index.js # 全局过滤器 添加utils文件夹目录结构 ↓ 1234utils ├── fetch.js # axios ├── filters.js # 全局filter └── mixin.js # 全局mixin src/main.js中添加全局引用 ↓ 12345678910import * as filters from './utils/filters'import fetch from './utils/fetch'/* 全局注册fetch */Vue.prototype.$fetch = fetch/* 注册全局过滤器 */Object.keys(filters).forEach(key =&gt; &#123; Vue.filter(key, filters[key])&#125;) 封装 axios123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import Vue from 'vue'import router from '../router'import axios from 'axios'import qs from 'qs'import Toast from '../components/toast'// #region config// 每页条数export const ROW = 10// 加载最小时间export const MINI_TIME = 300// 超时时间（超时时间）export const TIME_OUT_MAX = 8000// 环境valueexport const _env = process.env.NODE_ENV// 请求组（判断当前请求数）export const _requests = []// #endregion// #region 实例化axiosconst _instance = axios.create(&#123; timeout: TIME_OUT_MAX,&#125;)// #endregion// region request统一处理操作_instance.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8'// POST传参序列化_instance.interceptors.request.use( config =&gt; &#123; if (config.method === 'post') &#123; config.data = qs.stringify(config.data) &#125; return config &#125;, error =&gt; &#123; Toast('错误的传参') return Promise.reject(error) &#125;,)// endregion// region response统一处理操作_instance.interceptors.response.use( res =&gt; &#123; let _message = null if (res.status !== 200) &#123; console.error(res) switch (res.status) &#123; case 404: _message = '404,错误请求' break case 401: router.push(&#123; path: '/login', query: &#123; redirect: router.currentRoute.fullPath &#125; &#125;) _message = '未授权' break case 403: _message = '禁止访问' break case 408: _message = '请求超时' break case 500: _message = '服务器内部错误' break case 501: _message = '功能未实现' break case 503: _message = '服务不可用' break case 504: _message = '网关错误' break default: _message = '未知错误' &#125; Toast(_message) return Promise.reject(_message) &#125; else &#123; return res &#125; &#125;, error =&gt; &#123; console.error(error) Toast(error || '服务器繁忙，请稍后重试') return Promise.reject(error || '服务器繁忙，请稍后重试') &#125;,)// endregion// #region send get/postlet toast = null/** * 发送GET请求 * @param api 接口api * @param params 请求参数 * @returns &#123;Promise.&lt;T&gt;&#125; */async function get(api, params) &#123; try &#123; if (!toast) toast = Toast(&#123; time: -1, message: '加载中', icon: 'loading' &#125;) let &#123; data &#125; = await _instance.get(api, &#123; params &#125;) toast.close() return data &#125; catch (e) &#123; toast.close() Toast(&#123; message: '网络异常', position: 'bottom' &#125;) throw e &#125;&#125;/** * 发送POST请求 * @param api 接口api * @param params 请求参数 * @returns &#123;Promise.&lt;T&gt;&#125; */async function post(api, params) &#123; try &#123; if (!toast) toast = Toast(&#123; time: -1, message: '加载中', icon: 'loading' &#125;) let &#123; data &#125; = await _instance.post(api, qs.stringify(params)) toast.close() return data &#125; catch (e) &#123; toast.close() Toast(&#123; message: '网络异常', position: 'bottom' &#125;) throw e &#125;&#125;// #endregionexport default &#123; _instance, get, post,&#125; config 配置build 生成的文件路径使用相对路径修改config/index.js文件中build节点的assetsPublicPath值 1234567891011module.exports = &#123; dev: &#123; // ... &#125;, build: &#123; // ... assetsPublicPath: './', // ... &#125;,&#125; 开发的的时候需要使用代理(proxy)跨域访问服务器接口修改config/index.js文件中dev节点的proxyTable值 123456789101112131415module.exports = &#123; dev: &#123; // ... proxyTable: &#123; '/api': &#123; target: 'https://123.57.89.97:8081', changeOrigin: true, // pathRewrite: &#123; // '^/api': '/api' // &#125; &#125;, &#125;, // ... &#125;,&#125; 分离线上环境和本地环境的配置信息修改config/dev.env.js与config/prod.env.js，为不同的环境配置文件添加与NODE_ENV同级的环境变量 1234module.exports = &#123; NODE_ENV: '"development"', API: '"https://123.57.89.97:8081"',&#125; 通用样式(SCSS)目录结构 ↓ 1234567assets └── scss ├── base.scss # 基础样式 ├── common.scss # 通用样式 ├── fun.scss # 函数 ├── mixin.scss # 混合 └── variable.js # 变量 base.scss12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@charset "utf-8";@import 'variable';@import 'fun';@import 'mixin';@import 'common';/*基础样式*/html,body,#app &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1; width: 100%; height: 100%; font-family: Arial, 'Microsoft YaHei', '微软雅黑', Verdana, sans-serif;&#125;ul,li &#123; padding: 0; margin: 0; list-style: none;&#125;* &gt; img &#123; max-width: 100%; max-height: 100%;&#125;button &#123; position: relative; display: block; margin-left: auto; margin-right: auto; padding-left: 14px; padding-right: 14px; box-sizing: border-box; font-size: 18px; text-align: center; text-decoration: none; line-height: 2.55555556; border-radius: 5px; -webkit-tap-highlight-color: transparent; overflow: hidden; color: #000000; background-color: #f8f8f8; &amp;::after &#123; content: ' '; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid rgba(0, 0, 0, 0.2); -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0; box-sizing: border-box; border-radius: 10px; &#125;&#125;//页面切换动画.slide &#123; &amp;-enter, &amp;-leave-to &#123; -webkit-transform: translate(100%, 0); transform: translate(100%, 0); &#125; &amp;-enter-active, &amp;-leave-active &#123; transition: all 0.5s cubic-bezier(0.55, 0, 0.1, 1); &#125; &amp;-enter-to, &amp;-leave &#123; -webkit-transform: translate(0, 0); transform: translate(0, 0); &#125;&#125; common.scss123456789101112131415161718192021222324252627282930313233@charset "UTF-8";@import 'fun';@import 'mixin';@import 'variable';/*通用样式*/* &#123; box-sizing: border-box;&#125;.clear &#123; display: block !important; clear: both !important; float: none !important; margin: 0 !important; padding: 0 !important; height: 0; line-height: 0; font-size: 0; overflow: hidden;&#125;.clearfix &#123; zoom: 1;&#125;.clearfix:after &#123; content: ''; display: block; clear: both; height: 0;&#125; fun.scss1234567@charset "UTF-8";/*函数*/@function rem($pixels) &#123; @return $pixels / 100px * 1rem;&#125; mixin.scss1234567891011@charset "UTF-8";/*混合*/@mixin fullpage &#123; position: absolute; top: 0; bottom: 0; right: 0; left: 0;&#125; variable.scss1234567@charset "UTF-8";@import 'fun';/*变量*/$headerHeight: rem(50px); 查缺补漏我用了 axios , 为什么 IE 浏览器不识别(IE9+)那是因为 IE 整个家族都不支持 promise, 解决方案: 1234npm install es6-promise// 在 main.js 引入即可// ES6的polyfillrequire('es6-promise').polyfill()]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Style Guide For 前端]]></title>
    <url>%2Fposts%2F16482fed.html</url>
    <content type="text"><![CDATA[命名 文件夹、.JS、.CSS: 小驼峰(little camel-case) .vue 组件: 大驼峰(big camel-case)* css的class命名遵循 BEM 重构组件组件存放位置只有 一个 页面内的组件，放在页面文件夹下的 components 文件夹下； 两个 页面共用的组件，放在第一个页面文件夹下的 components 文件夹下； 三个以上 页面的共用组件，放在项目文件夹下的 components 文件夹下。 组件存放的位置会在开发过程中不断的调整重构。 添加项目级公用组件需将组件参数及用法描述添加到 README.md 。 Vue 引用组件一律使用 大驼峰(big camel-case) 命名。 如遇 Footer 组件则可将组件名定义为 VFooter ，不要使用 MyFooter 。 weex页面文件夹命名使用 小驼峰(little camel-case) ，文件夹由 至少两个单词组成 。 gittag 命名规范 分支+版本号+日期。版本号前3位逢9进1，最后一位极限逢99进1。例如：dev-v0.3.3.01-20180110 pre-v0.3.9.05-20181101 master-v0.3.9.05-20180101 master的tag根据pre的最后一个版本。 更多 Vue 风格指南 Airbnb JavaScript Style Guide]]></content>
      <categories>
        <category>前端</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这次，彻底弄懂接口及抽象类]]></title>
    <url>%2Fposts%2F912e5c18.html</url>
    <content type="text"><![CDATA[本文旨在讨论抽象类和接口的作用、实例及使用场景，都是我的理解和总结。更多关于接口和抽象类的概念知识，可自行查阅相关文档。 1. 抽象类及其作用抽象类，顾名思义，即类的抽象。 在介绍面向对象概念时，我们知道类是客观事物的抽象，而抽象类又是类的进一步抽象，该怎么理解呢？ 举个例子，我们定义若干个类 class BMW、class Benz、class Audi，分别对客观事物“宝马”、“奔驰”、“奥迪”三种汽车进行抽象，包含相关属性和行为（即方法）。但是我们知道，汽车都有通用的属性和行为，比如品牌、发动机、方向盘、轮胎等属性，前进、后退、转弯等行为，所以我们可以在宝马、奔驰等汽车之上，进一步抽象出“汽车”类 abstract class Car，包含通用的特性（属性和方法）。让 BMW、Benz、Audi 等继承抽象类 extends Car，便拥有了汽车的通用特性，然后在抽象类基础上定义各自的特殊属性及方法。 这里的 abstract class Car 即抽象类，可以看出，抽象类是用来捕捉子类的通用特性的，包括属性及行为。 2. 接口及其作用下面我们来看看接口，假使我研发出来一台会飞的汽车“伯特莱斯”（Bote-Royce），在程序中定义如下： 12345678910class BoteRoyce extends Car &#123; //...省略通用特性 /** * 可以飞 */ void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 看起来没问题： BoteRoyce extends Car：表达这是一辆汽车； fly() 方法：体现这车可以飞。 但是，随着技术发展，出现了众多可以制造飞行汽车的厂商，难道每一个可以飞的汽车都去定义一个 fly() 方法？ 心想这还不简单，在抽象类 Car 中定义一个抽象方法 abstract void fly() 让子类去实现，不就可以了吗？ No No No… 正如不是所有牛奶都叫特仑苏一样，不是所有汽车都会飞，飞行功能不是汽车的通用特性。将 fly() 方法定义在 Car 中，显然违背了“抽象类用来捕捉子类的通用特性”这一原则。 在这种场景下，解决方案之一就是使用接口，如下： 1234567/** * 飞行器接口 */public interface Aircraft &#123; //定义抽象方法 void fly();&#125; 类 BoteRoyce 的定义修改如下： 12345678910111213/* * 实现 Aircraft 接口，表示具备飞行器能力 */class BoteRoyce extends Car implements Aircraft &#123; /** * 覆写接口方法，实现飞行能力 */ @Override void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 再有其他品牌的飞行汽车，都可以通过 extends Car implements Aircraft 实现飞行能力。 上述定义的 interface Aircraft 即为接口，我们通常使用接口对行为进行抽象。 3. 接口和抽象类的区别关于二者的区别，可以结合前面的例子，来加深理解。 抽象类是对类本质的抽象，表达的是 is a 的关系，比如：BMW is a Car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。 而接口是对行为的抽象，表达的是 like a 的关系。比如：Bote-Royce like a Aircraft（像飞行器一样可以飞），但其本质上 is a Car。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。 4. 接口与抽象类的使用场景熟悉 Java 的同学可能会质疑，上述关于接口的使用，完全可以通过再次抽象 Car 去实现： 12345678/** * 会飞的汽车 */abstract class FlyCar extends Car &#123; //定义抽象方法 public abstract void fly();&#125; 普通的汽车依然 extends Car，可以飞行的汽车 extends FlyCar 即可： 12345678910111213/* * 继承 FlyCar，表示是可以飞行的汽车 */class BoteRoyce extends FlyCar &#123; /** * 覆写抽象方法，实现飞行能力 */ @Override public void fly() &#123; System.out.println("假装会飞~"); &#125;&#125; 如果你也这么想，表示你 get 到了抽象类的点。不过话说回来，这样的话接口岂不是没有存在的意义了？ 当然不是了。就 BoteRoyce 而言，如果你关心的是“飞行汽车”这个整体，那么定义抽象类 FlyCar 是个不错的选择；如果你关心的是汽车具备“飞行”的行为，那不妨继续沿用前面使用 Aircraft 接口的方案。 这一点与设计模式中六大原则之一的“里氏替换原则”不谋而合，该原则指出：所有引用基类（抽象类或接口）的地方必须能透明地使用其子类的对象。也就是说，当你遵循该原则时，你必须要考虑你关心的是“飞行汽车”实体，还是“飞行”行为，并将其作为基类，从而决定程序所能接受的子类对象。 同时，“接口隔离原则”指导我们，一个类对另一个类的依赖应该建立在最小的接口上。相比于抽象类 FlyCar，接口 Aircraft 能最大限度的减少对外暴露的接口，并隐藏细节，更符合这一原则。 所以说啊，面向对象只是指导我们编程的思想，而非条条框框。在实际开发中，具体使用抽象类还是接口，并没有绝对限制，而是取决于你的业务场景和架构设计。 5. 总结好了，本次关于接口与抽象类的总结就到这儿，你彻底弄懂了吗？下期分享再见~]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[夯实Java：从面向对象说起]]></title>
    <url>%2Fposts%2F92341839.html</url>
    <content type="text"><![CDATA[刚学习 Java 那会就接触了“面向对象”的概念，但当时并没有太多实战经验，所以对其的理解也仅限于概念。当工作两年后再回顾一下，有些概念能够落地了，遂记录一下。 1. 什么是面向对象面向对象是一种程序设计的思想，而不是一种方法，亦或准则。其指导我们从现实世界中客观存在的事物出发，进行程序设计。 2. 什么是对象Everything is Object，在 Java 语言的世界中，万事万物皆对象。上面提到“从现实世界中客观存在的事物出发”，这里客观存在的事物，我们称之为“对象”。 在程序中，对象是程序的基本构成单元，是客观存在的事物的体现。一个对象通常由一组属性和对这组属性进行操作的若干服务（方法）构成。 3. 面向对象与面向过程的出现面对简单的软件程序，我们往往不需要考虑过多的设计，任何一个小的功能单元或模块，都可以按照一定的步骤去实现，这种 step by step 的方式即为面向过程。 随着程序的复杂性提升，我们无法按步骤去描述并实现编码，所以面向过程已无法适应。加之考虑到代码的可读及复用性等，便有了对象的概念，以及面向对象的编程思想。 当然，还有面向组件、面向服务等设计思想，不在此讨论。 4. 面向对象与面向过程的区别要知道，二者并不是非此即彼，而是相辅相成的。 面向对象思想要求我们从宏观上进行程序设计，抽象出一个个“对象”。而面向过程，则在微观上对“对象”内部进行具体的实现。 可以看出，面向对象最终还是离不开面向过程。 举例来说，需要编程实现绘制圆形、三角形、矩形。 面向过程实现： 123drawCircle... //一坨绘制相关的代码，下同drawTriangledrawRect 面向对象实现： 123456789101112131415//抽象出画笔对象class Painter &#123; drawCircle()&#123; //上述面向过程实现，下同 &#125; drawTriangle()&#123;&#125; drawRect()&#123;&#125;&#125;//面向对象，使用画笔绘制1. painter.drawCircle() //此处只需要调用对象的方法，下同1. painter.drawTriangle()2. painter.drawRect() 5. 对象与类前面介绍了对象以及面向对象，下面回到 Java 中聊聊类的概念。 5.1 类我们常说“物以类聚”，表达“ 同类的东西聚在一起”。其实 Java 中的类也可以这么去理解：“物”即客观存在的“对象”，同类物体的特征描述，即为“类”。 上面是我的个人理解，用术语概括就是：类是客观事物的抽象，或者说是对现实生活中事物的一种描述（属性和行为）。 例如前面定义的 Painter 类，是对客观事物画笔的抽象，包含了一些绘制的方法（行为）。 5.2 对象与类的关系类进行实例化可生成对象，所以，类的具体表现或者实例就是对象，而对象的抽象或者总概括就是类。 6. 面向对象的三大特性说到面向对象，就不得不说其三大特性：封装、继承和多态。 下面简单说说自己的理解吧，就不再贴相关示例了，网上有很多优秀的例子。 6.1 封装封装是面向对象最基础的特性。在前面介绍对象时，提到“一个对象通常由一组属性和对这组属性进行操作的若干服务（方法）构成”，这里的构成体现的就是封装性。 封装，是指对外隐藏对象内部的属性和实现细节，只提供相应的接口和方法进行交互。一方面，外部只需专注于对象所提供的能力，而不用关心内部实现细节；另一方面，避免了外部随意修改或访问内部属性和方法，从而提升了程序的健壮性；同时，封装能提升代码的复用率。 6.2 继承继承指一个对象从另一个对象中获得属性和方法的过程，继承者称为子类，被继承者称为父类。继承使得子类对象拥有父类对象的全部属性与方法（非私有）。 Key point: 子类也可以被其他类继承成为父类； 父类可以拥有多个子类，但一个子类只能有一个父类。这一点与现实中父亲与孩子的关系是一致的； Java 中任何类都是 java.lang.Object 的直接或间接子类； 子类不能继承父类中访问权限为 private 的成员变量和方法； 子类可以重写（override）父类的方法； 子类可以通过 super 关键字访问父类的成员变量、方法和构造器； final 声明的类或方法，不能被继承或重写； 6.3 多态多态是在继承的基础上实现的，多态实现的三个必要条件： 继承 方法重写（override） 父类引用指向子类对象，例如：Human human = new Man()，这里 Man extends Human。 当使用多态方式调用方法时，会依据以下规则： 首先检查父类中是否有该方法，如果没有，则编译错误； 若子类重写了该方法，调用子类的重写方法； 若子类没有重写该方法，则调用父类的方法； 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 7. 总结以上是本文的全部内容，希望能对你有所启发。内容说不上全面、无误，还望读者朋友补充、指正。 最后，感谢阅读。]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的.so文件、abi兼容，通用armeabi-v7a和arm64-v8a架构的方法]]></title>
    <url>%2Fposts%2F75a88a70.html</url>
    <content type="text"><![CDATA[了解完 armeabi、armeabi-v7a、arm64-v8a、mips、mips64、x86、x86_64等abi的原理后，很久以前一般都只是用armeabi在做兼容。 现在其实市面上主流的手机都支持armeabi-v7a和arm64-v8a。请看如下简介：各版本的分析如下所示： mips / mips64: 极少用于手机可以忽略，有兴趣的可以百度一下。 x86 / x86_64: x86 架构的手机都会包含由 Intel 提供的称为 Houdini 的指令集动态转码工具，实现 对 arm .so 的兼容，再考虑 x86 1% 以下的市场占有率，x86 相关的两个 .so 也是可以忽略的 armeabi: ARM v5 这是相当老旧的一个版本，缺少对浮点数计算的硬件支持，在需要大量计算时有性能瓶颈 armeabi-v7a: ARM v7 目前主流版本，一般市面上的骁龙系列或者麒麟系列的处理器绝大部分都是这种架构 arm64-v8a: 64位支持所谓的ARMv8架构，就是在MIPS64架构上增加了ARMv7架构中已经拥有的的TrustZone技术、虚拟化技术及NEON advanced SIMD技术等特性，研发成的。 综上所述建议大家兼容armeabi-v7a和arm64-v8a这两个，其他架构少之又少，armeabi基本淘汰所以现在就不怎么考虑了。对于一般项目来说，足够了。 在build.gradle的android里的defaultConfig内添加如下内容: 12345defaultConfig &#123; ndk &#123; abiFilters &quot;armeabi-v7a&quot; abiFilters &quot;arm64-v8a&quot; &#125; 然后在项目中集成so文件的时候 只把armeabi-v7a和arm64-v8a这两个的so文件夹copy到libs里面，具体细节第三方平台的教程里面都写得很详细 如果报错: 12Error:(15, 1) A problem occurred evaluating project ':app'.&gt; Error: NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. For details, see http://tools.android.com/tech-docs/new-build-system/gradle-experimental. Set "android.useDeprecatedNdk=true" in gradle.properties to continue using the current NDK integration. 请在 gradle.properties 中 添加 1android.useDeprecatedNdk=true 对于新手Android开发者来说，像集成百度地图SDK、JPush等再出现找不到.so文件的问题直接只使用armeabi-v7a和arm64-v8a就足以。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>.so文件</tag>
        <tag>armeabi-v7a</tag>
        <tag>arm64-v8a</tag>
        <tag>abi兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的.so文件、ABI和CPU的关系]]></title>
    <url>%2Fposts%2Fb9d5fd68.html</url>
    <content type="text"><![CDATA[早期的Android系统几乎只支持ARMv5的CPU架构，你知道现在它支持多少种吗？ Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。 应用程序二进制接口ABI（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。 为什么你需要重点关注.so文件 项目中使用到了NDK，它将会生成.so文件。 如果只使用Java语言进行编码，你可能在想不需要关注.so文件了吧，因为Java是跨平台的。但你可能并没有意识到项目中依赖的函数库或者引擎库里面已经嵌入了.so文件，并依赖于不同的ABI。 Android应用支持的ABI取决于APK中位于lib/ABI目录中的.so文件，其中ABI可能是上面说过的七种ABI中的一种。 本地库监视器Native Libs Monitor这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。 ABI和CPU的关系很多设备都支持多于一种的ABI。当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。但最好是针对特定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新，例如硬件fpu，更多的寄存器，更好的向量化等）。 我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件 ABI目录（横向）和cpu（纵向） armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64 ARMv5 支持 ARMv7 支持 支持 ARMv8 支持 支持 支持 MIPS 支持 MIPS64 支持 支持 x86 支持 支持 支持 x86_64 支持 支持 支持 不同的ABI，针对不同的cpu架构有不同的优先权 例如： x86设备上，libs/x86目录中如果存在.so文件的话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件。 x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备。 64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。 .so文件重要法则处理.so文件时有一条简单却并不知名的重要法则。 你应该尽可能的提供专为每个ABI优化过的.so文件，你不应该混合着使用（不能就装对不同cpu架构的so文件，放在同一个ABI目录下）。你应该为每个ABI目录提供对应的.so文件。 NDK兼容性使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是后向兼容（兼容过去的版本）的，而是前向兼容（兼容将来的版本）的。推荐使用app的minSdkVersion对应的编译平台。 这也意味着当你引入一个预编译好的.so文件时，你需要检查它被编译所用的平台版本。 混合使用不同C++运行时编译的.so文件.so文件可以依赖于不同的C++运行时，静态编译或者动态加载。混合使用不同版本的C++运行时可能导致很多奇怪的crash，是应该避免的。 一个经验法则 当只有一个.so文件时，静态编译C++运行时是没问题的， 当存在多个.so文件时，应该让所有的.so文件都动态链接相同的C++运行时。 这意味着当引入一个新的预编译.so文件，而且项目中还存在其他的.so文件时，我们需要首先确认新引入的.so文件使用的C++运行时是否和已经存在的.so文件一致。 ###关于.so文件的错误示例*问题： *你的app目前只支持armeabi-v7a和x86架构，你想让app支持更多的cpu类型，新增了一个函数库依赖，这个函数库包含.so文件并支持更多的CPU架构。 发布我们的app后，会发现它在某些设备上会发生Crash，例如Galaxy S6，最终可以发现只有64位目录下的.so文件被安装进手机。 解决方案： 重新编译我们的.so文件使其支持缺失的ABIs 也可以设置ndk.abiFilters显示指定支持的ABIs 在IDE中的路径 Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定） Eclipse工程放在libs/ABI目录中（这也是ndk-build命令默认生成.so文件的目录） 在AAR压缩包中的路径AAR压缩包中位于jni/ABI目录中（.so文件会自动包含到引用AAR压缩包的APK中） 在APK中的路径最终APK文件中的lib/ABI目录中 通过PackageManager安装后，.so文件路径通过PackageManager安装后，在小于Android 5.0的系统中，.so文件位于app的nativeLibraryPath目录中；在大于等于Android 5.0的系统中，.so文件位于app的nativeLibraryRootDir/CPU_ARCH目录中。 生成不同ABI版本的APK以减少APK包大小为由是一个错误的借口，因为你也可以选择在应用市场上传指定ABI版本的APK，生成不同ABI版本的APK可以在build.gradle中如下配置： 12345678910111213141516171819202122android &#123; ... splits &#123; abi &#123; enable true reset() include 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a' //select ABIs to build APKs for universalApk true //generate an additional APK that contains all the ABIs &#125; &#125; // map for the version code project.ext.versionCodes = ['armeabi': 1, 'armeabi-v7a': 2, 'arm64-v8a': 3, 'mips': 5, 'mips64': 6, 'x86': 8, 'x86_64': 9] android.applicationVariants.all &#123; variant -&gt; // assign different version code for each output variant.outputs.each &#123; output -&gt; output.versionCodeOverride = project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), 0) * 1000000 + android.defaultConfig.versionCode &#125; &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>ABI</tag>
        <tag>CPU</tag>
        <tag>.so文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你必须知道的ABI和CPU关系]]></title>
    <url>%2Fposts%2F8c0a549.html</url>
    <content type="text"><![CDATA[ABI和CPU的重要知识1、 大部分cpu都支持多于一种的ABI。2、 当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。3、 ABI目录（横向）和cpu（纵向） armeabi armeabi-v7a arm64-v8a mips mips64 x86 x86_64 ARMv5 支持 ARMv7 支持 支持 ARMv8 支持 支持 支持 MIPS 支持 MIPS64 支持 支持 x86 支持 支持 支持 x86_64 支持 支持 支持 注意：上表格中的空白部分，是我不知道它是否支持，极有可能是不支持 解析： x86设备上，选择ABI的优先级 libs/x86目录中如果存在.so文件的话，会被安装 如果不存在，则会选择armeabi-v7a中的.so文件 如果也不存在，则选择armeabi目录中的.so文件 x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备，因为是运行在x86设备上模拟arm的虚拟层上。 4、 64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性能（ART，webview，media等等）。 5、 最好是针对特定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新，例如硬件fpu，更多的寄存器，更好的向量化等）。 6、 会安装优先级较高的ABI目录，则其它优先级较低的ABI目录（包括其它module中的ABI目录），都无法安装。例如：在cpu是ARMv7架构的手机上，如果检测到armeabi-v7a，就会选择安装armeabi-v7a，则armeabi下的文件，都无法安装了。 7、 相应的ABI二进制文件，要放进相应的ABI目录中 8、一般情况下不要简单得修改架构目录名 我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件，如果在对应的lib／ABI目录中存在.so文件的话。 ###工具查看项目中ABI文件的架构类型腾讯bugly，符号表工具，下载地址：http://bugly.qq.com/whitebook Native Libs Monitor这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。 ###疑难杂症虽然规则制定出来了，但总是会出现一些，不合规的现象，导致一些错误，难以理解。现在就让我们来一起把把脉，看看到底是什么疑难杂症 ####一、.so文件，放进了优先级低的ABI目录 1、如果你的项目中，有其他优先级更高的ABI目录，但是你把ABI文件放到了优先级低的目录，则你的ABI文件无法被加载2、如果你的项目中，ABI文件放在了，项目中优先级最高的ABI目录中（这个ABI目录是手机所支持的在项目中优先级最高的，但不一定是手机所支持的优先级最高的），则这个ABI文件，可以被加载，加载为ABI目录的所表示的架构类型。例子： 我的手机cpu架构是ARMv7，ABI文件是armeabi-v7a，但是放进了armeabi目录中 在运行的过程中会出现两种情况： 1、项目中有armeabi-v7a的目录，armeabi目录中的文件，无法被加载，运行后报错，出现如下log信息。 1Caused by: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/.xx../base.apk"],nativeLibraryDirectories=[/data/app/.xx../lib/arm, /vendor/lib, /system/lib]]] couldn't find "lib..xx...so" 2、项目中只有armeabi的目录，armeabi目录是该项目优先级最高的ABI目录（虽然armeabi目录在ARMv7所支持的优先级最高的ABI目录不是最高），作为armv5，安装到手机上。 ####二、ABI二进制文件，放进了优先级高的ABI目录可以被加载使用，被加载为ABI文件所表示的结构类型 例子： 我的手机cpu架构是ARMv7，ABI文件是armeabi-v5te，但是放进了armeabi-v7a目录中。 可以被加载，但是加载为ABI文件所表示的架构类型。这样就出现了，同一个应用中ABI文件，出现两种的情况。 ####三、两个第三的SDK中ABI文件优先级不一样问题： 两个第三方的SDK中ABI文件优先级不一样，手机加载运行时，会导致优先级低的库，无法被加载 例子： 我的手机cpu架构是ARMv7，项目中使用两个第三方SDK：企业A和企业B 企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。 在运行时，会发现运行后crash，出现如下log信息。 1Caused by: java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/.xx../base.apk"],nativeLibraryDirectories=[/data/app/.xx../lib/arm, /vendor/lib, /system/lib]]] couldn't find "lib..xx...so" 解决办法： #####1、使用同一优先级的ABI文件，ABI文件放入优先级相同的ABI目录 企业A：ABI文件是armeabi-v5te，放进armeabi目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。或企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。 #####2、使用不同优先级的ABI文件，ABI文件放入优先级相同的ABI目录。一般情况不建议这么做。 企业A：ABI文件是armeabi-v7a，但是放进armeabi目录中。企业B：ABI文件是armeabi-v5te，放进armeabi目录中。或企业A：ABI文件是armeabi-v7a，放进armeabi-v7a目录中。企业B：ABI文件是armeabi-v5te，但是放进armeabi-v7a目录中。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>ABI</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android下setTextSize的正确使用姿势]]></title>
    <url>%2Fposts%2F99d586fa.html</url>
    <content type="text"><![CDATA[问几个问题先在app/src/main/res/values/dimens.xml中定义尺寸如下： 1&lt;dimen name="font1"&gt;18sp&lt;/dimen&gt; 在代码中引用此尺寸如下： 1234mText.setTextSize(18); // 方法1mText.setTextSize(getResources().getDimension(R.dimen.font1)); // 方法2mText.setTextSize(TypedValue.COMPLEX_UNIT_PX,getResources().getDimension(R.dimen.font1)); // 方法3mText.setTextSize(TypedValue.COMPLEX_UNIT_SP,18); // 方法4 问题1: 方法1和方法2设置的文字尺寸大小相同么？问题2:方法3和方法4设置的文字尺寸大小相同么？问题3:方法1和方法4设置的文字尺寸大小相同么？ 如果你能很清楚的给出上面问题的答案，那就没必要再向下看了；如果你对以上问题感到模棱两可的话，请继续往下看: 要想解开以上疑惑，其实主要从以下两个方法的源码入手 setTextSize(…)进入TextView类，找到setTextSize(…)方法，发现它调用了另一个重载方法，注意这里调用重载方法时传入的第一个参数是一个默认值 TypedValue.COMPLEX_UNIT_SP，因此方法1和方法4设置的文字尺寸大小相同. 1234567891011121314public void setTextSize(float size) &#123; setTextSize(TypedValue.COMPLEX_UNIT_SP, size);&#125;public void setTextSize(int unit, float size) &#123; Context c = getContext(); Resources r; if (c == null) r = Resources.getSystem(); else r = c.getResources(); setRawTextSize(TypedValue.applyDimension(unit, size, r.getDisplayMetrics()));&#125; 重载方法中有两个方法需要重点看setRawTextSize(…)方法通过它的几个方法会发现它的作用就是真正设置文字大小并刷新显示： 12345678910private void setRawTextSize(float size) &#123; if (size != mTextPaint.getTextSize()) &#123; mTextPaint.setTextSize(size); if (mLayout != null) &#123; nullLayouts(); requestLayout(); invalidate(); &#125; &#125;&#125; TypedValue类中的applyDimension(…)方法根据传入的unit单位来处理文字大小，返回的尺寸为px (通过第一个case条件得知). 1234567891011121314151617public static float applyDimension(int unit, float value, DisplayMetrics metrics)&#123; switch (unit) &#123; case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); &#125; return 0;&#125; 如果传入的unit为COMPLEX_UNIT_PX，则会将value直接返回如果传入的unit为COMPLEX_UNIT_SP，则会将value处理成px返回 getDimension(…)进入Resources类，找到getDimension(…)方法 12345678910111213public float getDimension(@DimenRes int id) throws NotFoundException &#123; synchronized (mAccessLock) &#123; TypedValue value = mTmpValue; if (value == null) &#123; mTmpValue = value = new TypedValue(); &#125; getValue(id, value, true); if (value.type == TypedValue.TYPE_DIMENSION) &#123; return TypedValue.complexToDimension(value.data, mMetrics); &#125; throw new NotFoundException("Resource ID #0x" + Integer.toHexString(id) + " type #0x" + Integer.toHexString(value.type) + " is not valid"); &#125;&#125; 这里方法不多，点getValue(…)方法进去看会发现它内部又调用了native方法，这里我无法进一步追溯它的实现，不过没关系，因为我发现有个方法很眼熟那就是：TypedValue.complexToDimension(…) ，进入此方法会惊奇的发现它也调用了上面讲到的applyDimension(…)方法. 1234public static float complexToDimension(int data, DisplayMetrics metrics)&#123; return applyDimension( (data&gt;&gt;COMPLEX_UNIT_SHIFT)&amp;COMPLEX_UNIT_MASK, complexToFloat(data), metrics);&#125; 由此可以大胆的猜测 getDimension(…)方法最终也会将数据处理成px返回，因此方法3和方法4设置的文字尺寸大小相同，只是写法不同而已. 好了，回到开篇提到的四个问题，可以得出以下结论： 方法1：文字尺寸以sp为单位，大小为18方法2：文字尺寸以sp为单位，大小为（18sp转换为px的值）方法3：文字尺寸以px为单位，大小为（18sp转换为px的值）方法4：文字尺寸以sp为单位，大小为18方法1=方法3=方法4!＝方法2 至此，文章结束，希望此文能帮助到你，如果对此文有不同见解，欢迎直接评论！]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>TypedValue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中使用Handler造成内存泄露的分析和解决]]></title>
    <url>%2Fposts%2F91b033d9.html</url>
    <content type="text"><![CDATA[Java使用有向图机制，通过GC自动检查内存中的对象（什么时候检查由虚拟机决定），如果GC发现一个或一组对象为不可到达状态，则将该对象从内存中回收。也就是说，一个对象不被任何引用所指向，则该对象会在被GC发现的时候被回收；另外，如果一组对象中只包含互相的引用，而没有来自它们外部的引用（例如有两个对象A和B互相持有引用，但没有任何外部对象持有指向A或B的引用），这仍然属于不可到达，同样会被GC回收。 Android中使用Handler造成内存泄露的原因123456Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; mImageView.setImageBitmap(mBitmap); &#125;&#125; 上面是一段简单的Handler的使用。当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）。而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条MessageQueue -&gt; Message -&gt; Handler -&gt; Activity的链，导致你的Activity被持有引用而无法被回收。 内存泄露的危害只有一个，那就是虚拟机占用内存过高，导致OOM（内存溢出），程序出错。对于Android应用来说，就是你的用户打开一个Activity，使用完之后关闭它，内存泄露；又打开，又关闭，又泄露；几次之后，程序占用内存超过系统限制，FC。 使用Handler导致内存泄露的解决方法 通过程序逻辑来进行保护1.在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 2.如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。 将Handler声明为静态类静态类不持有外部类的对象，所以你的Activity可以随意被回收。代码如下： 123456static class MyHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; mImageView.setImageBitmap(mBitmap); &#125;&#125; 但其实没这么简单。使用了以上代码之后，你会发现，由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）： 123456789101112131415static class MyHandler extends Handler &#123; WeakReference&lt;Activity &gt; mActivityReference; MyHandler(Activity activity) &#123; mActivityReference= new WeakReference&lt;Activity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; final Activity activity = mActivityReference.get(); if (activity != null) &#123; mImageView.setImageBitmap(mBitmap); &#125; &#125;&#125; 将代码改为以上形式之后，就算完成了。 具体示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * * 实现的主要功能。 * * @version 1.0.0 * @author Abay Zhuang &lt;br/&gt; * Create at 2014-7-28 */public class HandlerActivity2 extends Activity &#123; private static final int MESSAGE_1 = 1; private static final int MESSAGE_2 = 2; private static final int MESSAGE_3 = 3; private final Handler mHandler = new MyHandler(this); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandler.sendMessageDelayed(Message.obtain(), 60000); // just finish this activity finish(); &#125; public void todo() &#123; &#125;; private static class MyHandler extends Handler &#123; private final WeakReference&lt;HandlerActivity2&gt; mActivity; public MyHandler(HandlerActivity2 activity) &#123; mActivity = new WeakReference&lt;HandlerActivity2&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; System.out.println(msg); if (mActivity.get() == null) &#123; return; &#125; mActivity.get().todo(); &#125; &#125; 上面这样就可以了吗？ 当Activity finish后 handler对象还是在Message中排队。 还是会处理消息，这些处理有必要？正常Activitiy finish后，已经没有必要对消息处理，那需要怎么做呢？解决方案也很简单，在Activity onStop或者onDestroy的时候，取消掉该Handler对象的Message和Runnable。通过查看Handler的API，它有几个方法：removeCallbacks(Runnable r)和removeMessages(int what)等。 代码如下： 12345@Overridepublic void onDestroy() &#123; // If null, all callbacks and messages will be removed. mHandler.removeCallbacksAndMessages(null);&#125; 延伸：什么是WeakReference？WeakReference弱引用，与强引用（即我们常说的引用）相对，它的特点是，GC在回收时会忽略掉弱引用，即就算有弱引用指向某对象，但只要该对象没有被强引用指向（实际上多数时候还要求没有软引用，但此处软引用的概念可以忽略），该对象就会在被GC检查到时回收掉。对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Handler</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法总结]]></title>
    <url>%2Fposts%2Fe3c0f347.html</url>
    <content type="text"><![CDATA[我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。 排序算法大体可分为两种： 一种是比较排序，时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。 另一种是非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。 下表给出了常见比较排序算法的性能： 一点我们很容易忽略的是排序算法的稳定性 排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。 对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。 例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。 其次，说一下排序算法稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。 1、冒泡排序(Bubble Sort)​ 冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。 ​ 冒泡排序算法的运作如下： 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。冒泡排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package sort;/** * 冒泡排序 * 从小到大排列 * 分类 -------------- 内部比较排序 * 数据结构 ---------- 数组 * 最差时间复杂度 ---- O(n^2) * 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n) * 平均时间复杂度 ---- O(n^2) * 所需辅助空间 ------ O(1) * 稳定性 ------------ 稳定 */public class BubbleSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //冒泡排序 public static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swapArr(arr, j, j + 1); &#125; &#125; &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); bubbleSort(arr); //冒泡排序 printArr(arr); //打印数组 &#125;&#125; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序的实现过程如下 尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。 2、鸡尾酒排序 鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。 鸡尾酒排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package sort;/** * 鸡尾酒排序：冒泡排序的改进 * 从小到大排列 * 分类 -------------- 内部比较排序 * 数据结构 ---------- 数组 * 最差时间复杂度 ---- O(n^2) * 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n) * 平均时间复杂度 ---- O(n^2) * 所需辅助空间 ------ O(1) * 稳定性 ------------ 稳定 */public class CocktailSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //鸡尾酒排序 public static void CocktailSort(int[] arr) &#123; //初始化边界 int left = 0; int right = arr.length - 1; while (left &lt; right) &#123; //前半部分 for (int i = left; i &lt; right; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; //将最大元素放到后边 swapArr(arr, i, i + 1); &#125; &#125; right--; //后半部分 for (int j = right; j &gt; left; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; //将最小元素放到前边 swapArr(arr, j, j - 1); &#125; &#125; left++; &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); CocktailSort(arr); //鸡尾酒排序 printArr(arr); //打印数组 &#125;&#125; 以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。 3、选择排序(Selection Sort) 选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。 选择排序的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package sort;/** * 选择排序 * 从小到大排列 * // 分类 -------------- 内部比较排序 * 数据结构 ---------- 数组 * 最差时间复杂度 ---- O(n^2) * 最优时间复杂度 ---- O(n^2) * 平均时间复杂度 ---- O(n^2) * 所需辅助空间 ------ O(1) * 稳定性 ------------ 不稳定 */public class SelectionSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //选择排序 public static void SelectionSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minValue = i; //定义一个最小下标，假设i为最小值的下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; //注意：j&lt;arr.length if (arr[minValue] &gt; arr[j]) //如果有有比arr[minValue]小的，则将minValue = j minValue = j; &#125; //判断最小下标是否改变，如果改变则将最小的放到i的位置上 if (minValue != i) &#123; swapArr(arr, minValue, i); //数组元素交换 &#125; &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); SelectionSort(arr); //选择排序 printArr(arr); //打印数组 &#125;&#125; 上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图 使用选择排序为一列数字进行排序的宏观过程： 选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。 比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。 4、插入排序(Insertion Sort)插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌 对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 插入排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package sort;/** * 插入排序 */public class InserttionSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //插入排序 public static void InsertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; //假设第一个元素为已排序序列，从第二个元素开始起插入 int j = i - 1; //已排序序列元素个数，下标从0开始，0代表一个 int get = arr[i]; while (j &gt;= 0 &amp;&amp; arr[j] &gt; get) &#123; //将要插入元素与已排序的序列从右向左进行比较 arr[j + 1] = arr[j]; //如果该元素大于要插入元素，则将其后移 j--; &#125; arr[j + 1] = get; //直到该元素小于或等于要插入元素，则将其插入到该元素的后边 &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); InsertionSort(arr); //直接插入排序 printArr(arr); //打印数组 &#125;&#125; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下 使用插入排序为一列数字进行排序的宏观过程： 插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 5、二分插入排序 插入排序的改进 对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package sort;/** * 二分插入排序 */public class DichotomyInsertionSort &#123; //打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; //交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; //二分插入排序 public static void DichotomyInsertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; //初始化已排序序列的边界 int left = 0; int right = i - 1; int get = arr[i]; //二分查找，找到已排序元素序列中小于或等于要插入元素的位置left while (left &lt;= right) &#123; int mid = (left + right) / 2; if (arr[mid] &gt; get) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; for (int j = i - 1; j &gt;= left; j--) &#123; arr[j + 1] = arr[j]; //&gt;=left位置之后的元素整体后移 &#125; arr[left] = get; //将left位置赋值为get &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; //数组初始化 System.out.print("原数组元素："); printArr(arr); //打印数组 System.out.print("排序后数组元素："); DichotomyInsertionSort(arr); //二分插入排序 printArr(arr); //打印数组 &#125;&#125; 当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。 6、希尔排序(Shell Sort) 插入排序的更高效改进： 希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。 希尔排序的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package sort;/** * 希尔排序：插入排序的更高级改进 * 从小到大排列 */public class ShellSort &#123; // 打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; // 交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; // 希尔排序 public static void ShellSort(int[] arr) &#123; int h = 0; while (h &lt;= arr.length) &#123; // 生成初始化增量 h = 3 * h + 1; &#125; while (h &gt;= 1) &#123; for (int i = h; i &lt; arr.length; i++) &#123; int j = i - h; int get = arr[i]; while (j &gt;= 0 &amp;&amp; arr[j] &gt; get) &#123; arr[j + 1] = arr[j]; j = j - h; &#125; arr[j + h] = get; &#125; h = (h - 1) / 3; // 递减增量 &#125; &#125; //主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; // 数组初始化 System.out.print("原数组元素："); printArr(arr); // 打印数组 System.out.print("希尔排序后数组元素："); ShellSort(arr); // 希尔排序 printArr(arr); // 打印数组 &#125;&#125; 以23, 10, 4, 1的步长序列进行希尔排序： 希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。 比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和 { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。 7、归并排序(Merge Sort) 归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。 归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。 归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 归并排序的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package sort;/** * 归并排序 * 从小到大排序 */public class MergeSort &#123; // 打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; // 合并两个已排好序的数组A[left...mid]和A[mid+1...right] public static void merge(int A[], int left, int mid, int right) &#123; int len = right - left + 1; int[] temp = new int[len]; int index = 0; int i = left; //前一数组的起始元素 int j = mid + 1; //后一数组的起始元素 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; // 带等号保证归并排序的稳定性 &#125; while (i &lt;= mid) &#123; temp[index++] = A[i++]; &#125; while (j &lt;= right) &#123; temp[index++] = A[j++]; &#125; for (int k = 0; k &lt; len; k++) &#123; A[left++] = temp[k]; &#125; &#125; // 递归实现的归并排序 public static void mergeSortRecursion(int A[], int left, int right) &#123; // 当待排序的序列长度为1时，递归开始回溯，进行merge操作 if (left == right) &#123; return; &#125; int mid = (left + right) / 2; mergeSortRecursion(A, left, mid); mergeSortRecursion(A, mid + 1, right); merge(A, left, mid, right); &#125; // 非递归(迭代) 实现的归并排序（自底向上） public static void mergeSortIteration(int A[], int len) &#123; // 子数组索引，前一个为A[left...mid]，后一个子数组为A[mid+1...right] int left, mid, right; for (int i = 1; i &lt; len; i *= 2) &#123; // 子数组的大小i初始化为1，每轮翻倍 left = 0; while (left + i &lt; len) &#123; // 后一个数组存在（需要归并） mid = left + i - 1; right = mid + i &lt; len ? mid + i : len - 1; // 后一个子数组大小可能不够 merge(A, left, mid, right); left = right + 1; // 前一个子数组向后移动 &#125; &#125; &#125; public static void main(String[] args) &#123; // 从小到大归并排序 int[] A1 = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; int[] A2 = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; int n1 = A1.length; int n2 = A2.length; System.out.print("A1原数组元素："); printArr(A1); // 打印数组 System.out.print("递归实现的归并排序结果："); mergeSortRecursion(A1, 0, n1 - 1); // 递归实现 printArr(A1); System.out.print("A2原数组元素："); printArr(A2); // 打印数组 System.out.print("非递归实现的归并排序结果："); mergeSortIteration(A2, n2); // 非递归实现 printArr(A2); &#125;&#125; 上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下 使用归并排序为一列数字进行排序的宏观过程： 归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对。 8、堆排序(Heap Sort)​ 堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。 我们可以很容易的定义堆排序的过程： 由输入的无序数组构造一个最大堆，作为初始的无序区 把堆顶元素（最大值）和堆尾元素互换 把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整 重复步骤2，直到堆的尺寸为1 堆排序的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package sort;/** * 堆排序 * 从小到大排列 */public class HeapSort &#123; // 打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; // 交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; // 从A[i]向下进行堆调整 public static void heapify(int A[], int i, int size) &#123; int left_child = 2 * i + 1; // 左孩子索引 int right_child = 2 * i + 2; // 右孩子索引 int max = i; // 选出当前节点与其左右孩子三者之中的最大值 if (left_child &lt; size &amp;&amp; A[left_child] &gt; A[max]) &#123; max = left_child; &#125; if (right_child &lt; size &amp;&amp; A[right_child] &gt; A[max]) &#123; max = right_child; &#125; if (max != i) &#123; swapArr(A, i, max); // 把当前节点和它的最大（直接）子节点进行交换 heapify(A, max, size); // 递归调用，继续从当前节点向下进行堆调整 &#125; &#125; // 建堆 public static int buildHeap(int A[], int n) &#123; int heap_size = n; for (int i = heap_size / 2 - 1; i &gt;= 0; i--) // 从每一个非叶子结点开始向下进行调整 heapify(A, i, heap_size); return heap_size; &#125; // 堆排序 public static void heapSort(int A[], int n) &#123; int heap_size = buildHeap(A, n); // 建立一个最大堆 while (heap_size &gt; 1) &#123; // 堆（无序区）元素个数大于1，未完成排序 // 将堆顶元素与堆的最后一个元素交换，并从堆中去掉最后一个元素 // 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法 swapArr(A, 0, --heap_size); heapify(A, 0, heap_size); // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(log n) &#125; &#125; // 主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; // 数组初始化 System.out.print("原数组元素："); printArr(arr); // 打印数组 System.out.print("堆排序后数组元素："); heapSort(arr, arr.length); // 堆排序 printArr(arr); // 打印数组 &#125;&#125; 堆排序算法的演示： 动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。 堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。 比如序列：{ 9, 5, 7, 5 }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { 5, 5, 7, 9 }，再进行堆调整得到{ 7, 5, 5, 9 }，重复之前的操作最后得到{ 5, 5, 7, 9 }从而改变了两个5的相对次序。 9、快速排序(Quick Sort)​ 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为： 从序列中挑出一个元素，作为”基准”(pivot). 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。 快速排序的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package sort;/** * 快速排序 * 从小到大排列 */public class QuickSort &#123; // 打印数组 public static void printArr(int[] arr) &#123; for (int temp : arr) &#123; System.out.print(temp + " "); &#125; System.out.println(); &#125; // 交换数组元素 public static void swapArr(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; // 划分函数 public static int partition(int A[], int left, int right) &#123; int pivot = A[right]; // 这里每次都选择最后一个元素作为基准 int tail = left - 1; // tail为小于基准的子数组最后一个元素的索引 for (int i = left; i &lt; right; i++) &#123; //遍历基准以外的其他元素 if (A[i] &lt;= pivot) &#123; // 把小于等于基准的元素放到前一个子数组末尾 swapArr(A, ++tail, i); &#125; &#125; // 最后把基准放到前一个子数组的后边，剩下的儿子数组既是大于基准的子数组 // 该操作很有可能把后面的稳定性打乱，所以快速排序是不稳定的排序算法 swapArr(A, tail + 1, right); return tail + 1; &#125; // 快速排序 public static void quickSort(int A[], int left, int right) &#123; if (left &gt;= right) &#123; return; &#125; int pivot_index = partition(A, left, right); // 基准的索引 quickSort(A, left, pivot_index - 1); quickSort(A, pivot_index + 1, right); &#125; // 主方法 public static void main(String[] args) &#123; int[] arr = &#123;6, 5, 3, 1, 8, 7, 2, 4&#125;; // 数组初始化 System.out.print("原数组元素："); printArr(arr); // 打印数组 System.out.print("快速排序后数组元素："); quickSort(arr, 0, arr.length - 1); // 快速排序 printArr(arr); // 打印数组 &#125;&#125; 使用快速排序法对一列数字进行排序的过程： 快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。 比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。 Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？ 答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序优化]]></title>
    <url>%2Fposts%2F4ef397b8.html</url>
    <content type="text"><![CDATA[前一阵子有个读者在微信里跟我聊了一件很有趣的事情，他去美团实习，面试让他哭笑不得，因为败在了冒泡排序上。 情况是这样子的，当时和面试官聊的感觉还可以，就在他觉得好像差不多快结束的时候，面试官给他扔了个题：“我这刚好有纸和笔，你来写个冒泡排序吧。” 这位读者心里一慌，为什么慌，倒并不是因为不会写，因为作为一个程序员，冒泡排序基本上没有不会写的，而是事发突然，感觉不太妙。当时他是这么写的： 123456789public void bubbleSort(int[] a) &#123; for(int i = a.length - 1; i &gt; 0; i--) &#123; for(int j = 0; j &lt; i; j++) &#123; if(a[j] &gt; a[j+1]) //交换，具体实现略 swap(a, j, j+1); &#125; &#125;&#125; 果不其然，他写了之后，面试官就问他，这种写法有没有什么问题？能否继续优化？结果还真没答上来。（看到这里，读者们不妨也先思考下如何优化。） 今天就这个冒泡排序，我们再多聊几句，回归一下经典。也希望以后有朋友实习也好，校招也罢，不要再栽在同样的问题上了。 冒泡排序算法的时间复杂度高，如果不清楚算法复杂度如何计算，可以参考下这篇文章：循序渐进带你学习时间复杂度和空间复杂度。但是冒泡排序简单，基本流程是：每一轮从头开始两两比较，将较大的项放在较小项的右边，这样每轮下来保证该轮最大的数在最右边。如何实现？就如上面这位朋友所写的那样，基本上大家都会写。 但是今天主要讨论的是如何优化，有人可能会说，这是再简单不过的算法了，还有什么好优化的？确实，上面这段代码没有毛病，但的确是有可优化之处的。 我们可以假设一种场景，比如 8 1 2 3 5 7，进行一次排序之后，结果就变成了 1 2 3 5 7 8，那我们还有必要再像上面代码里那样继续循环下去吗？肯定没有必要了，因为这已经是最终结果了。 那针对上面的代码，我们优化的点主要在于：假如某一趟排序之后已经有序，我们需要减少排序的趟数。否则就做了很多无用功。 针对这个问题，我们可以考虑在算法中加入一个布尔变量，来标识该轮有没有进行数据的交换，若在某一趟排序中未发现数据位置的交换，则说明待排序的无序区中所有的项均已满足排序后的结果。那么就没有必要再次排序下去了。可以如下改造： 12345678910111213public void bubbleSort(int[] a) &#123; boolean exchange; for(int i = a.length - 1; i &gt; 0; i--) &#123; exchange = false; for(int j = 0; j &lt; i; j++) &#123; if(a[j] &gt; a[j+1]) &#123; swap(a, j, j+1); exchange = true; &#125; &#125; if(!exchange) return; &#125;&#125; 这样就优化完了，其实代码逻辑很简单，通过一个布尔变量即可监控一趟过程有没有进行数据交换。 冒泡排序最好的情况是初始状态是正序的，一次扫描即可完成排序，所以最好的时间复杂度为O(N)；最坏的情况是反序的，此时最坏的时间复杂度为O(N^2)。平均情况，每轮N/2次循环，N轮时间复杂度为O(N^2)。所以它并不是个好的排序算法。这个问题的讨论就到此结束，如果有更好的优化算法也欢迎留言讨论。 冒泡排序并不好，但为什么面试官还会去问？针对这件事情，我们需要注意什么呢？ 经典的东西，可能已经不用了，但是从经典的东西身上，我们能学到的还有很多，否则也不会成为经典。特别是那些面试经常被问到的，总有它存在的合理性。 教科书上的东西不代表实战，所以很多时候考虑到非理想情况下，就可能不那么适用了。面试官往往更加注重的是在不适用的情况下，面试者是如何应对的。面试官更加看重的是面试者的思路。 应届生不能浮躁，特别是在准备面试的时候，一定要步步为营，切忌好高骛远，浅尝辄止，多学习学习经典的数据结构和算法，多做做算法题还是很有必要的。]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle依赖配置说明]]></title>
    <url>%2Fposts%2F7a69db10.html</url>
    <content type="text"><![CDATA[之前对Android Gradle构建的依赖一直傻傻分不清，这段时间正好接入集团的一个二方库，踩了很多坑，也顺带把Gradle依赖这块搞清楚了，主要整理了下Gradle依赖的类型、依赖配置、如何查看依赖、依赖冲突如何解决。 依赖类型dependencies DSL标签是标准Gradle API中的一部分，而不是Android Gradle插件的特性，所以它不属于android标签。 依赖有三种方式，如下面的例子： 1234567891011121314apply plugin: 'com.android.application'android &#123; ... &#125;dependencies &#123; // Dependency on a local library module implementation project(":mylibrary") // Dependency on local binaries implementation fileTree(dir: 'libs', include: ['*.jar']) // Dependency on a remote binary implementation 'com.example.android:app-magic:12.3'&#125; 本地library模块依赖 1implementation project(":mylibrary") 这种依赖方式是直接依赖本地库工程代码的（需要注意的是，mylibrary的名字必须匹配在settings.gradle中include标签下定义的模块名字）。 本地二进制依赖 1implementation fileTree(dir: 'libs', include: ['*.jar']) 这种依赖方式是依赖工程中的 module_name/libs/目录下的Jar文件（注意Gradle的路径是相对于build.gradle文件来读取的，所以上面是这样的相对路径）。 如果只想依赖单个特定本地二进制库，可以如下配置： 1implementation files('libs/foo.jar', 'libs/bar.jar') 远程二进制依赖 1implementation 'com.example.android:app-magic:12.3' 上面是简写的方式，这种依赖完整的写法如下： 1implementation group: 'com.example.android', name: 'app-magic', version: '12.3' group、name、version共同定位一个远程依赖库。需要注意的点是，version最好不要写成”12.3+”这种方式，除非有明确的预期，因为非预期的版本更新会带来构建问题。远程依赖需要在repositories标签下声明远程仓库，例如jcenter()、google()、maven仓库等。 依赖配置目前Gradle版本支持的依赖配置有：implementation、api、compileOnly、runtimeOnly和annotationProcessor，已经废弃的配置有：compile、provided、apk、providedCompile。此外依赖配置还可以加一些配置项，例如AndroidTestImplementation、debugApi等等。 常用的是implementation、api、compileOnly三个依赖配置，含义如下： implementation与compile对应，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），但是在编译时不会将依赖的实现暴露给其他module，也就是只有在运行时其他module才能访问这个依赖中的实现。使用这个配置，可以显著提升构建时间，因为它可以减少重新编译的module的数量。建议，尽量使用这个依赖配置。 api与compile对应，功能完全一样，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），与implementation不同，这个依赖可以传递，其他module无论在编译时和运行时都可以访问这个依赖的实现，也就是会泄漏一些不应该不使用的实现。举个例子，A依赖B，B依赖C，如果都是使用api配置的话，A可以直接使用C中的类（编译时和运行时），而如果是使用implementation配置的话，在编译时，A是无法访问C中的类的。 compileOnly与provided对应，Gradle把依赖加到编译路径，编译时使用，不会打包到输出（aar或apk）。这可以减少输出的体积，在只在编译时需要，在运行时可选的情况，很有用。 runtimeOnly与apk对应，gradle添加依赖只打包到APK，运行时使用，但不会添加到编译路径。这个没有使用过。 annotationProcessor与compile对应，用于注解处理器的依赖配置，这个没用过。 查看依赖树可以查看单个module或者这个project的依赖，通过运行依赖的Gradle任务，如下： 1、View -&gt; Tools Windows -&gt; Gradle（或者点击右侧的Gradle栏）； 2、展开 AppName -&gt; Tasks -&gt; android，然后双击运行AndroidDependencies。运行完，就会在Run窗口打出依赖树了。 ### 依赖冲突解决随着很多依赖加入到项目中，难免会出现依赖冲突，出现依赖冲突如何解决？ 定位冲突 依赖冲突可能会报类似下面的错误： 1Program type already present com.example.MyClass 通过查找类的方式（command + O）定位到冲突的依赖，进行排除。 如何排除依赖 1、dependencies中排除（细粒度） 1234compile('com.taobao.android:accs-huawei:1.1.2@aar') &#123; transitive = true exclude group: 'com.taobao.android', module: 'accs_sdk_taobao'&#125; 2、全局配置排除 123456configurations &#123; compile.exclude module: 'cglib' //全局排除原有的tnet jar包与so包分离的配置，统一使用aar包中的内容 all*.exclude group: 'com.taobao.android', module: 'tnet-jni' all*.exclude group: 'com.taobao.android', module: 'tnet-so'&#125; 3、禁用依赖传递 1234567compile('com.zhyea:ar4j:1.0') &#123; transitive = false&#125;configurations.all &#123; transitive = false&#125; 还可以在单个依赖项中使用@jar标识符忽略传递依赖： 1compile 'com.zhyea:ar4j:1.0@jar' 4、强制使用某个版本 如果某个依赖项是必需的，而又存在依赖冲突时，此时没必要逐个进行排除，可以使用force属性标识需要进行依赖统一。当然这也是可以全局配置的： 123456789compile('com.zhyea:ar4j:1.0') &#123; force = true&#125;configurations.all &#123; resolutionStrategy &#123; force 'org.hamcrest:hamcrest-core:1.3' &#125;&#125; 5、在打包时排除依赖 先看一个示例： 1234567891011task zip(type: Zip) &#123; into('lib') &#123; from(configurations.runtime) &#123; exclude '*unwanted*', '*log*' &#125; &#125; into('') &#123; from jar from 'doc' &#125;&#125; 代码表示在打zip包的时候会过滤掉名称中包含“unwanted”和“log”的jar包。这里调用的exclude方法的参数和前面的例子不太一样，前面的参数多是map结构，这里则是一个正则表达式字符串。 也可以使用在打包时调用include方法选择只打包某些需要的依赖项： 1234567891011task zip(type: Zip) &#123; into('lib') &#123; from(configurations.runtime) &#123; include '*ar4j*', '*spring*' &#125; &#125; into('') &#123; from jar from 'doc' &#125;&#125; 主要是使用dependencies中排除和全局配置排除。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android优化总结]]></title>
    <url>%2Fposts%2F51192665.html</url>
    <content type="text"><![CDATA[目录介绍 1.OOM和崩溃优化 1.1 OOM优化 1.2 ANR优化 1.3 Crash优化 2.内存泄漏优化 2.0 动画资源未释放 2.1 错误使用单利 2.2 错误使用静态变量 2.3 handler内存泄漏 2.4 线程造成内存泄漏 2.5 非静态内部类 2.6 未移除监听 2.7 持有activity引用 2.8 资源未关闭 2.9 其他原因 3.布局优化 3.1 include优化 3.2 ViewStub优化 3.3 merge优化 3.4 其他建议 4.代码优化 4.1 lint代码检测 4.2 代码规范优化 4.3 View异常优化 4.4 去除淡黄色警告优化 4.5 合理使用集合 4.6 Activity不可见优化 4.7 节制的使用Service 5.网络优化 5.1 图片分类 5.2 获取网络数据优化 5.3 网络请求异常拦截优化 6.线程优化 6.1 使用线程池 7.图片优化 7.1 bitmap优化 7.2 glide加载优化 8.加载优化 8.1 懒加载优化 8.2 启动页优化 9.其他优化 9.1 静态变量优化 9.2 注解替代枚举 9.3 多渠道打包优化 9.4 TrimMemory和LowMemory优化 9.5 轮询操作优化 9.6 去除重复依赖库优化 9.7 四种引用优化 9.8 加载loading优化 9.9 对象池Pools优化 10.RecyclerView优化 10.1 页面为何卡顿 10.2 具体优化方案 1.OOM和崩溃优化1.2 ANR优化 ANR的产生需要满足三个条件 主线程：只有应用程序进程的主线程响应超时才会产生ANR； 超时时间：产生ANR的上下文不同，超时时间也会不同，但只要在这个时间上限内没有响应就会ANR； 输入事件/特定操作：输入事件是指按键、触屏等设备输入事件，特定操作是指BroadcastReceiver和Service的生命周期中的各个函数，产生ANR的上下文不同，导致ANR的原因也会不同； ANR优化具体措施 将所有耗时操作，比如访问网络，Socket通信，查询大量SQL 语句，复杂逻辑计算等都放在子线程中去，然 后通过handler.sendMessage、runonUIThread、AsyncTask 等方式更新UI。无论如何都要确保用户界面作的流畅 度。如果耗时操作需要让用户等待，那么可以在界面上显示度条。 使用AsyncTask处理耗时IO操作。在一些同步的操作主线程有可能被锁，需要等待其他线程释放相应锁才能继续执行，这样会有一定的ANR风险，对于这种情况有时也可以用异步线程来执行相应的逻辑。另外，要避免死锁的发生。 使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。 Activity的onCreate和onResume回调中尽量避免耗时的代码 BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。 各个组件的生命周期函数都不应该有太耗时的操作，即使对于后台Service或者ContentProvider来讲，应用在后台运行时候其onCreate()时候不会有用户输入引起事件无响应ANR，但其执行时间过长也会引起Service的ANR和ContentProvider的ANR 2.内存泄漏优化 内存检测第一种：代码方式获取内存 123456789101112131415/** * 内存使用检测：可以调用系统的getMemoryInfo()来获取当前内存的使用情况 */private void initMemoryInfo() &#123; ActivityManager activityManager = (ActivityManager) Utils.getApp() .getSystemService(Context.ACTIVITY_SERVICE); ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo(); if (activityManager != null) &#123; activityManager.getMemoryInfo(memoryInfo); LogUtils.d("totalMem=" + memoryInfo.totalMem + ",availMem=" + memoryInfo.availMem); if (!memoryInfo.lowMemory) &#123; // 运行在低内存环境 &#125; &#125;&#125; 内存检测第二种：leakcanary工具 LeakCanary的原理是监控每个activity，在activity ondestory后，在后台线程检测引用，然后过一段时间进行gc，gc后如果引用还在，那么dump出内存堆栈，并解析进行可视化显示。 2.0 动画资源未释放 问题代码 123456789101112public class LeakActivity extends AppCompatActivity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); textView = (TextView)findViewById(R.id.text_view); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(textView,"rotation",0,360); objectAnimator.setRepeatCount(ValueAnimator.INFINITE); objectAnimator.start(); &#125;&#125; 解决办法 在属性动画中有一类无限循环动画，如果在Activity中播放这类动画并且在onDestroy中去停止动画，那么这个动画将会一直播放下去，这时候Activity会被View所持有，从而导致Activity无法被释放。解决此类问题则是需要早Activity中onDestroy去去调用objectAnimator.cancel()来停止动画。 12345@Overrideprotected void onDestroy() &#123; super.onDestroy(); mAnimator.cancel();&#125; 2.1 错误使用单利 在开发中单例经常需要持有Context对象，如果持有的Context对象生命周期与单例生命周期更短时，或导致Context无法被释放回收，则有可能造成内存泄漏。比如：在一个Activity中调用的，然后关闭该Activity则会出现内存泄漏。 解决办法： 要保证Context和AppLication的生命周期一样，修改后代码如下： this.mContext = context.getApplicationContext(); 1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。 2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。 2.2 错误使用静态变量 使用静态方法是十分方便的。但是创建的对象，建议不要全局化，全局化的变量必须加上static。全局化后的变量或者对象会导致内存泄漏！ 原因分析 这里内部类AClass隐式的持有外部类Activity的引用，而在Activity的onCreate方法中调用了。这样AClass就会在Activity创建的时候是有了他的引用，而AClass是静态类型的不会被垃圾回收，Activity在执行onDestory方法的时候由于被AClass持有了引用而无法被回收，所以这样Activity就总是被AClass持有而无法回收造成内存泄露。 2.3 handler内存泄漏 造成内存泄漏原因分析 通过内部类的方式创建mHandler对象,此时mHandler会隐式地持有一个外部类对象引用这里就是MainActivity，当执行postDelayed方法时，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，MessageQueue是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。 解决Handler内存泄露主要2点 有延时消息，要在Activity销毁的时候移除Messages监听 匿名内部类导致的泄露改为匿名静态内部类，并且对上下文或者Activity使用弱引用。 2.4 线程造成内存泄漏 早时期的时候处理耗时操作多数都是采用Thread+Handler的方式，后来逐步被AsyncTask取代，直到现在采用RxJava的方式来处理异步。 造成内存泄漏原因分析 在处理一个比较耗时的操作时，可能还没处理结束MainActivity就执行了退出操作，但是此时AsyncTask依然持有对MainActivity的引用就会导致MainActivity无法释放回收引发内存泄漏。 解决办法 在使用AsyncTask时，在Activity销毁时候也应该取消相应的任务AsyncTask.cancel()方法，避免任务在后台执行浪费资源，进而避免内存泄漏的发生。 2.5 非静态内部类 非静态内部类创建静态实例造成的内存泄漏。有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法。 问题代码 12345678910111213private static TestResource mResource = null;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mResource == null)&#123; mResource = new TestResource(); &#125;&#125;class TestResource &#123; //里面代码引用上下文，Activity.this会导致内存泄漏&#125; 解决办法 将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。 分析问题 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。 2.6 未移除监听 问题代码 1234567//add监听，放到集合里面tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() &#123; @Override public void onWindowFocusChanged(boolean b) &#123; //监听view的加载，view加载出来的时候，计算他的宽高等。 &#125;&#125;); 解决办法 12//计算完后，一定要移除这个监听tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this); 注意事项： 12tv.setOnClickListener();//监听执行完回收对象，不用考虑内存泄漏tv.getViewTreeObserver().addOnWindowFocusChangeListene,add监听，放到集合里面，需要考虑内存泄漏 2.7 持有activity引用2.8 资源未关闭 在使用IO、File流或者Sqlite、Cursor等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果及时不关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。 BroadcastReceiver，ContentObserver，FileObserver，Cursor，Callback等在 Activity onDestroy 或者某类生命周期结束之后一定要 unregister 或者 close 掉，否则这个 Activity 类会被 system 强引用，不会被内存回收。值得注意的是，关闭的语句必须在finally中进行关闭，否则有可能因为异常未关闭资源，致使activity泄漏。 2.9 其他原因 静态集合使用不当导致的内存泄漏 有时候我们需要把一些对象加入到集合容器（例如ArrayList）中，当不再需要当中某些对象时，如果不把该对象的引用从集合中清理掉，也会使得GC无法回收该对象。如果集合是static类型的话，那内存泄漏情况就会更为严重。因此，当不再需要某对象时，需要主动将之从集合中移除。 不需要用的监听未移除会发生内存泄露 问题代码 1234567//add监听，放到集合里面tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() &#123; @Override public void onWindowFocusChanged(boolean b) &#123; //监听view的加载，view加载出来的时候，计算他的宽高等。 &#125;&#125;); 解决办法 12//计算完后，一定要移除这个监听tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this); 注意事项： 123tv.setOnClickListener();//监听执行完回收对象，不用考虑内存泄漏 tv.getViewTreeObserver().addOnWindowFocusChangeListene,add监听，放到集合里面，需要考虑内存泄漏 复制代码 3.布局优化3.1 include优化 重用布局文件 标签可以允许在一个布局当中引入另一个布局，那么比如说我们程序的所有界面都有一个公共的部分，这个时候最好的做法就是将这个公共的部分提取到一个独立的布局中，然后每个界面的布局文件当中来引用这个公共的布局。 如果我们要在标签中覆写layout属性，必须要将layout_width和layout_height这两个属性也进行覆写，否则覆写效果将不会生效。 标签是作为标签的一种辅助扩展来使用的，它的主要作用是为了防止在引用布局文件时引用文件时产生多余的布局嵌套。布局嵌套越多，解析起来就越耗时，性能就越差。因此编写布局文件时应该让嵌套的层数越少越好。 举例：比如在LinearLayout里边使用一个布局。里边又有一个LinearLayout，那么其实就存在了多余的布局嵌套，使用merge可以解决这个问题。 3.2 ViewStub优化 仅在需要时才加载布局[ViewStub] 某个布局当中的元素不是一起显示出来的，普通情况下只显示部分常用的元素，而那些不常用的元素只有在用户进行特定操作时才会显示出来。 举例：填信息时不是需要全部填的，有一个添加更多字段的选项，当用户需要添加其他信息的时候，才将另外的元素显示到界面上。用VISIBLE性能表现一般，可以用ViewStub。 ViewStub也是View的一种，但是没有大小，没有绘制功能，也不参与布局，资源消耗非常低，可以认为完全不影响性能。 ViewStub所加载的布局是不可以使用标签的，因此这有可能导致加载出来出来的布局存在着多余的嵌套结构。 自定义全局的状态管理器【充分使用ViewStub】 针对多状态，有数据，空数据，加载失败，加载异常，网络异常等。针对空数据，加载失败，异常使用viewStub布局，一键设置自定义布局，也是优化的一种。 项目地址： 3.3 merge优化 视图层级 这个标签在UI的结构优化中起着非常重要的作用，它可以删减多余的层级，优化UI。但是就有一点不好，无法预览布局效果！ 3.4 其他建议 减少太多重叠的背景(overdraw) 这个问题其实最容易解决，建议就是检查你在布局和代码中设置的背景，有些背景是隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。如果采用的是selector的背景，将normal状态的color设置为”@android:color/transparent”,也同样可以解决问题。 避免复杂的Layout层级 这里的建议比较多一些，首先推荐使用Android提供的布局工具Hierarchy Viewer来检查和优化布局。第一个建议是：如果嵌套的线性布局加深了布局层次，可以使用相对布局来取代。第二个建议是：用标签来合并布局。第三个建议是：用标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了。记住，这些建议的最终目的都是使得你的Layout在Hierarchy Viewer里变得宽而浅，而不是窄而深。 总结：可以考虑多使用merge和include，ViewStub。尽量使布局浅平，根布局尽量少使用RelactivityLayout,因为RelactivityLayout每次需要测量2次。 4.代码优化 都是一些微优化，在性能方面看不出有什么显著的提升的。使用合适的算法和数据结构是优化程序性能的最主要手段。 4.1 建议使用lint检查去除无效代码 lint去除无效资源和代码 如何检测哪些图片未被使用 点击菜单栏 Analyze -&gt; Run Inspection by Name -&gt; unused resources -&gt; Moudule ‘app’ -&gt; OK，这样会搜出来哪些未被使用到未使用到xml和图片，如下： 如何检测哪些无效代码 使用Android Studio的Lint，步骤：点击菜单栏 Analyze -&gt; Run Inspection by Name -&gt; unused declaration -&gt; Moudule ‘app’ -&gt; OK 4.2 代码规范优化 避免创建不必要的对象 不必要的对象应该避免创建： 如果有需要拼接的字符串，那么可以优先考虑使用StringBuffer或者StringBuilder来进行拼接，而不是加号连接符，因为使用加号连接符会创建多余的对象，拼接的字符串越长，加号连接符的性能越低。 当一个方法的返回值是String的时候，通常需要去判断一下这个String的作用是什么，如果明确知道调用方会将返回的String再进行拼接操作的话，可以考虑返回一个StringBuffer对象来代替，因为这样可以将一个对象的引用进行返回，而返回String的话就是创建了一个短生命周期的临时对象。 尽可能地少创建临时对象，越少的对象意味着越少的GC操作。 nDraw方法里面不要执行对象的创建 静态优于抽象 如果你并不需要访问一个对系那个中的某些字段，只是想调用它的某些方法来去完成一项通用的功能，那么可以将这个方法设置成静态方法，调用速度提升15%-20%，同时也不用为了调用这个方法去专门创建对象了，也不用担心调用这个方法后是否会改变对象的状态(静态方法无法访问非静态字段)。 对常量使用static final修饰符 static int intVal = 42; static String strVal = “Hello, world!”; 编译器会为上面的代码生成一个初始方法，称为方法，该方法会在定义类第一次被使用的时候调用。这个方法会将42的值赋值到intVal当中，从字符串常量表中提取一个引用赋值到strVal上。当赋值完成后，我们就可以通过字段搜寻的方式去访问具体的值了。 final进行优化: static final int intVal = 42; static final String strVal = “Hello, world!”; 这样，定义类就不需要方法了，因为所有的常量都会在dex文件的初始化器当中进行初始化。当我们调用intVal时可以直接指向42的值，而调用strVal会用一种相对轻量级的字符串常量方式，而不是字段搜寻的方式。 这种优化方式只对基本数据类型以及String类型的常量有效，对于其他数据类型的常量是无效的。 在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。 基本数据类型的数组也要优于对象数据类型的数组。另外两个平行的数组要比一个封装好的对象数组更加高效，举个例子，Foo[]和Bar[]这样的数组，使用起来要比Custom(Foo,Bar)[]这样的一个数组高效的多。 4.3 View异常优化 view自定义控件异常销毁保存状态 经常容易被人忽略，但是为了追求高质量代码，这个也有必要加上。举个例子！ 12345678910111213141516171819202122@Overrideprotected Parcelable onSaveInstanceState() &#123; //异常情况保存重要信息。 //return super.onSaveInstanceState(); final Bundle bundle = new Bundle(); bundle.putInt("selectedPosition",selectedPosition); bundle.putInt("flingSpeed",mFlingSpeed); bundle.putInt("orientation",orientation); return bundle;&#125;@Overrideprotected void onRestoreInstanceState(Parcelable state) &#123; if (state instanceof Bundle) &#123; final Bundle bundle = (Bundle) state; selectedPosition = bundle.getInt("selectedPosition",selectedPosition); mFlingSpeed = bundle.getInt("flingSpeed",mFlingSpeed); orientation = bundle.getInt("orientation",orientation); return; &#125; super.onRestoreInstanceState(state);&#125; 4.4 去除淡黄色警告优化 淡黄色警告虽然不会造成崩溃，但是作为程序员还是要尽量去除淡黄色警告，规范代码 4.5 合理使用集合 使用优化过的数据集合 Android提供了一系列优化过后的数据集合工具类，如SparseArray、SparseBooleanArray、LongSparseArray，使用这些API可以让我们的程序更加高效。HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。 4.6 Activity不可见优化 当Activity界面不可见时释放内存 当用户打开了另外一个程序，我们的程序界面已经不可见的时候，我们应当将所有和界面相关的资源进行释放。重写Activity的onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发说明用户离开了程序，此时就可以进行资源释放操作了。 当时看到这个觉得很新奇的，但是具体还是没有用到，要是那个大神有具体操作方案，可以分享一下。 4.7 节制的使用Service 节制的使用Service 如果应用程序需要使用Service来执行后台任务的话，只有当任务正在执行的时候才应该让Service运行起来。当启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，系统可以在LRUcache当中缓存的进程数量也会减少，导致切换程序的时候耗费更多性能。我们可以使用IntentService，当后台任务执行结束后会自动停止，避免了Service的内存泄漏。 5.网络优化5.1 图片分类 图片网络优化 比如我之前看到豆瓣接口，提供一种加载图片方式特别好。接口返回图片的数据有三种，一种是高清大图，一种是正常图片，一种是缩略小图。当用户处于wifi下给控件设置高清大图，当4g或者3g模式下加载正常图片，当弱网条件下加载缩略图【也称与加载图】。 简单来说根据用户的当前的网络质量来判断下载什么质量的图片（电商用的比较多）。豆瓣开源接口可以参考一下！ 5.2 获取网络数据优化 移动端获取网络数据优化的几个点 连接复用：节省连接建立时间，如开启 keep-alive。 对于Android来说默认情况下HttpURLConnection和HttpClient都开启了keep-alive。只是2.2之前HttpURLConnection存在影响连接池的Bug，具体可见：Android HttpURLConnection及HttpClient选择 请求合并：即将多个请求合并为一个进行请求，比较常见的就是网页中的CSS Image Sprites。如果某个页面内请求过多，也可以考虑做一定的请求合并。 减少请求数据的大小：对于post请求，body可以做gzip压缩的，header也可以做数据压缩(不过只支持http 返回数据的body也可以做gzip压缩，body数据体积可以缩小到原来的30%左右。（也可以考虑压缩返回的json数据的key数据的体积，尤其是针对返回数据格式变化不大的情况，支付宝聊天返回的数据用到了） 5.3 网络请求异常拦截优化 在获取数据的流程中，访问接口和解析数据时都有可能会出错，我们可以通过拦截器在这两层拦截错误。 1.在访问接口时，我们不用设置拦截器，因为一旦出现错误，Retrofit会自动抛出异常。比如，常见请求异常404，500，503等等。 2.在解析数据时，我们设置一个拦截器，判断Result里面的code是否为成功，如果不成功，则要根据与服务器约定好的错误码来抛出对应的异常。比如，token失效，禁用同账号登陆多台设备，缺少参数，参数传递异常等等。 3.除此以外，为了我们要尽量避免在View层对错误进行判断，处理，我们必须还要设置一个拦截器，拦截onError事件，然后使用ExceptionUtils，让其根据错误类型来分别处理。 具体可以直接看lib中的ExceptionUtils类，那么如何调用呢？入侵性极低，不用改变之前的代码！ 12345@Overridepublic void onError(Throwable e) &#123; //直接调用即可 ExceptionUtils.handleException(e);&#125; 6.线程优化6.1 使用线程池 将全局线程用线程池管理 直接创建Thread实现runnable方法的弊端 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失 为什么要用线程池 重用线程池中的线程，避免频繁地创建和销毁线程带来的性能消耗；有效控制线程的最大并发数量，防止线程过大导致抢占资源造成系统阻塞；可以对线程进行一定地管理。 使用线程池管理的经典例子 RxJava，RxAndroid，底层对线程池的封装管理特别值得参考 关于线程池，线程，多线程的具体内容 参考：轻量级线程池封装库，支持异步回调，可以检测线程执行的状态 该项目中哪里用到频繁new Thread 保存图片[注意，尤其是大图和多图场景下注意耗时太久]；某些页面从数据库查询数据；设置中心清除图片，视频，下载文件，日志，系统缓存等缓存内容 使用线程池管理库好处，比如保存图片，耗时操作放到子线程中，处理过程中，可以检测到执行开始，异常，成功，失败等多种状态。 7.图片优化7.1 bitmap优化 加载图片所占的内存大小计算方式 加载网络图片：bitmap内存大小 = 图片长度 x 图片宽度 x 单位像素占用的字节数【看到网上很多都是这样写的，但是不全面】 加载本地图片：bitmap内存大小 = width * height * nTargetDensity/inDensity 一个像素所占的内存。注意不要忽略了一个影响项：Density 第一种加载图片优化处理：压缩图片 质量压缩方法：在保持像素的前提下改变图片的位深及透明度等，来达到压缩图片的目的，这样适合去传递二进制的图片数据，比如分享图片，要传入二进制数据过去，限制500kb之内。 采样率压缩方法：设置inSampleSize的值(int类型)后，假如设为n，则宽和高都为原来的1/n，宽高都减少，内存降低。 缩放法压缩：Android中使用Matrix对图像进行缩放、旋转、平移、斜切等变换的。功能十分强大！ 第二种加载图片优化：不压缩加载高清图片如何做？ 使用BitmapRegionDecoder，主要用于显示图片的某一块矩形区域，如果你需要显示某个图片的指定区域，那么这个类非常合适。 7.2 glide加载优化 在画廊中加载大图 假如你滑动特别快，glide加载优化就显得非常重要呢，具体优化方法如下所示 12345678910111213recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; LoggerUtils.e("initRecyclerView"+ "恢复Glide加载图片"); Glide.with(ImageBrowseActivity.this).resumeRequests(); &#125;else &#123; LoggerUtils.e("initRecyclerView"+"禁止Glide加载图片"); Glide.with(ImageBrowseActivity.this).pauseRequests(); &#125; &#125;&#125;); 8.加载优化8.1 懒加载优化 该优化在新闻类app中十分常见 ViewPager+Fragment的搭配在日常开发中也比较常见，可用于切换展示不同类别的页面。 懒加载,其实也就是延迟加载,就是等到该页面的UI展示给用户时,再加载该页面的数据(从网络、数据库等),而不是依靠ViewPager预加载机制提前加载两三个，甚至更多页面的数据。这样可以提高所属Activity的初始化速度,也可以为用户节省流量.而这种懒加载的方式也已经/正在被诸多APP所采用。 具体看这篇文章 www.jianshu.com/p/cf1f4104d… 8.2 启动页优化 启动时间分析 系统创建进程的时间和应用进程启动的时间，前者是由系统自行完成的，一般都会很快，我们也干预不了，我觉得能做的就是去优化应用进程启动，具体说来就是从发Application的onCreate()执行开始到MainActivity的onCreate()执行结束这一段时间。 启动时间优化 Application的onCreate()方法 MainActivity的onCreate()方法 优化的手段也无非三种，如下所示： 延迟初始化 后台任务 启动界面预加载 启动页白屏优化 为什么存在这个问题？ 当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态，于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是Preview Window，即预览窗口。 实际上就是是activity默认的主题中的android:windowBackground为白色或者黑色导致的。 总结来说启动顺序就是：app启动——Preview Window(也称为预览窗口)——启动页 解决办法 常见有三种，这里解决办法是给当前启动页添加一个有背景的style样式，然后SplashActivity引用当前theme主题，注意在该页面将window的背景图设置为空！ 更多关于启动页为什么白屏闪屏，以及不同解决办法，可以看我这篇博客：App启动页面优化 启动时间优化 IntentService子线程分担部分初始化工作 现在application初始化内容有：阿里云推送初始化，腾讯bugly初始化，im初始化，神策初始化，内存泄漏工具初始化，头条适配方案初始化，阿里云热修复……等等。将部分逻辑放到IntentService中处理，可以缩短很多时间。 开启IntentSerVice线程，将部分逻辑和耗时的初始化操作放到这里处理，可以减少application初始化时间 关于IntentService使用和源码分析，性能分析等可以参考博客：IntentService源码分析 9.其他优化9.1 静态变量优化 尽量不使用静态变量保存核心数据。这是为什么呢？ - 这是因为android的进程并不是安全的，包括application对象以及静态变量在内的进程级别变量并不会一直呆着内存里面，因为它很有会被kill掉。 - 当被kill掉之后，实际上app不会重新开始启动。Android系统会创建一个新的Application对象，然后启动上次用户离开时的activity以造成这个app从来没有被kill掉的假象。而这时候静态变量等数据由于进程已经被杀死而被初始化，所以就有了不推荐在静态变量（包括Application中保存全局数据静态数据）的观点。 9.2 注解替代枚举 使用注解限定传入类型 比如，尤其是写第三方开源库，对于有些暴露给开发者的方法，需要限定传入类型是有必要的。举个例子： 刚开始的代码 123456789/** * 设置播放器类型，必须设置 * 注意：感谢某人建议，这里限定了传入值类型 * 输入值：111 或者 222 * @param playerType IjkPlayer or MediaPlayer. */public void setPlayerType(int playerType) &#123; mPlayerType = playerType;&#125; 优化后的代码，有效避免第一种方式开发者传入值错误 12345678910111213141516171819202122/** * 设置播放器类型，必须设置 * 注意：感谢某人建议，这里限定了传入值类型 * 输入值：ConstantKeys.IjkPlayerType.TYPE_IJK 或者 ConstantKeys.IjkPlayerType.TYPE_NATIVE * @param playerType IjkPlayer or MediaPlayer. */public void setPlayerType(@ConstantKeys.PlayerType int playerType) &#123; mPlayerType = playerType;&#125;/** * 通过注解限定类型 * TYPE_IJK IjkPlayer，基于IjkPlayer封装播放器 * TYPE_NATIVE MediaPlayer，基于原生自带的播放器控件 */@Retention(RetentionPolicy.SOURCE)public @interface IjkPlayerType &#123; int TYPE_IJK = 111; int TYPE_NATIVE = 222;&#125;@IntDef(&#123;IjkPlayerType.TYPE_IJK,IjkPlayerType.TYPE_NATIVE&#125;)public @interface PlayerType&#123;&#125; 使用注解替代枚举，代码如下所示 1234567@Retention(RetentionPolicy.SOURCE)public @interface ViewStateType &#123; int HAVE_DATA = 1; int EMPTY_DATA = 2; int ERROR_DATA = 3; int ERROR_NETWORK = 4;&#125; 9.3 多渠道打包优化 还在手动打包吗？尝试一下python自动化打包吧…… 瓦力多渠道打包的Python脚本测试工具，通过该自动化脚本，自需要run一下或者命令行运行脚本即可实现美团瓦力多渠道打包，打包速度很快。配置信息十分简单，代码中已经注释十分详细。可以自定义输出文件路径，可以修改多渠道配置信息，简单实用。 项目地址：github.com/yangchong21… 9.4 TrimMemory和LowMemory优化 可以优化什么？ 在 onTrimMemory() 回调中，应该在一些状态下清理掉不重要的内存资源。对于这些缓存，只要是读进内存内的都算，例如最常见的图片缓存、文件缓存等。拿图片缓存来说，市场上，常规的图片加载库，一般而言都是三级缓存，所以在内存吃紧的时候，我们就应该优先清理掉这部分图片缓存，毕竟图片是吃内存大户，而且再次回来的时候，虽然内存中的资源被回收掉了，依然可以从磁盘或者网络上恢复它。 大概的思路如下所示 在lowMemory的时候，调用Glide.cleanMemory()清理掉所有的内存缓存。 在App被置换到后台的时候，调用Glide.cleanMemory()清理掉所有的内存缓存。 在其它情况的onTrimMemory()回调中，直接调用Glide.trimMemory()方法来交给Glide处理内存情况。 9.5 轮询操作优化 什么叫轮训请求？ 简单理解就是App端每隔一定的时间重复请求的操作就叫做轮训请求，比如：App端每隔一段时间上报一次定位信息，App端每隔一段时间拉去一次用户状态等，这些应该都是轮训请求。比如，电商类项目，某个抽奖活动页面，隔1分钟调用一次接口，弹出一些获奖人信息，你应该某个阶段看过这类轮询操作！ 具体优化操作 长连接并不是稳定的可靠的，而执行轮训操作的时候一般都是要稳定的网络请求，而且轮训操作一般都是有生命周期的，即在一定的生命周期内执行轮训操作，而长连接一般都是整个进程生命周期的，所以从这方面讲也不太适合。 建议在service中做轮询操作，轮询请求接口，具体做法和注意要点，可以直接看该项目代码。看app包下的LoopRequestService类即可。 大概思路：当用户打开这个页面的时候初始化TimerTask对象，每个一分钟请求一次服务器拉取订单信息并更新UI，当用户离开页面的时候清除TimerTask对象，即取消轮训请求操作。 9.6 去除重复依赖库优化 我相信你看到了这里会有疑问，网上有许多博客作了这方面说明。但是我在这里想说，如何查找自己项目的所有依赖关系树 注意要点：其中app就是项目mudule名字。 正常情况下就是app！ 1gradlew app:dependencies 关于依赖关系树的结构图如下所示，此处省略很多代码 12345678910111213| | | | | | \--- android.arch.core:common:1.1.1 (*)| | | | \--- com.android.support:support-annotations:26.1.0 -&gt; 28.0.0| +--- com.journeyapps:zxing-android-embedded:3.6.0| | +--- com.google.zxing:core:3.3.2| | \--- com.android.support:support-v4:25.3.1| | +--- com.android.support:support-compat:25.3.1 -&gt; 28.0.0 (*)| | +--- com.android.support:support-media-compat:25.3.1| | | +--- com.android.support:support-annotations:25.3.1 -&gt; 28.0.0| | | \--- com.android.support:support-compat:25.3.1 -&gt; 28.0.0 (*)| | +--- com.android.support:support-core-utils:25.3.1 -&gt; 28.0.0 (*)| | +--- com.android.support:support-core-ui:25.3.1 -&gt; 28.0.0 (*)| | \--- com.android.support:support-fragment:25.3.1 -&gt; 28.0.0 (*)\--- com.android.support:multidex:1.0.2 -&gt; 1.0.3 然后查看哪些重复jar 然后修改gradle配置代码 1234api (rootProject.ext.dependencies[&quot;zxing&quot;])&#123; exclude module: &apos;support-v4&apos; exclude module: &apos;appcompat-v7&apos;&#125; 9.7 四种引用优化 软引用使用场景 正常是用来处理大图片这种占用内存大的情况 代码如下所示 1234567Bitmap bitmap = bitmaps.get(position);//正常是用来处理图片这种占用内存大的情况bitmapSoftReference = new SoftReference&lt;&gt;(bitmap);if(bitmapSoftReference.get() != null) &#123; viewHolder.imageView.setImageBitmap(bitmapSoftReference.get());&#125;//其实看glide底层源码可知，也做了相关软引用的操作 这样使用软引用好处 通过软引用的get()方法，取得bitmap对象实例的强引用，发现对象被未回收。在GC在内存充足的情况下，不会回收软引用对象。此时view的背景显示 实际情况中,我们会获取很多图片.然后可能给很多个view展示, 这种情况下很容易内存吃紧导致oom,内存吃紧，系统开始会GC。这次GC后，bitmapSoftReference.get()不再返回bitmap对象，而是返回null，这时屏幕上背景图不显示，说明在系统内存紧张的情况下，软引用被回收。 使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。 弱引用使用场景 弱引用–&gt;随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收。 对于使用频次少的对象，希望尽快回收，使用弱引用可以保证内存被虚拟机回收。比如handler，如果希望使用完后尽快回收，看下面代码 1234567891011121314private MyHandler handler = new MyHandler(this);private static class MyHandler extends Handler&#123; WeakReference&lt;FirstActivity&gt; weakReference; MyHandler(FirstActivity activity) &#123; weakReference = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what)&#123; &#125; &#125;&#125; 到底什么时候使用软引用，什么时候使用弱引用呢？ 个人认为，如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 还有就是可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 9.8 加载loading优化 一般实际开发中会至少有两种loading 第一种是从A页面进入B页面时的加载loading，这个时候特点是显示loading的时候，页面是纯白色的，加载完数据后才显示内容页面。 第二种是在某个页面操作某种逻辑，比如某些耗时操作，这个时候是局部loading[一般用个帧动画或者补间动画]，由于使用频繁，因为建议在销毁弹窗时，添加销毁动画的操作。 自定义loading加载 github.com/yangchong21… 9.9 对象池Pools优化 对象池Pools优化频繁创建和销毁对象 使用对象池，可以防止频繁创建和销毁对象而出现内存抖动 在某些时候，我们需要频繁使用一些临时对象，如果每次使用的时候都申请新的资源，很有可能会引发频繁的 gc 而影响应用的流畅性。这个时候如果对象有明确的生命周期，那么就可以通过定义一个对象池来高效的完成复用对象。 具体参考案例，可以看该项目：github.com/yangchong21… 10.RecyclerView优化10.1 页面为何卡顿 RecyclerView滑动卡顿的原因有哪些？ 第一种：嵌套布局滑动冲突 导致嵌套滑动难处理的关键原因在于当子控件消费了事件, 那么父控件就不会再有机会处理这个事件了, 所以一旦内部的滑动控件消费了滑动操作, 外部的滑动控件就再也没机会响应这个滑动操作了 第二种：嵌套布局层次太深，比如六七层等 测量，绘制布局可能会导致滑动卡顿 第三种：比如用RecyclerView实现画廊，加载比较大的图片，如果快速滑动，则可能会出现卡顿，主要是加载图片需要时间 第四种：在onCreateViewHolder或者在onBindViewHolder中做了耗时的操作导致卡顿。按stackoverflow上面比较通俗的解释：RecyclerView.Adapter里面的onCreateViewHolder()方法和onBindViewHolder()方法对时间都非常敏感。类似I/O读写，Bitmap解码一类的耗时操作，最好不要在它们里面进行。 关于RecyclerView封装库 github.com/yangchong21… 10.2 具体优化方案 03.SparseArray替代HashMap 04.瀑布流图片错乱问题解决 05.item点击事件放在哪里优化 06.ViewHolder优化 07.连续上拉加载更多优化 08.拖拽排序与滑动删除优化 09.暂停或停止加载数据优化 11.异常情况下保存状态 12.多线程下插入数据优化 14.recyclerView优化处理 15.adapter优化 具体看这篇博客：recyclerView优化 关于其他内容介绍于博客汇总链接 1.技术博客汇总 2.开源项目汇总 3.生活博客汇总 4.喜马拉雅音频汇总 5.其他汇总]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android骨架屏，了解一下]]></title>
    <url>%2Fposts%2F2114cdef.html</url>
    <content type="text"><![CDATA[以前做应用开发时，在数据尚未加载前一般会先给用户一个提示，最简单粗暴的方式就是菊花图，大多数做法是放一张有个性的静态图，示意正在加载数据，这样体验会好些，直到出现 Skeleton Screen（中文一般叫做骨架屏）极大地提升用户感知体验。其实一开始我并不知道这个效果叫什么名字，后来在 GitHub 看到有人开源了，赶紧 Star。今天我给大家推荐几个 Skeleton Screen 相关库，来了解学习一波。 1、ShimmerRecyclerView简介A custom recycler view with shimmer views to indicate that views are loading （英语渣渣，这句话始终翻译不顺/捂脸）。 效果预览 2、Skeleton简介这个库提供了一种显示骨架加载视图的简便方法，它现在使用闪存动画的内存优化版本，因此速度更快，您也可以设置更大的布局动画。 效果预览 3、spruce-android简介Spruce 是一个轻量级动画库，可帮助编排屏幕上的动画。该库同时支持 iOS。 效果预览]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>骨架屏</tag>
        <tag>加载优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，Flutter]]></title>
    <url>%2Fposts%2Fbe2502a3.html</url>
    <content type="text"><![CDATA[什么是Flutter2018年2月27日，在2018世界移动大会上，Google发布了Flutter的第一个Beta版本。Flutter是Google用以帮助开发者在Ios和Android两个平台开发高质量原生应用的全新移动UI框架，点击查看Flutter介绍视频。 其实我第一次听说Flutter是在收到谷歌开发者公众号的推送里，当时读完了那篇文章觉得Flutter的优点确实比较突出： 热重载（Hot Reload），作为一个菜鸟安卓开发者，能热重载真的太舒服了，利用Android Studio直接一个ctrl+s就可以保存并重载，模拟器立马就可以看见效果，就这一点比原生安卓制作简直不知道高到哪里去了。 一切皆为Widget的理念，对于Flutter来说，手机应用里的所有东西都是Widget，通过可组合的空间集合、丰富的动画库以及分层课扩展的架构实现了富有感染力的灵活界面设计。 借助可移植的GPU加速的渲染引擎以及高性能本地代码运行时以达到跨平台设备的高质量用户体验。 这段介绍是直接抄下来的，虽然我并不知道什么叫可移植的GPU加速的渲染引擎，但是最终结果就是利用Flutter构建的应用在运行效率上会和原生应用差不多。 酷安上有一个Flutter的演示Demo，Flutter Gallery。 如果经常逛酷安的一定会发现这个画廊的演示Demo的图标和另一个演示Demo的图标是一样的，Google Fuchsia OS Preview,这个应用的是传闻的Google正在研发的新一代操作系统，所以个人认为，Flutter的存在可能不仅仅是实现在安卓和IOS上的运行，更是为了日后丰富Fuchsia这个新系统的软件生态而存在的。 Flutter的核心内容接下来我想写一下我自己通过这两天的接触对于Flutter的核心内容也就是上面好处的第二点的理解。 一切都是控件（Widget）在Flutter中，每个应用程序都是Widget，这点和其他的应用框架不一样，Flutter的对象模型是统一的，也就是控件。 一个控件可以定义： 结构元素（比如按钮或者菜单） 风格元素（比如字体或者颜色方案） 布局 一些业务逻辑 等等。。。。 控件是基于构图形成层次结构，每个控件嵌套在其中，并从其父代继承属性，没有单独的“应用程序”对象，只有根控件。 您可以通过告知框架用另一个控件替换层次结构中的控件来响应事件，比如用户交互，然后框架会对比新的控件和旧的控件，并有效的更新用户界面，即更新有变化的控件。 也就是说，在Flutter中，一个应用就是有许许多多的Widget组合而成的。 构建第一个Flutter实例先来介绍一下Flutter里面的基本空间： Text：文本控件，在应用中创建各种样式的文本。 Row,Column：Flex控件，可以创建水平(Row)或垂直(Column)方向的布局，是基于Web的flexbox的布局模式设计的。 Stack：非线性布局（水平或垂直），控件可以堆叠在其他控件上，可以使用Positioned控件控制Stack相对顶部、右部、底部和左部的位置，是基于Web的absolute定位的布局模式。 Container：创建矩形的可视元素，可以用BoxDecoration来设计样式，比如背景、边框和阴影，Container也有边距、填充和大小限制，另外，还可以在三维空间利用矩阵进行变换。 结合实例分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import 'package:flutter/material.dart';class MyAppBar extends StatelessWidget &#123; MyAppBar(&#123;this.title&#125;); final Widget title; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Container( height: 56.0, padding: const EdgeInsets.symmetric(horizontal: 8.0), decoration: new BoxDecoration(color: Colors.blue[500]), //new Row意味着该子布局为水平布局 child: new Row( children: &lt;Widget&gt;[ //布局依次为图标按钮，剩余容器和图标按钮，如果把第二个IconButton移动到Expanded前则内容会发生改变 new IconButton( icon: new Icon(Icons.menu), tooltip: '导航菜单', onPressed: null ), //Expanded的作用可以使用剩余的所有空间。 new Expanded( child: title ), new IconButton( icon: new Icon(Icons.search), tooltip: '搜索', onPressed: null ) ], ), ); &#125;&#125;class MyScaffold extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return new Material( child: new Column( children: &lt;Widget&gt;[ new MyAppBar( title: new Text( '示例标题', style: Theme .of(context) .primaryTextTheme .title, ), ), new Expanded( child: new Center( child: new Text('你好世界！'), ), ) ], ), ); &#125;&#125;void main() &#123; runApp(new MaterialApp( title: '我的应用', home: new MyScaffold(), ));&#125; 其实说真的我第一眼看到这段代码的时候，第一想法就是，为什么会有这么多括号？但是这不是重点，有点编程经验的都知道要先从main函数看起，这里的main函数里面套了一个runApp函数， runApp函数接受指定的控件(Widget)，并使其作为控件树(widget tree)的根控件。 runApp里面new了一个MaterialApp对象，然后这个对象有两个参数，第一个是titile，指明了这个控件的标题是啥，第二个参数是home，指明了这个控件的主体是啥。 再深入的看就会发现，home的值是一个new出来的MyScaffold对象，这时我们就可以去查看MyScaffold这个类的声明代码。 MyScaffold控件为子控件设置垂直布局，在垂直顶部放置一个MyAppBar的实例（这个控件也是自己创建的），将MyAppBar的Text控件作为标题使用，将控件作为参数传递给其他控件非常方便实用的，你可以创建通用的控件，以各种方式重复的使用。最后，MyScaffold使用Expanded，用一个中心文本来填充剩余的空间。 MyAppBar控件创建了一个Container(容器)，高度为56设备无关像素(device-independent pixels)，内部左右填充8像素(pixels)。在容器内部，MyAppBar为子控件设置Row(水平)布局，中间的title控件被设置成Expanded，Expanded的作用是展开Row、Column和Flex的子控件，意味它可以使用剩余的所有空间。 其实上述的分析过程就是一个对控件数的一个遍历，从根控件到里面的子控件，Flutter的设计理念就是一切皆为控件，组件套组建。虽然上述代码不是java，c等主流代码，但是理解起来却并不是非常难懂，上手难度确实不大，值得体验。 最后，推荐一些链接： Flutter官网http://blog.csdn.net/column/details/13593.html) Flutter中文开发者论坛]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP长连接说明]]></title>
    <url>%2Fposts%2Fa8aa4c4c.html</url>
    <content type="text"><![CDATA[[HTTP协议与TCP/IP协议的关系] [如何理解HTTP协议是无状态的] 什么是长连接、短连接？ [TCP连接] [TCP短连接] [TCP长连接] [长连接和短连接的优点和缺点] 目前腾讯云负载均衡对七层负载均衡的HTTP长连接配置，可设置为默认值75s，用户可对不同的负载均衡实例进行自定义配置。那么，HTTP长连接、短连接究竟是什么？ HTTP协议与TCP/IP协议的关系HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。 如何理解HTTP协议是无状态的HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 什么是长连接、短连接？在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： 1Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 TCP连接当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手”，而释放则需要“四次握手”，所以每个连接的建立都是需要资源消耗和时间消耗的。 经典的三次握手建立连接示意图： 经典的四次握手关闭连接示意图： TCP短连接模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。 短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。 TCP长连接我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。 如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态： 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。 长连接和短连接的优点和缺点由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。 长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。 转自腾讯云：HTTP长连接说明]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>HTTP长连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动App网络优化概述]]></title>
    <url>%2Fposts%2F38627c74.html</url>
    <content type="text"><![CDATA[一般开发一个 APP，会直接调用系统提供的网络请求接口去服务端请求数据，再针对返回的数据进行一些处理，或者使用AFNetworking/OKHttp这样的网络库，管理好请求线程和队列，再自动做一些数据解析，就结束了。 但对于一些大型 APP，还会想针对网络的一些问题进行进一步优化，包括： 速度：网络请求的速度怎样能进一步提升？ 弱网：移动端网络环境随时变化，经常出现网络连接很不稳定可用性差的情况，怎样在这种情况下最大限度最快地成功请求？ 安全：怎样防止被第三方窃听/篡改或冒充，防止运营商劫持，同时又不影响性能？ 对基于浏览器的前端开发来说，网络这块能做的事情很少，但对于客户端 APP 来说，整个网络请求过程是自由控制的，可以做很多事情，很多大型 APP 都针对这三个问题做了很多网络层的优化，一些新的网络层协议像 HTTP2 / QUIC 也是在这些方面进行了不少优化，在这里边学习边整理，大致列举一下常见的做法。 速度正常一条网络请求需要经过的流程是这样： DNS 解析，请求DNS服务器，获取域名对应的 IP 地址。 与服务端建立连接，包括 tcp 三次握手，安全协议同步流程。 连接建立完成，发送和接收数据，解码数据。 这里有明显的三个优化点： 直接使用 IP 地址，去除 DNS 解析步骤。 不要每次请求都重新建立连接，复用连接或一直使用同一条连接(长连接)。 压缩数据，减小传输的数据大小。 逐条来看能做什么。 1.DNSDNS 完整的解析流程很长，会先从本地系统缓存取，若没有就到最近的 DNS 服务器取，若没有再到主域名服务器取，每一层都有缓存，但为了域名解析的实时性，每一层缓存都有过期时间，这种 DNS 解析机制有几个缺点： 缓存时间设置得长，域名更新不及时，设置得短，大量 DNS 解析请求影响请求速度。 域名劫持，容易被中间人攻击，或被运营商劫持，把域名解析到第三方 IP 地址，据统计劫持率会达到7%。 DNS 解析过程不受控制，无法保证解析到最快的IP 一次请求只能解析一个域名。 为了解决这些问题，就有了 HTTPDNS，原理很简单，就是自己做域名解析的工作，通过 HTTP 请求后台去拿到域名对应的 IP 地址，直接解决上述所有问题： 域名解析与请求分离，所有请求都直接用IP地址，无需 DNS 解析，APP 定时请求 HTTPDNS 服务器更新IP地址即可。 通过签名等方式，保证 HTTPDNS 请求的安全，避免被劫持。 DNS 解析由自己控制，可以确保根据用户所在地返回就近的 IP 地址，或根据客户端测速结果使用速度最快的 IP。 一次请求可以解析多个域名。 其余细节就不多说了，HTTPDNS 优点这么多，几乎成为中大型 APP 的标配。至此解决了第一个问题 — DNS 解析耗时的问题，顺便把一部分安全问题 — DNS 劫持也解决了。 2.连接第二个问题，连接建立耗时的问题，这里主要的优化思路是复用连接，不用每次请求都重新建立连接，如何更有效率地复用连接，可以说是网络请求速度优化里最主要的点了，并且这里的优化仍在演进过程中，值得了解下。 keep-aliveHTTP 协议里有个 keep-alive，HTTP1.1默认开启，一定程度上缓解了每次请求都要进行TCP三次握手建立连接的耗时。原理是请求完成后不立即释放连接，而是放入连接池中，若这时有另一个请求要发出，请求的域名和端口是一样的，就直接拿出连接池中的连接进行发送和接收数据，少了建立连接的耗时。 实际上现在无论是客户端还是浏览器都默认开启了keep-alive，对同个域名不会再有每发一个请求就进行一次建连的情况，纯短连接已经不存在了。但有个问题，就是这个 keep-alive 的连接一次只能发送接收一个请求，在上一个请求处理完成之前，无法接受新的请求。若同时发起多个请求，就有两种情况： 若串行发送请求，可以一直复用一个连接，但速度很慢，每个请求都要等待上个请求完成再进行发送。 若并行发送这些请求，那么首次每个请求都要进行tcp三次握手建立新的连接，虽然第二次可以复用连接池里这堆连接，但若连接池里保持的连接过多，对服务端资源产生较大浪费，若限制了保持的连接数，并行请求里超出的连接仍每次要建连。 对这个问题，新一代协议 HTTP2 提出了多路复用去解决。 多路复用HTTP2 的多路复用机制一样是复用连接，但它复用的这条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行，也就解决了上面说的并发请求需要建立多条连接带来的问题，网络上有张图可以较形象地表现这个过程： ￼ HTTP1.1的协议里，在一个连接里传送数据都是串行顺序传送的，必须等上一个请求全部处理完后，下一个请求才能进行处理，导致这些请求期间这条连接并不是满带宽传输的，即使是HTTP1.1的pipelining可以同时发送多个request，但response仍是按请求的顺序串行返回，只要其中一个请求的response稍微大一点或发生错误，就会阻塞住后面的请求。 HTTP2 这里的多路复用协议解决了这些问题，它把在连接里传输的数据都封装成一个个stream，每个stream都有标识，stream的发送和接收可以是乱序的，不依赖顺序，也就不会有阻塞的问题，接收端可以根据stream的标识去区分属于哪个请求，再进行数据拼接，得到最终数据。 解释下多路复用这个词，多路可以认为是多个连接，多个操作，复用就是字面上的意思，复用一条连接或一个线程。HTTP2这里是连接的多路复用，网络相关的还有一个I/O的多路复用(select/epoll)，指通过事件驱动的方式让多个网络请求返回的数据在同一条线程里完成读写。 客户端来说，iOS9 以上 NSURLSession 原生支持 HTTP2，只要服务端也支持就可以直接使用，Android 的 okhttp3 以上也支持了 HTTP2，国内一些大型 APP 会自建网络层，支持 HTTP2 的多路复用，避免系统的限制以及根据自身业务需要增加一些特性，例如微信的开源网络库 mars，做到一条长连接处理微信上的大部分请求，多路复用的特性上基本跟 HTTP2 一致。 TCP队头阻塞HTTP2 的多路复用看起来是完美的解决方案，但还有个问题，就是队头阻塞，这是受限于 TCP 协议，TCP 协议为了保证数据的可靠性，若传输过程中一个 TCP 包丢失，会等待这个包重传后，才会处理后续的包。HTTP2的多路复用让所有请求都在同一条连接进行，中间有一个包丢失，就会阻塞等待重传，所有请求也就被阻塞了。 对于这个问题不改变 TCP 协议就无法优化，但 TCP 协议依赖操作系统实现以及部分硬件的定制，改进缓慢，于是 GOOGLE 提出 QUIC 协议，相当于在 UDP 协议之上再定义一套可靠传输协议，解决 TCP 的一些缺陷，包括队头阻塞。具体解决原理网上资料较多，可以看看。 QUIC 处于起步阶段，少有客户端接入，QUIC 协议相对于 HTTP2 最大的优势是对TCP队头阻塞的解决，其他的像安全握手 0RTT / 证书压缩等优化 TLS1.3 已跟进，可以用于 HTTP2，并不是独有特性。TCP 队头阻塞在 HTTP2 上对性能的影响有多大，在速度上 QUIC 能带来多大提升待研究。 3.数据第三个问题，传输数据大小的问题。数据对请求速度的影响分两方面，一是压缩率，二是解压序列化反序列化的速度。目前最流行的两种数据格式是 json 和 protobuf，json 是字符串，protobuf 是二进制，即使用各种压缩算法压缩后，protobuf 仍会比 json 小，数据量上 protobuf 有优势，序列化速度 protobuf 也有一些优势，这两者的对比就不细说了。 压缩算法多种多样，也在不断演进，最新出的 Brotli 和Z-standard实现了更高的压缩率，Z-standard 可以根据业务数据样本训练出适合的字典，进一步提高压缩率，目前压缩率表现最好的算法。 除了传输的 body 数据，每个请求 HTTP 协议头的数据也是不可忽视，HTTP2 里对 HTTP 协议头也进行了压缩，HTTP 头大多是重复数据，固定的字段如 method 可以用静态字典，不固定但多个请求重复的字段例如 cookie 用动态字典，可以达到非常高的压缩率，这里有详细介绍。 通过 HTTPDNS，连接多路复用，更好的数据压缩算法，可以把网络请求的速度优化到较不错的程度了，接下来再看看弱网和安全上可以做的事情。 弱网手机无线网络环境不稳定，针对弱网的优化，微信有较多实践和分享，包括： 提升连接成功率复合连接，建立连接时，阶梯式并发连接，其中一条连通后其他连接都关闭。这个方案结合串行和并发的优势，提高弱网下的连接成功率，同时又不会增加服务器资源消耗：￼ 制定最合适的超时时间对总读写超时(从请求到响应的超时)、首包超时、包包超时(两个数据段之间的超时)时间制定不同的计算方案，加快对超时的判断，减少等待时间，尽早重试。这里的超时时间还可以根据网络状态动态设定。 调优TCP参数，使用TCP优化算法。对服务端的TCP协议参数进行调优，以及开启各种优化算法，使得适合业务特性和移动端网络环境，包括RTO初始值，混合慢启动，TLP，F-RTO等。 针对弱网的这些细致优化未成为标准，系统网络库没有内置，不过前两个客户端优化微信的开源网络库 mars 有实现，若有需要可以使用。 安全标准协议 TLS 保证了网络传输的安全，前身是 SSL，不断在演进，目前最新是 TLS1.3。常见的 HTTPS 就是 HTTP 协议加上 TLS 安全协议。 安全协议概括性地说解决两个问题：1.保证安全 2. 降低加密成本 在保证安全上： 使用加密算法组合对传输数据加密，避免被窃听和篡改。 认证对方身份，避免被第三方冒充。 加密算法保持灵活可更新，防止定死算法被破解后无法更换，禁用已被破解的算法。 降低加密成本上： 用对称加密算法加密传输数据，解决非对称加密算法的性能低以及长度限制问题。 缓存安全协议握手后的密钥等数据，加快第二次建连的速度。 加快握手过程：2RTT-&gt; 0RTT。加快握手的思路，就是原本客户端和服务端需要协商使用什么算法后才能加密发送数据，变成通过内置的公钥和默认的算法，在握手的同时就把数据发出去，也就是不需要等待握手就开始发送数据，达到0RTT。 这些点涉及的细节非常多，对 TLS 的介绍有一篇雄文，说得很详细，在此推荐。 目前基本主流都支持 TLS1.2，iOS 网络库默认使用 TLS1.2，Android4.4 以上支持 1.2。TLS1.3 iOS 还处于测试阶段，Android 未查到消息。对于普通 APP，只要正确配置证书，TLS1.2 已经能保证传输安全，只是在建连速度上会有所损耗，有一些大型 APP 像微信就自行实现了 TLS1.3 的部分协议，早一步全平台支持。 最后网络优化这个话题非常庞大，本文只是在学习过程中从优化思路上列举了目前业界常见的优化点，还有很多细节很多更深入的优化没涉及到，网络层实践开发经验不足，若有错误欢迎指出。]]></content>
      <categories>
        <category>Android</category>
        <category>优化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>网络优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公司Android项目架构演进]]></title>
    <url>%2Fposts%2F600a4740.html</url>
    <content type="text"><![CDATA[入职ZTC接近两年，因为业务繁重，从入职开始一直在做业务上的需求，项目还是MVC模式开发，由此可见工程的耦合度极高，也是众多反锁的业务互相关联导致最初开发的时候没有很好的设计架构。经过大半年的边重构项目边合并老项目新需求的开发，见证了开发团队一路走来的努力，Android团队也在自己预期的想法中向前迈进。 前言在公司的发展方向上，由单一的求职平台，到人脉社交，问答社区的扩展，让我察觉到组件化必然是正确的演进方向。在项目gradle升级到3.x后，依赖隔离的新特性更是帮助我对组件化的推进工作。 组件化优点在现在的大环境下组件化的优点相信大家都比较熟悉。 高内聚，低耦合，代码边界清晰，每一个组件都可以拆分出来独立运行 功能集中，每一个组件负责属于自己组件的工作，不受其他组件影响也不影响其他组件功能 提高开发效率，每个组件可单独调试，保证代码质量 减少重复造轮子和维护工作量 加快编译速度，最理想的情况是，App工程仅仅是一个空壳，用于加载各个组件 组件化方案现在GitHub上面流行着各大家公司开源的路由库，他们基本采用组件化的方案是 这个是比较通用组件化的一个方式，当然不同厂有着会根据自己的实际情况进行改造流程，但是基本大同小异，我们五花八门讨论得最多的是不同业务组件的路由通讯协议封装，我们将一个个业务组件细化拆分，不可能最后是互相直接依赖使用导致各种混乱和耦合，我们此时需要的是路由，它帮我们管理各业务组件间有序地通讯，路由重点划一下:事件分发和动态拦截。 我第一期组件化的工作方向是功能模块化与业务组件化相结合。这是因为我们项目是一直遵循着模块化，对功能的整理比较好，我这边不对每一个业务进行拆分组件化，也就是不采用现很热门的路由通讯方式，因为如果我将项目弄成完全组件化，是过度封装了，导致开发成本不协调，然而目前我们首要处理的问题是业务组件复用问题，所以避免我们重复造轮子，我们先将咨询组件、支付组件、定位组件、网络请求组件、推送组件进行分离，同时优化封装图片加载库、普通工具库、Banner工具库、友盟第三方库、图片选择库、JSBridge库、地图库等非业务性的基础库。 总结组件化的推进工作，从简单的分离代码，里面帮助我们更好地梳理了陈旧代码，及时整理好wiki。到享受面向过程、面向对象、面向接口、面向切面的编程乐趣。 展望到了最后，这次组件化构架演进，只是一个开始，就如一开始所说的，将来会有一天多款App会进行整合，我个人推荐的是通过插件化的方式加载对应的业务模块，在前段时间官方所推出的动态化框架Android App Bundles更适合未来的发展。另外在未来大前端完全介入商城日常开发，架构还会继续进行调整。以上是我的简单总结和对模块化的一些尝试，不足之处还望大家交流指正。]]></content>
      <categories>
        <category>Android</category>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中JSBridge的原理与实现]]></title>
    <url>%2Fposts%2F88a3890e.html</url>
    <content type="text"><![CDATA[Android中的JSBridge是H5与Native通信的桥梁，其作用是实现H5与Native间的双向通信。要实现H5与Native的双向通信，解决如下四个问题即可： 1、Java如何调用JavaScript 2、JavaScript如何调用Java 3、方法参数以及回调如何处理 4、通信的数据格式是怎么样的 下面从以上问题依次开始讨论: 1、Java如何调用JavaScript在Android 中，Java与JavaScript的一切交互都是依托于WebView的。可通过如下方法来完成，其中function（）即为JavaScript代码，来实现相应的具体H5层功能 1WebView.loadUrl("javascript:function()"); 2、JavaScript如何调用Java要实现在JavaScript中调用Java，就需要在JavaScript中有触发Java方法的对象和方法。在JavaScript中，当调用window对象的prompt方法时，会触发Java中的WebChromeClient对象的onJsPrompt方法，因此可以利用这个机制来实现js调用native的代码。 3、方法参数以及回调处理任何IPC通信都涉及到参数序列化的问题，同理，Java与JavaScript之间只能传递基础类型（包括基本类型和字符串），不包括其他对象或者函数。所以可以采用json格式来传递数据。JavaScript与Java相互调用不能直接获取返回值，只能通过回调的方式来获取返回结果。 4、通信的数据格式Java与JavaScript通信需要遵循一定的通信协议，可以仿照HTTPS协议来将此协议定义为jsbridge协议： 1jsbridge://className:port/methodName?jsonObj 当js调用native功能时，应当指定native层要完成某个功能调用的类名（className）和方法名（methodName），以及js传递过来的参数（jsonObj）。port值是指当native需要将操作结果返回给js时，在js中定义一个callback，并将这个callback存储在指定的位置上，这个port就定义了callback的存储位置。 JSBridge的具体工作流程图如上所示：1、js触发调用native层的行为 1JSBridge.call(className, methodName, params, callback); 将call方法中的参数组合成jsbridge协议格式的url。然后通过prompt方法将url传递到native层。 1window.prompt(url); 2、通过WebChromeClient来获取js传递过来的url. 1234567public class JSBridgeWebChromeClient extends WebChromeClient &#123; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; result.confirm(JSBridge.callJava(view, message)); return true; &#125;&#125; 3、JSBridge类管理暴露给前端方法，前端调用的方法应该在此类中注册才可使用。register的实现是从Map中查找key是否存在，不存在则反射取得对应class中的所有方法,具体方法是在BridgeImpl中定义的，方法包括三个参数分别为WebView、JSONObject、CallBack。如果满足条件，则将所有满足条件的方法put到map中。 12345678910private static Map&lt;String, HashMap&lt;String, Method&gt;&gt; exposedMethods = new HashMap&lt;&gt;();public static void register(String exposedName, Class&lt;? extends IBridge&gt; clazz) &#123; if (!exposedMethods.containsKey(exposedName)) &#123; try &#123; exposedMethods.put(exposedName, getAllMethod(clazz)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; JSBridge类中的callJava方法就是将js传递过来的URL解析，根据将要调用的类名从刚刚建立的Map中找出，根据方法名调用具体的方法，并将解析出的三个参数传递进去。 123456789101112131415161718192021222324252627282930313233public static String callJava(WebView webView, String uriString) &#123; String methodName = ""; String className = ""; String param = "&#123;&#125;"; String port = ""; if (!TextUtils.isEmpty(uriString) &amp;&amp; uriString.startsWith("JSBridge")) &#123; Uri uri = Uri.parse(uriString); className = uri.getHost(); param = uri.getQuery(); port = uri.getPort() + ""; String path = uri.getPath(); if (!TextUtils.isEmpty(path)) &#123; methodName = path.replace("/", ""); &#125; &#125; if (exposedMethods.containsKey(className)) &#123; HashMap&lt;String, Method&gt; methodHashMap = exposedMethods.get(className); if (methodHashMap != null &amp;&amp; methodHashMap.size() != 0 &amp;&amp; methodHashMap.containsKey(methodName)) &#123; Method method = methodHashMap.get(methodName); if (method != null) &#123; try &#123; method.invoke(null, webView, new JSONObject(param), new Callback(webView, port)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; return null; &#125; 4、CallBack类是用来回调js中回调方法的Java对应类。Java层处理好的返回结果是通过CallBack类来实现的。在这个回调类中传递的参数是JSONObject（返回结果）、WebView和port，port应与js传递过来的port相对应。 1234567891011121314151617181920private static Handler mHandler = new Handler(Looper.getMainLooper()); private static final String CALLBACK_JS_FORMAT = "javascript:JSBridge.onFinish('%s', %s);"; private String mPort; private WeakReference&lt;WebView&gt; mWebViewRef; public Callback(WebView view, String port) &#123; mWebViewRef = new WeakReference&lt;&gt;(view); mPort = port; &#125; public void apply(JSONObject jsonObject) &#123; final String execJs = String.format(CALLBACK_JS_FORMAT, mPort, String.valueOf(jsonObject)); if (mWebViewRef != null &amp;&amp; mWebViewRef.get() != null) &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; mWebViewRef.get().loadUrl(execJs); &#125; &#125;); &#125; &#125; 5、JSBridgeImpl类中定义所有暴露给前端的方法的具体实现。本文以showToast为例来通过native代码显示toast，并给出js的回调函数，返回一个JSONObject对象。 1234567891011121314public static void showToast(WebView webView, JSONObject param, final Callback callback) &#123; String message = param.optString("msg"); Toast.makeText(webView.getContext(), message, Toast.LENGTH_SHORT).show(); if (null != callback) &#123; try &#123; JSONObject object = new JSONObject(); object.put("key", "value"); object.put("key1", "value1"); callback.apply(getJSONObject(0, "ok", object)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 6、在js中通过 12JSBridge.call('bridge','showToast',&#123;'msg': 'Hello'&#125;, function(res)&#123;alert(JSON.stringi fy(res))&#125;)" 即可调用在Java层定义的showToast方法，调用前不要忘记在java层的JSBridge中注册该方法。 1JSBridge.register("bridge", BridgeImpl.class); 二、总结：JSBridge的基本原理为：H5-&gt;通过某种方式触发一个url-&gt;Native捕获到url,进行分析-&gt;原生做处理-&gt;Native调用H5的JSBridge对象传递回调。如下图 三、安全性： Android4.2以下，addJavascriptInterface方法有安全漏洞，js代码可以获取到Java层的运行时对象，来伪造当前用户执行恶意代码。 ios7以下，JavaScript无法调用native代码。 通过js声明的对象，是通过loadUrl注入到页面中的，所以这个对象是js对象，而不是Java对象，没有getClass等Object方法，因此也无法获得Runtime对象，避免了恶意代码的注入。 JSBridge采用URL解析的交互方式，是一套成熟的解决方案，便于拓展，无重大安全性问题。]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[127.0.0.1和0.0.0.0地址的区别]]></title>
    <url>%2Fposts%2F21cd72b5.html</url>
    <content type="text"><![CDATA[1. 问题引入之前在使用tomcat的时候，启动tomcat默认都会绑定到127.0.0.1这个地址，最近在使用hexo写博客的时候发现通过 hexo server命令启动服务的时候绑定的ip地址是0.0.0.0。那么这两个IP地址到底有什么不同呢? 在讲解两个地址的不同之前，我们先回顾一下IP地址的基础知识。 2. IP地址分类2.1 IP地址表示IP地址由两个部分组成，net-id和host-id，即网络号和主机号。net-id:表示ip地址所在的网络号。host-id：表示ip地址所在网络中的某个主机号码。 即： 1IP-address ::= &#123; &lt;Network-number&gt;, &lt;Host-number&gt; &#125; 2.2 IP地址分类IP地址一共分为5类，即A～E，它们分类的依据是其net-id所占的字节长度以及网络号前几位。 A类地址:网络号占1个字节。网络号的第一位固定为0。 B类地址：网络号占2个字节。网络号的前两位固定为10。 C类地址：网络号占3个字节。网络号的前三位固定位110。 D类地址：前四位是1110，用于多播(multicast)，即一对多通信。 E类地址：前四位是1111，保留为以后使用。其中，ABC三类地址为单播地址（unicast),用于一对一通信，是最常用的。 2.3 特殊IP地址特殊IP地址就是用来做一些特殊的事情。RFC1700中定义了以下特殊IP地址。 {0,0}:网络号和主机号都全部为0，表示“本网络上的本主机”，只能用作源地址。 {0，host-id}:本网络上的某台主机。只能用作源地址。 {-1,-1}：表示网络号和主机号的所有位上都是1（二进制），用于本网络上的广播，只能用作目的地址，发到该地址的数据包不能转发到源地址所在网络之外。 {net-id,-1}:直接广播到指定的网络上。只能用作目的地址。 {net-id,subnet-id,-1}:直接广播到指定网络的指定子网络上。只用作目的地址。 {net-id,-1,-1}:直接广播到指定网络的所有子网络上。只能用作目的地址。 {127，}:即网络号为127的任意ip地址。都是内部主机回环地址(loopback),永远都不能出现在主机外部的网络中。 3. 问题解答接下来我们来看之前问过的问题：127.0.0.1和0.0.0.0地址的区别是什么？我们先来看下共同点： 都属于特殊地址。 都属于A类地址。 都是IPV4地址。 接下来我们分别看下这两个地址： 0.0.0.0IPV4中，0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。 在服务器中，0.0.0.0指的是本机上的所有IPV4地址，如果一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0,那么通过两个ip地址都能够访问该服务。 在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。 用途总结 当一台主机还没有被分配一个IP地址的时候，用于表示主机本身。（DHCP分配IP地址的时候） 用作默认路由，表示”任意IPV4主机”。用来表示目标机器不可用。 用作服务端，表示本机上的任意IPV4地址。 127.0.0.1127.0.0.1属于{127,}集合中的一个，而所有网络号为127的地址都被称之为回环地址，所以回环地址！=127.0.0.1,它们是包含关系，即回环地址包含127.0.0.1。回环地址：所有发往该类地址的数据包都应该被loop back。 用途 回环测试,通过使用ping 127.0.0.1 测试某台机器上的网络设备，操作系统或者TCP/IP实现是否工作正常。 DDos攻击防御：网站收到DDos攻击之后，将域名A记录到127.0.0.1，即让攻击者自己攻击自己。 大部分Web容器测试的时候绑定的本机地址。 localhost相比127.0.0.1，localhost具有更多的意义。localhost是个域名，而不是一个ip地址。之所以我们经常把localhost与127.0.0.1认为是同一个是因为我们使用的大多数电脑上都讲localhost指向了127.0.0.1这个地址。在ubuntu系统中，/ets/hosts文件中都会有如下内容： 1127.0.0.1 localhost127.0.1.1 jason-Lenovo-V3000# The following lines are desirable for IPv6 capable hosts::1 ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters 上面第一行是几乎每台电脑上都会有的默认配置。但是localhost的意义并不局限于127.0.0.1。 localhost是一个域名，用于指代this computer或者this host,可以用它来获取运行在本机上的网络服务。在大多数系统中，localhost被指向了IPV4的127.0.0.1和IPV6的::1。 1127.0.0.1 localhost::1 localhost 所以，在使用的时候要注意确认IPV4还是IPV6 4. 总结127.0.0.1 是一个环回地址。并不表示“本机”。0.0.0.0才是真正表示“本网络中的本机”。在实际应用中，一般我们在服务端绑定端口的时候可以选择绑定到0.0.0.0，这样我的服务访问方就可以通过我的多个ip地址访问我的服务。 比如我有一台服务器，一个外网地址A,一个内网地址B，如果我绑定的端口指定了0.0.0.0，那么通过内网地址或外网地址都可以访问我的应用。但是如果我只绑定了内网地址，那么通过外网地址就不能访问。所以如果绑定0.0.0.0,也有一定安全隐患，对于只需要内网访问的服务，可以只绑定内网地址。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gradle.properties文件使用]]></title>
    <url>%2Fposts%2Ffb76c4ba.html</url>
    <content type="text"><![CDATA[在一些项目中会分拆app 和 lib , 这时候引用support的时候,一旦更改版本会出现需要同步更改两个地方的问题.这种情况,可以通过配置gradle.properties实现替换.在项目编译过程中,gradle.properties配置的值会被编译解析,其作为配置文件使用是很有必要的. 1. 概述在Android Studio 创建一个项目的时候，Project下面会生成gradle.properties和local.properties文件，如下图: 2. properties的数据格式properties里面的数据格式采用键值对的方式，大概有以下几种写法: 12341. key=value 2. key:value 3. key :value 4. # 作为注释 这里主要参考以下链接：https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html*注意: *在Android Studio 中最好使用第一种写法，要不会有警告 3. 如何使用3.1 在项目根目录的gradle.properties文件配置:1234567891011121314151617# Project-wide Gradle settings.#添加ndk支持(按需添加)android.useDeprecatedNdk=true# 应用版本名称VERSION_NAME=1.0.0# 应用版本号VERSION_CODE=100# 支持库版本SUPPORT_LIBRARY=24.2.1# MIN_SDK_VERSIONANDROID_BUILD_MIN_SDK_VERSION=14# TARGET_SDK_VERSIONANDROID_BUILD_TARGET_SDK_VERSION=24# BUILD_SDK_VERSIONANDROID_BUILD_SDK_VERSION=24# BUILD_TOOLS_VERSIONANDROID_BUILD_TOOLS_VERSION=24.0.3 3.2 这时候配置app和lib的build.gradle可以这样写:1234567891011121314151617181920212223android &#123; compileSdkVersion project.ANDROID_BUILD_SDK_VERSION as int buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION defaultConfig &#123; applicationId project.APPLICATION_ID // lib项目不需要配置这一项 versionCode project.VERSION_CODE as int versionName project.VERSION_NAME minSdkVersion project.ANDROID_BUILD_MIN_SDK_VERSION as int targetSdkVersion project.ANDROID_BUILD_TARGET_SDK_VERSION as int &#125;&#125;dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) //这里注意是双引号 compile &quot;com.android.support:appcompat-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:design:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:recyclerview-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:support-annotations:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:cardview-v7:$&#123;SUPPORT_LIBRARY&#125;&quot; compile &quot;com.android.support:support-v4:$&#123;SUPPORT_LIBRARY&#125;&quot;&#125; 这样配置后,当你需要升级你的编译版本,版本号,支持库等的时候,仅需要修改项目根目录的gradle.properties文件即可,是不是又方便了一点点?]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unable to resolve dependency for ':trunk@debug/compileClasspath']]></title>
    <url>%2Fposts%2F4cae3fd9.html</url>
    <content type="text"><![CDATA[1234repositories &#123; google() jcenter() &#125; Go to File-&gt;Settings-&gt;Build, Execution, Deployment-&gt;Gradle-&gt;Uncheck Offline work option.]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android代码规范指南]]></title>
    <url>%2Fposts%2F89cc132f.html</url>
    <content type="text"><![CDATA[前言 无论你是个人开发还是团队，一个良好的代码规范，能够在项目当中发挥举足轻重的作用；它不仅能使你们的开发更加高效，而且还会减少BUG产生的几率，增强代码可维护性及稳定性。 关于规范，我们分两部分来讲，因为Android主要是用Java语言来写的，所以我们区别对待。 JAVA代码规范强制性规范: 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 类名使用UpperCamelCase 风格，必须遵从驼峰形式。 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长例如：MAX_STOCK_COUNT。 抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类 命名以它要测试的类的名称开始。 杜绝不规范的英文缩写：AbstractClass 缩写成AbsClass；condition缩写成condi;此类随意缩写严重降低了代码的可阅读性。 如果使用到了设计模式，建议在类名中体现出具体的模式： 关于Service或Dao层的命名 123public class ComponentFactorypublic class BufferStrategypublic class ScrollerProxy 实体类必须重载toString()方法，这样可以通过调用对象的toString()来排查问题。 Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 正例: “test”.equals(object); 反例: object.equals(“test”); 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 推荐规范： 集合初始化时，尽量指定集合初始值大小； ArrayList尽量使用ArrayList(int initialCapacity) 初始化 。 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历 说明:keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效 率更高。如果是 JDK8，使用 Map.foreach 方法。 高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格: 集合类 Key Value Super 说明 Hashtable 不允许为null 不允许为null Dictionary 线程安全 ConcurrentHashMap 不允许为null 不允许为null AbstractMap 分段锁技术 TreeMap 不允许为null 允许为null AbstractMap 线程不安全 HashMap 允许为null 允许为null AbstractMap 线程不安全 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。 通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优 化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题 解决方案中较为简单一种(适用于 JDK5 及以上版本)，将目标属性声明为 volatile 型。 1234567891011121314*反例*：class Foo &#123; private Helper helper = null; public Helper getHelper() &#123; if (helper == null) synchronized(this) &#123; if (helper == null) helper = new Helper(); &#125; return helper; &#125; // other functions and members... &#125; Android代码规范代码： Activity 命名一律使用 模块名+Activity 的方式。例如，LoginActivity、SignupActivity； Fragment 命名一律使用 模块名+Fragment 的方式； 自定义View：Custom(建议)+功能名+View/ViewGroup(具体的组件名称)。例如：CustomImageScroller、CustomRatingBar。 Widget 小组件：ScanWidget、WeatherWidget。 Dialog对话框：功能名+Dialog。例如：LoginDialog、ProgressDialog 尽量在每一个Activity或类中加入TAG,方便我们查看Activity的信息。(Tip : 使用Android Studio提供的快捷键logt可快速生成当前 类的常量) 对于使用Intent传递数据，声明一些Key的时候： EXTRA_KEY_+具体Key名称，例如我们现在有一个人的名字和年龄要传那么首先定义： 12public static final String EXTRA_KEY_PERSON_NAME=&quot;EXTRA_KEY_PERSON_NAME&quot;public static final String EXTRA_KEY_PERSON_AGE=&quot;EXTRA_KEY_PERSON_AGE&quot; 然后在具体的页面 new Intent()，依次传递进去值，这样写其实没什么问题；但是试想一下，如果你要调用的Activity是类似于一个工具性质或通用的Activity（图片选择器、登录、注册等等），这时候你要传递的key又很多，如果业务复杂的话，你应该会被这样冗余且不易阅读的代码直接搞崩溃掉。 所以最好的办法就是在你要调用Activity提供一个静态工厂方法，要知道静态工厂方法所带来的好处太多了，由于Activity是不允许通过new的方式来初始化的，所以静态工厂方法的好处在此就不那么明显，但是已经足够我们优化我们的代码了。举个例子，我们有一个笔记 NoteActivity，用于创建笔记和修改笔记， 123456789101112131415161718192021222324//笔记Idprivate static final String EXTRA_KEY_NOTE_ID =&quot;EXTRA_KEY_NOTE_ID&quot; ;//笔记内容private static final String EXTRA_KEY_NOTE_CONTENT =&quot;EXTRA_KEY_NOTE_CONTENT&quot; ;//笔记模式private static final String EXTRA_KEY_NOTE_MODE =&quot;EXTRA_KEY_NOTE_MODE&quot; ;//用于创建笔记public static void startForCreate(Context context, int noteId) &#123; start(context, noteId, null, MODE_CREATE);&#125; //用于编辑笔记public static void startForEdit(Context context, int noteId, String content) &#123; start(context, noteId, content, MODE_UPDATE);&#125;public static void start(Context context, int noteId, String content, int mode) &#123; Intent starter = new Intent(context, TableShareListSettingActivity.class); starter.putExtra(EXTRA_KEY_NOTE_ID,noteId); starter.putExtra(EXTRA_KEY_NOTE_CONTENT,content); starter.putExtra(EXTRA_KEY_NOTE_CONTENT,mode); context.startActivity(starter);&#125; 通过以上方法，我们能够很好的解耦复杂的Activity之间的调用，再加上静态方法工厂方法名，代码可阅读行大大提高，最终我们看到的调用NoteActivity将会是很简洁的一段代码： 12NoteActivity.startForCreate(this,noteId);NoteActivity.startForEdit(this,noteId,content); 此外，Android Studio工具中其实已经在Live Template中提供了这样的代码:CMD+J( For MAC OS),简单的输入starter就可以快速地在当前的Activity中添加一个Intent的静态操作方法，这其实也说明了Android官方团队也鼓励我们这么做。 如下图所示： 一下子省了好多代码，简直太赞了有木有！ 增加类注释，使用Android Studio的 File And Code Template： 所有的常量加上注释，且功能相同的排放在一起，不同的进行换行； Activity中变量采用m开头+类名。例如，mTable、mPerson； Activity中的控件：m+模块名+控件类型名称。例如，mLoginEditText,mLoginTextView; 资源Res1.按照资源的类型，分为以下几种 控件Id命名：控件缩写 _模块（module) _功能名(function) 控件类型 ID命名规则 TextView tv_module_function EditText et_module_function ImageView iv_module_function Button btn_module_function ListView lv_module_function GridView gv_module_function CheckBox check_module_function RadioButton radio_module_function LinearLayout ll_module_function RelativeLayout rl_module_function FrameLayout fl_module_function GridLayout gl_module_function ··· ··· Color资源命名 Resources Type 命名规则 color 组件名+具体作用名。例 R.color.button_text String资源命名 Resources Type 命名规则 string 具体功能。 例 R.string.hello Drawable资源命名 Resources Type 命名规则 launcher icon ic_launcher。例R.drawable.ic_launcher normal icon ic_具体模块_功能。例R.drawable.ic_audio_pause Toolbar icon ic_ab_功能名。例如ic_ab_search selector selector_模块_功能名。例如 selector_login_button shape shape_模块功能名状态。例如 R.drawable.shape_login_button_normal Layout资源命名 类型 命名规则 activity activity_模块名。例如 R.layout.activity_login fragment fragment_模块名。例如 R.layout.fragment_login_layout_header include layout_模块名_功能名。例如 @layout/layout_login_bottom adapter adapter_item_模块名_功能名。例如 R.layout.adapter_item_simple_text dialog dialog_模块_功能名。例如 R.layout.dialog_time_picker list header header_模块_功能。例如 R.layout.header_main_top_ad list footer footer_模块_功能。例如 R.layout.footer_main_bottom_action widget widget_模块_功能。例如 R.layout.widget_app_clock ··· ··· Menu资源命名 Resources Type 命名规则 menu menu_模块名。例如 menu_login Values资源命名 Resources Type 命名规则 color 模块名_color。例如 material_design_color dimens 模块名_dimens。例如 material_design_dimens style 模块名_style。例如 material_design_style themes 模块名_themes。例如 material_design_themes 总结其实代码规范只是一个Guideline，没有说非要某一种风格来编写代码。如果你的团队有自己的一套代码规范，然后开发也很高效，代码也很容易阅读且可维护，就完全可以按照自己的团队的技术规范来。我想表达的是，在编写的代码的时候，能有一个Guideline（准则）或者说是一个约定，我们共同遵守这样的约定，来达到我一开始说的代码规范性所带来的意义。 正所谓，“离娄之明，公输子之巧，不以规矩，不能成方圆。” 参考资料阿里巴巴Java开发手册]]></content>
      <categories>
        <category>Android</category>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置iPhone来电铃声]]></title>
    <url>%2Fposts%2Fb0d3dc9.html</url>
    <content type="text"><![CDATA[步骤 1保证电脑上有可以播放的音乐，找到喜欢的一首歌曲，鼠标右击用 iTunes 打开，「选中歌曲《故乡》」—「右键」—「歌曲信息」，如下图： 点击「歌曲信息」后，出现一个弹框，点击「选项」，勾选「停止」，右边的输入框里面输入 0:28，因为铃声必须是40秒之内的，然后点击「好」，如图： （PS：假设这首歌的时间是5:20，你可以任意设置播放的时间段，假如高潮部分是1:32到2:05，则勾选’开始’并输入1:32，勾选’停止’并输入2:05） 步骤 2还是选中歌曲《故乡》，右上角，依次选择「文件」—「转换」—「创建 AAC 版本」，如图： 然后可能会听到一个声音，说明创建成功，在刚刚选中的歌曲《故乡》下面会多出一个一模一样的来，只不过时间变成刚刚我填写的，如图： 步骤 3选中时间较短的《故乡》，右键选择「在 Finder 中显示」，如图： 这时可以看到故乡.m4a这样一个文件，是可以播放的，把它复制到桌面上来。鼠标选中桌面上的故乡.m4a，改为故乡.m4r，选择「使用 .m4r」，如图： 步骤 4选择你的手机，如图： 勾选「手动管理音乐和视频」，之后点击「应用」，等待完成，如图： 步骤 5在桌面上把故乡.m4r歌曲拖到手机上，如下图： 这时候发现手机下的「铃声」目录，会出现刚刚的歌曲，如图： 继续选择你的手机，点击同步，静静等待完成。 在同步的过程中，如果出现如下图所示，则说明设置的铃声时间过长，应当在 40s 之内： 结束同步完成后，算是大功告成了，拿起iPhone，按顺序 选择「设置」—「声音」—「电话铃声」，激动人心的时刻终于来了~ 大功告成.png]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidView的绘制流程]]></title>
    <url>%2Fposts%2Fd94c207f.html</url>
    <content type="text"><![CDATA[本文主要是梳理 View 绘制的整体流程，帮助开发者对 View 的绘制有一个更深层次的理解。 整体流程View 绘制中主要流程分为measure，layout， draw 三个阶段。 measure ：根据父 view 传递的 MeasureSpec 进行计算大小。 layout ：根据 measure 子 View 所得到的布局大小和布局参数，将子View放在合适的位置上。 draw ：把 View 对象绘制到屏幕上。 那么发起绘制的入口在哪里呢？在介绍发起绘制的入口之前，我们需要先了解Window，ViewRootImpl，DecorView之间的联系。 一个 Activity 包含一个Window，Window是一个抽象基类，是 Activity 和整个 View 系统交互的接口，只有一个子类实现类PhoneWindow，提供了一系列窗口的方法，比如设置背景，标题等。一个PhoneWindow 对应一个 DecorView 跟 一个 ViewRootImpl，DecorView 是ViewTree 里面的顶层布局，是继承于FrameLayout，包含两个子View，一个id=statusBarBackground 的 View 和 LineaLayout，LineaLayout 里面包含 title 跟 content，title就是平时用的TitleBar或者ActionBar，contenty也是 FrameLayout，activity通过 setContent（）加载布局的时候加载到这个View上。ViewRootImpl 就是建立 DecorView 和 Window 之间的联系。 这三个阶段的核心入口是在 ViewRootImpl 类的 performTraversals() 方法中。 123456789101112private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 在源码中这个方法贼长，但是核心还是这三个步骤，就是判断根据之前的状态判断是否需要重新 measure，是否需要重新 layout ，是否需要重新 draw。 measureSpeac在介绍 measure 方法之前，需要了解一个很核心的概念：measureSpeac 。在 Google 官方文档中是这么定义 measureSpeac 的 A MeasureSpec encapsulates the layout requirements passed from parent to child. Each MeasureSpec represents a requirement for either the width or the height. A MeasureSpec is comprised of a size and a mode.大概意思是：MeasureSpec 封装了从父View 传递给到子View的布局需求。每个MeasureSpec代表宽度或高度的要求。每个MeasureSpec都包含了size（大小）和mode（模式）。 我觉得这是measureSpeac 最好的解释了。 后面两句不难理解。MeasureSpec 一个32位二进制的整数型，前面2位代表的是mode，后面30位代表的是size。mode 主要分为3类，分别是 EXACTLY：父容器已经测量出子View的大小。对应是 View 的LayoutParams的match_parent 或者精确数值。 AT_MOST：父容器已经限制子view的大小，View 最终大小不可超过这个值。对应是 View 的LayoutParams的wrap_content UNSPECIFIED：父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。(这种不怎么常用，下面分析也会直接忽略这种情况) 封装了从父 View 传递给到子 View 的布局需求，这句话又怎么理解呢？ View 的 MeasureSpec 并不是父 View 独自决定，它是根据父 view 的MeasureSpec加上子 View 的自己的 LayoutParams，通过相应的规则转化。 看代码： View 测量流程是父 View 先测量子 View，等子 View 测量完了，再来测量自己。在ViewGroup 测量子 View 的入口就是 measureChildWithMargins 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; //获取子View的LayoutParam final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //通过父View的MeasureSpec和子View的margin，父View的padding计算，算出子View的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //通过计算出来的MeasureSpec，让子View自己测量。 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125;public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //计算子View的大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // 父View是EXACTLY的 case MeasureSpec.EXACTLY: //子View的width或height是个精确值,则size为精确值，mode为 EXACTLY if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 EXACTLY &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; //子View的width或height是WRAP_CONTENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 2、父View是AT_MOST的 case MeasureSpec.AT_MOST: //子View的width或height是个精确值,则size为精确值，mode为 EXACTLY if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; //子View的width或height是MATCH_PARENT,则size为父视图大小，mode为 AT_MOST &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // 父View是UNSPECIFIED的 case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 通过代码我们很可以很看到 View 的子 View 的 MeasureSpec 转化规则，但是感觉可能有点懵，我们用一个”商城-衣服”例子来比喻一下： 我们把父 View 看做成商城，子 View 看做成衣服，EXACTLY / MATCH_PARENT 看做成高档品牌，AT_MOST / WRAP_CONTENT 看做成杂牌，精确值看做成价格，View的大小看做价格。 如果是衣服（子 View）产地是高档品牌（LayoutParams = LayoutParams.MATCH_PARENT），商城是（父 View）高档的商城（EXACTLY），那么衣服的价格（size 大小）就会根据高档商城价格来定，能有多高就卖多高（View的大小取决于父View大小）。 如果是衣服（子 View）产地是高档品牌（LayoutParams = LayoutParams.MATCH_PARENT），商城是（父 View）杂牌的商城（AT_MOST），那么衣服的价格（size 大小）也会根据低档商城价格来定，太高普通人也买不起呀（View的大小取决于父View大小）。 如果是衣服（子 View）产地是杂牌（LayoutParams = LayoutParams.WRAP_CONTENT），商城是（父 View）高档的商城（EXACTLY），那么衣服的价格（size 大小）也会根据高档商城价格来定，能有多高就卖多高，毕竟店大欺人，绝不打折（View的大小取决于父View大小）。 如果是衣服（子 View）产地是杂牌（LayoutParams = LayoutParams.WRAP_CONTENT），商城是（父 View）杂牌的商城（AT_MOST），那么衣服的价格（size 大小）就会根据低档商城价格来定，小巷步行街不都是这样卖的吗（View的大小取决于父View大小） 如果是衣服（子 View）已经全国明码标价（android:layout_xxxx=”200dp”），商城是（父 View）无论是杂牌的商城（AT_MOST）还是高档的商城（EXACTLY），那么衣服的价格（size 大小）就不会变的。，不然打你小屁屁。 如果你觉得例子真的糟糕透了，那么看以下一表正经总结： 一表正经总结以下： 当父View的mode是EXACTLY的时候：说明父View的大小是确定的 子View的宽或高是MATCH_PARENT： 子View的宽或高是WRAP_CONTENT：子View是包裹布局，说明子View的大小还不确定，所以子View最大不能超过父View的大小mode=AT_MOST。 子View的宽或高是具体数值：子viewd大小已经固定了，子View的大小就是固定这个数值，mode=EXACTLY。 当父View的mode是AT_MOST的时候：说明父View大小是不确定的。 子View的宽或高是MATCH_PARENT：父View大小是不确定的，子View是填充布局情况，也不能确定大小，所以View大小不能超过父View的大小，mode=AT_MOST 子View的宽或高是WRAP_CONTENT：子View是包裹布局，大小不能超过父View的大小，mode=AT_MOST。 子View的宽或高是具体数值：子viewd大小已经固定了，子View的大小就是固定这个数值，mode=EXACTLY。 需要注意一点就是，此时的MeasureSpec并不是View真正的大小，只有setMeasuredDimension之后才能真正确定View的大小。 measuremeasure 主要功能就是测量设置 View 的大小。该方法是 final 类型，子类不能覆盖，在方法里面会调用 onMeasure()，我们可以复写 onMeasure（） 方法去测量设置 View 的大小。 1234567public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; /*-----------省略代码---------------* onMeasure(widthMeasureSpec, heightMeasureSpec); /*-----------省略代码---------------*/ &#125; 在 onMeasure( ) 方法中 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; onMeasure( ) 方法就是执行测量设置 View 代码的核心所在。 我们先来看下 getSuggestedMinimumWidth() 1234protected int getSuggestedMinimumWidth() &#123; //返回建议 View 设置最小值宽度 return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; 这里返回的建议最小值就是我们xml 布局中用的属性 minWidth或者是背景大小。 同理可得 getSuggestedMinimumHeight()。 看下 getDefaultSize 主要作用就是根据View的建议最小值，结合父View传递的measureSpec，得出并返回measureSpec 看代码 123456789101112131415161718 public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; //获取父View传递过来的模式 int specMode = MeasureSpec.getMode(measureSpec); //获取父View传递过来的大小 int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size;//View的大小父View未定，设置为建议最小值 break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; getDefaultSize 的逻辑跟我们之前分析的 MeasureSpec 转化规则非常相似。就是根据specMode设置大小。如果specMode是UNSPECIFIED 未确定大小，则会使用建议最小值，如果其他两种情况，则使用父View传递过来的大小。再次强调：并不是父View 独自决定，它是根据父 view 的MeasureSpec加上子vIew的自己的LayoutParams，通过相应的规则转化而得到的大小。 再来看下 setMeasuredDimension setMeasuredDimension 作用就是将测量好的宽跟高进行存储。在onMeasure（） 必须调用这个方法，不然就会抛出 IllegalStateException 异常。 我们重新梳理一下刚才那些流程： 在measure 方法，核心就是调用onMeasure( ) 进行View的测量。在onMeasure( )里面，获取到最小建议值，如果父类传递过来的模式是MeasureSpec.UNSPECIFIED，也就是父View大小未定的情况下，使用最小建议值，如果是AT_MOST或者EXACTLY模式，则设置父类传递过来的大小，然后调用setMeasuredDimension 方法进行存储大小。 layout()作用描述measure（） 方法中我们已经测量出View的大小，根据这些大小，我们接下来就需要确定 View 在父 View 的位置进行排版布局，这就是layout 作用。对 View 进行排版布局，还是要看父 View，也就是 ViewGroup。 看代码 123456789101112@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; 代码不多，大致作用就是判断 View 是否在执行动画，如果是在执行动画，则等待动画执行完调用 requestLayout()，如果没有添加动画或者动画已经执行完了，则调用 layout（），也就是调用View的 layout（）。 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) &#123; /*-----------省略代码---------------*/ boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; /*-----------省略代码---------------*/&#125; View 的 layout 的方法也是非常长。大致作用就是设置 View 的在父 View 的位置，然后判断位置是否发生变化，是否需要重新调用排版布局，如果是需要重新布局则用了 onLayout（）方法。在OnLayout 方法中，View 里面是一个空实现，而 ViewGroup 则是一个抽象方法。为什么这么设计呢？因为onLayout中主要就是为了给遍历View然后进行排版布局，分别设置View在父View中的位置。既然如此，那么View的意义就不大了，而ViewGruo 必须实现，不然没法对子View进行布局。那么如何对 View 进行排版呢？举例个简单的demo。 12345678910111213protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int childCount = getChildCount(); for ( int i = 0; i &lt; childCount; i++) &#123; View child = getChildAt(i); child.layout(l, t, r, b); &#125;&#125; 就是遍历所有的子 View 然后调用 child.layout(l, t, r, b)。 大家有兴趣也可以参考一下 FrameLayout， LinearLayout这类布局。 draw（）经过前面两部的测量跟布局之后，接下来就是绘制了，也就是真正把 View 绘制在屏幕可见视图上。draw（）作用就是绘制View 的背景，内容，绘制子View,还有前景跟滚动条。看下 View 的draw（） 源码 1234567891011121314151617181920212223242526272829303132333435@CallSuperpublic void draw(Canvas canvas) &#123; /*-----------省略代码---------------*/ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; /*-----------省略代码---------------*/ if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); /*-----------省略代码---------------*/ return; &#125; draw 过程中一共分成7步，其中两步我们直接直接跳过不分析了。 第一步：drawBackground(canvas)： 作用就是绘制 View 的背景。 第二步：onDraw(canvas) ：绘制 View 的内容。View 的内容是根据自己需求自己绘制的，所以方法是一个空方法，View的继承类自己复写实现绘制内容。 第三步：dispatchDraw（canvas）：遍历子View进行绘制内容。在 View 里面是一个空实现，ViewGroup 里面才会有实现。在自定义 ViewGroup 一般不用复写这个方法，因为它在里面的实现帮我们实现了子 View 的绘制过程，基本满足需求。 第四步：onDrawForeground(canvas)：对前景色跟滚动条进行绘制。 第五步：drawDefaultFocusHighlight(canvas)：绘制默认焦点高亮。 好了，整个绘制流程就分析完毕了！]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年轻人一定要知道的71条做饭技巧，让你做出美味又营养的美食！]]></title>
    <url>%2Fposts%2F7de80bae.html</url>
    <content type="text"><![CDATA[1、煮水饺时，在水里放一颗大葱或在水开后加点盐，再放饺子，饺子味道鲜美不粘连；在和面时，每500克面粉加拌一个鸡蛋，饺子皮挺刮不粘连2、 炖肉时，在锅里加上几块桔皮，可除异味和油腻并增加汤的鲜味3、煮骨头汤时加一小匙醋，可使骨头中的磷、钙溶解于汤中，并可保存汤中的维生素。5、烧豆腐时，加少许豆腐乳或汁，味道芳香7、将绿豆在铁锅中炒10分钟再煮能很快煮烂，但注意不要炒焦8、煮蛋时水里加点醋可防蛋壳裂开，事先加点盐也可 9、煮海带时加几滴醋易烂；放几棵波菜也行 10、煮火腿之前，将火腿皮上涂些白糖，容易煮烂，味道更鲜美12、煮水饺时，在锅中加少许食盐，锅开时水也不外溢 15、熬粥或煮豆时不要放碱，否则会破坏米、豆中的营养物质 16、用开水煮新笋容易熟，且松脆可口；要使笋煮后不缩小，可加几片薄荷叶或盐17、猪肚煮熟后，切成长块，放在碗内加一些鲜汤再蒸一会儿，猪肚便会加厚一倍18、煮猪肚时，千万不能先放盐，等煮熟后吃时再放盐，否则猪肚会缩得象牛筋一样硬 20、煮牛肉和其他韧、硬肉类以及野味禽类时，加点醋可使其软化。 21、炖老鸡：在锅内加二三十颗黄豆同炖，熟得快且味道鲜；或在杀老鸡之前，先灌给鸡一汤匙食醋，然后再杀，用文火煮炖，就会煮得烂熟；或放３～４枚山楂，鸡肉易烂 23、炖老鸭：在锅里放几个田螺容易烂熟 24、烧鸭子时，把鸭子尾端两侧的臊豆去掉，味道更美 25、煮咸肉：用十几个钻有许多小孔的核桃同煮，可消除臭味26、红烧牛肉时，加少许雪里红，肉味鲜美 27、做红烧肉前，先用少许硼砂把肉腌一下，烧出来的肉肥而不腻，甘香可口 28、油炸食物时，锅里放少许食盐，油不会外溅 29、在春卷的拌馅中适量加些面粉，能避免炸制过程中馅内菜汁流出糊锅底的现象30、炸土豆之前，先把切好的土豆片放在水里煮一会儿，使土豆皮的表面形成一层薄薄的胶质层，然后再用油炸 31、炸猪排时，在有筋的地方割２～３个切口，炸出来的猪排就不会收缩 32、将鸡肉先腌一会儿，封上护膜放入冰箱，待炸时再取出，炸出的鸡肉酥脆可口33、煎荷包蛋时，在蛋黄即将凝固之际浇一点冷开水，会使蛋又黄又嫩34、煎鸡蛋时，在平底锅放足油，油微热时蛋下锅，鸡蛋慢慢变熟，外观美，不粘锅35、煎鸡蛋时，在热油中撒点面粉，蛋会煎得黄亮好看，油也不易溅出锅外36、用羊油炒鸡蛋，味香无异味 38、炒鸡蛋时加入几滴醋，炒出的蛋松软味香 39、炒茄子时，在锅里放点醋，炒出的茄子颜色不会变黑 40、炒土豆时加醋，可避免烧焦，又可分解土豆中的毒素，并使色、味相宜41、炒豆芽时，先加点黄油，然后再放盐，能去掉豆腥味 42、炒波菜时不宜加盖 43、炒肉片：肉切成薄片加酱油、黄油、淀粉，打入一个鸡蛋，拌匀，炒散；等肉片变色后，再加佐料稍炒几下，肉片味美、鲜嫩45、炒肉菜时放盐过早熟得慢，宜在将熟时加盐，在出锅前再加上几滴醋，鲜嫩可口48、做肉饼和肉丸子时，一公斤肉馅放2小匙盐 49、做丸子按50克肉10克淀粉的比例调制，成菜软嫩 50、做滑炒肉片或辣子肉丁，按50克肉５克淀粉的比例上浆，成菜鲜嫩味美51、做馒头时，如果在发面里揉进一小块猪油，蒸出来的馒头不仅洁白、松软，而且味香52、蒸馒头时掺入少许桔皮丝，可使馒头增加清香 53、蒸馒头碱放多了起黄，如在原蒸锅水里加醋２～３汤匙，再蒸10～15分钟可变白54、将少量明矾和食盐放入清水中，把切开的生红薯浸入十几分钟，洗净后蒸煮，可防止或减轻腹胀56、放有辣椒的菜太辣时或炒辣椒时加点醋，辣味大减57、烹调时，放酱油若错倒了食醋，可撒放少许小苏打，醋味即可消除58、菜太酸，将一只松花蛋捣烂放入，菜太辣，放一只鸡蛋同炒 ，菜太苦，滴入少许白醋62、汤太咸又不宜兑水时，可放几块豆腐或土豆或几片蕃茄到汤中；也可将一把米或面粉用布包起来放入汤中63、汤太腻，将少量紫菜在火上烤一下，然后撒入汤中64、花生米用油炸熟，盛入盘中，趁热撒上少许白酒，稍凉后再撒上少许食盐，放置几天几夜都稣脆如初65、菜籽油有一股异味，可把油烧热后投入适量生姜、蒜、葱、丁香、陈皮同炸片刻，油即可变香66、用菜油炸一次花生米就没有怪味了，炒出的菜肴香味可口，并可做凉拌菜67、炸完食物后的油留下一些残渣并变得混浊，可将白萝卜切成厚圆片，用筷子把萝卜戳几个洞，放入剩油中炸，残渣会附着在萝卜片上，取出清除残渣，再反复放入锅中炸，混浊的油可变清澈69、当锅内温度达到最高时加入料酒，易使酒蒸发而去除食物中的腥味70、熬猪油：在电饭褒内放一点水或植物油，然后放入猪板油或肥肉，接通电源后，能自动将油炼好，不溅油，不糊油渣，油质清纯71、泡菜坛中放十几粒花椒或少许麦芽糖，可防止产生白花]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端使用技巧，切换到其他路径和目录]]></title>
    <url>%2Fposts%2F14a2657.html</url>
    <content type="text"><![CDATA[如果你想将当前 command line 会话切换到其他目录，需要用到三个命令：pwd，ls和cd pwd的含义是“print working directory”，会显示当前目录的绝对路径。 ls的含义是“list directory contents”，它会列出当前目录的内容。这个命令还有其他参数可选。 cd的含义是“change directory”，它会改变当前目录到你指定的目录。如果你不指定，则会返回你的 home folder。 命令 含义 pwd 当前工作目录 cd（不加参数） 进root cd（folder） 进入文件夹 cd .. 上级目录 cd ~ 返回root cd - 返回上一个访问的目录 rm 文件名 删除 cat 文件名 在终端下查看文件 ls 列出目录下所有文件 cp 文件名 目标目录 将文件拷贝到目标目录下 ~代表root 如：~/Document/ZM/ mkdiv 新建文件夹]]></content>
      <categories>
        <category>Mac</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio混淆模板及常用第三方混淆]]></title>
    <url>%2Fposts%2F9a4f9efd.html</url>
    <content type="text"><![CDATA[首先要在build.gradle中开启混淆，也就是 minifyEnabled true ，我用的build.gradle具体如下所示： 123456789101112131415161718192021222324252627282930313233def releaseTime() &#123; return new Date().format("yyyy.MM.dd", TimeZone.getTimeZone("UTC"))&#125;android &#123; .... buildTypes &#123; release &#123; // 混淆 minifyEnabled true // Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true // 前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; // 输出apk名称为appname-1.0-beta1-xxxx-xx-xx.apk def fileName = "app-$&#123;defaultConfig.versionName&#125;-beta1-$&#123;releaseTime()&#125;.apk" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125; ....&#125; 上面注释中写到proguard-android.txt文件，这是系统默认的混淆文件，具体在../sdk/tools/proguard/目录下，其中包含了android最基本的混淆，一般不需要改动，我们需要配置的是项目中app下的proguard-rules.pro文件，在此提供一份混淆模板。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165############################################### 对于一些基本指令的添加############################################### 代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5 # 混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames # 指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses # 这句话能够使我们的项目混淆后产生映射文件# 包含有类名-&gt;混淆后类名的映射关系-verbose # 指定不去忽略非公共库的类成员-dontskipnonpubliclibraryclassmembers # 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify # 保留Annotation不混淆-keepattributes *Annotation*,InnerClasses # 避免混淆泛型-keepattributes Signature # 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable # 指定混淆是采用的算法，后面的参数是一个过滤器# 这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/* ############################################### Android开发中一些需要保留的公共部分############################################## # 保留我们使用的四大组件，自定义的Application等等这些类不被混淆# 因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService # 保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125; # 保留继承的-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.** # 保留R下面的资源-keep class **.R$* &#123;*;&#125; # 保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; # 保留在Activity中的方法参数是view的方法，# 这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125; # 保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125; # 保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125; # 保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125; # 保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125; # 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event); void *(**On*Listener);&#125; # webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125; # 移除Log类打印各个等级日志的代码，打正式包的时候可以做为禁log使用，这里可以作为禁止log打印的功能使用# 记得proguard-android.txt中一定不要加-dontoptimize才起作用# 另外的一种实现方案是通过BuildConfig.DEBUG的变量来控制#-assumenosideeffects class android.util.Log &#123;# public static int v(...);# public static int i(...);# public static int w(...);# public static int d(...);# public static int e(...);#&#125; ############################################### 项目中特殊处理部分############################################## #-----------处理反射类--------------- #-----------处理js交互--------------- #-----------处理实体类---------------# 在开发的时候我们可以将所有的实体类放在一个包内，这样我们写一次混淆就行了。#-keep public class com.ljd.example.entity.** &#123;# public void set*(***);# public *** get*();# public *** is*();#&#125; #-----------处理第三方依赖库--------- 下面介绍常用第三方混淆配置（已按字母排序，不定期更新）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275# AndroidEventBus-keep class org.simple.** &#123; *; &#125;-keep interface org.simple.** &#123; *; &#125;-keepclassmembers class * &#123; @org.simple.eventbus.Subscriber &lt;methods&gt;;&#125;# 百度地图（jar包换成自己的版本，记得签名要匹配）-libraryjars libs/baidumapapi_v2_1_3.jar-keep class com.baidu.** &#123;*;&#125;-keep class vi.com.** &#123;*;&#125;-keep class com.sinovoice.** &#123;*;&#125;-keep class pvi.com.** &#123;*;&#125;-dontwarn com.baidu.**-dontwarn vi.com.**-dontwarn pvi.com.**# Bugly-dontwarn com.tencent.bugly.**-keep class com.tencent.bugly.** &#123;*;&#125;# ButterKnife-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125; -keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;# EventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Facebook-keep class com.facebook.** &#123;*;&#125;-keep interface com.facebook.** &#123;*;&#125;-keep enum com.facebook.** &#123;*;&#125;# FastJson-dontwarn com.alibaba.fastjson.**-keep class com.alibaba.fastjson.** &#123; *; &#125;-keepattributes Signature-keepattributes *Annotation*# Fresco-keep class com.facebook.fresco.** &#123;*;&#125;-keep interface com.facebook.fresco.** &#123;*;&#125;-keep enum com.facebook.fresco.** &#123;*;&#125;# 高德相关依赖# 集合包:3D地图3.3.2 导航1.8.0 定位2.5.0-dontwarn com.amap.api.**-dontwarn com.autonavi.**-keep class com.amap.api.**&#123;*;&#125;-keep class com.autonavi.**&#123;*;&#125;# 地图服务-dontwarn com.amap.api.services.**-keep class com.map.api.services.** &#123;*;&#125;# 3D地图-dontwarn com.amap.api.mapcore.**-dontwarn com.amap.api.maps.**-dontwarn com.autonavi.amap.mapcore.**-keep class com.amap.api.mapcore.**&#123;*;&#125;-keep class com.amap.api.maps.**&#123;*;&#125;-keep class com.autonavi.amap.mapcore.**&#123;*;&#125;# 定位-dontwarn com.amap.api.location.**-dontwarn com.aps.**-keep class com.amap.api.location.**&#123;*;&#125;-keep class com.aps.**&#123;*;&#125;# 导航-dontwarn com.amap.api.navi.**-dontwarn com.autonavi.**-keep class com.amap.api.navi.** &#123;*;&#125;-keep class com.autonavi.** &#123;*;&#125;# Glide-keep public class * implements com.bumptech.glide.module.GlideModule-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** &#123; **[] $VALUES; public *;&#125;# Gson-keepattributes Signature-keepattributes *Annotation*-keep class sun.misc.Unsafe &#123; *; &#125;-keep class com.google.gson.stream.** &#123; *; &#125;# 使用Gson时需要配置Gson的解析对象及变量都不混淆。不然Gson会找不到变量。# 将下面替换成自己的实体类-keep class com.example.bean.** &#123; *; &#125;# Jackson-dontwarn org.codehaus.jackson.**-dontwarn com.fasterxml.jackson.databind.**-keep class org.codehaus.jackson.** &#123; *;&#125;-keep class com.fasterxml.jackson.** &#123; *; &#125;# 极光推送-dontoptimize-dontpreverify-dontwarn cn.jpush.**-keep class cn.jpush.** &#123; *; &#125;# OkHttp-keep class com.squareup.okhttp.** &#123; *; &#125;-keep interface com.squareup.okhttp.** &#123; *; &#125;-dontwarn com.squareup.okhttp.**# OkHttp3-dontwarn com.squareup.okhttp3.**-keep class com.squareup.okhttp3.** &#123; *;&#125;-dontwarn okio.**# Okio-dontwarn com.squareup.** -dontwarn okio.** -keep public class org.codehaus.* &#123; *; &#125; -keep public class java.nio.* &#123; *; &#125;# OrmLite-keepattributes *DatabaseField* -keepattributes *DatabaseTable* -keepattributes *SerializedName* -keep class com.j256.**-keepclassmembers class com.j256.** &#123; *; &#125;-keep enum com.j256.**-keepclassmembers enum com.j256.** &#123; *; &#125;-keep interface com.j256.**-keepclassmembers interface com.j256.** &#123; *; &#125;# Realm-keep class io.realm.annotations.RealmModule-keep @io.realm.annotations.RealmModule class *-keep class io.realm.internal.Keep-keep @io.realm.internal.Keep class * &#123; *; &#125;-dontwarn javax.**-dontwarn io.realm.**# Retrofit-dontwarn retrofit2.**-keep class retrofit2.** &#123; *; &#125;-keepattributes Signature-keepattributes Exceptions# Retrolambda-dontwarn java.lang.invoke.*# RxJava RxAndroid-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;# Universal-Image-Loader-v1.9.5-libraryjars libs/universal-image-loader-1.9.5-SNAPSHOT-with-sources.jar-dontwarn com.nostra13.universalimageloader.**-keep class com.nostra13.universalimageloader.** &#123; *; &#125;# 微信支付-dontwarn com.tencent.mm.**-dontwarn com.tencent.wxop.stat.**-keep class com.tencent.mm.** &#123;*;&#125;-keep class com.tencent.wxop.stat.**&#123;*;&#125;# 信鸽-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep class com.tencent.android.tpush.** &#123;* ;&#125;-keep class com.tencent.mid.** &#123;* ;&#125;-keepattributes *Annotation*# 新浪微博-keep class com.sina.weibo.sdk.* &#123; *; &#125; -keep class android.support.v4.* &#123; *; &#125; -keep class com.tencent.* &#123; *; &#125; -keep class com.baidu.* &#123; *; &#125; -keep class lombok.ast.ecj.* &#123; *; &#125; -dontwarn android.support.v4.** -dontwarn com.tencent.**s -dontwarn com.baidu.** # 讯飞语音-dontwarn com.iflytek.**-keep class com.iflytek.** &#123;*;&#125;# xUtils3.0-keepattributes Signature,Annotation-keep public class org.xutils.** &#123;public protected *;&#125;-keep public interface org.xutils.** &#123;public protected *;&#125;-keepclassmembers class * extends org.xutils.** &#123;public protected *;&#125;-keepclassmembers @org.xutils.db.annotation.* class * &#123;;&#125;-keepclassmembers @org.xutils.http.annotation. class * &#123;*;&#125;-keepclassmembers class * &#123;@org.xutils.view.annotation.Event ;&#125;# 银联-dontwarn com.unionpay.**-keep class com.unionpay.** &#123; *; &#125;# 友盟统计分析-keepclassmembers class * &#123; public &lt;init&gt;(org.json.JSONObject); &#125;-keepclassmembers enum com.umeng.analytics.** &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;# 友盟自动更新-keepclassmembers class * &#123; public &lt;init&gt;(org.json.JSONObject); &#125;-keep public class cn.irains.parking.cloud.pub.R$*&#123; public static final int *; &#125;-keep public class * extends com.umeng.**-keep class com.umeng.** &#123; *; &#125;# 支付宝钱包-dontwarn com.alipay.**-dontwarn HttpUtils.HttpFetcher-dontwarn com.ta.utdid2.**-dontwarn com.ut.device.**-keep class com.alipay.android.app.IAlixPay&#123;*;&#125;-keep class com.alipay.android.app.IAlixPay$Stub&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback$Stub&#123;*;&#125;-keep class com.alipay.sdk.app.PayTask&#123; public *;&#125;-keep class com.alipay.sdk.app.AuthTask&#123; public *;&#125;-keep class com.alipay.mobilesecuritysdk.*-keep class com.ut.*]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的会写单例吗]]></title>
    <url>%2Fposts%2F6bfd7458.html</url>
    <content type="text"><![CDATA[提到单例模式，相信都不会陌生，今天对其进行总结。 以下是单例模式的特点： 单例类只能有一个实例。 单例类必须自己自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 种类的话不好说有几类，因为要考虑到是否在多线程下运行，下面来介绍主要的几类： 懒汉类123456789101112131415//懒汉式单例类.在第一次调用的时候实例化自己 public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton single = null; //静态工厂方法 public static Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 懒汉么，所以在多线程下会失效，所以下面介绍三种懒汉的升级版来适应多线程 在getinstance前加上synchronized（同步），但这导致的是每次getInstance都会去同步，消耗资源。 1234567891011121314public class Singleton &#123; private Singleton() &#123; &#125; private static Singleton single = null; // 静态工厂方法 public static synchronized Singleton getInstance() &#123; if (single == null) &#123; single = new Singleton(); &#125; return single; &#125;&#125; 双重检查锁，它是在以上做的修改，判断两次空，所以只有在第一次调用的时候会同步，避免了每次同步资源的消耗，注意 volatile 关键字。 123456789101112131415161718public class Singleton &#123; private Singleton() &#123; &#125; private volatile static Singleton singleton = null; // 声明成 volatile //静态工厂方法 public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 内部静态类，这种我觉得是最好的，既实现了线程安全，也避免了同步带来的性能影响。 123456789101112public class Singleton &#123; private static class LazyHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 饿汉类饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。 123456789101112//饿汉式单例类.在类初始化时，已经自行实例化public class Singleton &#123; private Singleton() &#123; &#125; private static final Singleton single = new Singleton(); //静态工厂方法 public static Singleton getInstance() &#123; return single; &#125;&#125; 这种也是我比较喜欢的，因为简单易懂，但当实现了Serializable接口后，反序列化时单例会被破坏，实现Serializable接口需要重写readResolve，才能保证其反序列化依旧是单例： 123private Object readResolve() throws ObjectStreamException &#123; return single; &#125; 枚举类123456public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。 以上就是常用的单例模式，一般的情况下，我会使用饿汉式，只有在要明确实现lazy loading效果时才会使用内部静态类，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android发送短信的两种方式]]></title>
    <url>%2Fposts%2F9f23975a.html</url>
    <content type="text"><![CDATA[Demo地址：SendSMSDemo SMS涉及的主要类SmsManager实现SMS主要用到SmsManager类，该类继承自java.lang.Object类，下面我们介绍一下该类的主要成员。 公有方法： ArrayList divideMessage(String text)当短信超过SMS消息的最大长度时，将短信分割为几块。参数：text——初始的消息，不能为空返回值：有序的ArrayList，可以重新组合为初始的消息 static SmsManager getDefault()获取SmsManager的默认实例。返回值：SmsManager的默认实例 void SendDataMessage(String destinationAddress, String scAddress, short destinationPort, byte[] data,PendingIntent sentIntent, PendingIntent deliveryIntent)发送一个基于SMS的数据到指定的应用程序端口。参数：1)、destinationAddress——消息的目标地址2)、scAddress——服务中心的地址or为空使用当前默认的SMSC 3)destinationPort——消息的目标端口号4)、data——消息的主体，即消息要发送的数据5)、sentIntent——如果不为空，当消息成功发送或失败这个PendingIntent就广播。结果代码是Activity.RESULT_OK表示成功，或RESULT_ERROR_GENERIC_FAILURE、RESULT_ERROR_RADIO_OFF、RESULT_ERROR_NULL_PDU之一表示错误。对应RESULT_ERROR_GENERIC_FAILURE，sentIntent可能包括额外的“错误代码”包含一个无线电广播技术特定的值，通常只在修复故障时有用。每一个基于SMS的应用程序控制检测sentIntent。如果sentIntent是空，调用者将检测所有未知的应用程序，这将导致在检测的时候发送较小数量的SMS。6)、deliveryIntent——如果不为空，当消息成功传送到接收者这个PendingIntent就广播。异常：如果destinationAddress或data是空时，抛出IllegalArgumentException异常。 void sendMultipartTextMessage(String destinationAddress, String scAddress, ArrayList parts,ArrayList sentIntents, ArrayList deliverIntents)发送一个基于SMS的多部分文本，调用者应用已经通过调用divideMessage(String text)将消息分割成正确的大小。参数：1)、destinationAddress——消息的目标地址2)、scAddress——服务中心的地址or为空使用当前默认的SMSC3)、parts——有序的ArrayList，可以重新组合为初始的消息4)、sentIntents——跟SendDataMessage方法中一样，只不过这里的是一组PendingIntent5)、deliverIntents——跟SendDataMessage方法中一样，只不过这里的是一组PendingIntent异常：如果destinationAddress或data是空时，抛出IllegalArgumentException异常。 void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent,PendingIntent deliveryIntent)发送一个基于SMS的文本。参数的意义和异常前面的已存在的一样，不再累述。 常量： public static final int RESULT_ERROR_GENERIC_FAILURE 表示普通错误，值为1(0x00000001) public static final int RESULT_ERROR_NO_SERVICE表示服务当前不可用，值为4 (0x00000004) public static final int RESULT_ERROR_NULL_PDU表示没有提供pdu，值为3 (0x00000003) public static final int RESULT_ERROR_RADIO_OFF表示无线广播被明确地关闭，值为2 (0x00000002) public static final int STATUS_ON_ICC_FREE表示自由空间，值为0 (0x00000000) public static final int STATUS_ON_ICC_READ表示接收且已读，值为1 (0x00000001) public static final int STATUS_ON_ICC_SENT表示存储且已发送，值为5 (0x00000005) public static final int STATUS_ON_ICC_UNREAD表示接收但未读，值为3 (0x00000003) public static final int STATUS_ON_ICC_UNSENT表示存储但为发送，值为7 (0x00000007) 第一：调用系统短信接口直接发送短信；主要代码如下： 12345678910111213141516/** * 直接调用短信接口发短信 * * @param phoneNumber * @param message */ public void sendSMS(String phoneNumber, String message) &#123; // 获取短信管理器 android.telephony.SmsManager smsManager = android.telephony.SmsManager .getDefault(); // 拆分短信内容（手机短信长度限制） List&lt;String&gt; divideContents = smsManager.divideMessage(message); for (String text : divideContents) &#123; smsManager.sendTextMessage(phoneNumber, null, text, sentPI,deliverPI); &#125; &#125; 第二：调起系统发短信功能；主要代码如下： 12345678910111213/** * 调起系统发短信功能 * * @param phoneNumber * @param message */ public void doSendSMSTo(String phoneNumber, String message) &#123; if (PhoneNumberUtils.isGlobalPhoneNumber(phoneNumber)) &#123; Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.parse("smsto:" + phoneNumber)); intent.putExtra("sms_body", message); startActivity(intent); &#125; &#125; 下面来主要讲解第一种方法，第一种方法可以监控发送状态和对方接收状态使用的比较多。 处理返回的状态代码如下: 1234567891011121314151617181920212223242526272829303132333435363738//处理返回的发送状态 String SENT_SMS_ACTION = "SENT_SMS_ACTION"; Intent sentIntent = new Intent(SENT_SMS_ACTION); sentPI= PendingIntent.getBroadcast(this, 0, sentIntent, 0); // register the Broadcast Receivers this.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context _context, Intent _intent) &#123; switch (getResultCode()) &#123; case Activity.RESULT_OK: Toast.makeText(MainActivity.this, "短信发送成功", Toast.LENGTH_SHORT) .show(); break; case SmsManager.RESULT_ERROR_GENERIC_FAILURE: break; case SmsManager.RESULT_ERROR_RADIO_OFF: break; case SmsManager.RESULT_ERROR_NULL_PDU: break; &#125; &#125; &#125;, new IntentFilter(SENT_SMS_ACTION)); //处理返回的接收状态 String DELIVERED_SMS_ACTION = "DELIVERED_SMS_ACTION"; // create the deilverIntent parameter Intent deliverIntent = new Intent(DELIVERED_SMS_ACTION); deliverPI = PendingIntent.getBroadcast(this, 0,deliverIntent, 0); this.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context _context, Intent _intent) &#123; Toast.makeText(MainActivity.this,"收信人已经成功接收", Toast.LENGTH_SHORT) .show(); &#125; &#125;, new IntentFilter(DELIVERED_SMS_ACTION)); 别忘了权限的问题： 1&lt;uses-permission android:name="android.permission.SEND_SMS" /&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>SMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0～9.0适配]]></title>
    <url>%2Fposts%2Fdd367189.html</url>
    <content type="text"><![CDATA[1.前言 大家还记得Android 6.0权限适配的泪水吗？而现在谷歌已经出了Android P的稳定版，而且谷歌粑粑，为了大家能给辛苦熬夜加班，特地的和个大市场合作，要强制推出9.0的适配，而近期在下不才，为了报着多踩坑的心态，做了一下7.0～9.0的适配，脸颊也是老泪两行 2.安卓6.0的适配2.1 怎么适配 ● 在6.0所有权限都需要申请？ 曰：当然不是。只有属于危险权限的才需要申请。危险权限看下表1-2 ● 那危险权限也很多啊，也要一个个申请？ 曰：当然不是。你看看下面的表，都分好组了（9组），对于同一组内的权限，只要有一个被同意，其他的都会被同意。 ● 谁最帅 曰：当然是子信。 2.2 列举权限的分组 表1-2危险权限分组 分组 名字 分割线 PHONE android.permission.READ_PHONE_STATE android.permission.CALL_PHONE android.permission.READ_CALL_LOG android.permission.ADD_VOICEMAIL android.permission.WRITE_CALL_LOG android.permission.USE_SIP android.permission.PROCESS_OUTGOING_CALLS CALENDAR android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR CAMERA android.permission.CAMERA CONTACTS android.permission.READ_CONTACTS android.permission.WRITE_CONTACTS android.permission.GET_ACCOUNTS LOCATION android.permission.ACCESS_FINE_LOCATION android.permission.ACCESS_COARSE_LOCATION MICROPHONE android.permission.RECORD_AUDIO SENSORS android.permission.BODY_SENSORS SMS android.permission.SEND_SMS android.permission.RECEIVE_SMS android.permission.READ_SMS android.permission.RECEIVE_WAP_PUSH android.permission.RECEIVE_MMS STORAGE android.permission.READ_EXTERNAL_STORAGE android.permission.WRITE_EXTERNAL_STORAGE 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 危险权限 start --&gt;&lt;!--PHONE--&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt;&lt;uses-permission android:name="android.permission.READ_CALL_LOG"/&gt;&lt;uses-permission android:name="android.permission.ADD_VOICEMAIL"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CALL_LOG"/&gt;&lt;uses-permission android:name="android.permission.USE_SIP"/&gt;&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;&lt;!--CALENDAR--&gt;&lt;uses-permission android:name="android.permission.READ_CALENDAR"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CALENDAR"/&gt;&lt;!--CAMERA--&gt;&lt;uses-permission android:name="android.permission.CAMERA"/&gt;&lt;!--CONTACTS--&gt;&lt;uses-permission android:name="android.permission.READ_CONTACTS"/&gt;&lt;uses-permission android:name="android.permission.WRITE_CONTACTS"/&gt;&lt;uses-permission android:name="android.permission.GET_ACCOUNTS"/&gt;&lt;!--LOCATION--&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt;&lt;!--MICROPHONE--&gt;&lt;uses-permission android:name="android.permission.RECORD_AUDIO"/&gt;&lt;!--SENSORS--&gt;&lt;uses-permission android:name="android.permission.BODY_SENSORS"/&gt;&lt;!--SMS--&gt;&lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_SMS"/&gt;&lt;uses-permission android:name="android.permission.READ_SMS"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_WAP_PUSH"/&gt;&lt;uses-permission android:name="android.permission.RECEIVE_MMS"/&gt;&lt;!--STORAGE--&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;!-- 危险权限 Permissions end --&gt; 以上是列出9组需要动态申请的权限，建议自己代码统一封装成一个工具类，这里就不细说了， Android6.0权限工具 3.Android 7.0的适配3.1 应用间共享文件 在targetSdkVersion大于等于的24的App中，但是我们没有去适配7.0。那么在调用安装页面，或修改用户头像操作时，就会失败。那么就需要你去适配7.0或是将targetSdkVersion改为24以下（不推荐）。适配的方法这里就不细讲，大家可以看鸿洋大神的 Android 7.0 行为变更 通过FileProvider在应用间共享文件这篇文章 3.2 APK signature scheme v2 Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。 1）只勾选v1签名就是传统方案签署，但是在7.0上不会使用V2安全的验证方式。 2）只勾选V2签名7.0以下会显示未安装，7.0上则会使用了V2安全的验证方式。 3）同时勾选V1和V2则所有版本都没问题。 3.3 org.apache不支持问题 1234// build.gradle里面加上这句话defaultConfig &#123; useLibrary 'org.apache.http.legacy' &#125; 3.3 SharedPreferences闪退 12SharedPreferences read = getSharedPreferences(RELEASE_POOL_DATA, MODE_WORLD_READABLE);//MODE_WORLD_READABLE ：7.0以后不能使用这个获取，会闪退，修改成MODE_PRIVATE 4.Android 8.0的适配4.1 安卓8.0中PHONE权限组新增两个权限 12ANSWER_PHONE_CALLS：允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 acceptRingingCall() 函数。READ_PHONE_NUMBERS ：权限允许您的应用读取设备中存储的电话号码。 4.2 通知适配 安卓8.0中，为了更好的管制通知的提醒，不想一些不重要的通知打扰用户，新增了通知渠道，用户可以根据渠道来屏蔽一些不想要的通知 兼容的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 安卓8。0通知的兼容类哦， * NotifyCompatYc yc : 是雨辰的简写，谢谢哦，嘿嘿 ----高贵的子信 */public class NotifyCompatYc &#123; public static final String QFMD_CHANNEL_ID = "com.oms.mingdeng"; public static final String QFMD_CHANNEL_NAME = "祈福明燈"; public static final String LJMS_DEFAULT_CHANNEL_NAME = "靈機妙算"; public static final String LJMS_CHANNEL_ID = "com.oms.mmcnotity"; public static final String XYS_CHANNEL_ID = "com.oms.xuyuanshu"; public static final String XYS_CHANNEL_NAME = "許願樹"; public static void setONotifyChannel(NotificationManager manager, NotificationCompat.Builder builder, String channeId, String channelName) &#123; if (TextUtils.isEmpty(channeId)||TextUtils.isEmpty(channelName))&#123; L.e("NotifyCompatYc: ".concat("安卓8.0的通知兼容库中 channeId 与 channelName 不能为empty")); &#125; if (Build.VERSION.SDK_INT &gt;= 26) &#123; //第三个参数设置通知的优先级别 NotificationChannel channel = new NotificationChannel(channeId, channelName, NotificationManager.IMPORTANCE_DEFAULT); channel.canBypassDnd();//是否可以绕过请勿打扰模式 channel.canShowBadge();//是否可以显示icon角标 channel.enableLights(true);//是否显示通知闪灯 channel.enableVibration(true);//收到小时时震动提示 channel.setBypassDnd(true);//设置绕过免打扰 channel.setLockscreenVisibility(NotificationCompat.VISIBILITY_SECRET); channel.setLightColor(Color.RED);//设置闪光灯颜色 channel.getAudioAttributes();//获取设置铃声设置 channel.setVibrationPattern(new long[]&#123;100, 200, 100&#125;);//设置震动模式 channel.shouldShowLights();//是否会闪光 if (manager != null) &#123; manager.createNotificationChannel(channel); &#125; if (builder != null) &#123; builder.setChannelId(channeId);//这个id参数要与上面channel构建的第一个参数对应 &#125; &#125; &#125; public static void setONotifyChannel(NotificationManager manager, String channeId, String channelName) &#123; setONotifyChannel(manager,null,channeId,channelName); &#125; public static Notification getNotification(Context context, String channelId) &#123; NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(context, channelId); Notification notification = notificationBuilder.setOngoing(true) .setSmallIcon(R.drawable.ic_launcher) .setPriority(NotificationManager.IMPORTANCE_MIN) .setCategory(Notification.CATEGORY_SERVICE) .build(); return notification; &#125;&#125;复制代码public class NotifyManager &#123; // 单例开始 private volatile static NotifyManager INSTANCE; private NotifyManager(Context context) &#123; initNotifyManager(context); &#125; public static NotifyManager getInstance(Context context) &#123; if (INSTANCE == null) &#123; synchronized (NotifyManager.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new NotifyManager(context); &#125; &#125; &#125; return INSTANCE; &#125; // 单例结束 private NotificationManager manager; // NotificationManagerCompat private NotificationCompat.Builder builder; //初始化通知栏配置 private void initNotifyManager(Context context) &#123; context = context.getApplicationContext(); manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE); // 如果存在则清除上一个消息// manager.cancel(news_flag); builder = new NotificationCompat.Builder(context,NotifyCompatYc.QFMD_CHANNEL_ID); NotifyCompatYc.setONotifyChannel(manager,builder,NotifyCompatYc.QFMD_CHANNEL_ID,NotifyCompatYc.QFMD_CHANNEL_NAME); // 设置标题 builder.setContentTitle(context.getResources().getString(R.string.qfmd_notify_title1)); // 状态栏的动画提醒语句 builder.setTicker(context.getResources().getString(R.string.qfmd_notify_ticker)); // 什么时候提醒的 builder.setWhen(System.currentTimeMillis()); // 设置通知栏的优先级 builder.setPriority(Notification.PRIORITY_DEFAULT); // 设置点击可消失 builder.setAutoCancel(true); // 设置是否震动等 builder.setDefaults(Notification.DEFAULT_VIBRATE); // 设置icon builder.setSmallIcon(R.drawable.lingji_icon); // 设置点击意图 Intent intent = new Intent(context, GongdenggeActivity.class); Bundle bundle = new Bundle(); bundle.putBoolean(Contants.INTENT_GOTO_MYLMAP, true); intent.putExtras(bundle); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pendingIntent = PendingIntent.getActivity(context, 230, intent, PendingIntent.FLAG_UPDATE_CURRENT); builder.setContentIntent(pendingIntent); &#125; /** * 显示祈福明灯过期通知 */ public void showQiFuLampOutOfDateNotify(Context context) &#123; // 设置内容 builder.setContentText(context.getResources().getString(R.string.qfmd_notify_content1)); manager.notify(13251, builder.build()); &#125; public void showQiFuLampBlessNotify(Context context) &#123; builder.setContentText(context.getResources().getString(R.string.qfmd_notify_content2)); manager.notify(13255, builder.build()); &#125;&#125; 4.3 安装APK 首先在AndroidManifest文件中添加安装未知来源应用的权限: 1&lt;uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/&gt; 这样系统会自动询问用户完成授权。当然你也可以先使用 canRequestPackageInstalls()查询是否有此权限，如果没有的话使用Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES这个action将用户引导至安装未知应用权限界面去授权。 12345678910111213141516171819202122232425262728private static final int REQUEST_CODE_UNKNOWN_APP = 100; private void installAPK()&#123; if (Build.VERSION.SDK_INT &gt;= 26) &#123; boolean hasInstallPermission = getPackageManager().canRequestPackageInstalls(); if (hasInstallPermission) &#123; //安装应用 &#125; else &#123; //跳转至“安装未知应用”权限界面，引导用户开启权限 Uri selfPackageUri = Uri.parse("package:" + this.getPackageName()); Intent intent = new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, selfPackageUri); startActivityForResult(intent, REQUEST_CODE_UNKNOWN_APP); &#125; &#125;else &#123; //安装应用 &#125; &#125; //接收“安装未知应用”权限的开启结果 @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CODE_UNKNOWN_APP) &#123; installAPK(); &#125; &#125; 4.4 SecurityException的闪退 问题原因：项目使用了ActiveAndroid，在 8.0 或 8.1 系统上使用 26 或以上的版本的 SDK 时，调用 ContentResolver 的 notifyChange 方法通知数据更新，或者调用 ContentResolver 的 registerContentObserver 方法监听数据变化时，会出现上述异常。 解决方案： （1）在清单文件配置 1234567&lt;provider android:name=&quot;com.activeandroid.content.ContentProvider&quot; android:authorities=&quot;com.ylmf.androidclient&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot;&gt;&lt;/provider&gt;复制代码 （2）去掉这个监听刷新的方法，改为广播刷新 4.5 静态广播无法正常接收 问题原因： Android 8.0 引入了新的广播接收器限制，因此您应该移除所有为隐式广播 Intent 注册的广播接收器 解决方案： 使用动态广播代替静态广播 4.6 Caused by: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation 123456问题原因： Android 8.0 非全屏透明页面不允许设置方向（后面8.1系统谷歌就去掉了这个限制，可能很多人真的不习惯吧）解决方案： （1）android:windowIsTranslucent设置为false (2)如果还是想用的话，就去掉清单文件中Activity中的android:screenOrientation=&quot;portrait&quot;， （3）就是使用透明的dialog或者PopupWindow来代替，也可以用DialogFragment，看自己的需求和喜好. Android 9.0的适配9.1 CLEARTEXT communication to life.115.com not permitted by network security policy 问题原因： Android P 限制了明文流量的网络请求，非加密的流量请求都会被系统禁止掉 解决方案： 在资源文件新建xml目录，新建文件 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt;&lt;/network-security-config&gt; 清单文件配置： 1234567&lt;application android:networkSecurityConfig="@xml/network_security_config"&gt; &lt;!--9.0加的，哦哦--&gt; &lt;uses-library android:name="org.apache.http.legacy" android:required="false" /&gt; &lt;/application&gt; 但还是建议都使用https进行传输 9.2 其他Api的修改 java.lang.IllegalArgumentException: Invalid Region.Op - only INTERSECT and DIFFERENCE are allowed 12345if (Build.VERSION.SDK_INT &gt;= 26) &#123; canvas.clipPath(mPath); &#125; else &#123; canvas.clipPath(mPath, Region.Op.REPLACE); &#125; 总结 经过几天的踩坑，终于把targetSdkVersion升级到28，对于以上的经验，也许还存在某些疏漏的，也希望大家可以指正，补充，告诉，希望对你有一定的帮助，鄙人也很开心。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android Tips</tag>
        <tag>权限</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端-iTerm2使用]]></title>
    <url>%2Fposts%2Fe6bc65de.html</url>
    <content type="text"><![CDATA[iTerm2 https://www.zhihu.com/question/27447370 https://medium.com/ayuth/iterm2-zsh-oh-my-zsh-the-most-power-full-of-terminal-on-macos-bdb2823fb04c https://jeremysu0131.github.io/Tool-Mac-iTerm-2-Oh-My-Zsh-Powerlevel9k-設定/ 智能选中双击选中、三击选中整行、四击智能选中（智能规则可配置），选中即复制 巧用 ⌘ 键按住 ⌘ 键 可以拖拽选中的字符串； 点击 url：调用默认浏览器访问该网址； 点击文件：调用默认程序打开文件； 如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行； 点击文件夹：在 finder 中打开该文件夹； 同时按住⌥键，可以以矩形选中，类似于 vim 中的⌃ v操作。 快捷键标签新建标签：⌘ + t 关闭标签：⌘ + w 切换标签：⌘ + 数字 ⌘ + 左右方向键 切换全屏：⌘ + enter 查找：⌘ + f 分屏垂直分屏：⌘ + d 水平分屏：⌘ + ⇧ + d 切换屏幕：⌘ + ⌥ + 方向键⌘ + [ 或 ⌘ + ] 查看历史命令：⌘ + ; 查看剪贴板历史：⌘ + ⇧ + h 其他清除当前行：⌃ + u 到行首：⌃ + a 到行尾：⌃ + e 前进后退：⌃ + f/b (相当于左右方向键) 上一条命令：⌃ + p 搜索命令历史：⌃ + r 删除当前光标的字符：⌃ + d 删除光标之前的字符：⌃ + h 删除光标之前的单词：⌃ + w 删除到文本末尾：⌃ + k 交换光标处文本：⌃ + t 清屏 1：⌘ + r 清屏 2：⌃ + l 时间线：⌘ + ⇧ + e 自带有哪些很实用的功能/快捷键⌘ + 数字 在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴，这个很实用 ⌘ + f 所查找的内容会被自动复制 ⌘ + d 横着分屏 /⌘ + ⇧ + d 竖着分屏 ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 ⌃ + u 清空当前行，无论光标在什么位置 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 ⌘ + ⇧ + h 会列出剪切板历史 可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 常用的一些快捷键⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了 1⌘←` / `⌘→` 到一行命令最左边/最右边 ，这个功能同 `C+a` / `C+e ⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在 Iterm 中已经预定义好了，⌥f / ⌥b，看个人习惯了 好像就这几个 设置方法如下 当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合 C+a / C+e 这个几乎在哪都可以使用 C+p / !! 上一条命令 C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但 iterm 中是删掉整行) C+w A+d 从光标处删至字首/尾 C+h C+d 删掉光标前后的自负 C+y 粘贴至光标后 C+r 搜索命令历史，这个较常用 标记跳转 类似编辑器的 mark 工具，iTerm2 也可以在命令行位置设置标记 设置标记：⌘ + ⇧ + m 跳转到上个标记：⌘ + ⇧ + j 多个标记切换：⌘ + ⇧ + 方向键 选中即复制iterm2 有 2 种好用的选中即复制模式。 一种是用鼠标，在 iterm2 中，选中某个路径或者某个词汇，那么，iterm2 就自 动复制了。另一种是无鼠标模式，⌘+f,弹出 iterm2 的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入 tab，查找窗口将自动变化内容，并将其复制。如果输入的是 ⇧+tab，则自动将查找内容的左边选中并复制。 自动完成输入打头几个字母，然后输入 ⌘+; iterm2 将自动列出之前输入过的类似命令。 剪切历史输入 ⌘+⇧+h，iterm2 将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在 Preferences &gt; General &gt; Save copy/paste history to disk 中设置。 及时回放 某个交互命令会覆写屏幕上的输入，之前的历史信息可能会被覆盖掉，无法查看，iterm2 这个及时回放功能，会记录历史输入，输出，有点类似视频录制。 进入回放：⌘ + opt + b 方向键控制时间 ：arrow 退出回放：esc oh-my-zsh https://www.zhihu.com/question/29977255 智能补全cd ~/ 切换目录，敲击两下tab，会列出当前目录下的所有目录，并且可以使用键盘上下左右键来选择要进入的目录。 命令选项补齐，比如输入 docker，然后按 tab，即可显示出 docker 都有哪些命令选项。 智能切换目录进入一个很深的目录，例如 /var/log/nginx/error/lastyear/may/first/monday, 用 zsh 可以这样输入 cd /v/l/n/e/l/m/f/m 然后按 tab 即可补全整个路径。或者你实现知道当前目录名称，可以直接输入目录，即可进去目录。 在 zsh 下可以记录最近进过的 10 个目录，只需要输入d，然后就可以看到对应的 0-9 的目录，输入cd -数字即可进入对应的目录。 或者直接输入 cd - 然后 tab，会列出最近使用过的 31 个目录。 配置需要的时候把 iterm2 呼出来,不需要的时候自动隐藏iTerm2 &gt; Preferences &gt; Keys，左侧 Hotkey 选项 勾选 Show/hide iTerm2 with a system-wide hotkey，设置快捷键 复用上个会话的目录1iTerm2 &gt; Preferences &gt; Profiles &gt; Working Directory &gt; Reuse previous session’s directory 别名1alias zsh-config=&apos;vim ~/.zshrc&apos; 终端下命令行下用 Sublime、vscode、atom 打开文件夹或目录vscode 命令行调用VS Code 提供了一个 code 命令，用来在 shell 环境下调用编辑器。使用快捷键 ⇧⌘P（或 F1） 唤起命令面板，输入以下命令即可完成安装。 code 命令后可接多个路径或文件： 1code pro6.js pro6.scss ../ 文件对比： 1code -d new-file.js old-file.js 打开文件并跳至指定行： 1code -g source/cn/static/global/tracker.js:15 更多 code 命令行使用方法，参见《Additional Command line arguments》。 手动添加 打开终端，随便一个目录输入 1cd 检查是否有.zshrc文件 1ls -al 1) 添加启动命令 1sudo nano .zshrc 在文件末尾加上别名： alias atom=&apos;/Applications/Atom.app/Contents/MacOS/Atom&apos;alias subl=&apos;/Applications/SublimeText.app/Contents/SharedSupport/bin/subl&apos;alias code=&apos;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&apos; `⌘ + X` 再输入 `y` 保存，重启 iterm2。 查找 APP 路径： vim配色终端输入vim ~/.vimrc，设置内容如下， 123syntax onset numberset ruler powerlevel9k主题 配置项Stylizing Your Prompt 其他人的配置Show Off Your Config 我的配置123456789101112131415161718export DEFAULT_USER=&quot;Leo&quot;export TERM=&quot;xterm-256color&quot;ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;# 调整字体模式POWERLEVEL9K_MODE=&apos;nerdfont-complete&apos;# 左侧提示符显示内容:系统时间(time)、root权限指示(root_indicator)、username and host(context)、当前工作目录(dir)、目录写入权限(dir_writable)、git信息(vcs)POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=(time root_indicator dir dir_writable vcs)# 右侧提示符显示内容:上一命令执行状态(status)、后台任务个数(background_jobs)、上一命令执行时间(command_execution_time)、可用RAM(ram)、系统的负载均值(load)POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS=(status background_jobs command_execution_time ram load)# context也就是你的用户名以及终端名称，默认是 `%n@%m`。POWERLEVEL9K_CONTEXT_TEMPLATE=&quot;Leo&quot;# 低于这个值的命令执行时间不显示，0 也就是命令执行时间多长都显示POWERLEVEL9K_COMMAND_EXECUTION_TIME_THRESHOLD=&quot;0&quot;# 时间格式化POWERLEVEL9K_TIME_FORMAT=&quot;%D&#123;%H:%M&#125;&quot;# 显示分支版本POWERLEVEL9K_SHOW_CHANGESET=true 如果图标显示不出来可以进入 iTerm 的设置 &gt; Profiles &gt; Text &gt; Change Font &gt; 选择 Hack Nerd Font 字体 Regular 大小 18pt，完成后重新启动 iTerm ，设置完成。 插件 打开配置文件：~/.zshrc autojump：快速切换目录 zsh-syntax-highlighting：zsh 可用命令高亮 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting zsh-autosuggestions：命令自动提示 1git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 1plugins=(brew git node npm osx autojump zsh-autosuggestions zsh-syntax-highlighting)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
        <tag>iTerm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感恩节的简介和习俗]]></title>
    <url>%2Fposts%2F3b06da8c.html</url>
    <content type="text"><![CDATA[感恩节的简介每年11月的第四个星期四是感恩节。感恩节是美国人民独创的—个古老节日，也是美国人合家欢聚的节日，因此美国人提起感恩节总是倍感亲切。 感恩节的由来，要一直追溯到美国历史的发端。1620年9月，著名的“五月花”号船，满载不堪忍受英国国内迫害的清教徒102人离港启航。在漫无边际的大洋中，漂泊了整整65天，经历了狂风巨浪的种种折磨，方才在马萨诸塞州科德角顶的普洛文斯敦港靠岸。接着，“五月花”号按计划继续南行，打算在弗吉尼亚的詹姆斯敦靠岸，但因航行误差，他们来到了普利茅斯附近。在那里，由于对地形和环境茫无所知，他们十分谨慎地让大部分人仍然留在船上，只派一批精明强干的人出外探测地形。1个月后，他们终于发现了普利茅斯港口，并且意外地在这里找到了一个优良的渔港。这里有几块已经收获过的玉米田，有清亮的淡水小溪，还有十分宜于筑垒设防的山丘，但空无一人。原来这里是一个印第安人的村落、不久前天花流行。夺去了全体村民的生命。几天后，“五月花”号就渡过科德角湾，在普利茅斯港抛锚上岸。这里成为英国移民在美洲的第二块永久居留地。后来他们把登岸的一块大礁石命名为普利茅斯石。​到了1620年和1621年之交的冬天，他们遇到了难以想象的困难。在寒冷无比的冬季，他们自己搭盖的简陋房屋难以抵御风雪，粮食也不足，再加上繁重的劳动和传染病的侵袭，待到冬天结束，活下来的移民只有50来人了。​开春时节，普利茅斯村的移民结识了一位名叫斯·昆图的印第安人。斯·昆图对移民们十分友好。不久，他把自己部落的酋长马萨索德介绍给移民。心地善良的印第安人热情地欢迎远道而来的客人，马萨索德不仅给移民带来礼物，还特地派本部落的人教会移民们怎样狩猎、捕鱼和种植玉米、南瓜、蚕豆。在印第安人的帮助下，移民们终于获得了丰收。​移民们在欢庆丰收的日子里，按照传统习俗，规定了感谢上帝的日子，并决定为感谢印第安朋友的真诚帮助，邀请他们一同来欢庆节日。印第安人欣然接受了邀请，并且提前送来了5只鹿，表示他们的友好情谊。这就是感恩节的由来。 感恩节的习俗集体庆祝初时感恩节没有固定日期，由各州临时决定，直到美国独立后，感恩节才成为全国性的节日。 每逢感恩节这一天，美国举国上下热闹非常，基督徒按照习俗前往教堂做感恩祈祷，城市乡镇到处都有化装游行、戏剧表演或体育比赛等。分别了一年的亲人们也会从天南海北归来，一家人团圆，品尝以“火鸡”为主的感恩节美食。 ​美国当地最著名的庆典则是从1924年开始的梅西百货感恩节游行（Macy’s Thanksgiving Day Parade）。 每逢感恩节这一天，美国举国上下热闹非凡，人们按照习俗前往教堂做感恩祈祷，城乡市镇到处举行化装游行、戏剧表演和体育比赛等，学校和商店也都按规定放假休息。孩子们还模仿当年印第安人的模样穿上离奇古怪的服装，画上脸谱或戴上面具到街上唱歌、吹喇叭。散居在他乡外地的家人也会回家过节，一家人团团围坐在一起，大嚼美味火鸡，并且对家人说：“谢谢！”。感恩节后，学校会让同学们画一张感恩节的画，大部分学生都画的是火鸡。 同时，好客的美国人也忘不掉这一天邀请好友、单身汉或远离家乡的人共度佳节。从18世纪起，美国就开始出现一种给贫穷人家送一篮子食物的风俗。当时有一群年轻妇女想在一年中选一天专门做善事，认为选定感恩节是最恰当不过的。所以感恩节一到，她们就装上满满一篮食物亲自送到穷人家。这件事远近传闻，不久就有许多人学着她们的样子做起来。不管遇到谁，他们都会说：“Thank you！” 节日购物感恩节购物已经成为了美国人的习俗。从感恩节到圣诞节这一个月，美国零售业奥巴马特赦火鸡“勇气”。​总销售额能占到全年的1/3强，是各个商家传统的打折促销旺季。疯狂的购物月从感恩节的次日（星期五）开始，这一天即被称为Black Friday（黑色星期五）。之所以叫这个名字，据说是因为周五这天一大早，所有人都要摸着黑冲到商场排队买便宜货，这种行为有个非常形象的说法，叫Early Bird（早起的鸟儿）[4]。在外国“感恩节”和中国的春节一样重要！ 每年一度的总统放生火鸡仪式始于1947年杜鲁门总统当政时期，但实际上这个传统仪式可以追溯到美国内战林肯总统当政的时期。1863年的一天，林肯的儿子泰德突然闯入内阁会议请求赦免一只名叫杰克的宠物火鸡，因为这只被送进白宫的火鸡，即将成为人们的感恩节大餐。 ​2006年11月22日，布什在白宫玫瑰花园举行感恩节放生仪式上，特赦了一只名布什特赦“飞鸟”火鸡叫“飞鸟”的火鸡。 美国总统奥巴马25号特赦感恩节火鸡．并将火鸡被命名为“勇气”。这也是他上任以来，首次特赦火鸡．奥巴马并对保护美国人民身家安全的英勇战士表示感恩。 每年11月的第4个星期四是美国感恩节。在女儿萨莎和玛丽亚的陪伴下，奥巴马特赦了本来要用做盘中餐的火鸡．奥巴马说，我原本打算吃掉这只火鸡。由于萨莎和玛丽亚的干预，我赦免了“勇气”。这只火鸡将被送到迪士尼乐园。为防止意外，当局还准备了一只备用火鸡，名叫“卡罗琳娜”。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webview常见问题汇总]]></title>
    <url>%2Fposts%2F8c79d027.html</url>
    <content type="text"><![CDATA[前言 通常我们在自己开发的 APP 中打开网页无非两种方法： 一是跳转到系统自带的浏览器，二是使用 WebView 控件加载页面。使用 WebView 控件的好处就是可以通过各种 api 接口来定制各种行为，常用的几个设置地方为 WebSettings、JavaScriptInterface、WebViewClient 和WebChromeClient。平时出现的问题都可以通过修改这些设置来解决。 问题总结1、使用了 WebView 还是跳转到了系统自带的浏览器？很简单的解决方法，为你的 webview 设置一个新的 WebViewClient。 1234567webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125;&#125;); 12// 或者直接添加，效果是一样的webView.setWebViewClient(new WebViewClient()); 2、获取网页的标题和图标通过 WebChromeClient 可以获取到这些信息。 1234567891011121314webView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onReceivedTitle(WebView view, String title) &#123; super.onReceivedTitle(view, title); setTitle(title); &#125; @Override public void onReceivedIcon(WebView view, Bitmap icon) &#123; super.onReceivedIcon(view, icon); setIcon(icon); &#125;&#125;); 但是，这里有个问题，当通过 webView.goBack() 方式返回上一级Web页面的时候不会触发这个方法，因此会导致标题无法跟随历史记录返回上一级页面。所以需要在 onPageFinished() 中对界面标题重新设置。 1234567webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); setTitle(String.valueOf(view.getTitle())); &#125;&#125;); 3、返回键实现网页的后退键在 WebView 中可以通过 goBack() 方法后退到历史记录的上一项。 12345678// 在 Actvity 中监听返回键按钮 @Override public void onBackPressed() &#123; if (webView.canGoBack()) webView.goBack(); else super.onBackPressed(); &#125; 4、设置 WebView 的 header在 WebView 的 loadUrl() 方法中传入 Header 参数即可。 1234567public void loadURLWithHTTPHeaders() &#123; final String url = "http://cpacm.net"; WebView webView = new WebView(getActivity()); Map&lt;String,String&gt; extraHeaders = new HashMap&lt;String, String&gt;(); extraHeaders.put("Referer", "http://www.google.com"); webView.loadUrl(url, extraHeaders);&#125; 5、设置 WebView 的 User-Agent不要试图在 Header 里面去修改，而是在 WebSettings 修改 1webView.getSettings().setUserAgentString("Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0"); 6、如何设置 WebView 的缓存当需要本地缓存网页的时候就需要打开 WebViewSettings 的缓存开关,这样子当下次进到该页面无网络的情况下也能打开页面。 123456789WebSettings settings = webView.getSettings();settings.setAppCacheEnabled(true); //启用应用缓存settings.setDomStorageEnabled(true); //启用或禁用DOM缓存。settings.setDatabaseEnabled(true); //启用或禁用DOM缓存。if (SystemUtil.isNetworkConnected()) &#123; //判断是否联网 settings.setCacheMode(WebSettings.LOAD_DEFAULT); //默认的缓存使用模式&#125; else &#123; settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY); //不从网络加载数据，只从缓存加载数据。&#125; 当我们加载Html时候，会在我们data/应用package下生成database与cache两个文件夹:我们请求的Url记录是保存在webviewCache.db里，而url的内容是保存在webviewCache文件夹下.WebView中存在着两种缓存：网页数据缓存（存储打开过的页面及资源）、H5缓存（即AppCache）。 网页数据缓存 WebSettings可设置缓存方式： ①LOAD_DEFAULT：默认设置，当有缓存而且没有过期使用缓存，否则使用网络数据。 ②LOAD_CACHE_ELSE_NETWORK：只要有缓存就使用缓存，即使已经过期，否则使用网络数据。 ③LOAD_NO_CACHE：不适用缓存，只加载网络数据。 ④LOAD_CACHE_ONLY：不使用网络，只使用缓存数据。 ⑤LOAD_CACHE_NORMAL： API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式 方法调用： webSettings.setCacheMode(WebSettings.LOAD_NO_CACHE); AppCache 查阅相关资料，总结如下： ①AppCache简介：对app内存缓存的方案，具体表现为当请求某个文件时不是从网络获取该文件，而是从本地获取。 ②AppCache的好处：离线浏览 ，速度 - 已缓存资源加载得更快，减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。在WebView中使用相关api1、缓存构成根据setAppCachePath(String appCachePath)提供的路径，在H5使用缓存过程中生成的缓存文件。/data/data/package_name/cache//data/data/package_name/database/webview.db/data/data/package_name/database/webviewCache.db综合可以得知 webview 会将我们浏览过的网页url已经网页文件(css、图片、js等)保存到数据库表中 2、缓存模式无模式选择，通过setAppCacheEnabled(boolean flag)设置是否打开。默认关闭，即，H5的缓存无法使用。 3、清除缓存找到调用setAppCachePath(String appCachePath)设置缓存的路径，把它下面的文件全部删除就OK了。 4、控制大小通过setAppCacheMaxSize(long appCacheMaxSize)设置缓存最大容量，默认为Max Integer。同时，可能通过覆盖WebChromeClient.onReachedMaxAppCacheSize(long requiredStorage, long quota, WebStorage.QuotaUpdater quotaUpdater)来设置缓存超过先前设置的最大容量时的策略。 如：www.taobao.com的cache-control为no-cache，在模式LOAD_DEFAULT下，无论如何都会从网络上取数据，如果没有网络，就会出现错误页面；在LOAD_CACHE_ELSE_NETWORK模式下，无论是否有网络，只要本地有缓存，都使用缓存。本地没有缓存时才从网络上获取。www.360.com.cn的cache-control为max-age=60，在两种模式下都使用本地缓存数据。 总结：根据以上两种模式，建议缓存策略为，判断是否有网络，有的话，使用LOAD_DEFAULT，无网络时，使用LOAD_CACHE_ELSE_NETWORK。 设置WebView 缓存模式 12345678910111213141516171819private void initWebView() &#123; mWebView.getSettings().setJavaScriptEnabled(true); mWebView.getSettings().setRenderPriority(RenderPriority.HIGH); mWebView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT); //设置 缓存模式 // 开启 DOM storage API 功能 mWebView.getSettings().setDomStorageEnabled(true); //开启 database storage API 功能 mWebView.getSettings().setDatabaseEnabled(true); String cacheDirPath = getFilesDir().getAbsolutePath()+APP_CACAHE_DIRNAME; // String cacheDirPath = getCacheDir().getAbsolutePath()+Constant.APP_DB_DIRNAME; Log.i(TAG, "cacheDirPath="+cacheDirPath); //设置数据库缓存路径 mWebView.getSettings().setDatabasePath(cacheDirPath); //设置 Application Caches 缓存目录 mWebView.getSettings().setAppCachePath(cacheDirPath); //开启 Application Caches 功能 mWebView.getSettings().setAppCacheEnabled(true); &#125; 清除缓存 1234567891011121314151617181920212223242526272829/** * 清除WebView缓存 */ public void clearWebViewCache()&#123; //清理Webview缓存数据库 try &#123; deleteDatabase("webview.db"); deleteDatabase("webviewCache.db"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //WebView 缓存文件 File appCacheDir = new File(getFilesDir().getAbsolutePath()+APP_CACAHE_DIRNAME); Log.e(TAG, "appCacheDir path="+appCacheDir.getAbsolutePath()); File webviewCacheDir = new File(getCacheDir().getAbsolutePath()+"/webviewCache"); Log.e(TAG, "webviewCacheDir path="+webviewCacheDir.getAbsolutePath()); //删除webview 缓存目录 if(webviewCacheDir.exists())&#123; deleteFile(webviewCacheDir); &#125; //删除webview 缓存 缓存目录 if(appCacheDir.exists())&#123; deleteFile(appCacheDir); &#125; &#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package com.example.webviewtest; import java.io.File; import android.app.Activity; import android.graphics.Bitmap; import android.os.Bundle; import android.util.Log; import android.view.View; import android.webkit.JsPromptResult; import android.webkit.JsResult; import android.webkit.WebChromeClient; import android.webkit.WebSettings; import android.webkit.WebSettings.RenderPriority; import android.webkit.WebView; import android.webkit.WebViewClient; import android.widget.RelativeLayout; import android.widget.TextView; import android.widget.Toast; public class MainActivity extends Activity &#123; private static final String TAG = MainActivity.class.getSimpleName(); private static final String APP_CACAHE_DIRNAME = "/webcache"; private TextView tv_topbar_title; private RelativeLayout rl_loading; private WebView mWebView; private String url; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //url:http://m.dianhua.cn/detail/31ccb426119d3c9eaa794df686c58636121d38bc?apikey=jFaWGVHdFVhekZYWTBWV1ZHSkZOVlJWY&amp;app=com.yulore.yellowsdk_ios&amp;uid=355136051337627 url = "http://m.dianhua.cn/detail/31ccb426119d3c9eaa794df686c58636121d38bc?apikey=jFaWGVHdFVhekZYWTBWV1ZHSkZOVlJWY&amp;app=com.yulore.yellowsdk_ios&amp;uid=355136051337627"; findView(); &#125; private void findView() &#123; tv_topbar_title = (TextView) findViewById(R.id.tv_topbar_title); rl_loading = (RelativeLayout) findViewById(R.id.rl_loading); mWebView = (WebView) findViewById(R.id.mWebView); initWebView(); mWebView.setWebViewClient(new WebViewClient() &#123; @Override public void onLoadResource(WebView view, String url) &#123; Log.i(TAG, "onLoadResource url="+url); super.onLoadResource(view, url); &#125; @Override public boolean shouldOverrideUrlLoading(WebView webview, String url) &#123; Log.i(TAG, "intercept url="+url); webview.loadUrl(url); return true; &#125; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; Log.e(TAG, "onPageStarted"); rl_loading.setVisibility(View.VISIBLE); // 显示加载界面 &#125; @Override public void onPageFinished(WebView view, String url) &#123; String title = view.getTitle(); Log.e(TAG, "onPageFinished WebView title=" + title); tv_topbar_title.setText(title); tv_topbar_title.setVisibility(View.VISIBLE); rl_loading.setVisibility(View.GONE); // 隐藏加载界面 &#125; @Override public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) &#123; rl_loading.setVisibility(View.GONE); // 隐藏加载界面 Toast.makeText(getApplicationContext(), "", Toast.LENGTH_LONG).show(); &#125; &#125;); mWebView.setWebChromeClient(new WebChromeClient() &#123; @Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; Log.e(TAG, "onJsAlert " + message); Toast.makeText(getApplicationContext(), message, Toast.LENGTH_SHORT).show(); result.confirm(); return true; &#125; @Override public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123; Log.e(TAG, "onJsConfirm " + message); return super.onJsConfirm(view, url, message, result); &#125; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; Log.e(TAG, "onJsPrompt " + url); return super.onJsPrompt(view, url, message, defaultValue, result); &#125; &#125;); mWebView.loadUrl(url); &#125; private void initWebView() &#123; mWebView.getSettings().setJavaScriptEnabled(true); mWebView.getSettings().setRenderPriority(RenderPriority.HIGH); mWebView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT); //设置 缓存模式 // 开启 DOM storage API 功能 mWebView.getSettings().setDomStorageEnabled(true); //开启 database storage API 功能 mWebView.getSettings().setDatabaseEnabled(true); String cacheDirPath = getFilesDir().getAbsolutePath()+APP_CACAHE_DIRNAME; // String cacheDirPath = getCacheDir().getAbsolutePath()+Constant.APP_DB_DIRNAME; Log.i(TAG, "cacheDirPath="+cacheDirPath); //设置数据库缓存路径 mWebView.getSettings().setDatabasePath(cacheDirPath); //设置 Application Caches 缓存目录 mWebView.getSettings().setAppCachePath(cacheDirPath); //开启 Application Caches 功能 mWebView.getSettings().setAppCacheEnabled(true); &#125; /** * 清除WebView缓存 */ public void clearWebViewCache()&#123; //清理Webview缓存数据库 try &#123; deleteDatabase("webview.db"); deleteDatabase("webviewCache.db"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //WebView 缓存文件 File appCacheDir = new File(getFilesDir().getAbsolutePath()+APP_CACAHE_DIRNAME); Log.e(TAG, "appCacheDir path="+appCacheDir.getAbsolutePath()); File webviewCacheDir = new File(getCacheDir().getAbsolutePath()+"/webviewCache"); Log.e(TAG, "webviewCacheDir path="+webviewCacheDir.getAbsolutePath()); //删除webview 缓存目录 if(webviewCacheDir.exists())&#123; deleteFile(webviewCacheDir); &#125; //删除webview 缓存 缓存目录 if(appCacheDir.exists())&#123; deleteFile(appCacheDir); &#125; &#125; /** * 递归删除 文件/文件夹 * * @param file */ public void deleteFile(File file) &#123; Log.i(TAG, "delete file path=" + file.getAbsolutePath()); if (file.exists()) &#123; if (file.isFile()) &#123; file.delete(); &#125; else if (file.isDirectory()) &#123; File files[] = file.listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; deleteFile(files[i]); &#125; &#125; file.delete(); &#125; else &#123; Log.e(TAG, "delete file no exists " + file.getAbsolutePath()); &#125; &#125; &#125; 7、无法下载文件？在自己写的 WebView 下是无法直接下载文件，需要自己监听下载事件并对下载的动作进行处理。 12345678910111213/*** 当下载文件时打开系统自带的浏览器进行下载，当然也可以对捕获到的 url 进行处理在应用内下载。**/webView.setDownloadListener(new FileDownLoadListener());private class FileDownLoadListener implements DownloadListener &#123; @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) &#123; Uri uri = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); &#125;&#125; 8、无法打开文件选择器？通过重写 WebChromeClient 来实现点击 来打开系统文件选择器。 一个完整的Activity示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class MainActivity extends AppCompatActivity &#123; /** Android 5.0以下版本的文件选择回调 */ protected ValueCallback&lt;Uri&gt; mFileUploadCallbackFirst; /** Android 5.0及以上版本的文件选择回调 */ protected ValueCallback&lt;Uri[]&gt; mFileUploadCallbackSecond; protected static final int REQUEST_CODE_FILE_PICKER = 51426; protected String mUploadableFileTypes = "image/*"; private WebView mWebView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initWebView(); &#125; private void initWebView() &#123; mWebView = (WebView) findViewById(R.id.my_webview); mWebView.loadUrl("file:///android_asset/index.html"); mWebView.setWebChromeClient(new OpenFileChromeClient()); &#125; private class OpenFileChromeClient extends WebChromeClient &#123; // Android 2.2 (API level 8)到Android 2.3 (API level 10)版本选择文件时会触发该隐藏方法 @SuppressWarnings("unused") public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123; openFileChooser(uploadMsg, null); &#125; // Android 3.0 (API level 11)到 Android 4.0 (API level 15))版本选择文件时会触发，该方法为隐藏方法 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123; openFileChooser(uploadMsg, acceptType, null); &#125; // Android 4.1 (API level 16) -- Android 4.3 (API level 18)版本选择文件时会触发，该方法为隐藏方法 @SuppressWarnings("unused") public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123; openFileInput(uploadMsg, null, false); &#125; // Android 5.0 (API level 21)以上版本会触发该方法，该方法为公开方法 @SuppressWarnings("all") public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) &#123; if (Build.VERSION.SDK_INT &gt;= 21) &#123; final boolean allowMultiple = fileChooserParams.getMode() == FileChooserParams.MODE_OPEN_MULTIPLE;//是否支持多选 openFileInput(null, filePathCallback, allowMultiple); return true; &#125; else &#123; return false; &#125; &#125; &#125; @SuppressLint("NewApi") protected void openFileInput(final ValueCallback&lt;Uri&gt; fileUploadCallbackFirst, final ValueCallback&lt;Uri[]&gt; fileUploadCallbackSecond, final boolean allowMultiple) &#123; //Android 5.0以下版本 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(null); &#125; mFileUploadCallbackFirst = fileUploadCallbackFirst; //Android 5.0及以上版本 if (mFileUploadCallbackSecond != null) &#123; mFileUploadCallbackSecond.onReceiveValue(null); &#125; mFileUploadCallbackSecond = fileUploadCallbackSecond; Intent i = new Intent(Intent.ACTION_GET_CONTENT); i.addCategory(Intent.CATEGORY_OPENABLE); if (allowMultiple) &#123; if (Build.VERSION.SDK_INT &gt;= 18) &#123; i.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true); &#125; &#125; i.setType(mUploadableFileTypes); startActivityForResult(Intent.createChooser(i, "选择文件"), REQUEST_CODE_FILE_PICKER); &#125; public void onActivityResult(final int requestCode, final int resultCode, final Intent intent) &#123; if (requestCode == REQUEST_CODE_FILE_PICKER) &#123; if (resultCode == Activity.RESULT_OK) &#123; if (intent != null) &#123; //Android 5.0以下版本 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(intent.getData()); mFileUploadCallbackFirst = null; &#125; else if (mFileUploadCallbackSecond != null) &#123;//Android 5.0及以上版本 Uri[] dataUris = null; try &#123; if (intent.getDataString() != null) &#123; dataUris = new Uri[] &#123; Uri.parse(intent.getDataString()) &#125;; &#125; else &#123; if (Build.VERSION.SDK_INT &gt;= 16) &#123; if (intent.getClipData() != null) &#123; final int numSelectedFiles = intent.getClipData().getItemCount(); dataUris = new Uri[numSelectedFiles]; for (int i = 0; i &lt; numSelectedFiles; i++) &#123; dataUris[i] = intent.getClipData().getItemAt(i).getUri(); &#125; &#125; &#125; &#125; &#125; catch (Exception ignored) &#123; &#125; mFileUploadCallbackSecond.onReceiveValue(dataUris); mFileUploadCallbackSecond = null; &#125; &#125; &#125; else &#123; //这里mFileUploadCallbackFirst跟mFileUploadCallbackSecond在不同系统版本下分别持有了 //WebView对象，在用户取消文件选择器的情况下，需给onReceiveValue传null返回值 //否则WebView在未收到返回值的情况下，无法进行任何操作，文件选择器会失效 if (mFileUploadCallbackFirst != null) &#123; mFileUploadCallbackFirst.onReceiveValue(null); mFileUploadCallbackFirst = null; &#125; else if (mFileUploadCallbackSecond != null) &#123; mFileUploadCallbackSecond.onReceiveValue(null); mFileUploadCallbackSecond = null; &#125; &#125; &#125; &#125;&#125; 9、怎么为 WebView 的加载添加进度条这里的 onPageFinished() 有个问题，不能在这里监听页面是否加载完毕（我自己测试的时候，好像在重定向和加载完 iframes 时都会调用这个方法）。 把页面加载完毕的判断放在 onProgressChanged() 里可能会更为准确。 12345678910111213141516171819webView.setWebChromeClient(new WebChromeClient() &#123; @Override public void onProgressChanged(WebView view, int position) &#123; progressBar.setProgress(position); if (position == 100) &#123; progressBar.setVisibility(View.GONE); &#125; super.onProgressChanged(view, position); &#125;&#125;);webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; progressBar.setVisibility(View.VISIBLE); super.onPageStarted(view, url, favicon); &#125;&#125;); 10、怎样对页面进行 Js 注入？首先你要在 WebView 开启 JavaScript,然后搭建桥梁 1234567891011WebSettings webSettings = webView.getSettings();webSettings.setJavaScriptEnabled(true);webView.addJavascriptInterface(new WebAppBridge(new WebAppBridge.OauthLoginImpl() &#123; @Override public void getResult(String s) &#123; //TODO &#125; &#125;), "oauth");webView.loadUrl("javascript:" + getAssetsJs("autologin.js"));webView.loadUrl("javascript:adduplistener()"); WebAppBridge的代码 123456789101112131415161718public class WebAppBridge &#123; private OauthLoginImpl oauthLogin; public WebAppBridge(OauthLoginImpl oauthLogin) &#123; this.oauthLogin = oauthLogin; &#125; @JavascriptInterface public void getResult(String str) &#123; if (oauthLogin != null) oauthLogin.getResult(str); &#125; public interface OauthLoginImpl &#123; void getResult(String s); &#125;&#125; 简单的说就是向网页注入一段 js, 在这段 js 里面设置回调到java中的方法 getResult()，由 WebAppBridge.getResult 来回收。其中js的核心代码为: 1oauth.getResult(str); 其中 oauth 这个名称要与 webView.addJavascriptInterface()方法的第二个参数一样。 具体的代码可以参考这个项目中写的 js 注入逻辑 OauthDialog地址：https://github.com/cpacm/MoeMusic/blob/master/app/src/main/java/com/cpacm/moemusic/ui/widgets/dialogs/OauthDialog.java 11、如何手动添加 Cookie需要获得 CookieManager 的对象并将 cookie 设置进去。 从服务器的返回头中取出 cookie 根据Http请求的客户端不同，获取 cookie 的方式也不同，请自行获取。 123456789101112131415161718/*** 将cookie设置到 WebView* @param url 要加载的 url* @param cookie 要同步的 cookie*/public static void syncCookie(String url,String cookie) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context); &#125; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); /** * cookie 设置形式 * cookieManager.setCookie(url, "key=value;" + "domain=[your domain];path=/;") **/ cookieManager.setCookie(url, cookie);&#125; 删除 Cookie 的方法 12345678910111213141516171819/*** 这个两个在 API level 21 被抛弃* CookieManager.getInstance().removeSessionCookie();* CookieManager.getInstance().removeAllCookie();** 推荐使用这两个， level 21 新加的* CookieManager.getInstance().removeSessionCookies();* CookieManager.getInstance().removeAllCookies();**/public static void removeCookies() &#123; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.removeAllCookie(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; cookieManager.flush(); &#125; else &#123; CookieSyncManager.createInstance(Application.getInstance()); CookieSyncManager.getInstance().sync(); &#125;&#125; 12、如何使 HTML5 video 在 WebView 全屏显示当网页全屏播放视频时会调用 WebChromeClient.onShowCustomView() 方法，所以可以通过将 video 播放的视图全屏达到目的。 1234567891011121314151617181920212223242526272829@Overridepublic void onShowCustomView(View view, CustomViewCallback callback) &#123; if (view instanceof FrameLayout &amp;&amp; fullScreenView != null) &#123; // A video wants to be shown this.videoViewContainer = (FrameLayout) view; this.videoViewCallback = callback; fullScreenView.addView(videoViewContainer, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); fullScreenView.setVisibility(View.VISIBLE); isVideoFullscreen = true; &#125;&#125;@Overridepublic void onHideCustomView() &#123; if (isVideoFullscreen &amp;&amp; fullScreenView != null) &#123; // Hide the video view, remove it, and show the non-video view fullScreenView.setVisibility(View.INVISIBLE); fullScreenView.removeView(videoViewContainer); // Call back (only in API level &lt;19, because in API level 19+ with chromium webview it crashes) if (videoViewCallback != null &amp;&amp; !videoViewCallback.getClass().getName().contains(".chromium.")) &#123; videoViewCallback.onCustomViewHidden(); &#125; isVideoFullscreen = false; videoViewContainer = null; videoViewCallback = null; &#125;&#125; 但是很多的手机版本在网页视频播放时是不会调用这个方法的，所以这个方法局限性很大。 13、Android5.0上 WebView中Http和Https混合问题12345678/*** MIXED_CONTENT_ALWAYS_ALLOW：允许从任何来源加载内容，即使起源是不安全的；* MIXED_CONTENT_NEVER_ALLOW：不允许Https加载Http的内容，即不允许从安全的起源去加载一个不安全的资源；* MIXED_CONTENT_COMPATIBILITY_MODE：当涉及到混合式内容时，WebView 会尝试去兼容最新Web浏览器的风格。**/if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);&#125; 14、如何避免 WebView 的内存泄露问题 可以将 Webview 的 Activity 新起一个进程，结束的时候直接System.exit(0);退出当前进程； 不在xml中定义 WebView，而是在代码中创建，使用 getApplicationgContext() 作为传递的 Conetext； 在 Activity 销毁的时候，将 WebView 置空 1234567891011@Overrideprotected void onDestroy() &#123; if (webView != null) &#123; webView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null); webView.clearHistory(); ((ViewGroup) webView.getParent()).removeView(webView); webView.destroy(); webView = null; &#125; super.onDestroy();&#125; 总结 如果你踩到了 WebView 上的坑，请先默哀一分钟，然后努力找找解决方法吧，总会有人体验过你的悲剧，也会有人重蹈你的覆辙。当然 WebView 里肯定不止我上面列出来的这些问题，如果你有更多的 WebView 问题解决方案欢迎评论交流。]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习指南]]></title>
    <url>%2Fposts%2Fca8423a1.html</url>
    <content type="text"><![CDATA[随着ReactNative、Weex与Flutter等跨端框架的发展，大前端的概念也逐渐普及开来，纯粹的Native开发相对变得比较少，前端也成为了客户端同学必须要掌握的一门技术，但是客户端同学做的是跨端开发，在学习路线上和前端同学又稍有不同，下面从客户端同学的视角去讨论如何学习前端知识。 这里为大家整理了一份跨端技术图谱，这份图谱并没有去穷尽所有的前端技术，只是从客户端开发的视角去梳理常用的技术点，帮助大家理清脉络。 更多关于跨端技术的讨论可以参见BeesHybrid项目。 开发工具IDE推荐VSCode，轻量级、插件丰富，常用插件如下所示： Terminal：命令行工具。 Git History：查看单行提交记录和文件提交记录。 Git Project Manager：Git项目管理工具。 Git Len：解决日常开发协作痛点，推荐安装。 vscode-icons：让你的文件都带上好看的图标。 Path Intellisense：文件路径自动补全。 Auto Close Tag：自动闭合HTML标签。 Baracket Pair Colorizer：成对括号分颜色显示，方便区分。 Settings Sync：同步你的配置和扩展，参见同步教程。 VS Color Picker：取色器。 ES7 React/Redux/GraphQL/React-Native snippets：React代码提示。 Vue 2 Snippets：Vue2代码提示。 更多关于VSCode的使用技巧可以参见强大的VSCode。 前端基础对于客户端同学来说，要想上手React、Vue这些框架，需要先掌握HTML、CSS与JavaScript等基础知识，这部分的内容建议通过书籍来学习 ，一点一滴打捞基础，要有耐心。 HTML书籍：《HTML5权威指南》 CSS书籍：《CSS权威指南》、《精通CSS》 JavaScript书籍：《JavaScript高级程序设计》、《你不知道的Javascript》 除了基础的JavaScript知识，你还需要掌握ES6相关概念，这块可以参考ECMAScript 6 入门。 NPM我们还需要了解NPM相关知识，NPM就像Android里的Maven仓库一样，它是一个JavaScript仓库。 Node.js的包管理工具。 官方文档 NPM新手教程 前端框架Vue Vue.js（读音 /vjuː/，类似于 view 的读音）是一套构建用户界面(user interface)的渐进式框架。 官方文档 awesome-vue Vue.js 2.0 快速上手精华梳理 Vue学习看这篇就够 [译] 从1万篇文章中挑出的40篇最棒的 Vue 学习指南（2018版） React 用于构建用户界面的 JavaScript 库。 官方文档 React.js 小书 React入门教程 揭秘react生态体系 [译] 从1.8万篇文章中脱颖而出45个最棒的 React.js 学习指南（2018版） [译] State of Vue.js report 2017 中文版 跨端框架从PC时代开始，Native与Web就一直是相互竞争、相互融合的关系，我们先来简单看看它们之间的优势与劣势。 Native Web 性能 高 低 用户体验 好 差 功能 可以充分利用平台自身的能力 只有使用W3C的标准能力 迭代 周期长，需要发布 周期短，随时发布 维护成本 高 低 跨平台 差 好 线程 多线程 单线程 可以看出，Native与Web之间各有优劣，在移动互联网发展的过程中，开发者们也一直在寻找融合双方优势的方案，经历了以下四个阶段的发展： Hybrid 1.0：为Web页面提供Naive API的能力，也就是用JS Bridge去增强系统的WebView的功能。缺点是：体验差，如滚动、动画与交互等，稳定性差，如列表内存占用大等。 Hybrid 2.0：将Native组件覆盖在WebView之上，例如微信的cover-view，提供更多的扩展能力。缺点是：用户体验融合性不好，如层级、事件、布局等。 Hybrid 3.0：前端DSL开发，Native渲染，例如React Native与Weex。缺点：对W3C标准能力支持有限，存在平台差异，三端并不完全统一。 Hybrid 4.0：百花齐放的小程序、快应用、轻应用方案，这个容器也有两种：WebView容器与类ReatNative容器。技术方案上并没有太多的花样，这种方案的兴起由微信带起，本质上 还是源于各大公司对于流量入口和生态的竞争。后续我们会着重聊一下。 注：值得一提的是，同层渲染现在已经逐渐在Android和iOS平台的WebView上实现，未来Hybrid会有更多的玩法。 ReactNative 使用JavaScript和React编写原生移动应用. 官方文档 React-Native学习指南 给所有开发者的React Native详细入门指南（第一阶段） Weex Weex是一个基于现代web开发经验构建高性能移动应用程序的框架。 官方文档 awesome-weex WEEX从入门到放肆-图文视频教程（完整版） awesome-weex：Weex 学习与开发资料 Flutter Flutter允许您通过一个代码库在iOS和Android上构建漂亮的本地应用程序。 官方文档 Flutter 开发资源汇总 [译] Awesome Flutter：带你从入门到进阶的 Flutter 指南 小程序小程序也属于跨端框架的范畴，但它与Weex这些框架不同，比起像ReactNative这种技术创新，它更像是一种商业创新，它源于各大巨头对于流量与入口的竞争。详情可参见2018年上半年小程序生态白皮书。 我们先就他们的技术方案做个简单的对比，如下所示： 微信小程序：基于WebView渲染，自建的DSL，与Vue 1.0有点像，不是很好用，后续又出了WePY、mpVue、Taro等DSL。 支付宝小程序：基于WebView与ReactNative两套容器渲染，自建了一套类React的DSL。 快应用：基于Native进行渲染，自己定义了一套类Vue的DSL。 淘宝轻应用：基于WebView与Weex两套容器渲染，自建了一套类Vue的DSL。 事实上，小程序承载的更多是业务形态，我们从业务开发角度对小程序的前端架构做个总结。 微信小程序 小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 官方文档 微信小程序公开课 微信小程序开发资源汇总 支付宝小程序 支付宝小程序是一种全新的开放模式，它运行在支付宝客户端，可以被便捷地获取和传播，为终端用户提供更优的用户体验. 官方文档 支付宝小程序社区 快应用 快应用是基于手机硬件平台的新型应用形态；标准是由主流手机厂商组成的快应用联盟联合制定；快应用标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台；以平台化的生态模式对个人开发者和企业开发者全品类开放。 官方文档 快应用官方开源项目 快应用开发圈资源汇总 小米直达服务介绍与开发实战 淘宝小程序 官方文档 模块化 commonjs AMD(CMD) UMD ES Module 任务管理器 npm scripts grunt gulp 模块打包工具 r.js webpack rollup browserify CSS预处理器 Sass Less Stylus Postcss 静态检查器 flow typescript 测试工具 mocha jasmine jest ava 代码检测工具 eslint jslint 附录资源 前端资源库 前端技能树 前端开发技能树魔兽天赋游戏版 JavaScript算法与数据结构 怎样成长为一个优秀的 Web 前端开发工程师？ 技术栈前端技术从底层到顶层一共可以分为20个，如下所示： 浏览器 渲染引擎、JavaScript引擎 HTML/JavaScript/CSS三支柱 编辑器 编译任务 编译工具 打包、调试、质量 测试 JS基础类库 JS类库 UI框架 CSS预处理器 模板 现代化 安全/模式 中间语言 跨平台解决方案 图片来源]]></content>
      <categories>
        <category>前端</category>
        <category>学习指南</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin常用语法以及注意事项]]></title>
    <url>%2Fposts%2Fa1a08df3.html</url>
    <content type="text"><![CDATA[类型的声明与使用val与varval 不可变引用，var 可变引用。 我们应该尽可能使用val关键字来声明所有的kotlin变量，why？ 首先一个变量在声明时是不可变的，那就代表你在使用的时候不需要考虑其他地方会对它重新赋值和改变(对于对象注意只是引用不可变)，直接使用。 val声明的类型由于必须初始化,它是线程安全的。 kotlin为了保证类型安全，所有变量声明的地方必须要做初始化，即显示赋一个初值。 空与非空kotlin对于可空类型和非空类型认为是两个完全不同的类型，比如Int与Int?,他们俩就不是相同的类型。利用这个特点和编译时检查，kotlin基本可以避免空指针异常。 上面已经说了kotlin的类型声明时必须要有初值，所以空与非空类型和val与var一组合就会变成4种情况，下面我们对一个Person对象进行声明: 1234val p:Person = Person() val p:Person? = null // 这个情况是没有意义的var p:Person = Person() // 如果这个对象是非空类型，那么初始化的时候必须赋一个非null初值var p:Person? = null //可以给一个null,也可以给一个对象实例 上面这段代码基本解释了val与var和空与非空的关系。 空与非空的使用kotlin对空与非空做了严格的限制，那我们在使用时不都要对可空类型类型做判断吗？为了避免这个问题，kotlin提供了许多运算符来使开发人员对于可空与非空编码更加愉快。 安全调用运算符 “?.” 比如我们声明了这样一个类型var p:Person? = null。如果我们直接使用p.name，kotlin编译器是会报错的无法编译通过，所有我们必须这么做: 1if(p != null) p.name 这种代码写多了实在是太没有意义了，所有kotlin提供了?.。上面代码我们可以直接这样代替p?.name。它的实际执行过程是这样的:如果p为空则不操作，如果p不为空则调用p.name。 Elvis 运算符 “?:” 在kotlin中我们会写这种代码: 1val name = if(p != null) p.name else &quot;&quot; //kotlin中的if是一个表达式 不过使用?:可以更简单实现上面的逻辑 : val name = p?.name ?: &quot;&quot; 。 它的实际执行逻辑是如果p为null，p?.name就会为null， ?:会检查前面的结果，如果是null，那么则返回&quot;&quot;。 安全转换 “as?” 在kotlin中类型转换关键字为as。不过类型转换会伴随着转换失败的风险。使用as?我们可以更优雅的写出转换无风险的代码: 12345//Person类中的方法fun equals(o:Any?):Boolean&#123; val otherPerson = o as? Person ?: return false ....&#125; 即as?在转换类型失败时会返回null 非空断言 “!!” 如果使用一个可空类型的方法，并且你不想做非空判断，那么你可以这样做: person!!.getAge()。 不过如果person为null，这里就会抛出空指针异常。 其实还是在蛮多case下可以使用它，但是不建议使用，意难忘你完全可以使用？、？来做更优雅的处理，你也可以使用lateinit来避免编译器的可空提示。 val与bylazy、var与lateinit bylazy 它只能和val一块使用。 123private val mResultView：View = bylazy&#123; initResultView()&#125; 使用bylazy我们可以对一个变量延迟初始化，即懒加载。它是线程安全的。具体原理是:当我们使用bylazy声明的变量时，如果这个变量为null,那么就会调用bylazy代码块来初始化这个变量。 lateinit 它只能和var一块使用，并且不允许修饰可空类型，那它的使用场景是什么呢？ 在有些case下，比如一个构造复杂的对象，我们就是想把变量声明为非空类型并且就是不想给他一个初值(代价太大了),这时候我们就可以使用lateinit : 123456lateinit var p : Person //Person的构造函数太复杂了，不想在这里给一个初值fun refreshUI(p2:Person)&#123; //p = p2 val name = p.name //注意这个地方是可能会抛p为初始化异常的！！！如果你没有初始化&#125; 由于使用lateinit的时候我们要人工保证这个变量已经被初始化，并且kotlin在你每个使用这个变量的地方都会添加一个非null判断。所以lateinit尽量少用。 when 与 ififif在kotlin中不只是一个控制结构它也是一个表达式,即它是有返回结果的，我们可以利用它来代替java中的三目运算符: 1val background = if(isBlcak) R.drawable.black_image else R.drawable.white_image when它的使用方法有多种: 代替switch的功能 1234when(color)&#123; &quot;red&quot;,&quot;green&quot; -&gt;&#123; &#125; &quot;blue&quot;-&gt;&#123; &#125;&#125; kotlin中的when可以用来判断任何对象，它会逐一检查每一个分支，如果满足这个分支的条件就执行。 多条件判断 可以使用when来避免if..elseif..elseif..else的写法: 12345678val a = 1val b = 2when&#123; a &gt; 0 &amp;&amp; b &gt; 0 -&gt;&#123;&#125; a &lt; 0 &amp;&amp; b &gt; 0 -&gt;&#123;&#125; a &lt; 0 &amp;&amp; b &lt; 0 -&gt;&#123;&#125; else -&gt;&#123; &#125;&#125; when是带有返回值的表达式 和if一样，when也是一个表达式: 12345val desColor = when(color)&#123; &quot;red&quot;, &quot;gren&quot; -&gt; &quot;red&amp;green&quot; &quot;blue&quot; -&gt; &quot;blue&quot; else -&gt; &quot;black&quot; // when作为表达式时必须要有else分支。 &#125; 类类的构造与主构造函数 简单的声明一个 javabean 在kotlin中我们可以这样简单的定义一个类: class Person(val name:String = &quot;&quot;, var age:Int = 0) 这样就定义了一个Person类，这个类有两个属性:name和age。并且他有一个两个参数的构造函数来对这两个属性初始化。可以看出kotlin将一个类的声明变的十分方便。 主构造函数 普通的java构造函数是有代码块的，即可以做一些逻辑操作，那按照kotlin上面的方式，我们怎么做构造函数的逻辑操作呢? kotlin提供了初始化代码块: 123456class Person(val name:String = &quot;&quot;, var age:Int = 0)&#123; init&#123; name = &quot;susion&quot; age = 13 &#125;&#125; init代码块会在主构造函数之后运行，注意不是所有的构造函数。 数据类 data class更方便的定义一个javabean，我们可以使用数据类: 1data class Person(val name:String = &quot;&quot;, val age:Int = 0) 使用data定义的Person会默认生成equals、hashCode、toString方法。需要注意的是数据类的属性我们应该尽量定义成val的。这是因为在主构造函数中声明的这些属性都会纳入到equals和hashCode方法中。如果某个属性是可变的， 那么这个对象在被加入到容器后就会是一个无效的状态。 object 和 companion object在kotlin中没有静态方法，也没有静态类。不过kotlin提供了object与companion object object 单例类 使用object我们可以很轻松的创建一个单例类 : 12345678object LoginStatus&#123; var isLogin = false fun login()&#123; isLogin = true &#125; ...&#125; 我们可以这样直接使用LoginStatus.isLogin()。 那这个单例在kotlin中是怎么实现的呢？我们可以反编译看一下它生成的java代码: 123456789101112131415161718public final class LoginStatus &#123; private static boolean isLogin; public static final LoginStatus INSTANCE; // for java调用 ..... //省略不重要的部分 public final void login() &#123; isLogin = true; &#125; private LoginStatus() &#123; INSTANCE = (LoginStatus)this; &#125; static &#123; //类加载的时候构造实例 new LoginStatus(); &#125;&#125; 即kotlin object实现的单例是线程安全的。它的对象是在类创建的时候就产生了。 object的静态方法的使用 上面我们已经知道object创建单例的原理了。这在某些case下就很棒，但是某些时候我们不是想要单例，我们只是想要一些静态方法呢？比如我们经常创建的一些工具类(UIUtils、StringUtils)等。我们可以直接使用object来完成: 123456public object UIUtils&#123; ... ... ... ..很多方法&#125; 按照kotlin单例的设计，我们只要一旦使用这些方法，那么一直有一个单例对象UIUtils存在于内存中。那么这样好吗? 我们是否可以这样写呢 : 123456public class UIUtils&#123; ... ... ... ..很多方法&#125; 然后在使用的时候:UIUtils().dp2Px(1)。这样至少不会有一个对象一直在内存中。我想我们在某些case下可以这样使用我们的工具类。或者你可以使用kotlin的扩展函数或顶层函数来定义一些工具方法。所以对于kotlin的object的使用需要注意。 companion object companion object主要是为了方便我们可以在一个类中创建一些静态方法而存在的，比如: 123456class Person(val name: String) &#123; companion object &#123; fun isMeal(p: Person) = false &#125; &#125; 依旧看一下它反编译后的java代码: 123456789101112131415public final class Person &#123; ... public static final Person.Companion Companion = new Person.Companion((DefaultConstructorMarker)null); .... public static final class Companion &#123; public final boolean isMeal(@NotNull Person p) &#123; Intrinsics.checkParameterIsNotNull(p, &quot;p&quot;); return false; &#125; private Companion() &#123; &#125; ..... &#125;&#125; 即它也是生成了一个单例类Person.Companion。不过这个单例类是一个静态类。不允许构造。不过它的实现机制几乎和object相同。 lambdakotlin中lambda的本质就是可以传递给其他函数的一小段代码。kotlin中lambda使用的最多的就是和集合一块使用。 lambad与java接口 比如我们经常给View设置onClickListener,在kotlin中我们可以很方便的实现这段代码: 123userView.setOnClickListener&#123;&#125; // 如果lambda是函数的最后一个参数，那么是可以放在括号外面的。 即你可以直接传递给它一个lambda。kotlin在实际编译的时候会把这个lambda编译成一个匿名内部类。 那么所有java传对象的地方都可以这样使用吗？ 当然不是, 只有java参数满足下面条件才可以使用: 这个参数是一个接口，并且这个接口只有一个抽象方法。就可以这样使用，比如Runnable、Callable等。 with 与 apply with个人感觉比较鸡肋，这里就不讲它了。不过apply是十分实用的。在kotlin中apply被实现为一个函数: 1public inline fun &lt;T&gt; T.apply(block: T.() -&gt; kotlin.Unit): T &#123; &#125; 即它是一个扩展函数，接收一个lambda，并返回对象本身,并且他是一个内联的函数(下面会讲) 我最常用的一个case是给view设置参数: 123456val tvName = TextView(context).apply&#123; textSize = 10 textColor = xx text = &quot;susion&quot; ...&#125; 常用的库函数内联函数kotlin集合库中很多函数可以接收lambda作为参数。但我们前面说了kotlin的lambda表达式会被编译为一个匿名内部类，即每一次lambda的调用都会创建一个匿名内部类，所以会带来运行时的开销。 kotlin集合库中函数时给我们使用的，如果有这种开销的话，这肯定是一个不好的设计，因此kotlin集合库中的大部分函数都是内联函数。 比如上面的apply声明 : public inline fun &lt;T&gt; T.apply(block: T.() -&gt; kotlin.Unit): T { .... } 何为内联呢？: 当一个函数被声明为inline时，它的函数体是内联的，即函数体会被直接替换到函数被调用的地方。即不会存在运行时开销，下面要说的filter和map都是内联函数。 filter 与 map filter接收一个返回Boolean的lambda，用于对一个集合做筛选工作,并返回一个新集合: 1val wangList = userList.filter&#123;it.firstName == &quot;wang&quot;&#125; map也是接收一个lambda，它的返回值是另一个类型的集合，即map可以把一个类型的集合变成另一个类型的集合。 1val ageList = userList.map&#123; it.age &#125; 这两个函数虽然好用，不过我们要注意他们的实现，以免带来不必要的性能损耗 : filter和map函数都会创建一个新集合，因此如果你是下面这种用法就可能出现不必要的集合创建: 1val wangList = userList.map&#123; it.name &#125;.filter&#123;it == &quot;wang&quot;&#125; 在这种情况下，userList集合非常大的话，那么map操作之后生成的中间集合也可能非常大，对于这种情况可以考虑使用 kotlin序列。 count与find count用于统计集合中满足某个条件的数量，可以对比下面这种写法 123val wangCount= userList.filter&#123;it.firstName == &quot;wang&quot;&#125;.sizeval wangCount2 = userList.count&#123;it.firstName == &quot;wang&quot;&#125; //很明显，这种写法远好于第一种 find用来寻找集合中满足某个case的元素。 具体用法就不写了。 Kotlin的一些优秀的设计思想kotlin是基于java的，不过它在设计摒弃了很多java不好的思想。下面简单列举一些: kotlin中并不区分受检查异常和未受检查异常。即不用指定函数抛出的异常，而且也可以不处理异常 kotlin中类和类的方法默认是final的，即不允许继承和重写。这主要是为了减少继承，避免脆弱基类的问题 kotlin中集合接口分为访问集合数据和修改集合数据。比如kotlin.collections.Collection中就没有修改集合的方法。 kotlin中的函数支持默认参数，避免了多次重写一个函数的情况 kotlin支持扩展函数。它实际上就是某个类的静态方法。 …..]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让hexo的首页只显示文章的部分内容而不是全部]]></title>
    <url>%2Fposts%2Fe778c36e.html</url>
    <content type="text"><![CDATA[Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？目标 &gt; 在网站首页只显示每篇文章的部分内容，不要全部内容都展示出来。解决 &gt; 要解决这个问题有两个方法：一是修改 主题 _config.yml 文件设置，而是直接在你的 md 中加一句代码即可。 第一种方法用文本编辑器打开 themes/ 目录下的对应的主题的theme文件夹下的 _config.yml 文件，找到这段代码，如果没有则新建，可能不同的主题会不支持这种方法： 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。 修改后重启 hexo 就ok了。 第二种方法在你写 md 文章的时候，可以在内容中加上 &lt;!--more--&gt;，这样首页和列表页展示的文章内容就是 &lt;!--more--&gt; 之前的文字，而之后的就不会显示了。 效果 上面两种方式展示出来的效果是不一样的。 第一种修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 …。 而第二种加上 &lt;!--more--&gt;展示出来的就是你原本文章的样式，最后不会有…。 第三种方式在文章的 front-matter 中添加 description，并提供文章摘录 1234567891011---title: 让hexo的首页只显示文章的部分内容而不是全部id: set-hexo-show-more-button-on-indexcategories: - WEB开发date: 2017-09-30 11:01:40tags: - blog - hexodescription: Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？正如你现在看到的本篇文章，只显示到这里。--- 但是使用这种方式生成的描述信息在文章的详情页是不再显示的。 总结各种方式展示的效果各有好处，第二种方法保留了样式而且可以自行选择显示哪些内容来预览，推荐使用此方法，第一种方法显示的每篇文章的预览都是一样的高度，第三种则需要在文章的[front-matter]{https://hexo.io/docs/front-matter.html}里面添加。 综合考虑的话还是建议使用第二种方法，毕竟以后各种插件也能准确的获取到你想要输出的本篇的描述信息。 参考链接： http://www.5isjyx.com/coding/201704/nextreadthefulltext.html http://theme-next.iissnan.com/faqs.html]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudioGit设置忽略文件不生效]]></title>
    <url>%2Fposts%2F40a53d12.html</url>
    <content type="text"><![CDATA[在Android中git提交想忽略某些不想提交的文件，可以在项目目录中新建一个.gitignore，如果没有这个文件，可以手动建一个。里面匹配一下你不想提交的文件。 下面这是Android Studio的忽略规则 1234567891011121314151617181920212223242526272829303132333435363738394041# OSX*.DS_Store# Gradle filesbuild/.gradle/*/build/# IDEA*.iml.idea/.name.idea/encodings.xml.idea/inspectionProfiles/Project_Default.xml.idea/inspectionProfiles/profiles_settings.xml.idea/misc.xml.idea/modules.xml.idea/scopes/scope_settings.xml.idea/vcs.xml.idea/workspace.xml.idea/libraries# Built application files*.apk*.ap_# Files for the Dalvik VM*.dex# Java class files*.class# Generated filesantLauncher/binantLauncher/gen# Local configuration file (sdk path, etc)local.properties# Log Files*.log 规则网上很多，可以自己搜下，或者自己写一个也行。但是当我们提交的时候，却发现这些规则并没有失效，原因就是因为.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 123git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos;]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启你的终端装逼第一步]]></title>
    <url>%2Fposts%2F9253a935.html</url>
    <content type="text"><![CDATA[作为开发人员，和终端的亲密度那肯定不是一般地高，以上便是我打开终端迎面而来的画面，是不是逼格满满，23333，下面来教大家如何在 mac 上配置，其他系统应该也同理。 首先打开终端（这一步要是不会，那老铁你就别配置了吧）。 输入 cd /etc 进入目录。 输入 sudo pico motd,然后输入密码后进入修改页面。 然后在其中输入你想显示的装逼内容，再此提供一个图形界面网站：这是一个神奇的网站，干货满满吧。 最后 control + x，输入 y 保存，重启终端就可以看到逼格满满的欢迎页了。 如下图是我的：]]></content>
      <categories>
        <category>Mac</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>博客</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 性能优化]]></title>
    <url>%2Fposts%2F20aedb71.html</url>
    <content type="text"><![CDATA[数据处理和视图加载分离我们知道，从远端拉取数据肯定是要放在异步的，在我们拉取下来数据之后可能就匆匆把数据丢给了 VH 处理，其实，数据的处理逻辑我们也应该放在异步处理，这样 Adapter 在 notify change 后，ViewHolder 就可以简单无压力地做数据与视图的绑定逻辑，比如： 1mTextView.setText(Html.fromHtml(data).toString()); 这里的 Html.fromHtml(data) 方法可能就是比较耗时的，存在多个 TextView 的话耗时会更为严重，这样便会引发掉帧、卡顿，而如果把这一步与网络异步线程放在一起，站在用户角度，最多就是网络刷新时间稍长一点。 数据优化分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 DiffUtil 来进行局部刷新数据，而不是一味地全局刷新数据。 布局优化减少过渡绘制减少布局层级，可以考虑使用自定义 View 来减少层级，或者更合理地设置布局来减少层级，不推荐在 RecyclerView 中使用 ConstraintLayout，有很多开发者已经反映了使用它效果更差，相关链接有：Is ConstraintLayout that slow?、constraintlayout 1.1.1 not work well in listview。 减少 xml 文件 inflate 时间这里的 xml 文件不仅包括 layout 的 xml，还包括 drawable 的 xml，xml 文件 inflate 出 ItemView 是通过耗时的 IO 操作，尤其当 Item 的复用几率很低的情况下，随着 Type 的增多，这种 inflate 带来的损耗是相当大的，此时我们可以用代码去生成布局，即 new View() 的方式，只要搞清楚 xml 中每个节点的属性对应的 API 即可。 减少 View 对象的创建一个稍微复杂的 Item 会包含大量的 View，而大量的 View 的创建也会消耗大量时间，所以要尽可能简化 ItemView；设计 ItemType 时，对多 ViewType 能够共用的部分尽量设计成自定义 View，减少 View 的构造和嵌套。 其他其他并不代表不重要，而是我不能把他们进行分类哈，其中可能某些操作会对你的 RecyclerView 有很大的优化。 升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能，可参考 RecyclerView 数据预取。 如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout浪费资源； 设置 RecyclerView.addOnScrollListener(listener); 来对滑动过程中停止加载的操作。 如果不要求动画，可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭来提神效率。 对 TextView 使用 String.toUpperCase 来替代 android:textAllCaps=&quot;true&quot;。 对 TextView 使用 StaticLayout 或者 DynamicLayout 的自定义 View 来代替它。 通过重写 RecyclerView.onViewRecycled(holder) 来回收资源。 通过 RecycleView.setItemViewCacheSize(size); 来加大 RecyclerView 的缓存，用空间换时间来提高滚动的流畅性。 如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool。 对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗。 通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示： 123456new LinearLayoutManager(this) &#123; @Override protected int getExtraLayoutSpace(RecyclerView.State state) &#123; return size; &#125;&#125;;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC应用无法打开或文件损坏的处理方法]]></title>
    <url>%2Fposts%2Fef30a8ec.html</url>
    <content type="text"><![CDATA[有些用户下载了一些程序之后，却发现无法在MAC中安装，安装时会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。那么该如何解决这个问题呢？ 在MAC下安装一些软件时提示”来自身份不明开发者”，其实这是MAC新系统启用了新的安全机制。默认只信任 Mac App Store 下载的软件和拥有开发者 ID 签名的应用程序。换句话说就是 MAC 系统默认只能安装靠谱渠道（有苹果审核的 Mac App Store）下载的软件或被认可的人开发的软件。 这当然是为了用户不会稀里糊涂安装流氓软件中招，但没有开发者签名的 “老实软件” 也受影响了，安装就会弹出下图所示警告框：“打不开 xxx，因为它来自身份不明的开发者”。 出现这个问题的解决方法有2种： 最简单的方式：按住Control后，再次点击软件图标，即可。 修改系统配置：系统偏好设置… -&gt; 安全性与隐私。 系统偏好设置 安全性与隐私 认证 修改为任何来源 高能预警！！！！！！！！(专门为不仔细看文章的准备的。。。。。。。没办法，只能放这么大了，要不老有人在评论里面问)如果没有这个选项的话（macOS Sierra 10.12）,打开终端，输入sudo spctl --master-disable然后按回车。然后会看见个password后面还有个钥匙图标，然后不用管他直接再继续输入你自己电脑解锁密码（输入的时候不显示你输入的密码，感觉就是输入不了东西一样，也不用管，凭感觉输入完按回车键）。然后再回到隐私里，就看见任何来源了。 ©软件著作权归作者所有;本站所有软件均来源于网络，仅供学习使用，请支持正版！ 转载请注明出处：精品MAC应用分享 » MAC应用无法打开或文件损坏的处理方法]]></content>
      <categories>
        <category>Mac</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发技巧]]></title>
    <url>%2Fposts%2F56f29aad.html</url>
    <content type="text"><![CDATA[有同学问我，对应用开发你有没有值得注意或小技巧的地方可以分享的。比如适配、优化、排查错误什么的。鸡排把自己的总结笔记整理出来了。供大家参考。 开工准备在项目业务代码开工之前，最好把这些问题都解决掉，否则必将酿成大祸害。它们是： 组件路由 异步处理 组件化模块工程 全局网络拦截器 异常统一处理器 基础视图组件封装 日志记录工具 解决写无数次一模一样代码的模板（如自定义MVP模板） 机型适配特定的机型上出问题时，别着急。我们可以尝试以下几个办法。 反编译rom，看底层改动(条件略高) 联系该厂商的工程师（如果可以的话） 拷贝整个我们调用api的源码进行单独依赖，而放弃系统内的 逆向在该机型上正常的同类app，参考逆向后的代码实现 参考各个版本不同的Android API变化，可以从源码入手进行对 利用反射获取该特定机型上的某个我们想知道的方法，动态调试 排查崩溃闪退日志: 如果app在调试的过程中出现闪退,此时在logcat下日志会被新起来的进程冲刷掉。这时需要把过滤器选择为No filter 把日志级别选为 error即可查看到上一次崩溃的日志。 有一种情况是手机并不在我们身边,我们也无法使用调试工具。此时可以接入一些第三方的日志记录工具。在开发状态下不建议使用友盟 360之类sdk,因为很有可能我们的app根本无法连接到网络就崩溃了。 可以选择把日志存到本地文件中。再又使用手机的人发回来。一般这个人是测试。 如果app未接入任何日志保存工具,可以在data/anr/目录下查看到所有的ANR异常信息。但需要su权限。否则无法访问到。 APP性能体验优化 素材有必要使用压缩后的。推荐熊猫PNG压缩。 资源能用代码画尽量使用代码去画，而不要使用静态资源。 在复杂的布局上,比如很多app的首页需要加载不同类型的item。使用了RecyclerView多类型加载,刷新数据时一定要使用单独对item刷新api。切勿使用notifyitemchanged()方法,这里要用两个参数的notifyItemChanged(1,&quot;gfg&quot;)方法。 数据懒加载，或排队加载 混淆可以使包减小含:(xml 资源 class等) 如果玩得不是很6，尽量不要写静态引用，匿名内部类这种会导致内存泄漏的东西。如果很担心自己失误的写了，一定要去分析它们，把他们揪出来。 Activity的层级不要太深。过深会在低内存设备上被回收栈底的。 建议和技巧 发现某处代码可以复用性的封装一下或者改良一下会更好的时候一定要乘早，不要拖延。（烂泥巴只会越来越烂，后面改=永远没可能） debug编译期间可以把用不到的abi过滤掉，会让我们加速部署。 尽量保持较新的 support library依赖。因为较高的版本中修复了一些bug。 接入第三方包时，最好与自身模块保持独立，做到随时解耦，随便复用。 多个native库依赖时，若发现某些abi上不支持，那么就需要保持最小的abi。否则会给某些机型优先读取它更合适的架构。会造成灾难性的崩溃。如:ARM文件夹中含两个so，ARMv8中只有一个。届时手机优先加载了ARMV8的情况下，将带来找不到so库的崩溃异常。 不要太随性的引入第三方依赖库，如果只是用了很小一部分功能，建议剥出来自己封装。 第三方的包含私有api为暴露时，记得用反射去实现。当然这一切需要我们能翻他们的sdk源码读。也许被混淆了。这时就可以使用动态调试去跟踪。 多数情况下官方的support包比第三方要好得多。只是我们不知道，或者不熟悉。 渐变图、纯色图、带一根线的图用shape，不要静态图。会引发血案！ 当无法通过搜索解决问题的时候，读源码是最快的解决思路。千万不要瞎猜和尝试随缘写代码来解决问题。 封装控件时注意对资源类型做校验如:Image.setImageResource(img);这里的img需要做强校验，类型检测，防止别人用的时候不小心写错了。因为如果我们不主动抛出异常。靠LayoutInflater通过反射去解析xml时提示出了的错误日志非常难看。一般还会伴随一大堆调用栈和闪退出现。 冷启动优化，不要在Application启动时里做过多的任务&amp;第一个Activity里也是一样。最好把初始化的白屏Window设上一张图片过渡一下。 有不妥之处，欢迎指出和补充，拼死挣扎的Android程序员。]]></content>
      <categories>
        <category>Android</category>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 8.0采坑以及解决方法]]></title>
    <url>%2Fposts%2Fb2677b13.html</url>
    <content type="text"><![CDATA[虽然 Android 9.0 都已经面世了，本篇文章写的有点迟了。 但是迟到好过不到，因此基于此这边还是记录一下项目中遇到的 Android 8.0 的坑及对应解决方法。 每次系统升级，虽然系统功能更加强大了，各方面性能也提高了。 但是对于开发者而言，一个困扰的问题也是随之而来——兼容。 尤其对于一些已经上市的 App 而言，在新系统发布之前就要了解到底有哪些改动，以避免用户升级新系统后导致 App 没法正常运行。 好了，回归主题，说说 Android 8.0 里面的几个坑吧。 唤不起系统安装器如果你的 App 提供了更新功能，用户点击更新，你下载完 Apk 之后会自动弹出安装界面。 这个安装界面的弹出就是依赖于系统的安装器。 假设你在 Android 8.0 以下的手机操作正常，但是在 8.0 的手机上，你会发现，下载完之后完全没反应。 假设你以为说弹个提示让用户自己安装，我想说用户才不会理你。用户分分钟就不更新了。 所以说我们要解决这个问题。让这个安装器在 Android 8.0 的手机也能正常唤起。 其实解决方法非常简单。 只需要在 AndroidManifest.xml 中声明以下权限即可。 1&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt; 而且还不需要你在代码动态申请，是不是 So easy。 一行代码解决这个兼容性问题。 通知问题假设你的 App 需要在任务栏显示通知。如果你是按照 Android 8.0 之前的写法的话。那么在 8.0 的手机上面你是显示不了的。 那怎么办呢？ 关于通知的基本写法这边就不再赘余，如果不清楚的小伙伴自行查阅资料。这边重点说下解决方法。 首先说下下面代码出现的几个变量： 123private static NotificationManager manager;public static final String NOTIFICATION_CHANNEL = &quot;your app pkg name&quot;;private static final String NOTIFICATION_CHANNEL_NAME = &quot;App Channel&quot;; 第一个写过通知的都知道，一个管理类。 第二个是通知的一个 CHANNEL，这个也是 8.0 之后才引入的。取值 App 包名即可。 第三个自定义，只要保证唯一即可。 兼容有两步需要操作。 1. 创建Channel12345678910private static void createChannel() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; NotificationChannel notifyChannel = new NotificationChannel(NOTIFICATION_CHANNEL, NOTIFICATION_CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT); notifyChannel.setLightColor(Color.GREEN); notifyChannel.setLockscreenVisibility(Notification.VISIBILITY_PRIVATE); manager.createNotificationChannel(notifyChannel); &#125; &#125; 2. 获取 Notification.Builder1234567private Notification.Builder getNotificationBuilder(Context sourceContext) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; return new Notification.Builder(sourceContext, NOTIFICATION_CHANNEL); &#125; else &#123; return new Notification.Builder(sourceContext); &#125; &#125; 可以看到，上面的操作都以 8.0 作为分界处理。 做完这两步，之前不能显示通知的 App 就可以显示了。 更多内容可以看官方示例： github.com/googlesampl…]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio清理缓存CleanProject与InvalidateCaches]]></title>
    <url>%2Fposts%2Fc7a76d2f.html</url>
    <content type="text"><![CDATA[####Android studio 有时找不到R文件、 导入的资源、布局 、 jar包 等 . 可能是studio 缓存造成的 . 1.使用clean project工具栏 Build –&gt; clean project 2. 使用invalidate caches restart选择工具栏 File –&gt; Invalidate Caches /Restart… -&gt; Invalidate and Restart 重启Android studio]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HexoNext点击搜索一直转圈圈，解决控制字符问题]]></title>
    <url>%2Fposts%2Fb30a2a4e.html</url>
    <content type="text"><![CDATA[1. 环境 macOS Sierra 10.13.6 vscode 1.29.0 最新版 2. 如何重现这个问题在使用中文输入法输入中文的时候，一直按后退键，例如输入sfsf，当你按了4下后退键时，你会发现，搜狗输入法弹出框虽然消失了，但是页面上还会剩下一个s, 这是你如何再次按一下后退的话，s就会变成bs, 变成隐藏字符。这个一般是右边有markdown渲染插件时才会出现。 从更确切的角度说，是你的编辑器一旦开了webview，就会出现这个问题，即使是vscode的欢迎页，也是webview，也会导致这个问题。所以最好在写代码时尽量关闭webview。 3. 如何让隐藏字符现身Mac版的vscode控制字符一般是不会显示出来的，可以用一下的方法让其显示出来 1&quot;editor.renderControlCharacters&quot;: true 在编辑器中显示的像很小的BS, 表示backspace的意思。一般是在输入时，按了后退或者删除会偶尔出现这个字符。 4. 隐藏的控制字符会出现什么问题？4.1. 控制字符在github上会出现问号例如下图的的和同字之间就是出现一个隐藏字符，在github上就会出现一个带有背景的问号。 4.2. 控制字符在Hexo NexT Local Search 会导致search.xml渲染失败，搜索框一直在转圈如果你使用浏览器打开search.xml，会发现解析报错 5. 如何解决5.1. 手动删除隐藏字符可以使用替换，先复制一个隐藏字符，然后把隐藏字符替换成空 5.2. 使用插件 Remove backspace control characterRemove backspace control character 在本家chromium已被合并，因此，在8月上旬发行的vscode 1.15将会重新确定(vscode 1.15, electron 1.7.4)。事实上，到现在这个问题还是没解决的 特点 格式化程序，用于删除打开的文档中包含的控制字符。要被删除的控制字符默认如下。 1/[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm 用法 “editor.formatOnSave”: true 如果被设定,保存时启动 “editor.formatOnType”: true 在被设定的情况下，进行变换时;输入时启动 7. 参考 Mac 上的 VSCode 编写 Markdown 总是出现隐藏字符？ Hexo next 主题的 local search 功能失效，点击搜索链接无法弹出叠加层 Backspace can not erase the last one character during Chinese/Japanese IME conversion (macOS) #24981 Backspace can not erase the last one character during Japanese IME conversion (macOS) #9173 Two backspaces required to delete last character in webview input 控制字符 Using IME with markdown preview enabled, press ESC/BACKSPACE leads in control characters #37114]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同的国家/地区与语言缩写代码]]></title>
    <url>%2Fposts%2Ff8376e8.html</url>
    <content type="text"><![CDATA[国家/地区 语言代码 国家地区 语言代码 简体中文(中国) zh-cn 简体中文(台湾地区) zh-tw 繁体中文(香港) zh-hk 英语(香港) en-hk 英语(美国) en-us 英语(英国) en-gb 英语(全球) en-ww 英语(加拿大) en-ca 英语(澳大利亚) en-au 英语(爱尔兰) en-ie 英语(芬兰) en-fi 芬兰语(芬兰) fi-fi 英语(丹麦) en-dk 丹麦语(丹麦) da-dk 英语(以色列) en-il 希伯来语(以色列) he-il 英语(南非) en-za 英语(印度) en-in 英语(挪威) en-no 英语(新加坡) en-sg 英语(新西兰) en-nz 英语(印度尼西亚) en-id 英语(菲律宾) en-ph 英语(泰国) en-th 英语(马来西亚) en-my 英语(阿拉伯) en-xa 韩文(韩国) ko-kr 日语(日本) ja-jp 荷兰语(荷兰) nl-nl 荷兰语(比利时) nl-be 葡萄牙语(葡萄牙) pt-pt 葡萄牙语(巴西) pt-br 法语(法国) fr-fr 法语(卢森堡) fr-lu 法语(瑞士) fr-ch 法语(比利时) fr-be 法语(加拿大) fr-ca 西班牙语(拉丁美洲) es-la 西班牙语(西班牙) es-es 西班牙语(阿根廷) es-ar 西班牙语(美国) es-us 西班牙语(墨西哥) es-mx 西班牙语(哥伦比亚) es-co 西班牙语(波多黎各) es-pr 德语(德国) de-de 德语(奥地利) de-at 德语(瑞士) de-ch 俄语(俄罗斯) ru-ru 意大利语(意大利) it-it 希腊语(希腊) el-gr 挪威语(挪威) no-no 匈牙利语(匈牙利) hu-hu 土耳其语(土耳其) tr-tr 捷克语(捷克共和国) cs-cz 斯洛文尼亚语 sl-sl 波兰语(波兰) pl-pl 瑞典语(瑞典) sv-se 西班牙语 (智利) es-cl]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android组件化，完全解耦]]></title>
    <url>%2Fposts%2Fd7e6359d.html</url>
    <content type="text"><![CDATA[目前,Android 组件化普遍使用于移动开发,但是组件化的初衷是为了解耦代码,并行开发效率;小型app似乎会care不到,完全解耦的组件化会在app越来越臃肿的时候带来很大的提升; 1.组件化介绍ok,那么我们需要知道完全解耦的组件化框架应该注意哪些点: 主app只加载业务组件,不可调用组件;组件与组件之间不存在调用关系;这样无论是主app和业务组件都是完全独立,完全解耦的; 主app和组件都依赖common组件,通过common的注册和分发实现组件之间的交互,这个common我们姑且叫做业务主线 android中page使用common下层接口和路由进行实现(在本框架中,ARouter实现Activity跳转,ARouter-Interceptor实现Activity跳转的拦截;Fragment通过common下沉注册分发实现Fragment的填充) 每一个组件应当是一个app可单独编译:Library和Application之间转化使用gradle配置相应的Manifest和applicationId 2.单独编译组件化配置(gradle)依赖关系 App 依赖common Home/Login/News 依赖common common 依赖component-base 2.1. 首先在整个工程的gradle.properties中配置组件 Library/Application切换的开关: 123isRunLogin = false //login组件isRunHome = false //home组件isRunNews = false //news组件 2.2. 由于android中Library(组件)/Application切换时的差异,需要单独配置主见以home组件为例:首先开build.gradle: 12345678910111213141516171819202122232425//注释1: 配置切换application/Library的打包if (isRunHome.toBoolean())&#123; apply plugin: &apos;com.android.application&apos;&#125;else&#123; apply plugin: &apos;com.android.library&apos;&#125;android &#123; ....... sourceSets &#123; //注释2: Library/Application切换 AndroidManifest main &#123; if (isRunLogin.toBoolean())&#123; manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; &#125;else&#123; manifest.srcFile &apos;src/main/manifest/AndroidManifest.xml&apos; &#125; &#125; &#125; ......&#125;...... 注释1: 切换application/Libaray的打包配置 注释2: Application为单独编译,需要有applicationId,并且主Activity需要配置main属性;Libaray为集成编译,组件不能有applicationId,且不可以设置启动的main Activity下面看集成编译(Library)和单独编译(Application)的Manifest配置: 123456789//集成编译,打包为Library&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="component.android.com.home"&gt; &lt;application android:theme="@style/home_AppTheme"&gt; &lt;activity android:name=".view.activity.HomeActivity"/&gt; &lt;/application&gt;&lt;/manifest&gt; 12345678910111213141516171819202122//单独编译,打包为单独Application 可单独编译&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="component.android.com.home"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:name=".global.HomeApp" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/home_AppTheme"&gt; &lt;activity android:name=".view.activity.HomeActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 3.组件之间activity跳转(Actiivity跳转)3.1. 组件之间的activity跳转,这里使用ARouter ARouter是阿里开源的一种页面跳转task 首先看ARouter在build.gralde的配置: 12345678910111213141516171819202122//主app build.gradle......dependencies &#123; ...... androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2' &#125;//home/login/news 组件 build.gradledependencies &#123; ........ annotationProcessor 'com.alibaba:arouter-compiler:1.1.4'&#125;//common build.gradledependencies &#123; ...... api 'com.alibaba:arouter-api:1.3.1' // arouter-compiler 的注解依赖需要所有使用 ARouter 的 module 都添加依赖 annotationProcessor 'com.alibaba:arouter-compiler:1.1.4'&#125; 3.2 在app和各组件中进行page跳转 首先是ARouter的初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MainApplication extends BaseApp &#123; @Override public void onCreate() &#123; super.onCreate(); //在主app中初始化ARouter initRouter(); initMoudleApp(this); initMoudleData(this); &#125; private void initRouter() &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); &#125; @Override public void initMoudleApp(Application application) &#123; for (String moduleApp : AppConfig.moduleApps) &#123; try &#123; Class clazz = Class.forName(moduleApp); BaseApp baseApp = (BaseApp) clazz.newInstance(); baseApp.initMoudleApp(this); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void initMoudleData(Application application) &#123; for (String moduleApp : AppConfig.moduleApps) &#123; try &#123; Class clazz = Class.forName(moduleApp); BaseApp baseApp = (BaseApp) clazz.newInstance(); baseApp.initMoudleData(this); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//组件中 home--HomeApplicationpublic class HomeApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 这里需要注意一下 当集成编译时候 ,组件仅仅是一个组件,不会单独具备Applicagtion入口,所以需要在主app的MainApplication中利用反射的方式 initMoudleData/initMoudleData进行ARouter等初始化的配置; 下面看ARouter的跳转实例: 123456789//app/MainActivity....private void initClick() &#123; findViewById(R.id.btn_nav_home).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ARouter.getInstance().build("/home/homeActivity").navigation() &#125;&#125; 在app中实现跳转,但是这个 path/home/homeActivity需要在home组件目标位置添加注解才能实现activity的跳转: 123456789@Route(path = "/myhome/homeActivity")public class HomeActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_home); &#125;&#125; 这样 就成功实现类组件之间的activity的跳转; 4.组件之间的逻辑交互App点击跳转home,须判断登录逻辑: 1.登录则跳转home组件的homeActivity 2.未登录则跳转login组件的loginActivity,点击登录,再重复以上逻辑这样 主app,home和login就实现了一个简单的交互逻辑首先开component: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//ILoginServicepublic interface ILoginService &#123; boolean getLoginStatus(); int getLoginUserId();&#125;//DefultLoginServicepublic class DefultLoginService implements ILoginService &#123; @Override public boolean getLoginStatus() &#123; return false; &#125; @Override public int getLoginUserId() &#123; return 0; &#125;&#125;//ComponentServiceFactorypublic class ComponentServiceFactory &#123; ...... public static ComponentServiceFactory getInstance(Context context)&#123; if (instance == null)&#123; synchronized (ComponentServiceFactory.class)&#123; if (instance == null)&#123; instance = new ComponentServiceFactory(); &#125; &#125; &#125; return instance; &#125; private ILoginService loginService; public void setLoginService(ILoginService iloginService)&#123; loginService = iloginService; &#125; public ILoginService getLoginService()&#123; if (loginService == null)&#123; loginService = new DefultLoginService(); &#125; return loginService; &#125;&#125; 然后在login中通过common的ComponentServiceFactory注册对应的loginService 12345678910111213141516171819202122232425262728293031323334//LoginServicepublic class LoginService implements ILoginService &#123; @Override public boolean getLoginStatus() &#123; return AccountUtils.getInstance().isAccountStatus(); &#125; @Override public int getLoginUserId() &#123; return 0; &#125;&#125;//Login组件LoginApp注册service........public class LoginApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; Log.i("LoginApp","initMoudleApp"); if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); ComponentServiceFactory.getInstance(this).setLoginService(new LoginService()); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 在App-MainActivity中跳转homeActivity,在home组件中使用ARouter的拦截器: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//app-mainActivityprivate void initClick() &#123; findViewById(R.id.btn_nav_home).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ARouter.getInstance().build("/home/homeActivity").navigation(MainActivity.this, new NavCallback() &#123; //ARouter拦截器的监听 @Override public void onArrival(Postcard postcard) &#123; LogUtils.LogI("loginInterceptor","done"); &#125; @Override public void onFound(Postcard postcard) &#123; //super.onFound(postcard); LogUtils.LogI("loginInterceptor","found"); &#125; @Override public void onLost(Postcard postcard) &#123; //super.onLost(postcard); LogUtils.LogI("loginInterceptor","lost"); &#125; @Override public void onInterrupt(Postcard postcard) &#123; //super.onInterrupt(postcard); LogUtils.LogI("loginInterceptor","interrupt"); &#125; &#125;); &#125; &#125;); &#125;//home-HomeInterceptor@Interceptor(priority = 1,name = "homeInterceptor")public class HomeInterceptor implements IInterceptor &#123; private Context context; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; switch (postcard.getPath())&#123; case "/myhome/homeActivity": //通过component进行逻辑交互 if (ComponentServiceFactory.getInstance(context).getLoginService().getLoginStatus())&#123; callback.onContinue(postcard); &#125;else &#123; ARouter.getInstance().build("/login/loginActivity").navigation(); //callback.onInterrupt(new RuntimeException("请登录")); //callback.onContinue(postcard); &#125; break; default: callback.onContinue(postcard); break; &#125; &#125; @Override public void init(Context context) &#123; this.context = context; &#125;&#125;//login-loginInterceptor@Interceptor(priority = 2,name = "loginInterceptor")public class LoginInterceptor implements IInterceptor &#123; private Context context; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; switch (postcard.getPath())&#123; case "/login/loginActivity": LogUtils.LogI("loginInterceptor","请点击登录按钮"); callback.onContinue(postcard); break; default: callback.onContinue(postcard); //在每一个组件中添加一个navi的拦截器 逻辑在 &#125; &#125; @Override public void init(Context context) &#123; this.context = context; &#125;&#125; 1.在跳转homeActivity时,跳转到home组件的homeInterceptor拦截器 2.在homeInterceptor中通过component获取login注册的lohginservice来获取登录状态,实现下一步跳转 可以看到 app 通过ARouter跳home home通过component的注册分发,判断登录逻辑 进行下一步跳转;这样就实现了不依赖其他组件的逻辑交互 5.组件化fragment解耦在android中我们使用最多的就是fragment,一般情况下 我们会实例化fragment再进行下一步逻辑;为了解耦我们在component中注册fragment接口,在相应组件中注册fragmentservice,在其他组件中实现分发: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//component-LoginFragmentServicepublic class LoginFragmentService implements IFragmentService &#123; @Override public Fragment getFragment(String tag) &#123; return new LginHomeFragment(); &#125; @Override public void newFragment(Activity activity, int resId, FragmentManager fragmentManager, Bundle bundle, String tag) &#123; FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.add(resId,new LginHomeFragment(),tag); transaction.commit(); &#125;&#125;//component-ComponentServiceFactorypublic class ComponentServiceFactory &#123; private static volatile ComponentServiceFactory instance; private IFragmentService newsFragmentService; private IFragmentService homeFragmentService; private IFragmentService loginFragmentService; public static ComponentServiceFactory getInstance(Context context)&#123; if (instance == null)&#123; synchronized (ComponentServiceFactory.class)&#123; if (instance == null)&#123; instance = new ComponentServiceFactory(); &#125; &#125; &#125; return instance; &#125;........ //主册fragmentservice入口 public void setHomeFragmentService(IFragmentService iFragmentService)&#123; homeFragmentService = iFragmentService; &#125; public void setLoginFragmentService(IFragmentService iFragmentService)&#123; loginFragmentService = iFragmentService; &#125; public void setNewsFragmentService(IFragmentService iFragmentService)&#123; newsFragmentService = iFragmentService; &#125; public IFragmentService getNewsFragmentService() &#123; return newsFragmentService; &#125; public IFragmentService getHomeFragmentService() &#123; return homeFragmentService; &#125; public IFragmentService getLoginFragmentService() &#123; return loginFragmentService; &#125;&#125; 在home组件中进行fragmentservice的注册工作: 1234567891011121314151617181920//home-HomeApppublic class HomeApp extends BaseApp &#123; @Override public void initMoudleApp(Application application) &#123; if (BuildConfig.DEBUG)&#123; //打印日志 ARouter.openLog(); ARouter.openDebug(); &#125; ARouter.init(this); ComponentServiceFactory.getInstance(this).setHomeFragmentService(new HomeFragmentService()); &#125; @Override public void initMoudleData(Application application) &#123; &#125;&#125; 在App中调用: 1234567// app-MainActivity:private void initBaseView() &#123; FragmentManager supportFragmentManager = getSupportFragmentManager(); ComponentServiceFactory.getInstance(this) .getHomeFragmentService().newFragment(this,R.id.content,supportFragmentManager,null,null); &#125; 这样一个home组件中的homeFragment就加载到主app的xml中同理组件之间的fragment引用亦如此注意框架中component-IFragmentService实现了两个方法: 12345//获取目标的fragment来进行操作 Fragment getFragment(String tag); //用于固定的区域来填充相应fragment void newFragment(Activity activity, int resId, FragmentManager fragmentManager, Bundle bundle, String tag); getFragment(String tag);为获取目标fragment接口,获取到实例之后开发者自己实现fragment相关逻辑 newFragment(...);适用于在布局中静态添加fragment,一步到位 当然框架中还有部分限制组件资源的gradle配置,有兴趣可以在github下载demo]]></content>
      <categories>
        <category>Android</category>
        <category>组件化</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Handler消息机制学习]]></title>
    <url>%2Fposts%2F7a63eeca.html</url>
    <content type="text"><![CDATA[1.概述 Handler允许你发送和处理Message，以及和线程相关联的Runnable对象。每一个Handler实例都与一个线程及该线程的MessageQueue相关联。既当你创建一个Handler时，该Handler必须绑定一个线程以及该线程的消息队列，一旦它被创建，它能把messages和runnables传送到message queue，并在它们从message queue中出来的时候执行它们。 Handler主要有两个主要用途： 在未来的某个时间点调度messages和runnables的执行 将要在不同线程上执行的操作加入队列 当你的应用程序被创建出来的时候，主线程会专门运行一个message queue来管理最顶级的应用对象(如activities, broadcast receivers，等等)以及它们创建的任何其它窗口。你可以创建你自己的线程，通过Handler来与主线程建立联系 2.源码分析2.1 MessageQueue-消息队列 MessageQueue是一个通过Looper分发它持有的消息列表的低层级类。Messages没有直接添加到MessageQueue中，而是通过与Looper相关联的Handler对象。 Message-消息 该类实现了Parcelable接口，你可以把它看作一个数据类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849** * * Defines a message containing a description and arbitrary data object that can be * sent to a &#123;@link Handler&#125;. This object contains two extra int fields and an * extra object field that allow you to not do allocations in many cases. * 定义包含描述和任意数据对象的消息 * 发送到Handler。这个对象包含两个额外的int字段和一个 * 额外的对象字段，允许您在很多情况下不进行分配。 * &lt;p class="note"&gt;While the constructor of Message is public, the best way to get * one of these is to call &#123;@link #obtain Message.obtain()&#125; or one of the * &#123;@link Handler#obtainMessage Handler.obtainMessage()&#125; methods, which will pull * them from a pool of recycled objects.&lt;/p&gt; * 注意：不要直接使用New Message()创建Message对象，最好的方式是通过Handler.obtainMessage() * 方法，它会从对象回收池中拉取该消息对象 */public final class Message implements Parcelable &#123; /** @hide */ public static final Object sPoolSync = new Object(); /** * Return a new Message instance from the global pool. Allows us to * avoid allocating new objects in many cases. * 从全局池返回一个新的消息实例。让我们在很多情况下避免分配新对象。 */ public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; ** * Same as &#123;@link #obtain()&#125;, but sets the value for the target member on the Message returned. * 与obtain()相同，但在返回的消息上设置目标成员的值。 * @return A Message object from the global pool. * 返回来自全局池的消息对象 */ public static Message obtain(Handler h) &#123; Message m = obtain(); m.target = h;//接收传递过来的Handler return m; &#125;&#125; 2.2 Looper-消息轮询器 Looper用于为线程轮询messages。线程默认是没有与之相关联的Lopper，我们必须通过Looper.prepare()方法去创建它。示例： 123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; ThreadLocal提供线程的局部变量，通过它访问线程独立初始化变量的副本。即Looper通过ThreadLocal类来与当前线程进行交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//私用构造方法//quitAllowed是否允许退出private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);//实例化消息队列 mThread = Thread.currentThread();//获取当前线程&#125;/** Initialize the current thread as a looper.* This gives you a chance to create handlers that then reference* this looper, before actually starting the loop. Be sure to call* &#123;@link #loop()&#125; after calling this method, and end it by calling* &#123;@link #quit()&#125;.* 初始化当前线程的Looper* 在它准备轮询之前，给你一个时机点去创建一个Handler并引用它* 调用该方法后一定记得Looper.loop()方法，并结束的时候调用Looper.quit()方法退出*/public static void prepare() &#123; prepare(true);&#125;// sThreadLocal.get() will return null unless you have called prepare().//必须先调用Looper.prepare()方法，否则返回空static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();private static void prepare(boolean quitAllowed) &#123; //每一个线程只能有唯一的一个looper if (sThreadLocal.get() != null) &#123;//不为空抛出异常 throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));//设置Looper&#125;/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. * 返回与当前线程关联的looper */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125;/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. * 在当前线程运行消息队友 */public static void loop() &#123; final Looper me = myLooper();//获取looper if (me == null) &#123;//为空则抛出异常 throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue;//获取looper的消息队列 // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. //确保这个线程的标识是本地进程的标识， //并跟踪身份令牌的实际情况。 Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0); boolean slowDeliveryDetected = false; for (;;) &#123;//无限轮询 Message msg = queue.next(); // might block if (msg == null) &#123; //没有message则不往下执行 // No message indicates that the message queue is quitting. return; &#125; ***省略代码*** final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; try &#123; msg.target.dispatchMessage(msg);//调用Handler的dispatchMessage(msg)方法 dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; //回收可能正在使用的消息。 //在处理消息队列时，MessageQueue和Looper在内部使用。 msg.recycleUnchecked(); &#125;&#125;//sThreadLocal.get()public T get() &#123; Thread t = Thread.currentThread();//通过Thread的静态方法获取当前的线程 //ThreadLocalMap是一个定制的HashMap(),仅适用于维护线程局部值,每一个线程都持有一个ThreadLocalMap对象 ThreadLocalMap map = getMap(t);//传入当前线程获取当前线程的ThreadLocalMap对象-------------------------------------------------------------------------------————————————— ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;-------------------------------------------------------------------------------————————————— if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 2.3 Handler2.3.1 创建Handler对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. * 如果你不想通过继承Handler来实现，你必须实现Callback接口 */public interface Callback &#123; /** * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */ public boolean handleMessage(Message msg);&#125;//默认构成器//如果该Handler所绑定的线程没有looper，它将收不到任何messages，并且会抛出异常public Handler() &#123; this(null, false);&#125;//默认构造器的Callback为空，所以当我们通过new Handler()来创建实例时，//我们必须重写Handler的handleMessage(Message msg)方法，即：companion object &#123;//注意写成静态内部类的形式，避免内存泄漏 private class MyHandler :Handler()&#123; override fun handleMessage(msg: Message?) &#123; super.handleMessage(msg) &#125; &#125;&#125;-------------------------------------------------------------------------------—————————————//主动实现Callback接口，来创建Handler实例public Handler(Callback callback) &#123; this(callback, false);&#125; companion object &#123; private val mHandler1:Handler = Handler(object :Handler.Callback&#123; override fun handleMessage(msg: Message?): Boolean &#123; return true &#125; &#125;) 或 private val mHandler2:Handler = Handler(Handler.Callback &#123; true &#125;)&#125;-------------------------------------------------------------------------------————————————— /** * Use the provided &#123;@link Looper&#125; instead of the default one. * * @param looper The looper, must not be null. * //不使用默认的looper */public Handler(Looper looper) &#123; this(looper, null, false);&#125;//之前我看到某些前辈是通过下面这种方式来创建Handler实例，通过传递主线程的looper//但这是没必要的，Handler默认就是使用主线程的looper(下面会分析)//并且源码注释也说了，使用你自己的提供的looper而不是默认的private val mHandler:Handler = object :Handler(Looper.getMainLooper())&#123; override fun handleMessage(msg: Message?) &#123; super.handleMessage(msg) &#125;&#125;-------------------------------------------------------------------------------—————————————//该构造同上，如果你不想重写handleMessage(msg: Message?)方法，那么你就重写Callback接口public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125;//是否需要异步处理messages，默认是异步的public Handler(boolean async) &#123; this(null, async);&#125;//自己提供looper，实现Callback接口，决定是否异步public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125;-------------------------------------------------------------------------------—————————————/* * Set this flag to true to detect anonymous, local or member classes * that extend this Handler class and that are not static. These kind * of classes can potentially create leaks. * 将此标志设置为true以检测匿名类、本地类或成员类 * 继承了Handler不是静态的，可能存在内存泄漏 */private static final boolean FIND_POTENTIAL_LEAKS = false;//通过Handler()、Handler(Callback callback)、Handler(boolean async)//都会调用该构造器public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123;//检查可能存在的内存泄漏，默认是false final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper();//获取looper if (mLooper == null) &#123;//如果为空抛出异常 throw new RuntimeException( "Can't create handler inside thread " + Thread.currentThread() + " that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue;//获取Looper中的消息队列 mCallback = callback; mAsynchronous = async;&#125;private static void handleCallback(Message message) &#123; message.callback.run();//执行Message持有的Runnable&#125;/** * Handle system messages here. * 处理系统Messages */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123;//如果Message的Runnable不为空 handleCallback(msg);调用Handler的handleMessage(msg)方法处理Message &#125; else &#123; if (mCallback != null) &#123;//如果Handler的Callback不为空 if (mCallback.handleMessage(msg)) &#123;//调用Callback的handleMessage(msg)方法 return; &#125; &#125; //否则调用Handler的handleMessage(msg)方法 handleMessage(msg); &#125;&#125; 2.3.2 创建Message对象1234567891011121314151617181920public final Message obtainMessage()&#123; return Message.obtain(this);&#125;public final Message obtainMessage(int what)&#123; return Message.obtain(this, what);&#125;public final Message obtainMessage(int what, Object obj)&#123; return Message.obtain(this, what, obj);&#125;public final Message obtainMessage(int what, int arg1, int arg2)&#123; return Message.obtain(this, what, arg1, arg2);&#125;public final Message obtainMessage(int what, int arg1, int arg2, Object obj)&#123; return Message.obtain(this, what, arg1, arg2, obj);&#125; 2.3.3 发送Message123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * Causes the Runnable r to be added to the message queue. * The runnable will be run on the thread to which this handler is * attached. * 将Runnable添加到消息队列中。 * runnable将在此Handler所在的线程上运行。 * * @return Returns true if the Runnable was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. * Runnable成功添加到消息队列中返回ture，失败返回false */public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain();创建Message对象 m.callback = r;把Runnale传递给Message return m;&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123;//延迟时间小于0，则置为0 delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;//延迟发送public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;public final boolean postDelayed(Runnable r, Object token, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r, token), delayMillis);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this;//把当前的Handler传递给Message的Handler if (mAsynchronous) &#123;//是否异步 msg.setAsynchronous(true); &#125; //最终调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis);&#125;MessageQueue：boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123;//Message的Handler为空，抛出异常 throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123;//Message正在使用，抛出异常 throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123;//判断是否退出 IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle();//回收Message return false; &#125; msg.markInUse();设置Message是否正在使用的Flag msg.when = when; Message p = mMessages; boolean needWake;//是否需要唤醒 if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. //插入到队列的中间。通常我们不需要唤醒 //启动消息队列，除非队列头部有阻碍 //消息是队列中最早的异步消息。 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123;//开启无限轮询 prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; ###]]></content>
      <categories>
        <category>Android</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARouter路由框架]]></title>
    <url>%2Fposts%2Fa9949862.html</url>
    <content type="text"><![CDATA[1一个用于帮助 Android App 进行组件化改造的框架 —— 支持模块间的路由、通信、解耦 Demo展示Demo apk下载、Demo Gif一、什么是路由说简单点就是映射页面跳转关系的，当然它也包含跳转相关的一切功能。 二、为什么需要路由Android系统已经给我们提供了api来做页面跳转，比如startActivity，为什么还需要路由框架呢？我们来简单分析下路由框架存在的意义： 在一些复杂的业务场景下（比如电商），灵活性比较强，很多功能都是运营人员动态配置的，比如下发一个活动页面，我们事先并不知道具体的目标页面，但如果事先做了约定，提前做好页面映射，便可以自由配置。 随着业务量的增长，客户端必然随之膨胀，开发人员的工作量越来越大，比如64K问题，比如协作开发问题。App一般都会走向组件化、插件化的道路，而组件化、插件化的前提就是解耦，那么我们首先要做的就是解耦页面之间的依赖关系。 简化代码。数行跳转代码精简成一行代码。 其他… 三、为什么需要路由ARouter是阿里巴巴开源的Android平台中对页面、服务提供路由功能的中间件，提倡的是简单且够用。GitHub：https://github.com/alibaba/ARouter 四、功能介绍 支持直接解析标准URL进行跳转，并自动注入参数到目标页面中 支持多模块工程使用 支持添加多个拦截器，自定义拦截顺序 支持依赖注入，可单独作为依赖注入框架使用 支持InstantRun 支持MultiDex(Google方案) 映射关系按组分类、多级管理，按需初始化 支持用户指定全局降级与局部降级策略 页面、拦截器、服务等组件均自动注册到框架 支持多种方式配置转场动画 支持获取Fragment 完全支持Kotlin以及混编(配置见文末 其他) 支持第三方 App 加固(使用 arouter-register 实现自动注册) 支持生成路由文档 五、典型应用 从外部URL映射到内部页面，以及参数传递与解析 跨模块页面跳转，模块间解耦 拦截跳转过程，处理登陆、埋点等逻辑 跨模块API调用，通过控制反转来做组件解耦 六、基础功能 添加依赖和配置 1234567891011121314151617181920android &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName()] &#125; &#125; &#125;&#125;dependencies &#123; // 替换成最新版本, 需要注意的是api // 要与compiler匹配使用，均使用最新版可以保证兼容 compile &apos;com.alibaba:arouter-api:x.x.x&apos; annotationProcessor &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125;// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末&apos;其他#4&apos;// Kotlin配置参考文末&apos;其他#5&apos; 添加注解 123456// 在支持路由的页面上添加注解(必选)// 这里的路径需要注意的是至少需要有两级，/xx/xx@Route(path = "/test/activity")public class YourActivity extend Activity &#123; ...&#125; 初始化SDK 12345if (isDebug()) &#123; // 这两行必须写在init之前，否则这些配置在init过程中将无效 ARouter.openLog(); // 打印日志 ARouter.openDebug(); // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)&#125;ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化 发起路由操作 123456789// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)ARouter.getInstance().build("/test/activity").navigation();// 2. 跳转并携带参数ARouter.getInstance().build("/test/1") .withLong("key1", 666L) .withString("key3", "888") .withObject("key4", new Test("Jack", "Rose")) .navigation(); 添加混淆规则(如果使用了Proguard) 123456789-keep public class com.alibaba.android.arouter.routes.**&#123;*;&#125;-keep public class com.alibaba.android.arouter.facade.**&#123;*;&#125;-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe&#123;*;&#125;# 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider# 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现# -keep class * implements com.alibaba.android.arouter.facade.template.IProvider 使用 Gradle 插件实现路由表的自动加载 1234567891011apply plugin: &apos;com.alibaba.arouter&apos;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &quot;com.alibaba:arouter-register:?&quot; &#125;&#125; 可选使用，通过 ARouter 提供的注册插件进行路由表的自动加载(power by AutoRegister)， 默认通过扫描 dex 的方式进行加载通过 gradle 插件进行自动注册可以缩短初始化时间解决应用加固导致无法直接访问dex 文件，初始化失败的问题，需要注意的是，该插件必须搭配 api 1.3.0 以上版本使用！ 七、进阶用法 通过URL跳转1234567891011// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可public class SchameFilterActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Uri uri = getIntent().getData(); ARouter.getInstance().build(uri).navigation(); finish(); &#125;&#125; AndroidManifest.xml 12345678910111213&lt;activity android:name=".activity.SchameFilterActivity"&gt; &lt;!-- Schame --&gt; &lt;intent-filter&gt; &lt;data android:host="m.aliyun.com" android:scheme="arouter"/&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;category android:name="android.intent.category.BROWSABLE"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 解析URL中的参数 123456789101112131415161718192021222324252627282930313233343536373839404142// 为每一个参数声明一个字段，并使用 @Autowired 标注// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象@Route(path = "/test/activity")public class Test1Activity extends Activity &#123; @Autowired public String name; @Autowired int age; @Autowired(name = "girl") // 通过name来映射URL中的不同参数 boolean boy; @Autowired TestObj obj; // 支持解析自定义对象，URL中使用json传递 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); // ARouter会自动对字段进行赋值，无需主动获取 Log.d("param", name + age + boy); &#125;&#125;// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：@Route(path = "/yourservicegroupname/json")public class JsonServiceImpl implements SerializationService &#123; @Override public void init(Context context) &#123; &#125; @Override public &lt;T&gt; T json2Object(String text, Class&lt;T&gt; clazz) &#123; return JSON.parseObject(text, clazz); &#125; @Override public String object2Json(Object instance) &#123; return JSON.toJSONString(instance); &#125;&#125; 声明拦截器(拦截跳转过程，面向切面编程) 123456789101112131415161718// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行@Interceptor(priority = 8, name = "测试用拦截器")public class TestInterceptor implements IInterceptor &#123; @Override public void process(Postcard postcard, InterceptorCallback callback) &#123; ... callback.onContinue(postcard); // 处理完成，交还控制权 // callback.onInterrupt(new RuntimeException("我觉得有点异常")); // 觉得有问题，中断路由流程 // 以上两种至少需要调用其中一种，否则不会继续路由 &#125; @Override public void init(Context context) &#123; // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次 &#125;&#125; 处理跳转结果 123456789101112// 使用两个参数的navigation方法，可以获取单次跳转的结果ARouter.getInstance().build("/test/1").navigation(this, new NavigationCallback() &#123; @Override public void onFound(Postcard postcard) &#123; ... &#125; @Override public void onLost(Postcard postcard) &#123; ... &#125;&#125;); 自定义全局降级策略 12345678910111213// 实现DegradeService接口，并加上一个Path内容任意的注解即可@Route(path = "/xxx/xxx")public class DegradeServiceImpl implements DegradeService &#123; @Override public void onLost(Context context, Postcard postcard) &#123; // do something. &#125; @Override public void init(Context context) &#123; &#125;&#125; 为目标页面声明更多信息 1234// 我们经常需要在目标页面中配置一些属性，比方说"是否需要登陆"之类的// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断@Route(path = "/test/activity", extras = Consts.XXXX) 通过依赖注入解耦:服务管理(一) 暴露服务 12345678910111213141516171819// 声明接口,其他组件通过接口来调用服务public interface HelloService extends IProvider &#123; String sayHello(String name);&#125;// 实现接口@Route(path = "/yourservicegroupname/hello", name = "测试服务")public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return "hello, " + name; &#125; @Override public void init(Context context) &#123; &#125;&#125; 通过依赖注入解耦:服务管理(二) 发现服务 12345678910111213141516171819202122232425262728public class Test &#123; @Autowired HelloService helloService; @Autowired(name = "/yourservicegroupname/hello") HelloService helloService2; HelloService helloService3; HelloService helloService4; public Test() &#123; ARouter.getInstance().inject(this); &#125; public void testService() &#123; // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务) helloService.sayHello("Vergil"); helloService2.sayHello("Vergil"); // 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType helloService3 = ARouter.getInstance().navigation(HelloService.class); helloService4 = (HelloService) ARouter.getInstance().build("/yourservicegroupname/hello").navigation(); helloService3.sayHello("Vergil"); helloService4.sayHello("Vergil"); &#125;&#125; 八、更多功能 初始化中的其他设置 123ARouter.openLog(); // 开启日志ARouter.openDebug(); // 使用InstantRun的时候，需要打开该开关，上线之后关闭，否则有安全风险ARouter.printStackTrace(); // 打印日志的时候打印线程堆栈 详细的API说明 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 构建标准的路由请求ARouter.getInstance().build("/home/main").navigation();// 构建标准的路由请求，并指定分组ARouter.getInstance().build("/home/main", "ap").navigation();// 构建标准的路由请求，通过Uri直接解析Uri uri;ARouter.getInstance().build(uri).navigation();// 构建标准的路由请求，startActivityForResult// navigation的第一个参数必须是Activity，第二个参数则是RequestCodeARouter.getInstance().build("/home/main", "ap").navigation(this, 5);// 直接传递BundleBundle params = new Bundle();ARouter.getInstance() .build("/home/main") .with(params) .navigation();// 指定FlagARouter.getInstance() .build("/home/main") .withFlags(); .navigation();// 获取FragmentFragment fragment = (Fragment) ARouter.getInstance().build("/test/fragment").navigation(); // 对象传递ARouter.getInstance() .withObject("key", new TestObj("Jack", "Rose")) .navigation();// 觉得接口不够多，可以直接拿出Bundle赋值ARouter.getInstance() .build("/home/main") .getExtra();// 转场动画(常规方式)ARouter.getInstance() .build("/test/activity2") .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom) .navigation(this);// 转场动画(API16+)ActivityOptionsCompat compat = ActivityOptionsCompat. makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);// ps. makeSceneTransitionAnimation 使用共享元素的时候，需要在navigation方法中传入当前ActivityARouter.getInstance() .build("/test/activity2") .withOptionsCompat(compat) .navigation(); // 使用绿色通道(跳过所有的拦截器)ARouter.getInstance().build("/home/main").greenChannel().navigation();// 使用自己的日志工具打印日志ARouter.setLogger();// 使用自己提供的线程池ARouter.setExecutor(); 获取原始的URI 1String uriStr = getIntent().getStringExtra(ARouter.RAW_URI); 重写跳转URL 123456789101112131415161718192021// 实现PathReplaceService接口，并加上一个Path内容任意的注解即可@Route(path = "/xxx/xxx") // 必须标明注解public class PathReplaceServiceImpl implements PathReplaceService &#123; /** * For normal path. * * @param path raw path */ String forString(String path) &#123; return path; // 按照一定的规则处理之后返回处理后的结果 &#125; /** * For uri type. * * @param uri raw uri */ Uri forUri(Uri uri) &#123; return url; // 按照一定的规则处理之后返回处理后的结果 &#125;&#125; 生成路由文档 123456789101112// 更新 build.gradle, 添加参数 AROUTER_GENERATE_DOC = enable// 生成的文档路径 : build/generated/source/apt/(debug or release)/com/alibaba/android/arouter/docs/arouter-map-of-$&#123;moduleName&#125;.jsonandroid &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [AROUTER_MODULE_NAME: project.getName(), AROUTER_GENERATE_DOC: &quot;enable&quot;] &#125; &#125; &#125;&#125; 九、其他 路由中的分组概念 SDK中针对所有的路径(/test/1 /test/2)进行分组，分组只有在分组中的某一个路径第一次被访问的时候，该分组才会被初始化 可以通过 @Route 注解主动指定分组，否则使用路径中第一段字符串(/*/)作为分组 注意：一旦主动指定分组之后，应用内路由需要使用 ARouter.getInstance().build(path, group) 进行跳转，手动指定分组，否则无法找到1@Route(path = "/test/1", group = "app") 拦截器和服务的异同 拦截器和服务所需要实现的接口不同，但是结构类似，都存在 init(Context context) 方法，但是两者的调用时机不同 拦截器因为其特殊性，会被任何一次路由所触发，拦截器会在ARouter初始化的时候异步初始化，如果第一次路由的时候拦截器还没有初始化结束，路由会等待，直到初始化完成。 服务没有该限制，某一服务可能在App整个生命周期中都不会用到，所以服务只有被调用的时候才会触发初始化操作 旧版本gradle插件的配置方式 1234567891011121314151617181920212223apply plugin: &apos;com.neenbedankt.android-apt&apos;buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.4&apos; &#125;&#125;apt &#123; arguments &#123; AROUTER_MODULE_NAME project.getName(); &#125;&#125;dependencies &#123; compile &apos;com.alibaba:arouter-api:x.x.x&apos; apt &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125; Kotlin项目中的配置方式 1234567891011121314// 可以参考 module-kotlin 模块中的写法apply plugin: &apos;kotlin-kapt&apos;kapt &#123; arguments &#123; arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName()) &#125;&#125;dependencies &#123; compile &apos;com.alibaba:arouter-api:x.x.x&apos; kapt &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125; 十、Q&amp;A “W/ARouter::: ARouter::No postcard![ ]” 这个Log正常的情况下也会打印出来，如果您的代码中没有实现DegradeService和PathReplaceService的话，因为ARouter本身的一些功能也依赖 自己提供的Service管理功能，ARouter在跳转的时候会尝试寻找用户实现的PathReplaceService，用于对路径进行重写(可选功能)，所以如果您没有 实现这个服务的话，也会抛出这个日志 推荐在app中实现DegradeService、PathReplaceService “W/ARouter::: ARouter::There is no route match the path [/xxx/xxx], in group [xxx][ ]” 通常来说这种情况是没有找到目标页面，目标不存在 如果这个页面是存在的，那么您可以按照下面的步骤进行排查 检查目标页面的注解是否配置正确，正确的注解形式应该是 (@Route(path=”/test/test”), 如没有特殊需求，请勿指定group字段，废弃功能) 检查目标页面所在的模块的gradle脚本中是否依赖了 arouter-compiler sdk (需要注意的是，要使用apt依赖，而不是compile关键字依赖) 检查编译打包日志，是否出现了形如 ARouter:Compiler &gt;&gt;&gt; xxxxx 的日志，日志中会打印出发现的路由目标 启动App的时候，开启debug、log(openDebug/openLog), 查看映射表是否已经被扫描出来，形如 D/ARouter::: LogisticsCenter has already been loaded, GroupIndex[4]，GroupIndex &gt; 0 开启InstantRun之后无法跳转(高版本Gradle插件下无法跳转)？​ 因为开启InstantRun之后，很多类文件不会放在原本的dex中，需要单独去加载，ARouter默认不会去加载这些文件，因为安全原因，只有在开启了openDebug之后 ARouter才回去加载InstantRun产生的文件，所以在以上的情况下，需要在init之前调用openDebug TransformException:java.util.zip.ZipException: duplicate entry …. ARouter有按组加载的机制，关于分组可以参考 6-1 部分，ARouter允许一个module中存在多个分组，但是不允许多个module中存在相同的分组，会导致映射文件冲突 Kotlin类中的字段无法注入如何解决？ 首先，Kotlin中的字段是可以自动注入的，但是注入代码为了减少反射，使用的字段赋值的方式来注入的，Kotlin默认会生成set/get方法，并把属性设置为private 所以只要保证Kotlin中字段可见性不是private即可，简单解决可以在字段上添加 @JvmField 通过URL跳转之后，在intent中拿不到参数如何解决？ 需要注意的是，如果不使用自动注入，那么可以不写 ARouter.getInstance().inject(this)，但是需要取值的字段仍然需要标上 @Autowired 注解，因为 只有标上注解之后，ARouter才能知道以哪一种数据类型提取URL中的参数并放入Intent中，这样您才能在intent中获取到对应的参数 新增页面之后，无法跳转？ ARouter加载Dex中的映射文件会有一定耗时，所以ARouter会缓存映射文件，直到新版本升级(版本号或者versionCode变化)，而如果是开发版本(ARouter.openDebug())， ARouter 每次启动都会重新加载映射文件，开发阶段一定要打开 Debug 功能]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram与VirtualView]]></title>
    <url>%2Fposts%2Fb1fd08a9.html</url>
    <content type="text"><![CDATA[VirtualViewTangram中已经实现了页面布局的动态化，我们可以通过配置json文件自由的布局；但还有一个局限性，json中使用的卡片或者组件的type，必须是注册OK的（也就是在客户端已经实现好的）才能使用；如果想要在原来的版本中新增一个type类型的组件，这是没有办法做到的，还是只能通过升级客户端来实现。 于是，VirtualView出现了。 基布局描术文件是一个xml文件，并附带一个json数据文件:描述布局文件示例：（其中的相关数据来源都可以从数据json文件中使用表达式获取） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 &lt;RatioLayout orientation="H" layoutWidth="match_parent" layoutHeight="wrap_content" background="#f8f8f8"&gt; &lt;VHLayout layoutRatio="1" orientation="V" layoutWidth="0" layoutHeight="match_parent" background="#f8f8f8"&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="120.5" scaleType="fit_xy" src="$&#123;picture_2&#125;"/&gt; &lt;VLine layoutWidth="match_parent" layoutHeight="0.5" paintWidth="0.5" orientation="H" color="#e8ecef" /&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="60" scaleType="fit_xy" src="$&#123;picture_5&#125;"/&gt; &lt;/VHLayout&gt; &lt;VLine layoutWidth="0.5" layoutHeight="match_parent" paintWidth="0.5" orientation="V" color="#e8ecef" /&gt; &lt;VHLayout layoutRatio="1" orientation="V" layoutWidth="0" layoutHeight="match_parent" background="#f8f8f8"&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="60" scaleType="fit_xy" src="$&#123;picture_3&#125;"/&gt; &lt;VLine layoutWidth="match_parent" layoutHeight="0.5" paintWidth="0.5" orientation="H" color="#e8ecef" /&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="60" scaleType="fit_xy" src="$&#123;picture_4&#125;"/&gt; &lt;VLine layoutWidth="match_parent" layoutHeight="0.5" paintWidth="0.5" orientation="H" color="#e8ecef" /&gt; &lt;VImage layoutWidth="match_parent" layoutHeight="60" scaleType="fit_xy" src="$&#123;picture_6&#125;"/&gt; &lt;/VHLayout&gt;&lt;/RatioLayout&gt; 数据json文件示例： 1234567&#123; "picture_2": "http://xxxx/images/59afb155c769f.png", "picture_3": "http://xxxx/images/59afb303042ca.png", "picture_4": "http://xxxx/images/59afb303042cb.png", "picture_5": "http://xxxx/images/59afb36cf1eb8.png", "picture_6": "http://xxxx/images/59afb303042cd.png"&#125; xml文件需要经过编绎生成目标文件才可加载使用，如果用于项目中一般下发的都是经过编绎后的文件，也可以在客户端实时编绎。 一个xml就是一个组件，Tangram通过加载这个xml文件即可使用该xml文件所描术的组件，从而实现了动态新增组件类型的功能。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tragram Android使用指南]]></title>
    <url>%2Fposts%2F37457476.html</url>
    <content type="text"><![CDATA[具体组件可以查看官方文档：http://tangram.pingguohe.net/docs/android/access-tangram 接入Tangram代码1.引入依赖12// gradlecompile &apos;com.alibaba.android:tangram:1.0.0@aar&apos; 或者 1234567// maven&lt;dependency&gt; &lt;groupId&gt;com.alibaba.android&lt;/groupId&gt; &lt;artifactId&gt;tangram&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;type&gt;aar&lt;/type&gt;&lt;/dependency&gt; 2.初始化 Tangram 环境应用全局只需要初始化一次，提供一个通用的图片加载器，一个应用内通用的ImageView类型（通常情况下每个应用都有自定义的 ImageView，如果没有的话就提供系统的 ImageView 类）。 12345678TangramBuilder.init(context, new IInnerImageSetter() &#123; @Override public &lt;IMAGE extends ImageView&gt; void doLoadImageUrl(@NonNull IMAGE view, @Nullable String url) &#123; //假设你使用 Picasso 加载图片 Picasso.with(context).load(url).into(view); &#125;&#125;, ImageView.class); 3.初始化 TangramBuilder在 Activity 中初始化TangramBuilder，假设你的 Activity 是TangramActivity。 1TangramBuilder.InnerBuilder builder = TangramBuilder.newInnerBuilder(TangramActivity.this); 这一步 builder 对象生成的时候，内部已经注册了框架所支持的所有组件和卡片，以及默认的IAdapterBuilder（它被用来创建 绑定到 RecyclerView 的Adapter）。 4.注册自定义的卡片和组件1234567//TangramBuilder中已经预先注册了许多组件及卡片，可直接使用；此处只需要注册自定义的组件及卡片即可builder = TangramBuilder.newInnerBuilder(this);builder.registerCell("自定义名字1", 自定义组件1.class);builder.registerCell("自定义名字2", 自定义组件2.class);builder.registerCard("自定义名字3", 自定义卡片3.class);builder.registerCell(数字, 自定义组件4.class);builder.registerVirtualView("VirtualView名字");//Tangram对VirtualView的支持 一般情况下，内置卡片的类型已经满足大部分场景了，业务方主要是注册一下自定义组件。注册组件有3种方式： 注册绑定组件类型和自定义View，比如builder.registerCell(1, TestView.class);。意思是类型为1的组件渲染时会被绑定到TestView的实例上，这种方式注册的组件使用通用的组件模型BaseCell。 注册绑定组件类型、自定义 model、自定义View，比如builder.registerCell(1, TestCell.class, TestView.class);。意思是类型为1的组件使用自定义的组件模型TestCell，它应当继承于BaseCell，在渲染时会被绑定到TestView的实例上。 注册绑定组件类型、自定义model、自定义ViewHolder，比如builder.registerCell(1, TestCell.class, new ViewHolderCreator&lt;&gt;(R.layout.item_holder, TestViewHolder.class, TestView.class));。意思是类型为1的组件使用自定义的组件模型TestCell，它应当继承于BaseCell，在渲染时以R.layout.item_holder为布局创建类型为TestView的 view，并绑定到类型为TestViewHolder的 viewHolder 上，组件数据被绑定到定到TestView的实例上。 一般情况下，使用前两种方式注册组件即可。至于组件开发规范，请参考组件开发。 5.生成TangramEngine实例在上述基础上调用： 1TangramEngine engine = builder.build(); 6.绑定业务 support 类到 engineTangram 内部提供了一些常用的 support 类辅助业务开发，业务方也可以自定义所需要的功能模块注册进去。以下常用三个常用的support，分别处理点击、卡片数据加载、曝光逻辑，详情请参考文档。 123engine.register(SimpleClickSupport.class, new XXClickSupport());engine.register(CardLoadSupport.class, new XXCardLoadSupport());engine.register(ExposureSupport.class, new XXExposureSuport()); 7.绑定 recyclerView1234setContentView(R.layout.main_activity);RecyclerView recyclerView = (RecyclerView) findViewById(R.id.main_view);...engine.bindView(recyclerView); 8.监听 recyclerView 的滚动事件12345678recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); //在 scroll 事件中触发 engine 的 onScroll，内部会触发需要异步加载的卡片去提前加载数据 engine.onScrolled(); &#125;&#125;); 9.设置悬浮类型布局的偏移（可选）如果你的 recyclerView 上方还覆盖有其他 view，比如底部的 tabbar 或者顶部的 actionbar，为了防止悬浮类 view 和这些外部 view 重叠，可以设置一个偏移量。 1engine.getLayoutManager().setFixOffset(0, 40, 0, 0); 10.设置卡片预加载的偏移量（可选）在页面滚动过程中触发engine.onScrolled()方法，会去寻找屏幕外需要异步加载数据的卡片，默认往下寻找5个，让数据预加载出来，可以修改这个偏移量。 1engine.setPreLoadNumber(3) 11.加载数据并传递给 engine数据一般是调用接口加载远程数据，这里演示的是 mock 加载本地的数据： 12345678String json = new String(getAssertsFile(this, "data.json")); JSONArray data = null; try &#123; data = new JSONArray(json); engine.setData(data); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; 12.退出的时候销毁 engine1engine.destroy(); 通过主动调用 destroy 方法，可以释放内部的资源，比如清理 adapter、清理事件总线缓存的未处理消息、注销广播等。注意调用 destroy 方法之后就不需要调用 unbind 方法了。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 TAC 上使用 Tangram4 TAC SDK]]></title>
    <url>%2Fposts%2F1365aa6d.html</url>
    <content type="text"><![CDATA[背景Tangram 客户端 SDK 对后端数据格式有标准化的需求，而后端接口格式千千万万，总不会是每个接口格式都能如你所愿，Tangram4TAC 就是为了解决这种问题构建，以标准化模型来在 TAC 在构建一个 Tangram 页面。 SDK 介绍 一期 SDK 非常简单，尽量精简抽象，主要提供了 Tangram 组件模型的定义和默认的数据转换输出服务（称之为 render）。如上图所示，橘色部分为 SDK 提供的核心模型对象，Cell 是组件定义，Container 是容器定义，Style 是样式定义。浅绿色部分为 Tangram 内置的布局类型组件定义。白色部分为业务自定义组件，不集成在 SDK 内部，用户可以自己扩展任意部分来实现自己的组件 model 对象。 Cell、Container、Style 的属性定义也是按照现有 Tangram 的规范来定义，业务字段需要用户自己继承对应的类来扩展。 当我们用这些模型对象构建好 Tangram 组件树之后，就需要对外输出数据，一般情况下对外输出的不是原始的对象，可能是需要转换成 JSON 或者 Map 对象，过程中还需要对字段进行一些处理。SDK 内提供了几个辅助工具： @FieldExcluder 注解：model 内部可能会有一些用来保存状态，传递上下文信息的字段，并不需要最终输出属性，通过此注解将这些属性在转换过程中过滤掉，减少冗余数据。 @FieldNameMapper 注解：默认情况下，我们期望 model 内部的属性定义名和输出字段名一致，但也有存在不兼容的情况，比如 Style 里的背景色字段要求按照 CSS 的规范输出 background-color 属性名，而 JAVA 的变量名不支持这种规范，所以可以通过该注解提供一个别名，比如： 12@FieldNameMapper(key = &quot;background-color&quot;)protected String backgroundColor; SDK 默认的 render 类 DefaultRender 遵循上述原则，并将 Cell 对象转换成 Map 结构。用户也可以提供自定义的 render 对象给 Cell 更改转换逻辑。 举例说明上述就是 SDK 的核心功能，非常的精简，下面用一个例子说明使用流程。以天猫首页 icon 区改造为例。 1.实现一个 TmallCell 继承自 Cell，内部封装天猫客户端环境下扩展的公共业务字段。 12345678910111213141516171819202122232425262728293031323334353637abstract public class TmallCell&lt;T extends Style&gt; extends Cell&lt;T&gt; &#123; protected String action; protected String title; protected String imgUrl; public TmallCell() &#123; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getImgUrl() &#123; return imgUrl; &#125; public void setImgUrl(String imgUrl) &#123; this.imgUrl = imgUrl; &#125; public String getAction() &#123; return action; &#125; public void setAction(String action) &#123; this.action = action; &#125;&#125; 2.实现 Icon 继承自 TmallCell，封装 icon 自身的数据。 12345678910111213141516171819202122232425262728293031323334353637public class Icon extends TmallCell&lt;IconStyle&gt; &#123; private String title; private String imgUrl; private String bizId; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getImgUrl() &#123; return imgUrl; &#125; public void setImgUrl(String imgUrl) &#123; this.imgUrl = imgUrl; &#125; public String getBizId() &#123; return bizId; &#125; public void setBizId(String bizId) &#123; this.bizId = bizId; &#125; @Override public String getType() &#123; return &quot;icon&quot;; &#125;&#125; 3.实现 IconStyle 继承自 Style，封装 icon 自身的特有样式属性。 123456789101112public class IconStyle extends Style &#123; protected String titleColor; public String getTitleColor() &#123; return titleColor; &#125; public void setTitleColor(String titleColor) &#123; this.titleColor = titleColor; &#125;&#125; 4.调用接口获取业务数据后，准备构造组件树，先构造布局容器对象，设置样式，提供一个默认的 render 对象。 12345678910FiveColumnContainer fiveColumnContainer = new FiveColumnContainer();fiveColumnContainer.setId(&quot;icon&quot;);FlowStyle style = new FlowStyle();style.setBackgroundColor(&quot;#FFFFFF&quot;);style.setPadding(6, 12, 11, 12);style.setMargin(-80, 0, -26, 0);style.setCols(new float[]&#123;10.1f, 102.1f&#125;);style.sethGap(6);style.setzIndex(5);fiveColumnContainer.setStyle(style); 5.根据数据构造 Icon 组件对象，并设置样式和属性。 1234567891011121314for (int i = 0; i &lt; 5; i++) &#123; IconStyle iconStyle = new IconStyle(); iconStyle.setTitleColor(&quot;#FF0000&quot;); if (i == 1) &#123; iconStyle.setDisableReuse(true); &#125; Icon icon = new Icon(); icon.setStyle(iconStyle); icon.setId(String.valueOf(i)); icon.setTitle(&quot;icon_&quot; + i); icon.setImgUrl(&quot;https://gw.alicdn.com/tfs/TB1ISdWSFXXXXbFXXXXXXXXXXXX-146-147.png&quot;); icon.setAction(&quot;https://www.tmall.com/&quot;); fiveColumnContainer.addChild(icon);&#125; 6.调用 render 方法输出数据返回给 TAC。 12Map&lt;String, Object&gt; result = (Map&lt;String, Object&gt;) fiveColumnContainer.render();resultList.add(result); 上述流程总结起来如图：]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件的动态化方案-Tangram2.0]]></title>
    <url>%2Fposts%2F270f0900.html</url>
    <content type="text"><![CDATA[Tangram 2.0 库Android Tangram-Android Virtualview-Android iOS Tangram-iOS Virtualview-iOS 背景技术背景一直以来，无线应用都在不断寻求动态化页面的解决方案，在阿里巴巴集团内，除了风风火火地 Weex 项目外，各个团队都有大大小小的解决方案。我们猫客一直持续基于 Tangram 方案来解决页面动态化的问题，然而在面对持续升级的业务需求时，原有的开发模式也慢慢变得无法胜任，本年度以来，我们 Tangram 体系在各个层面都进行了大跨度的技术升级（可参考文章天猫APP改版之首页架构&amp;开发模式全面升级），本文再详细介绍一下页面内组件体系升级方案。 老组件体系的问题在原有的 Tangram 体系里，主要解决了页面内布局结构的动态化能力，通过 json 数据描述可以组合出常用的页面结构。然而页面内具体的坑位样式，我们称之为业务组件，是采用常规的 native 代码开发的，除非内置了足够多的逻辑，否则组件的样式调整或者新组件的开发都要发布版本，无法满足业务节奏；当然我们也尝试过使用 Weex 开发业务组件贴到页面上，但是在体验和性能上还是有较大的缺陷。 所以总结起来，就是两点问题： 业务组件无法动态更新； 现有的动态组件方案较重，影响性能和体验； 解决之道对于上述问题，解决思路其实是比较通用的，要动态更新界面视图，就需要用界面模板描述视图，模板与数据分离。将动态下发的模板和数据在端上绑定渲染。要提升性能，也有三大着力点——减少视图层级与个数，结构尽量扁平化；异步布局渲染流程，解放主线程计算量；回收与复用组件，减少内存开销。 新的组件体系就是在模板化描述视图，动态更新视图，减少视图层级几个方面做文章，至于组件的回收复用，则是在页面级别统一完成；而异步布局渲染流程，则是后续的优化方向。 新的组件方案称之为 VirtualView，简称 VV，也称为2.0组件，它的设计遵循以下几个思路： 以了一种虚拟化开发基础组件的技术，使用方只要按照指定协议实现一个基础组件的尺寸计算、绘制逻辑、布局逻辑，即能实现在宿主容器的 canvas 里实现直接绘制 UI 内容的，让最终渲染出来的视图结构呈现扁平化，提升组件渲染性能。同时为了解决虚拟化 View 带来的原生 View 的能力损失的问题，它支持加载和渲染原生基础组件，两者组合产生合力，既能减少开销，又能满足特殊场景下的业务需求。 内置实现了一系列基础组件，可以让使用方直接上手尝试；而搭建业务组件的方式采用 XML 模板来编写，配套 XML 模板更新 sdk，这使得业务组件动态更新成为了可能。XML 模板里还支持写数据绑定的表达式，在样式动态化、数据动态化的场景下能非常方便地实现业务需求。 XML 模板里涉及到的基础节点、属性、字符串资源等都被提前编译成二进制资源，客户端加载通过加载编译后的模板数据来创建视图。 设计方案整体架构先从整体上预览一下整个方案的大体结构： 自下往上，自左往右的顺序介绍各个模块： 基础模板加载器负责加载编译后的模板数据，比如从文件加载、从二进制数组加载、从网络加载，将编译后的二进制模板数据加载到内存里，通过组件加载器、字符串资源加载器、表达式资源加载器等提取出其中的资源。 框架还内置了基础组件，包括原子的基础组件如文本、图片、线条，还包括布局类型的基础组件，比如线性布局、帧布局、网格布局等；每一种类型的基础组件提供了原生 Native 版本的实现和虚拟化的实现，用户也可以自定义自己的基础组件注册到框架内部，组件构造器通过加载好的组件数据，来构造出整个业务组件树，并添加到宿主容器里，对于虚拟组件，会在渲染阶段绘制到宿主容器的 canvas 上，而原生组件会作为子 View 添加到宿主容器里。 框架内部也提供了基础的表达式能力，主要分两种，一种是简单的数据绑定表达式，一种是简单的逻辑表达式；前者用于在模板里写表达式绑定数据到基础组件的属性上，而后者提供了一种轻量级的逻辑运算能力，可以访问基础组件的属性并更新，实现一些联动效果。 事件管理，本方案聚焦于界面的动态化创建，但对业务逻辑的处理主要还是靠原生的代码实现，因此处理组件的一些常用交互事件，比如组件的点击、长按、触摸、曝光事件等。事件管理模块负责将外部的各个类型的事件处理模块注册进来，当组件发生特定的事件时，找到对应类型的处理模块来调用处理。 宿主容器管理负责对虚拟组件的宿主容器进行构建和回收复用的管理。当原有的组件滑出屏幕后，可以回收到统一的池子里，以便后续复用。 组件管理负责对基础组件进行构建和回收复用管理。当原有的组件滑出屏幕后，除了宿主容器可以回收复用，内部的基础组件对象也可以回收到统一的池子里。如果组件的池子是空的，则在需要的时候构造新的组件。 扩展模块管理则用于注册外部功能扩展模块，当内置的基础能力无法满足业务场景的时候，通过扩展模块注册特定的功能模块，然后编写自定义基础组件来实现特定功能。 模板存储、模板校验、模板更新、模板注册则分别负责模板数据的存储、安全性校验、版本校验、与更新检查与新模板下载、注册模板数据到框架，整体协同来完成业务组件的动态更新，它并不与整个渲染组件的核心框架耦合，可以作为独立模块存在。 配套的工具和服务主要包括模板编写工具、模板编译工具、模板更新服务.模板编写工具用于 XML 的模板的编辑，并调用编译模块编译模板，模板里涉及到的组件资源、字符串资源、表达式资源会分别用对应的模块处理。编译后端模板数据可以上传到模板更新服务里，客户端调用相应的接口检查是否有更新。 运行流程有了上述基础，当我们要开发新的业务组件的时候，除了有新增 Native 逻辑的需求场景（比如新增视频功能），大部分需求都可以告别原生代码的编写，转而编写组件模板。 先编写业务组件的模板。 通过工具将模板数据编译成二进制数据。 客户端加载二进制数据可以有两种路径，一是直接打包到客户端里，写代码加载，另一种是发布到模板管理后台，客户端在线更新到模板数据。 不论哪种方式加载二进制数据，客户端接下来的工作是解析二进制数据里，比如校验版本号，合法性，读取头信息等等。 等要真正创建组件的时候，根据组件名称找到二进制数据，从中解析并创建出真正的组件模型数据。 从模板里创建在组件往往不含有业务数据，因为业务数据是动态性的，用户需要获取到业务数据绑定到组件上，组件的属性里可以写表达式来指定使用哪一个数据字段。 值得注意的是，在上述架构及流程里，描述了一个完整的实践经验，但对于本方案来说，核心点在于提供了对组件从编写到展示流程的实现，其周边的配套设施，并没有内置在框架里，包括客户端上的模板管理、更新、注册模块，以及后端的模板发布服务，因为这些模块往往涉及业务逻辑，且与各个应用的基础设施相关，内置在框架里反而限制了使用方的接入。这里提供一些可供参考的经验： 模板管理后台要能对模板的进行发布、更新，并且按照客户端版本、平台、组件版本、生效优先级等几个维度来管理模板； 模板文件可以存放到 CDN 上供客户端下载，管理平台只是对比下发远信息；下载文件要做足够的校验； 客户端要内置一份打底的模板数据，这样不至于因为模板不存在而出现空窗； 客户端可提供一个统一的模板管理模块，面向全应用提供服务，在合适的时候请求管理平台检查有没有更新，比如启动、用户刷新、推送指令的到达，并且负责下载、文件校验、通知页面刷新等功能；页面刷新可以做优先级区分，比如高优先级的模板更新主动去刷新下页面，而低优先级的可以等二次进入页面或者刷新页面的时候生效； 几个核心设计组件的基础模型对于组件，我们做了如下定义，每一个基础的原子组件或者容器组件都会有以下属性，自定义的基础组件应当继承自基础定义并做扩展。 名称 类型 默认值 描述 id int 0 组件id layoutWidth int/float/enum(match_parent/wrap_content) 0 组件的布局宽度，与Android里的概念类似，写绝对值的时候表示绝对宽高，match_parent表示尽可能撑满父容器提供的宽高，wrap_content表示根据自身内容的宽高来布局 layoutHeight int/float/enum(match_parent/wrap_content) 0 组件的布局宽度，与Android里的概念类似，写绝对值的时候表示绝对宽高，match_parent表示尽可能撑满父容器提供的宽高，wrap_content表示根据自身内容的宽高来布局 layoutGravity enum(left/right/top/bottom/v_center/h_center) left|top 描述组件在容器中的对齐方式，left：靠左，right：靠右，top：靠上，bottom：靠底，v_center：垂直方向居中，h_center：水平方向居中，可用或组合描述 autoDimX int/float 1 组件宽高比计算的横向值 autoDimY int/float 1 组件宽高比计算的竖向值 autoDimDirection enum(X/Y/NONE) NONE 组件在布局中的基准方向，用于计算组件的宽高比，与autoDimX、autoDimY配合使用，设置了这三个属性时，在计算组件尺寸时具有更高的优先级。当autoDimDirection=X时，组件的宽度由layoutWidth和父容器决策决定，但高度 = width * (autoDimY / autoDimX)，当autoDimDirection=Y时，组件的高度由layoutHeight和父容器决策决定，但宽度 = height * (autoDimX / autoDimY) minWidth int/float 0 最小宽度 minHeight int/float 0 最小高度 paddingLeft int/float 0 左内边距 paddingRight int/float 0 右内边距 paddingTop int/float 0 上内边距 paddingBottom int/float 0 下内边距 layoutMarginLeft int/float 0 左外边距 layoutMarginRight int/float 0 右外边距 layoutMarginTop int/float 0 上外边距 layoutMarginBottom int/float 0 下外边距 background int 0 背景色 backgroundImage string null 背景图地址 borderWidth int 0 边框宽度 borderColor int 0 边框颜色 visibility enum(visible/invisible/gone) visible 可见性，与Android里的概念类似，visible：可见，invisible：不可见，但占位，gone：不可见也不占位 gravity enum(left/right/top/bottom/v_center/h_center) left|top 描述内容的对齐，比如文字在文本组件里的位置、原子组件在容器里的位置，left：靠左，right：靠右，top：靠上，bottom：靠底，v_center：垂直方向居中，h_center：水平方向居中，可用或组合描述 方案内内置了一系列基础组件，完整的组件列表如下： 虚拟文本组件 原生文本组件 虚拟图片组件 原生图片组件 虚拟线条组件 原生线条组件 虚拟进度条组件 虚拟图形组件 原生翻页布局容器组件 原生滚动布局容器组件 虚拟帧布局容器组件 虚拟比例布局容器组件 虚拟网格布局容器组件 原生网格布局容器组件 虚拟线性布局容器组件 原生线性布局容器组件 虚拟组件上文提到虚拟化开发的组件的技术，简称虚拟组件。很多做性能优化的方案、建议都会提到采用 Canvas 直接绘制的方式来减少 View 的个数，虚拟将这个开发流程做了抽象与规范，可以让开发人员像定义原生组件一样定义虚拟组件。 具体来讲，基础组件需要遵循一个接口的规范，这个口定义了渲染过程中需要的三个流程：计算尺寸阶段、布局阶段、绘制阶段；定义这个三个阶段是为了更好的与系统平台特别是 Android 平台对接，因为在 Android 原生平台下也会有这个三个阶段，在 iOS 平台下则也需要按照本方案里要求的规范去处理。计算尺寸阶段定义要触发一次尺寸计算，需要对其包含的子组件进行计算调用；布局阶段定义了要触发一次布局，将子元素按照计算好的位置尺寸排布，也要对包含的子组件进行布局调用；绘制阶段定义要进行视图绘制，当然也要对起包含的子组件进行绘制的调用；对于虚拟组件，就在这些接口里实现相关逻辑，而对于原生组件，在这些接口实现里调用原生组件的对应逻辑。 不论是虚拟化组件还是原生组件，都采用上述相同的模型来定义，再加上相同的尺寸计算接口、布局接口、绘制接口，这样对于宿主容器来说，包装在内部的组件就不分虚拟化还是原生，一视同仁，暴露给外面的接口也是一样的，只要将宿主容器像普通的 View 一样添加到的视图界面上，就可以在后续的渲染过程中显示出来。如果虚拟组件使用的越多，View 的个数就越少，对于系统来说层级越扁平。以下图示例的组件来说，最终呈现的 View 只有宿主容器和两个图片组件，如果将图片也用虚拟化的方式实现，最终 View 只有一个宿主容器，而界面仍然保持不变。 二进制文件的格式通过 XML 编写的业务组件，并不直接在客户端里运行使用，而是先进行一次二进制序列化操作，原始的 XML 模板文件保存成文件的时候，就是以纯文本的形式存在，会包含很多冗余信息，比如空格、换行、还有重复出现的字符串等，文件体积比较大，以xml解析器去解析的时候，也会需要大量字符串操作，效率和性能不能达到最优。而将它编译成二进制格式，会避免这些问题，比如文件重复出现的字符串只保留一份，通过字符串索引去引用它，所有的组件类型也都会被转换成一个数字索引，在客户端内通过数字索引反过来找到对应的类实例化。这样文件格式会非常紧凑，体积更小。整个设计也借鉴了 Android 系统编译模板文件的思路。它的具体格式说明如下： 按照图中从左往右、从上往下的顺序分别说明每个段的作用： 开始5个字节固定为 ALIVV；相当于我们的文件格式的一个标记。 版本号分三个，分别为主版本号，次版本号和修订版本号，均为 2 个字节；在无重大重构更新时，前两位一般不变，第三位用于组件的业务级别变更升级； 组件区的起始位置和长度，均为 4 个字节；表示这份文件里组件区数据从第几个字节开始，它总共有多少个字节，这样解析这份数据的时候能直接将文件指针定位到特定位置来读取数据。 字符串区的起始位置和长度，均为 4 个字节；表示这份文件里字符串数据从第几个字节开始，它总共有多少个字节。 表达式区的起始位置和长度，均为 4 个字节；表示这份文件里字符串数据从第几个字节开始，它总共有多少个字节。 数据区的起始位置和长度，均为 4 个字节；表示这份文件里附加数据从第几个字节开始，它总共有多少个字节。目前这一区块是作为一种保留区，实际还未使用到。 当前文件所属页编码，2 个字节，唯一标识一个页（保留使用） 当前文件依赖页的个数为 2 个字节，后面为依赖页的 Id，依赖页个数大于 0 表示该页用到了其他页的资源或者代码，在该页加载之前需要确保依赖页必须已经加载；（保留使用） 组件区开始，前 4 个字节表示文件里业务组件个数，目前一个 XML 模板编译成一个二进制文件，故其值固定为 1。每个业务组件前 2 个字节表示业务组件名称字符串的长度，后面为指定长度的字符串字节数据；紧接着是 2 个字节的编译后组件二进制流长度，后面为二进制代码； 字符串区开始，前4个字节表示字符串个数，在我们的框架里，会内置一些系统级别的字符串资源，比如上文5.2开端表格里提到的那些属性名，这些字符串不用序列化到二进制文件里，而模板文件里出现的非系统字符串才会作为资源序列化到二进制文件。每个字符串资源前 4 个字节字符串索引 Id 即它的 hashCode，后面 2 个自己为字符串的长度，再后面为对应的字符串； 逻辑表达式代码表。前 4 个字节表示逻辑表达式资源个数，每个表达式资源前4个自己表示表达式的索引，它是表达式原始字符串的hashCode，后面两个2 个字节表示表达式的长度，后面为对应的表达式内容，它是表达式按照关键字切割后的字符串结构； 扩展数据段是保留为第三方扩展使用； 绑定数据的表达式开发业务组件的时候，基础属性或者样式往往不能在模板里直接写死，而是需要从数据里获取，所以引入了用户数据绑定的表达式，语法和实现上目前比较简单，参考了很多同类的设计，尽可能符合开发人员的直觉。 访问数据属性的表达式 语法上以 ${ 开头，以 } 结束。对于Map，通过 . 操作符进行访问，对于 Array 或者 List 通过 [] 操作符进行访问。 比如： 12$&#123;benefitImgUrl&#125;$&#123;data[0].benefitImgUrl&#125; 条件表达式 用来给那些需要根据数据中某个字段来设置值的属性，语法上以 @{ 开头，以 } 结束，中间部分为表达式的具体内容。 1条件表达式 ? 结果表达式[1] : 结果表达式[2] 当条件表达式成立的时候，使用结果表达式[1]，否则使用结果表达式[2]。 其中： 条件表达式支持布尔类型、字符串类型、JSONObject、JSONArray。 以下场景均为 false： 布尔类型值为 false 字符串为 null 或者 “” 或者 “null” 字符串 “false” 或者 “FALSE” JSONObject 为空或 JSONObject.NULL JSONArray 长度为 0 字段不存在 比如： 1@&#123;$&#123;logoUrl&#125; ? visible : invisible &#125; 考虑到篇幅限制，不能将上述架构和流程中的每一细节完全展开，详情可以参考苹果核这里的文档。 效果与 Tangram 及 TAC 结合VirtualView 方案是 Tangram 的极大补充，可以解决80%场景下的动态化需求，而 Tangram 依赖的数据则通过 TAC 提供解决，三者结合可以形成一个闭环，让一个开发从端到端地解决整块业务的开发。 组件动态下发以双十一期间为例，90%的双十一业务组件都是动态下发的，且随时可根据业务节奏调整。 展望尽管在功能流程上已经逐步稳定，能承载起日常及大促的需求变更，我们的方案还是有很多不足之处的，比如我们期望更高的运行效率、更加扁平化的UI结构、更加方便的开发体验，对此也做了更进一步的规划建设： 功能 计划 提供更加完善的文档和教程、Demo，内外版本同步，建立以 github 为中心的迭代开发机制 17年12月 组件创建、布局计算、数据绑定机制优化，提升性能 18年1月 重构模板编译工具，提升编译开发体验 18年1月 提供预览服务，提升开发效率 18年3月 提供配套的后端数据服务与基础设施，即 TAC 平台开放 18年3月 附录Tangram 2.0 主要更新说明 组件模型的概念升级，从原来的『卡片』+『组件』升级成『布局』+『组件』，即原来的『卡片』认为是一种具有布局能力的组件，具备嵌套另一组件的能力； 页面结构优化，页面下可以直接挂载组件，不需要嵌套一层布局； 组件类型的语义化，从原来的 1、2、3、4…等数字枚举类型定义，升级成字符串类型的定义，兼容解析原有的数字枚举定义； 更好的嵌套布局实现，流式布局在模型描述上支持多层次的嵌套，并优化了 Android 端上的实现方式； margin 去重的实现，同一层级的容器组件或原子组件直接，支持外边距 margin 的去重，使得动态数据下控制间距更方便； 支持 zIndex，无论是容器组件还是原子组件，支持在其样式上配置 zIndex，zIndex 值越大，绘制层次越高； 升级组件开发方式，引入动态化组件开发技术，提升组件动态性，实现组件样式的高效渲染与动态更新； 其他相关的 Tangram 库Android vlayout UltraViewPager iOS LazyScrollView 工具 virtualview_tools]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram Android设计说明]]></title>
    <url>%2Fposts%2F1867f4d.html</url>
    <content type="text"><![CDATA[前言前段时间开源了团队内的vlayout项目，从 Github 上反馈来看，还是深受欢迎。 但如果仅仅是采用 vlayout 搭建页面，使用起来还不是特别灵活，在此基础之上，我们封装了一套动态化调整界面的模块，命名为 Tangram，现在同样已开源——Tangram Android和Tangram iOS。我们希望将它打造成某一特定领域的解决方案，提速业务开发。 基本模型在前面的文章《页面动态化的基础 —— Tangram》里，已经重点介绍了 Tangram 里涉及的几个主要概念和模型设计，这里简单重复一下，将页面拆分成三个层次：页面——卡片——组件。页面指的就是整体可滑动页面实体；卡片指的是页面内可按行划分的一个一个独立区块，组件指的是卡片内部一个独立的、业务级别的单元，它可以是一张图，也可以是文字 + 图的组合。因此整体整个页面可以这样描述：一个页面嵌套了多个卡片，一个卡片嵌套了多个组件。Tangram 体系就是规范了这三层的数据结构描述，将其渲染出一张页面。 架构整体的层次结构如下，我们自底向上进行说明： 整个 Tangram 框架的页面UI搭建基于 vlayout 和 UltraViewPager。vlayout 之前已经提到过了，用来构建多类型、多布局类型的 RecyclerView；UltraViewPager 是 ViewPager 的一种扩展，整合了多种特性，比如横向滑动，竖向滑动，循环滚动等，用来实现 Tangram 内部所需要的轮播滚动卡片；这两个都比较独立，因此独立成库先行开源了，即使不使用 Tangram，也可以单独使用它们。 vlayout 主要提供了一个自定义的 LayoutManager，因此 Tangram 还需要提供一个 RecyclerView 和 Adapter 来才能配合 vlayout 运行。这里的 RecyclerView 可以由外部业务方通过 TangramEngine 注入，也可以内部默认构造。GroupBasicAdapter 则封装了 vlayout 所需要的 Adapter 的逻辑，组件的创建、组件数据的绑定、组件类型的定义等都由它负责。 在 UI 基础之上的便是各种功能逻辑模块： TangramEngine 是核心类，它负责绑定 RecyclerView 到底层 vlayout，绑定页面数据，操作页面数据（包括增、删、改），还提供注册外部服务的接口。 ServiceManager 是服务管理模块，不轮是内部还是外部功能模块，都可以注册到这里，一方面能被 Tangram 内部的其他模块访问到使用，另一方面解耦了框架与业务模块。 Bus 是事件总线，它在内部也被注册到 ServieManager，内部模块和业务使用方都可以使用它进行通信，解耦业务代码。 DataParser 负责解析数据，它将原始数据解析成卡片、组件的 model 对象。框架里提供的是解析 JSON 数据的解析器，也支持扩展解析其他类型的数据。 DataResolver 负责识别卡片、组件并构建对象，解析器解析数据的时候，需要依赖这些 Resolver去识别数据中的卡片或者组件是否合法，Resolver 识别的方式就是去组件库或者卡片库里寻找这些组件是否已经注册过。 与业务相关性较大的就是组件库、卡片库以及相关业务接口。TangramBuilder 是业务方构建 TangramEngine 的入口。组件库里注册了业务方所需有的组件，Tangram 的实例是一个页面一份，因此每个业务方可以分别注册各自所需要的组件，当业务方使用 Tangram 进行业务开发的时候，主要工作可能就在组件的开发上。卡片库注册的是卡片类型，框架里已经内置了一系列卡片，如果业务方有需要可以单独再注册特殊类型的卡片。而 ClickSupport、ExposureSupport 等都是辅助业务开发的功能模块，前者定义了组件点击处理的接口，后者定义了组件曝光处理的接口。它们都被注册到 ServiceManager 里，业务方在组件或者页面内都可以使用它们。 初始化流程 初始化 Tangram 的流程其实比较简单，无非就是构造 TangramEngine 对象，注册业务组件或者卡片，注册服务模块，绑定 RecyclerView，我们在接入文档——接入Tangram代码里详细说明了步骤。这里不一一赘述，在初始化过程中，各个核心模块也都完成了初始化。 运行流程基本流程图 页面数据示例12345678910111213141516171819202122232425262728293031323334353637[ &#123; "id": "banner1", "type": 1, "style": &#123; "aspectRatio": 3.223 &#125;, "items": [ &#123; "bizId":"item1", "type": 110, "msg": "info1" &#125;, &#123; "bizId":"item2", "type": 110, "msg": "info2" &#125; ] &#125;, &#123; "type": 1, "style": &#123; "aspectRatio": 3.223 &#125;, "items": [ &#123; "type": 10, "imgUrl": "https://gw.alicdn.com/tfs/TB1pdJFQpXXXXbUXpXXXXXXXXXX-750-243.png" &#125;, &#123; "type": 10, "imgUrl": "https://gw.alicdn.com/tfs/TB1pdJFQpXXXXbUXpXXXXXXXXXX-750-243.png" &#125; ] &#125;] 整个 Tangram 对界面的动态调整是通过数据来驱动的，所以首先要将原始数据传递给 TangramEngine，由于集团体系内的接口都采用 JSON 数据，Tangram 框架的默认设计也是接收 JSON 格式的数据，不过也支持通过自定义 DataParser 提前将其他格式的数据解析好之后再传给 TangramEngine。以上述的示例的 JSON 数据为例，一个页面下挂载了一个卡片数组，每个卡片都定义了 id、type、style、items节点；items 内部的数组定义的是组件数据，组件也有type、bizId 等业务字段数据。 不论是传递原始 JSON 数据给 TangramEngine还是通过直接解析原始数据，都是通过 DataParser 来完成的，它会按照树型结构解析出对应的卡片和组件的 model 对象，解析过程依赖于相应的卡片 Resolver 和组件 Resolver 来识别卡片、组件是否已注册，关键点就是识别 type 字段。若碰到无法识别的 type，则不会解析出对应的 model 对象。 解析完成之后会得到一个卡片列表，每个列表的卡片 model 元素里持有它所包含的组件列表。 model 列表交给 GroupBasicAdapter 进行处理，首先提取卡片列表，将包含空组件列表的卡片过滤掉，因为它没有东西可以渲染展示，然后创建出 vlayout 所需要的 LayoutHelper 列表，设置它们的样式属性，这样就打通了通过 JSON 数据最终控制布局排版的流程。 同时将所有的组件 model 提取出来成为一个独立的列表，真正交给 GroupBasicAdapter 去渲染数据，组件 model 列表的大小就是 GroupBasicAdapter 的 item 的大小， RecyclerView 也就直接加载组件视图，卡片相对于只负责了布局逻辑的控制，并没有 UI 实体的承载。 数据都准备完毕之后，RecyclerView 就驱动 vlayout 里的 LayoutManager 进行渲染和布局。 LayoutManager 首先回调 RecyclerView 内部获取 ViewHolder，若复用池里存在复用的对象，就回调 GroupBasicAdapter 进行数据绑定，否则先回调 GroupBasicAdapter 进行组件 ViewHolder 的创建，然后进行数据绑定。ViewHolder 的创建也是通过 Resolver 内部创建 UI 的模块进行构造。 这就是 Tangram 渲染页面的整体流程，本身并没有特别复杂的逻辑。而整个框架里的其他模块比如事件总线、ServiceManager 等都是在组件自身绑定数据，处理业务逻辑过程中会使用到，对于这些功能模块的使用，我们也编写了相应的教程文档供参考。 相关文章本文简要地对 Tangram Android 内部的设计和工作流程进行了说明，有助于对阅读源码的理解。但是建议读者在对 Tangram 有一定了解的基础之上再阅读此文，否则可能有云里雾里的感觉，因为这里涉及到大量的知识点没法完全展开，可以参考以下文章进行了解。 《Tangram是我们对界面动态化的态度》 《页面动态化的基础 —— Tangram》 《Tangram 的基础 —— vlayout（Android）》 《Tangram Android 使用指南》]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram1.0技术架构]]></title>
    <url>%2Fposts%2F6aeb1897.html</url>
    <content type="text"><![CDATA[Tangram作为一个面向常规业务产品的解决方案由3个部分组成： Tangram SDK：目前Tangram 1.0开源了iOS和Android两个平台的SDK，负责端上的界面渲染。Tangram SDK基于两个自建的高效组件复用容器（VLayout-Android和LazyScroll-iOS），开发的界面视图生成器。 Tangram AC：Tangram App Container，是整个Tangram体系中的业务核心。负责把模板和数据按照业务逻辑进行组装，并输出给SDK。 Tangram OP：Tangram Operator，是Tangram控制台，是业务人员调整界面结构、样式和数据源的控制台。 Tangram SDK 现在我们讨论的是Tangram 1.0架构，也就是正在服务手机天猫和其他几个App的版本。Tangram 2.0将在模型设计和核心技术上都有较大升级，暂不做讨论。 视图分层Tangram以一棵深度为3的树形结构构建视图： 根节点是Tangram View。Tangram View是Tangram的最终产物，与使用者直接交互的接口，一个View实例。 第二层节点被定义为布局。布局是一个起到容器作用的View实例，被要求遵守Tangram布局接口规范。一般来说一个布局会独占Tangram View的一行，多个布局依次向下排列。此外还会有特殊布局，如：浮动布局，是漂浮在屏幕上的一个布局，可以被拖动到任何位置。（访问Tangram主页 - 内置布局支持，了解更多布局） 叶子节点是组件。组件就是要展示业务信息的View，是Tangram中的原子View。相比布局而言，开发一个组件的限制要小很多，只需要实现少数几个方法即可。把任意一个自定义的View转化为Tangram组件都非常方便，这也是Tangram所倡导的：把任意正在使用的视图组件快速转化为Tangram视图。 Tangram ViewTangram View作为整个体系的核心产物，是基于上文提到过的LazyScrollView（iOS）和VLayout（Android）开发的。其最主要的作用是在运行时处理上述三层结构中组件的回收和复用。 Tangram View的回收和复用基于一个双索引结构。在渲染准备期需要提前知晓界面中全部叶子节点的尺寸和相对根节点的相对位置，给予位置和尺寸信息构建两个索引：所有组件顶部相对位置顺序的倒排和底部相对位置的倒排。当整个界面中出现组件的增减或位置变化，都需要调用一次Reload操作重建索引，当然创建索引过程采用了效率较高的排序算法。 渲染初始状态或屏幕发生滚动后，Tangram View会拿到当前屏幕的可视范围相对根节点的坐标，并快速在上述双索引结构中找到处在可视范围内的组件集合。然后，可视组件集合与当前存活组件集合分别相减就可以得到需要构造的新组件和可以回收的旧组件。先把旧组件标记为可被回收（注意：这里除了标记，不做任何其他操作），加入复用池，再遍历新组件集合：看复用池里有没有同类型组件可以被复用，若没有则调用工厂构造一个新的。 Tangram BusTangram Bus是Tangram提供的一个事件总线，主要为了避免各个模块为了需要相互通信而造成耦合。Tangram Bus的设计思想与常规的事件总线设计大同小异，使用方法也是采用监听模式：需要响应时间的模块注册一个监听方法到总线，而其他模块产生响应事件后会通知总线，总线则会调用监听方法。这里通过两个例子来说明Tangram Bus的作用： 跳转操作：界面的跳转逻辑是有Controller层负责的，而触发点击的一定是组件。为了避免组件和C层的耦合，C注册一个跳转的监听跳转事件的方法到总线，而组件发生需要跳转的操作时，会抛一个跳转事件到总线里，并在事件中带上跳转必需的信息。 索引重建：上文提到组件位置或尺寸发生变化需要触发索引重建，所以Tangram Core会注册一个方法监听位置或尺寸变更事件，当组件或布局发生变化则抛一个响应事件到总线。 Tangram AC主要目的Tangram AC是一个后端系统，是一个App容器，主要目的是通过规范化的开发模式打破后端开发在流程和环境上的壁垒，并通过容器本身的性能和稳定性保障绕过经验壁垒，给前端工程师一个直接开发后端逻辑的机会。 在传统的开发模式里，一个功能的开发流程至少要包括：接口约定、Mock数据和数据联调，三个需要前后端协作的过程，而且每个过程都会消耗大量资源，而且在我看来这样的消耗是完全没有意义的，不产生价值的。另一方面在现在的产品形态里对动态性要求越来越高，大量逻辑后移，客户端越来越薄。作为直接接触用户的前端开发，对整个产品逻辑的控制却越来越少，给技术驱动的产品创新造成了巨大障碍。 那么问题出在哪里？就是被上述提到过的流程、环境和经验的壁垒区分开来的前端和后端。所以打破这种壁垒，让听到炮火声的前端开发有更多的逻辑控制权，同时把后端开发从无聊的结构转换，数据拼装中解放出来就显得意义非凡。Tangram AC就是基于这样的想法诞生。 流程设计TAC把每一个独立运行的逻辑称为一个服务，多个服务组成一个应用对外提供数据服务。 TAC的每一个服务有一个独立的源码仓库，开发者提交服务源码后在控制台针对特定分支提交打包请求，TAC将把制定源码打成一个可执行的服务包。开发者通过控制台把选定的服务包发布到日常或预发环境中进行测试和联调，通过TAC强制验证后，可以把这个包发布到生产环境直接对线上应用提供服务。 在TAC的运行时，有一套完整的质量监控设施，实时监控整体容器的和各个服务的状态，保证整体容器运行正常。此外，为了保障核心应用的稳定性，TAC还提供了独立部署的机制，也就是说部分核心应用所涉及到的服务允许被独立部署的一个物理集群上独占资源。如此既保证了核心服务的稳定性，不会被稳定性级别更低的应用影响，也保证了核心服务在大量占用资源时不会拖慢其他应用。 Tangram OPTangram OP是整个体系最重要的控制台，上文中提到过的布局排布方式等都可以通过OP GUI的方式配置完成，也就是说在部署了OP的体系中，可以直接通过配置生成一张页面结构。并通过OP提供的数据关联功能关联到AC的某个数据服务上，组成一个完整的产品。 关于OP的具体实现不涉及到Tangram的接入，更多是为了提升使用效率，所以在这里不做赘述，日后Tangram OP开源后将做更多介绍。 结语Tangram旨在打造一个常规产品开发新模式，传达一个以创造价值为目的的开发理念，建设一个开发生态： 不为了创新而创新，而为了创造价值而创新，工程师要在有价值的方向上追求极致，而在仅仅能娱乐自己的方向上适可而止 让前端和后端做应该做的事，做更有价值的事，不因某些壁垒而无法更好的创造价值]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vlayout使用说明（二）]]></title>
    <url>%2Fposts%2F2be51ee4.html</url>
    <content type="text"><![CDATA[前言vlayout 的设计思路请参考Tangram 的基础 —— vlayout（Android）。框架已经开源，欢迎移步到 github上指教。本文介绍 vlayout 的基本布局样式上的属性说明。 margin, paddingMargin, padding就是外边距、内边距，概念与Android系统的margin, padding一样，但也有不同的地方： 它不是整个RecyclerView页面的margin和padding，它是每一块LayoutHelper所负责的区域的margin和padding。 一个页面里可以有多个LayoutHelper，意味着不同LayoutHelper可以设置不同的margin和padding。 LayoutHelper的margin和padding与页面RecyclerView的margin和padding可以共存。 目前主要针对非fix类型的LayoutHelper实现了margin和padding，fix类型LayoutHelper内部没有相对位置关系，不处理边距。 接口对于LayoutHelper，调用 12public void setPadding(int leftPadding, int topPadding, int rightPadding, int bottomPadding)public void setMargin(int leftMargin, int topMargin, int rightMargin, int bottomMargin) bgColor, bgImg背景颜色或者背景图，这其实不是布局属性，但是由于在vlayout对视图进行了直接布局，不同区域的视图的父节点都是RecyclerView，如果想要针对某一块区域单独绘制背景，就很难做到了。vlayout框架对此做了特殊处理，对于非fix、非float类型的LayoutHelper，支持配置背景色或背景图。同样目前主要针对非fix类型的LayoutHelper实现这个特性。 接口使用背景色 1public void setBgColor(int bgColor) 使用背景图 首先为LayoutManager提供一个ImageView简单工厂 123456this.mLayoutManager.setLayoutViewFactory(new LayoutViewFactory() &#123; @Override public opinion generateLayoutView(@NonNull Context context) &#123; return new XXImageView(context); &#125; &#125;); 再为LayoutHelper提设置图片加载的Listener 1234567891011121314151617181920212223242526272829baseHelper.setLayoutViewBindListener(new BindListener(imgUrl));baseHelper.setLayoutViewUnBindListener(new UnbindListener(imgUrl));private static class BindListener implements BaseLayoutHelper.LayoutViewBindListener &#123; private String imgUrl; public BindListener(String imgUrl) &#123; this.imgUrl = imgUrl; &#125; @Override public void onBind(View layoutView, BaseLayoutHelper baseLayoutHelper) &#123; //loading image &#125; &#125; private static class UnbindListener implements BaseLayoutHelper.LayoutViewUnBindListener &#123; private String imgUrl; public UnbindListener(String imgUrl) &#123; this. imgUrl = imgUrl; &#125; @Override public void onUnbind(View layoutView, BaseLayoutHelper baseLayoutHelper) &#123; //cancel loading image &#125; &#125; aspectRatio为了保证布局过程中视图的高度一致，我们设计了aspectRatio属性，它是宽与高的比例，LayoutHelper里有aspectRatio属性，通过vlayout添加的视图的LayoutParams也有aspectRatio属性，后者的优先级比前者高，但含义不一样。 LayoutHelper定义的aspectRatio，指的是一行视图整体的宽度与高度之比，当然整体的宽度是减去了RecyclerView和对应的LayoutHelper的margin, padding。 视图的LayoutParams定义的aspectRatio，指的是在LayoutHelper计算出视图宽度之后，用来确定视图高度时使用的，它会覆盖通过LayoutHelper的aspectRatio计算出来的视图高度，因此具备更高优先级。 接口对于LayoutHelper，调用 1public void setAspectRatio(float aspectRatio) 对于LayoutParams，调用 1((VirutalLayoutManager.LayoutParams) layoutParams).mAspectRatio dividerHeightLinearLayoutHelper的属性，LinearLayoutHelper是像ListView一样的线性布局，dividerHeight就是每个组件之间的间距。 接口对于LinearLayoutHelper，调用 1public void setDividerHeight(int dividerHeight) weightsColumnLayoutHelper, GridLayoutHelper的属性，它们都是提供网格状的布局能力，建议使用GridLayoutHelper，它的能力更加强大，参考下文介绍。默认情况下，每个网格中每一列的宽度是一样的，通过weights属性，可以指定让每一列的宽度成比例分配，就像LinearLayout的weight属性一样。 weights属性是一个float数组，每一项代表某一列占父容器宽度的百分比，总和建议是100，否则布局会超出容器宽度；如果布局中有4列，那么weights的长度也应该是4；长度大于4，多出的部分不参与宽度计算；如果小于4，不足的部分默认平分剩余的空间。 接口对于ColumnLayoutHelper, GridLayoutHelper，调用 1public void setWeights(float[] weights) vGap, hGapGridLayoutHelper与StaggeredGridLayoutHelper都有这两个属性，分别控制视图之间的垂直间距和水平间距。 接口对于GridLayoutHelper, StaggeredGridLayoutHelper，调用 12public void setHGap(int hGap)public void setVGap(int vGap) spanCount, spanSizeLookupGridLayoutHelper的属性，参考于系统的GridLayoutManager，spanCount表示网格的列数，默认情况下每一个视图都占用一个网格区域，但通过提供自定义的spanSizeLookUp，可以指定某个位置的视图占用多个网格区域。 接口使用spanCount调用 1public void setSpanCount(int spanCount) 使用spanSizeLookup 1public void setSpanSizeLookup(SpanSizeLookup spanSizeLookup) autoExpandGridLayoutHelper的属性，当一行里视图的个数少于spanCount值的时候，如果autoExpand为true，视图的总宽度会填满可用区域；否则会在屏幕上留空白区域。 接口调用 1public void setAutoExpand(boolean isAutoExpand) laneStaggeredGridLayoutHelper中有这个属性，与GridLayoutHelper里的spanCount类似，控制瀑布流的列数。 接口调用 1public void setLane(int lane) fixAreaAdjusterfix类型的LayoutHelper，在可能需要设置一个相对父容器四个边的偏移量，比如整个页面里有一个固定的标题栏添加在vlayout容器上，vlayout内部的fix类型视图不希望与外部的标题有所重叠，那么就可以设置一个fixAreaAdjuster来做偏移。 接口调用 1public void setAdjuster(FixAreaAdjuster adjuster) alignType, x, yFixLayoutHelper, ScrollFixLayoutHelper, FloatLayoutHelper的属性，表示吸边时的基准位置，有四个取值，分别是TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT。x和y是相对这四个位置的偏移量，最终的偏移量还要受上述的fixAreaAdjuster影响。 TOP_LEFT：基准位置是左上角，x是视图左边相对父容器的左边距偏移量，y是视图顶边相对父容器的上边距偏移量； TOP_RIGHT：基准位置是右上角，x是视图右边相对父容器的右边距偏移量，y是视图顶边相对父容器的上边距偏移量； BOTTOM_LEFT：基准位置是左下角，x是视图左边相对父容器的左边距偏移量，y是视图底边相对父容器的下边距偏移量； BOTTOM_RIGHT：基准位置是右下角，x是视图右边相对父容器的右边距偏移量，y是视图底边相对父容器的下边距偏移量； 接口设置基准调用 1public void setAlignType(int alignType) 设置偏移量调用 12public void setX(int x)public void setY(int y) showTypeScrollFixLayoutHelper的属性，取值有SHOW_ALWAYS, SHOW_ON_ENTER, SHOW_ON_LEAVE。 SHOW_ALWAYS：与FixLayoutHelper的行为一致，固定在某个位置； SHOW_ON_ENTER：默认不显示视图，当页面滚动到这个视图的位置的时候，才显示； SHOW_ON_LEAVE：默认不显示视图，当页面滚出这个视图的位置的时候显示； 调用 1public void setShowType(int showType) stickyStart, offsetStickyLayoutHelper的属性，当视图的位置在屏幕范围内时，视图会随页面滚动而滚动；当视图的位置滑出屏幕时，StickyLayoutHelper会将视图固定在顶部（stickyStart = true）或者底部（stickyStart = false），固定的位置支持设置偏移量offset。 调用 12public void setStickyStart(boolean stickyStart)public void setOffset(int offset)]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vlayout使用说明（一）]]></title>
    <url>%2Fposts%2Fb89a9b41.html</url>
    <content type="text"><![CDATA[前言vlayout 的设计思路请参考Tangram 的基础 —— vlayout（Android）。框架已经开源，欢迎移步到 github上指教。本文介绍 vlayout 的基本使用。 默认实现 默认通用布局实现，解耦所有的View和布局之间的关系: Linear, Grid, 吸顶, 浮动, 固定位置等。 LinearLayoutHelper: 线性布局 GridLayoutHelper: Grid布局， 支持横向的colspan FixLayoutHelper: 固定布局，始终在屏幕固定位置显示 ScrollFixLayoutHelper: 固定布局，但之后当页面滑动到该图片区域才显示, 可以用来做返回顶部或其他书签等 FloatLayoutHelper: 浮动布局，可以固定显示在屏幕上，但用户可以拖拽其位置 ColumnLayoutHelper: 栏格布局，都布局在一排，可以配置不同列之间的宽度比值 SingleLayoutHelper: 通栏布局，只会显示一个组件View OnePlusNLayoutHelper: 一拖N布局，可以配置1-5个子元素 StickyLayoutHelper: stikcy布局， 可以配置吸顶或者吸底 StaggeredGridLayoutHelper: 瀑布流布局，可配置间隔高度/宽度 上述默认实现里可以大致分为两类：一是非fix类型布局，像线性、Grid、栏格等，它们的特点是布局在整个页面流里，随页面滚动而滚动；另一类就是fix类型的布局，它们的子节点往往不随页面滚动而滚动。 所有除布局外的组件复用，VirtualLayout将用来管理大的模块布局组合，扩展了RecyclerView，使得同一RecyclerView内的组件可以复用，减少View的创建和销毁过程。 使用版本请参考mvn repository上的最新版本（目前最新版本是1.0.1），最新的 aar 都会发布到 jcenter 和 MavenCentral 上，确保配置了这两个仓库源，然后引入aar依赖： 1234// gradlecompile (&apos;com.alibaba.android:vlayout:1.0.1@aar&apos;) &#123; transitive = true&#125; 或者maven 1234567// pom.xml in maven&lt;dependency&gt; &lt;groupId&gt;com.alibaba.android&lt;/groupId&gt; &lt;artifactId&gt;vlayout&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;type&gt;aar&lt;/type&gt;&lt;/dependency&gt; 初始化LayoutManager 123final RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);final VirtualLayoutManager layoutManager = new VirtualLayoutManager(this);recyclerView.setLayoutManager(layoutManager); 设置回收复用池大小，（如果一屏内相同类型的 View 个数比较多，需要设置一个合适的大小，防止来回滚动时重新创建 View）： 123RecyclerView.RecycledViewPool viewPool = new RecyclerView.RecycledViewPool();recyclerView.setRecycledViewPool(viewPool);viewPool.setMaxRecycledViews(0, 10); 更新：看了很多人写的demo和源码解析后，需求提醒注意上述示例代码里只针对type=0的item设置了复用池的大小，如果你的页面有多种type，需要为每一种类型的分别调整复用池大小参数。 加载数据时有两种方式: 一种是使用 DelegateAdapter, 可以像平常一样写继承自DelegateAdapter.Adapter的Adapter, 只比之前的Adapter需要多重载onCreateLayoutHelper方法。 其他的和默认Adapter一样。 1234567891011121314DelegateAdapter delegateAdapter = new DelegateAdapter(layoutManager, hasConsistItemType);recycler.setAdapter(delegateAdapter);// 之后可以通过 setAdapters 或 addAdapter方法添加DelegateAdapter.AdapterdelegateAdapter.setAdapters(adapters);// orpublic class CustomAdapter extends DelegateAdapter.Adapter &#123; ......&#125;CustomAdapter adapter = new CustomAdapter(data, new GridLayoutHelper());delegateAdapter.addAdapter(adapter); 更新：hasConsistItemType这个参数有时候容易被人忽略，当hasConsistItemType=true的时候，不论是不是属于同一个子adapter，相同类型的item都能复用。表示它们共享一个类型。 当hasConsistItemType=false的时候，不同子adapter之间的类型不共享 另一种是当业务有自定义的复杂需求的时候, 可以继承自VirtualLayoutAdapter, 实现自己的Adapter 123456789101112131415161718192021public class MyAdapter extends VirtualLayoutAdapter &#123; ......&#125;MyAdapter myAdapter = new MyAdapter(layoutManager);//构造 layoutHelper 列表List&lt;LayoutHelper&gt; helpers = new LinkedList&lt;&gt;();GridLayoutHelper gridLayoutHelper = new GridLayoutHelper(4);gridLayoutHelper.setItemCount(25);helpers.add(gridLayoutHelper);GridLayoutHelper gridLayoutHelper2 = new GridLayoutHelper(2);gridLayoutHelper2.setItemCount(25);helpers.add(gridLayoutHelper2);//将 layoutHelper 列表传递给 adaptermyAdapter.setLayoutHelpers(helpers);//将 adapter 设置给 recyclerViewrecycler.setAdapter(myAdapter); 在这种情况下，需要使用者注意在当LayoutHelpers的结构或者数据数量等会影响到布局的元素变化时，需要主动调用setLayoutHelpers去更新布局模式。 Demo 详细代码参考：github 扩展布局如果默认的布局实现满足不了，你的需求，可以注册自定义的LayoutHelper来实现布局逻辑。有三种基类可以供你使用： BaseLayoutHelper：像LinearLayoutHelper、GridLayoutHelper等，内部View可以按行回收的布局，可直接继承此类，主要实现layoutViews()、computeAlignOffset()等方法。 AbstractFullFillLayoutHelper：有些布局内部的View 并不是从上至下排列的顺序，即 Adatper 里的数据顺序和物理视图顺序不一致，那么可能就不能按数据顺序布局和回收，需要一次性布局、一次性回收。主要实现layoutViews()等方法。可参考OnePlusNLayoutHelper。 FixAreaLayoutHelper：fix 类型的布局，子节点不随页面滚动而滚动。主要实现layoutViews()、beforeLayout()、afterLayout()等方法，可参考FixLayoutHelper。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram的基础 vlayout for android]]></title>
    <url>%2Fposts%2Fdf690640.html</url>
    <content type="text"><![CDATA[前言vlayout 是手机天猫 Android 版内广泛使用的一个基础 UI 框架项目 提供了一个用于RecyclerView的自定义的LayoutManger，可以实现不同布局格式的混排，目标是支撑客户端native页面的快速开发。它也是 Tangram 框架的基础模块，现已开源，欢迎移步到 github 上指教。 简介背景Android中UI性能消耗主要来自于两个方面： 布局层次嵌套导致多重measure/layout View控件的创建和销毁 除了从在实践中注意消除嵌套布局，Android官方也提供了ListView/GirdView/RecyclerView等基础空间来处理View的回收与复用。 但很多时候我们都会碰到视觉需要在一个长列表下做多种类型的布局来分配各种元素, 特别是电商业务各类首页，频道等页面，元素结构复杂多样。 这种时候实现的选择有不用复用，直接用各个组件进行拼接，但这样会损失性能；选择一个主要的复用容器, 如ListView或者RecyclerView+LinearLayoutManager等，然后在其中使用嵌套等方式对其他的布局方式进行处理，这样一个是减少了复用的能力，另一个是如果需要嵌套无法兼容的布局的时候，需要处理嵌套滑动的情况。 既然RecyclerView提供了基础的回收复用功能，也支持LayoutManager的扩展，那么能不能用一个LayoutManager就完成所有的布局类型呢？ 感觉的这是一个不错的方向，目前在 github 上也能找到类似的项目，但是这些之前也埋有不少bug, 大部分都是因为在一些特殊场景下和RecyclerView相关的其他的类一起使用时出现问题。 为了避免掉入bug大坑，我们决定基于LinearLayoutManager来做改造。 特性 自定义了一个VirtualLayoutManager，它继承自 LinearLayoutManager；引入了 LayoutHelper 的概念，它负责具体的布局逻辑；VirtualLayoutManager管理了一系列LayoutHelper，将具体的布局能力交给LayoutHelper来完成，每一种LayoutHelper提供一种布局方式，框架内置提供了几种常用的布局类型，包括：网格布局、线性布局、瀑布流布局、悬浮布局、吸边布局等。这样实现了混合布局的能力，并且支持扩展外部，注册新的LayoutHelper，实现特殊的布局方式。 每一种LayoutHelper负责布局一批组件范围内的组件，不同组件范围内的组件之间，如果类型相同，可以在滑动过程中回收复用。因此回收粒度比较细，且可以跨布局类型复用。 提供了自定义的布局样式，可以满足多样化的布局需求，比如每一个组件范围内的布局支持一个背景颜色、背景图片；网格布局里，可以支持1列、2列、3列、4列、5列共5种样式，每一列的宽度默认平均分配屏幕宽度，也可以指定按比例分配列宽。吸边布局支持吸到屏幕底部、屏幕顶部、屏幕左边、屏幕右边。这些都是系统默认的LayoutManager不支持的。 架构整体的设计方案和思路如下： RecyclerView是整个页面的主体，它的运行需要绑定一个Adapter和LayoutManager，在我们的设计里自定义了VirtualLayoutAdapter和VirtualLayoutManager来绑定到RecyclerView。 VirtualLayoutAdapter继承自系统的Adaper，它除了提供系统要求创建组件、绑定数据到组件的功能，定义了两个接口：getLayoutHelper()——用于返回某个位置组件对应的一个LayoutHelper；setLayoutHelpers()——业务方调用此方法设置整个页面所需要的一系列LayoutHelper。不过这两个方法的具体实现都委托给VirtualLayoutManager来完成。 VirtualLayoutManager继承自系统的 LinearLayoutManager，在RecyclerView加载组件或者滑动的时候，会调用VirtualLayoutManager，告诉它当前还有哪些空白区域可以用来摆放组件，也就是调用了架构图中所示的layoutChunk方法。 VirtualLayoutManager会持有一个LayoutHelperFinder，当layoutChunck被调用的时候，会传入一个位置参数，告诉LayoutManager当前要布局第几个组件，LayoutHelperFinder就通过这个位置找到当前这个位置对应的LayoutHelper，因为每个LayoutHelper都会绑定它负责的布局区域的起始位置和结束位置。 LayoutHelper负责具体的布局逻辑，它有一系列子模块，其中基类LayoutHelper定义了一系列接口，用来和VirtualLayoutManager通信，包括isOutOfRange()——告诉VirtualLayoutManager它所传递过来位置是否在当前LayoutHelper的布局区域内；setRange()——设置当前LayoutHelper负责的布局区域；beforeLayout()——在真正布局之前做一些前置工作；doLayout()——真正的布局逻辑接口；afterLayout()——在布局完成之后做一些后置工作；MarginLayoutHelper稍微扩展LayoutHelper，提供了布局常用的内边距padding、外边距margin的计算功能；BaseLayoutHelper是第一层具体实现，实现了当前LayoutHelper在屏幕范围内的具体区域，用于填充对这一区域填充背景色、背景图等逻辑。而剩下的LinearLayoutHelper、GridLayoutHelper等负责了具体的布局逻辑，它们都重点实现了beforeLayout()、doLayout()、afterLayout()方法，特别是在doLayout()方法里，会获取一个一组件，按照各自的协议对组件进行尺寸计算、界面布局。框架内置了以下几种重要的 LayoutHelper： LinearLayoutHelper，实现简单的线性布局； GridLayoutHelper，实现网格布局，支持1-5列的网格，支持配置列间距、行间距，支持不等宽的网格； StaggeredLayoutHelper，实现瀑布流式的布局； FloatLayoutHelper，负责悬浮效果，处于该布局中的组件会悬浮在整个页面上方，并且可拖拽，不随页面滚动而滚动； FixedLayoutHelper，负责固定位置的布局，它可固定在屏幕某个位置，不可拖拽，不随页面滚动而滚动； StickyLayoutHelper，它是一种吸边的布局，当它包含的组件处于屏幕可见范围内的时候，像正常的组件一样随页面滚动而滚动，当组件将要被滑出屏幕返回的时候，可以吸到屏幕的顶部或者底部，实现一种吸住的效果； 工作流程初始化 在使用vlayout的时候，首先做初始化工作，对业务使用方来说，和使用普通的 RecyclerView + LayoutManager 初始化流程基本一致。对于框架流程上来说，前前后后涉及了6个角色，基本流程如下： vlayout的业务使用方初始化RecyclerView对象。 创建一个VirtualLayoutAdapter对象，实现相关接口。 初始化一个VirtualLayoutManager对象。在初始化VirtualLayoutAdapter的时候，内部也初始化了一个RangeLayoutFinder对象，用来后续的LayoutHelper查找。 业务使用方需要将VirtualLayoutAdapter和VirtualLayoutManager都绑定到RecyclerView里。 获取数据列表，这个数据就是要显示到页面上的源数据，它可以是同步获取，也可以是异步从本地磁盘或者远程服务器获取。最关键的地方在用这个数据列表要包含一组布局和位置信息，能够用来识别数据列表中从第m个位置到第n个位置的数据它们是该用那种布局方式进行布局。这个布局和位置信息的数据结构并不做强制限制，只要能提供足够的信息，用来快速方便地完成下述第6步。 根据数据列表和源数据提供的布局位置信息，生成LayoutHelper列表，每个LayoutHelper对象会被知道它负责的源数据位置范围、源数据的个数等信息。 将生成的LayoutHelper列表传递给VirtualLayoutAdapter。 VirtualLayoutAdapter进一步将LayoutHelper列表给VirtualLayoutManager。 VirtualLayoutManager也进一步将LayoutHelper列表传递给RangeLayoutHelperFinder。 RangeLayoutHelperFinder真正开始处理这些LayoutHelper列表，它会根据每个LayoutHelper负责布局的起始位置和结束位置，对LayoutHelper做索引，这样当后续VirtualLayoutManager传入一个位置参数让RangeLayoutHelperFinder查找一个对应的LayoutHelper时，RangeLayoutHelperFinder会通过二分查找的方式返回一个LayoutHelper。 接下来还要将数据列表也传递给VirtualLayoutAdapter。 至此，整个初始化流程就完成，这里暴露给业务方的主要是VirtualLayoutAdapter，它接收数据列表和LayoutHelper列表，内部在传递给RecyclerView和VirtualLayoutManager进行后续的工作。 布局过程 当完成前面的初始化工作，将数据和LayoutHelper都绑定到vlayout内部之后，紧接着就可以开始布局流程了。这里无论是刚打开页面第一次布局，还是用户滑动页面，进行一次新的布局，流程都是一致的。 RecyclerView内部会维护一个状态，计算当前是否存在未填充满组件的区域，区域还有多大。 如果发现有空白区域，就将页面状态传给LayoutManager——在我们的框架里——就是VirtualLayoutManager，告诉它要进行组件的填充布局。VirtualLayoutManager能获取到的信息有当前可见的第一个组件的位置，当前可见的最后一个组件的位置，当前空白区域的大小，这些信息都是RecyclerView提供的，后面才开始真正vlayout发挥作用的时候。 VirtualLayoutManager先去遍历所有LayoutHelper，告诉它们当前可视范围的位置信息，不在范围之内的LayoutHelper可以做一些清理工作，比如将绑定过背景的LayoutHelper要清理背景。 VirtualLayoutManager获取到下一个要填充的组件的位置信息。 通过RangeLayoutHelperFinder找到下一个组件对应的LayoutHelper。 LayoutHelper开始真正布局一个或者多个组件， 注意一个LayoutHelper一次布局在宽度上会布局满一整行的区域，对于LinearLayoutHelper、FixedLayoutHelper等LayoutHelper，一个组件就占一整行，这个时候就布局一个组件就行了；而GridLayoutHelper、StaggeredLayoutHelper等一行可能会摆多个组件，它们一次布局会将尽可能多的组件都获取到填充满一行宽度。至于能填充多少高度，那就根据组件自己占用的高度来决定了。 LayoutHelper会从让RecyclerView返回一个组件，RecyclerView会尝试从回收池里获取一个被缓存的组件，如果存在缓存组件，就直接返回给LayoutHelper使用，如果不存在，则要调用Adapter——在vlayout框架里——就是VirtualLayoutAdapter去生成一个新的 组件实例。这个逻辑是RecyclerView的固有逻辑，也就组件复用的能力。 当RecyclerView内部不存在一个类型的组件缓存时，VirtualLayoutAdapter生成一个组件，一步一步返回给LayoutHelper。 LayoutHelper获取到了下一个要布局的组件，开始布局。 布局之前先对组件进行一次宽、高的测量计算，宽度是LayoutHelper通过布局信息、样式等条件计算得到的，限定了当前这个组件只能这么宽，而高度不由LayoutHelper决定，而是通过测量组件的高度来获取。 有了组件的宽高信息，结合一些样式，比如内边距、外边距、组件间间距等信息，LayoutHelper开始布局当前组件的位置。 当布局完一行组件之后，要再去遍历所有LayoutHelper，告诉它们当前可视范围的位置信息，做一些后置工作，比如新布局的区域是不是有背景要绑定，有的话要做背景的设置。悬浮类布局要根据位置做吸顶或者吸底的特殊处理，在可见范围内的悬浮类布局对组件做正常布局等。 通过前面布局过程中组件的高度计算，那么也就知道当前一次布局消耗了多少的空白区域。 这个空白区域进一步反馈给RecyclerView。RecyclerView会进行状态跟更新，如果空白区域都被填充满了，那么就结束一次布局了，如果还有，就要触发下一个位置的布局，在重复上述流程。 效果demo动效 实战效果 总结本文着重介绍 vlayout 的设计思路和原理，如果要进一步熟悉其细节，最好是到 github 上下载源码阅读，结合本文的说明，效果会更佳。如果想要尝试使用 vlayout 搭建页面，也可以到 github 上下载 demo，阅读使用文档和样式属性说明文档。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram七巧板实现界面动态化]]></title>
    <url>%2Fposts%2F57a68464.html</url>
    <content type="text"><![CDATA[Tangram，七巧板，几块简单的积木就能拼出大千世界。我们用Tangram来命名这套界面方案，也是希望他能像七巧板一样可以通过几块积木就搭出丰富多彩的界面。 号外：Tangram开源了！通过http://tangram.pingguohe.net可以了解更多技术细节，直接去GitHub查看iOS(https://github.com/alibaba/tangram-ios)和Android(https://github.com/alibaba/tangram-android)源码。 什么是TangramTangram不仅仅是一个Native（iOS &amp; Android）的界面开发框架，而是我们从日常工作中沉淀出的一套界面解决方案，涵盖了Native SDK，GUI操作台，后端逻辑容器，组件库机制的一整套方案。 Tangram从手机天猫 - 首页方案抽象而来，是面向组件的界面方案，是我们不断权衡性能、稳定性、开发效率、灵活性和动态性多方面表现的结果。除了手机天猫首页外，还支撑了天猫App中的天猫直播，我的天猫，猜你喜欢等多个业务，并且在阿里星球等多个阿里系App中有所应用。 就如Tangram主页所说，我们重点关注方案的多平台一致性，高性能和业务支撑能力。 Tangram怎么来的从2013年天猫在移动平台发力开始，我们一直在探索界面动态化方案。先后经历了WebView+HTML方案，动态Native方案，直至Tangram的原型——组件化方案。 最初我们看重动态性，在HTML框架和发布工具上做了大量的文章。我们可以快速开发出一张HTML页面，并推送到端上，而且通过Hybrid接口还能与Native进行交互。然而在大规模（双11）应用的过程中我们很快发现了问题——性能。当时我们认为WebView的性能是HTML页面的瓶颈，现在还不是大规模推广HTML的时候，我们需要一套替代方案。 很快我们提出了Dynative方案，框架内置基础组件（文本，图片，Button等）和函数（数学运算，字符串，网络等），以JSON为模板描述页面。Dynative方案兼具HTML方案的动态性和Native方案的高性能，看似完美。但很快在下一次的双11我们再次跌倒——效率。由于基于JSON定义的模板不具备通用性，写一张有逻辑的会场页面就需要数千行JSON，而且里边还有各种潜规则。能搞定这份模板的人，不超过5个。 痛定思痛，作为业务团队我们开始从业务的角度审视技术方案。带界面的业务基本分三种： 临时性业务——比如活动，几张页面生命周期可能2周，1周，甚至一两天。数量多，需求频繁，有可沉淀的东西，但变化更多。对极致性能不敏感。 常规业务——比如频道，生命周期长，需要长期维护。数量有限，需求稳定，沉淀性好。对极致性能相当敏感。 基础业务——跟常规业务相比需求稳定性更高，对性能和稳定性有极高的要求。 对于第1型，我们认为未来一定属于HTML，随着WebView性能的提升和Mobile开发框架与开发技能日趋成熟，现阶段HTML体现出的劣势终将荡然无存。而第2型和第3型是值得我们去思考的，结合我们团队所负责的业务形态，我们结合多年在业务上的经验制定了以粗粒度组件化+灵活布局容器为基本理念的界面解决方案。 整体上，Tangram View作为根节点，具备滚动能力；页面的子节点为布局容器，每行一个容器，向下单行排列；布局容器中按照各自的布局规则，在其内对任意组件进行排列。 至此，Tangram的基础模型已经确定，放弃了第1型和第3型，重点关注第2型。从改造手机天猫首页的实现方案开始，通过几个月的时间证明这套模型和方案在业务上完全可行。进一步对方案进行抽象，并且开始周边建设。 Tangram关注的重点正如Tangram主页上所述的，Tangram关注三个重点：面向业务、多端一致性和高性能。 面向业务正如第一部分所讲的，Tangram来源于多次试错和方向的调整，最终站在业务角度出发，权衡多项技术指标的结果。所以面向业务是出发点，是整个Tangram体系的最基本原则。 基于这个原则，在端上Tangram始终坚持粗粒度组件。粗粒度意味着通用性和灵活性的下降，某种程度上还会对动态性造成影响，但在第2型业务中通用性、灵活性和动态性的需求是有节制的，在粗粒度上完全可以满足业务需求。而且，粗粒度还会带给我们使用成本低，性能更好等优势。在端上重点精力则投入到提升组件库复用度，布局容器和组件的丰富性，从而推动业务发展。 除了端上的工作，另一部分重点工作在控制台和服务网关的建设上。作为一个面向业务的方案，控制台是业务方和产品的接口，控制台的主要目标是让业务方可以直接控制基于Tangram建设的产品——调整页面布局，切换页面数据，等。服务网关的建设目标是最大程度的降低业务创建Tangram页面的压力和成本。 多端一致性在多年的业务开发经历中，我们屡次被多端表现不一致的问题困扰。为了实现业务诉求，不得不通过复杂的网关逻辑来兼容多端逻辑不一致情况，以实现表现一致。因此我们早早的制定了两个Tangram端开发原则： 任意新功能的提出都是不区分平台，在功能设计中必须同时考虑多端功能，具体的实现方案和逻辑必须多端统一Review以保证多端表现一致。 任意一端的变更都必须在改动前把方案同步给其他端，而且变更必须多端同步发布。 高性能在面向业务的原则之下，已经给高性能打下了一个良好的基础。而在高性能的思考上我们重点基于页面渲染效率和组件回收复用两方面。 页面渲染——为了提升渲染效率，Tangram将在视图渲染之前把大量的计算工作在VM中完成，并缓存在VM组成的树形结构里。 回收和复用——Tangram在Android和iOS平台上分别开发了VLayout和LazyScroll两个基础组件，通过一个双索引可见区域组件发现算法，实现了跨父节点组件的高效回收和复用。 总结以上是对目前已经开源的Tangram 1.0的介绍，而目前我们已经完成了Tangram 2.0的讨论，开始执行2.0版本的重构工作。在Tangram 2.0中出于适应业务形态的变化，对Tangram 1.0中基于布局和组件的二维结构进行进一步的抽象，用于支撑更复杂的流式布局。并且对于控制台和服务网关也将进一步升级，大幅提升新业务开发效率。在性能层面，对组件开发模型和渲染模式进行一次较大的升级，在渲染和滚动效率上将得到巨大提升。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面动态化的基础Tangram]]></title>
    <url>%2Fposts%2F2ee0ad3d.html</url>
    <content type="text"><![CDATA[什么是Tangram 顾名思义，Tangram中文名是七巧板的意思，我们希望这个框架提供一系列基本单元，就像积木块一样，通过快速拼装就能搭建出一个页面或者调整页面的结构。重运营的业务特别是电商业务，往往讲究灵活多变，需要对线上业务做实时调整，此类页面动态化的需求便应运而生。 Tangram的设计理念 对于客户端开发来说，版本发出去之后，再要修改代码，是一件成本比较高的事情，针对线上实时调整比较多的地方，往往就采用了H5的方式上线。由于H5的体验相对Native欠缺一些，就有了后来Facebook的ReactNative(RN)，以及阿里自己的解决方案Weex，以Native的方式实现页面动态调整的能力。在如今，表面上看起来Tangram的方案会有些多余，但是通过了解它的设计与演变，那就知道它还是有存在的理由。 在历史上，大概两年前的这个时候，我们团队接手天猫首页的业务，迫切需要一套页面动态化方案。那个时候RN刚刚面世不久，特别是Android版本的RN还不稳定，更不用说后来的Weex了。而我们手里有的一套方案是自己开发过的Dynative（可以理解为初级版本的Weex）。但这些方案有个共同点就是比较重量级，它们都期望从基本的UI元素开始做一套纯动态的方案。在种种现有框架不成熟的时候，对于首页这种重量级的页面，我们还是希望以一种更加纯粹的Native开发模式来支撑业务。 在设计理念上，Tangram也有它的特殊之处，无论是H5还是Weex之类的方案，它们的动态能力在于随时可发布代码，它们是面向开发的动态化方案，发布代码意味着测试、灰度、发布等一系列流程。而Tangram是面向运营和产品的方案，它的动态能力体现在无须做代码改动，提供足够多的动态可配置的能力，通过在后台做样式的调整来达到页面调整的目的。所以简单比较如下： H5 Weex/RN Tangram 动态能力 强 较强 偏弱 面向人员 开发 开发 运营/产品 体量 完善的体系 较重量级 轻量级 体验 常规H5体验 鉴于H5和native之间 纯native体验 鉴于这样的设计目标，在这个框架里，重点着手于以下四个方面： 页面布局动态化，意思是页面的排版布局，可以通过后端数据的下发来调整。 组件业务化，这里的组件不是指基本的文本、图片、按钮等基本UI控件，而是指能承担一定业务能力的最小复用单元，因此它可能是一个文本和一个图片的组合这样子的一种形式。 动态能力粗粒度化，通过布局+组件的形式搭建整个页面，有多少种布局能力是内置在框架里的，有多少组件也是业务接入的时候注册到框架里的，后端下发的数据声明了用哪些布局、用哪些组件，通过布局嵌套组件的形式渲染整个页面。所以这个动态能力比较粗，不像H5或者Weex从基本的UI元素开始搭建整个页面。 组件的复用，为了承载那些个超长页面，需要对同类型的组件具备回收复用的能力，就像ListView、RecyclerView那样。 Tangram里重要的概念模型页面拆解 从一个实例出发，上图中展示的是一个早期的天猫首页，根据导购页面的特点，我们将页面拆分成三个层次：页面——卡片——组件，页面（第一张图）指的就是整体可滑动页面实体，并没有特殊之处；卡片指的是页面内可按行划分的一个一个独立区块（参考第二张图），组件（参考第三张图）指的是卡片内部一个独立的、业务级别的单元，它可以是一张图，也可以是文字+图的组合。因此整体整个页面可以这样描述：一个页面嵌套了多个卡片，一个卡片嵌套了多个组件。 页面结构 通过将页面拆分成三层结构，整个页面在model上就可以描述成这样一个树状结构。这里最重要的两个model是卡片和组件的model，整个页面的动态化将通过它们的动态化以及它们之间组合关系的动态化来完成。下面看这两层的具体协议描述： 卡片模型 卡片的职责是负责对组件进行布局，那么如何描述布局呢，前面说过，我们采用的是粗粒度的动态化方式，卡片的布局描述就是一种声明式的方式，因此卡片不需要布局模板，只要在model的数据里描述卡片的类型即可，至于卡片有哪些类型，则是注册在Tangram框架里的，业务方在接入框架的时候也可以注册自定义的卡片类型。这样就让Tangram省去了对布局模板的解析，简化了框架复杂度的同时，简化了开发复杂度。 卡片model描述上有四个组成：header、footer、body、style。最重要的是body部分，它包含了内嵌的组件model，如果卡片没有body，即没有组件，也就不在视觉上做渲染。卡片的布局也就是对body里包含的组件来进行布局。Tangram内置了一系列布局能力对组件进行布局，包括流式布局、瀑布流布局、吸顶布局、悬浮布局、轮播布局等等，基本上常见的布局方式都可以覆盖到。header、footer是卡片的标题和尾部，这是根据业务场景设计的可选内容，因为很多时候一块业务区域会有个标题之类的东西。在实现的时候，我们可以将他们转换到body里的组件，但在概念上，单独描述会更容易理解。style是对布局样式的描述，所有布局会有一些通用的样式属性，也有一些特有的，通过样式的描述，可以让布局能力更加丰富。画图举几个例子： 卡片样式简介 这里对卡片的样式做一些介绍，因为很多时候页面调整就是对样式的调整，结构调整也会涉及到样式调整，因此样式的动态性对页面的动态性具有重要贡献，这里举例的是几个通用的样式属性，如果卡片比较特殊，还可以自定义样式属性。 backgroundColor: 卡片的背景，在做页面氛围的时候经常会用到。 margin/padding: 卡片外边距、内边距，这是通用UI系统都会支持的属性。 gap: 卡片内的组件往往需要增加间距，如果通过组件的margin来实现，会有很多不便之处，相邻组件间左右或者上下都配置了margin，则需要考虑去重的实现，要么就在配置的时候对相邻组件的margin做精心控制。用gap的概念则很方便，它可以指定水平方向间距、垂直方向间距。 cols: 默认情况下，流式布局每一列宽度都是等分屏幕宽度的，如果需要做不等分的布局，就可以通过cols来指定每一列的占比，这样布局能力就能更加丰富了。 组件模型 组件的职责是负责业务逻辑和UI元素展示，它是尽可能小的业务单元，一般以实际设计稿出发，抽象出最小可复用单元。组件也是声明式的，需要在model的数据里描述组件的类型，至于有哪些类型，也是业务方在接入时预先注册，因为组件的业务成分比较重，Tangram一般就不内置了。除了类型描述，model数据里剩下的就是组件的数据和样式描述了。组件的数据不做具体规范，一般满足组件自身的需求即可，样式也不做强制规范，但有一些和布局相关的样式在框架层面会进行支持，这个下文介绍。 在组件的实现上，它首先是一个普通的View，并特殊之处，如果脱离Tangram框架，它也应该能正常运行使用。但在Tangram里，我们为组件设计了一个统一的ViewModel，定义了几个生命周期事件；通过ViewModel对组件的属性进行赋值，在组件初始化时会调用init，在滑入屏幕绑定数据时候调用bind，在滑出屏幕解除绑定时调用unbind。 除此之外组件的行为基本上都是业务逻辑了，不做过多介绍，这里再介绍几个和页面动态性相关的样式。 组件样式简介 backgroundColor: 组件的背景，同样也是在做页面氛围的时候经常会用到。 margin/padding: 组件外边距、内边距，同样也是UI系统都会支持的属性。 display: 参考css的设计，特别是在流式布局里，组件默认都是内联(inline)的，当布局占满屏幕宽度时，再考虑换行。如果在正常的流式卡片布局里要横插一行，则可以将组件声明为block，不然的话，就得将这个卡片打散成三个卡片才行。 colspan: 默认情况下，流式布局每一列宽度都是等分屏幕宽度的，也就是占用一个格子，组件上声明colspan可以让这个组件占用多个格子。它与卡片上的cols区别在于它占用的宽度值是离散的，而cols通过百分比可以做到宽度值的连续分布。 width/height: 其实是组件的宽高比，用来对组件进行对齐，利于界面排版。 每个组件都可以声明额外的自定义样式属性，比如字体颜色、字体大小等等，这里就不做过多介绍。通过卡片和组件的样式，基本上就可以组合出大部分场景的页面结构了，也就是Tangram的初衷——像搭积木一样拼装一个页面。 实现原理上面介绍了整个Tangram的基本概念，花了这么多篇幅讲概念模型，除了告诉大家这个东西是什么、它做什么、它是怎么设计的，最重要传递的一个信息是，作为业务系统，需要首先在概念模型上做好架构设计，在协议规范上做好统一，这样具体的平台去实现的时候，都能根据这个规范来做实现，不管谁实现的，都属于Tangram，这就好比JAVA虚拟机规范和JAVA虚拟机的关系一样。对于我们团队来说，对Tangram的实现也经历了一系列变更，但基本规范没怎么变动，这也是能大规模去支持业务的一个重要支点。下面会介绍目前实现上的思路和重要技术点。 基本结构和流程 主要有这么几个组成：核心引擎、数据解析器、卡片库、组件库、布局框架，核心引擎负责调度整个流程，在启动框架的时候要核心引擎要做一系列初始化，包括初始化卡片库和组件库，也就将内置的卡片类型注册进框架，将外部业务提供的组件也注册好，同时也要将数据解析器初始化好，布局框架也要初始化好。当页面数据传入的时候，核心引擎调用数据解析器将数据转换成卡片和组件的model对象，解析过程会根据之前注册过的卡片、组件类型来解析，不认识的数据将会被抛弃，卡片和组件的基本样式也会解析。解析完毕的卡片、组件model将会扔给布局框架进行页面渲染。布局框架根据卡片提供的布局信息进行布局，根据组件提供的组件信息进一步获取组件实例，贴到布局容器里。 布局框架实现 实现上难度最大的在于布局框架，布局框架的灵活性、性能决定了整个Tangram的灵活性和性能。在Android上，布局框架基于RecyclerView+自定义LayoutManager的方式实现；在iOS上，布局框架基于自定义的LazyScrollView来实现。这两框架基本上都能做到对页面的扁平化实现，提供了跨卡片的组件级别复用能力。先对这两块做一个介绍： 整个页面树被解析出卡片+组件的数据列表之后，会对块数据做进一步转换。首先提取所有组件model，也就是将组件都打平到同一级别的列表，这个列表会被传递给RecyclerView的Adapter，因此数据的位置其实就对应了RecyclerView看到的组件位置。而卡片model，将会拿来构建一个个LayoutHelper，这些LayoutHelper是负责具体布局的对象，一种布局类型的卡片对应于一种LayoutHelper，而且LayoutHelper还包含了它负责的组件的位置起始区域，它们会被传递给自定义的LayoutManager。当RecyclerView开始渲染页面或者滑动时，它内部维护了一个布局状态，获取当前屏幕范围内还有多少区域是空白的，下一个要加载的View的位置是多少，然后把这些信息告诉LayoutManager去加载View做布局。我们的自定义LayoutManager拿到这个位置之后，就反向查找对应的LayoutHelper，然后交给LayoutHelper去布局，这个过程还会涉及到从回收复用池或者通过Adapter获取一个组件实例。不同的LayoutHelper会按照约定的协议进行进一步布局。 对于iOS来说，也有类似的布局逻辑，但这里重点介绍iOS的页面容器LazyScrollView。这是一个自定义的滚动布局，具备回收复用能力。它的回收复用算法是这样的：在页面渲染前先计算所有组件的位置信息，根据组件在页面内位置的上边距做一个排序索引，根据下边距再做一个排序索引。页面滚动的时候通过滚动区域与上下边距的取交集，就可以获取到当前可见范围的组件是哪些，然后不可见范围内的组件实例可以回收，新进入可视区域的组件可以从回收复用池里拿到组件实例或者新创建一个组件实例贴到布局里。 扩展上面介绍的内容构建里Tangram的基本骨架，但要支撑起业务，还需要很多辅助工具，如果没有这些扩展，将很难支撑业务。这些扩展有些是内部注册在框架，也有些是外部注入。 点击处理模块，组件都需要有点击交互，点击处理模块定义了接口，业务方根据接口实现具体模块然后注入。 曝光处理模块，与点击模块类似，可提供组件曝光时的业务逻辑加载。 通用定时器模块，用来提供计时功能，满足组件内的倒计时需求、定时需求。 事件总线，用来做组件与卡片的通信，或者组件与外部通信等等。 脚本动画，将动画脚本化，提供动画的动态能力，让组件的交互更加丰富。 通用请求模块，有时候卡片数据、或者组件数据需要调用远程接口更新，同通用请求也是定义了加载接口，外部业务方自行实现注入。 纯动态组件，解决组件动态问题，因为我们的动态化是粗粒度的，行走江湖免不了内置动态能力满足不了一个临时需求的场景。动态组件集成了集团内的动态化方案，目前最主要的就是阿里的Weex方案，通过Weex的动态能力来解决组件的动态能力。 有了这些扩展功能，整个Tangram落地到业务就非常方便了，目前我们支撑了天猫首页、天猫直播首页、天猫超市首页等重要业务，还推广到了集团其他部门。 实践经验最后分享一些业务开发的经验，分客户端和后端运营两方面介绍。延伸到其他业务，这些经验应该也是有借鉴意义的。 客户端 首先是规范与协议的统一，我们这个框架支撑了多个业务，不同业务、不同平台之间，只有规范统一，才能尽可能支撑多的业务，否则不同业务接入，要做转换，是一件成本很高的事情。在不同平台之间统一规范，也可以让一份数据在多端使用。 在客户端上开发，稳定性是一个非常重要的指标，整个应用应该有自己的保护模式，对于框架来说，我们也要有防御性编程的思维，特别是是动态化方案，往往根据数据来执行代码，访问数据本身要足够小心，像空字段、类型转换、数组越界都是常见的问题，通过安全方法的使用，可以在一个地方保证数据访问的安全性。 组件库，也是一个非常重要的建设，不同业务之间可以复用相同的组件，减少组件开发。 容器化是实现页面在线拼装的一个必要的建设，客户端需要有一个容器页面，就像webview一样，给一个url，就可以加载页面，后端也也需要做数据的容器化接入，能导入业务数据，按照Tangram协议输出。再利用组件库里的现有组件，就可以完成一个页面搭建，目前有一些简单的页面（搜索专辑、推荐专辑）就是这样完成上线的。 解耦也是一个老生常谈的问题，在Tangram里实现扩展能力的时候，解耦这一方面做得就特别棒，像脚本动画、Weex都是其他团队的成果，但是可以很方便的插入到Tangram框架里，而且可以热插拔，业务方不想使用就可以不接入。 运营管理 Tangram是一个动态框架，虽然它的重点技术在客户端，但是没有后端的话是不完整的，必须要有一个完善的后端管理平台来做页面的日常运维才行。我们开发了一个专门的管理后台，可以对Tangram页面做多维度的管理。后端管理平台还承载了页面的稳定性、页面发布的效率、页面试错等能力。 Tangram页面动态调整都是配置发布，视觉调整。因此我们有独特的发布流程，首先后台变更完成之后不会直接发布，而是进入到预发布状态，在这个状态下，可以通过白名单预览提前检查变更效果，预览的方式是将变更生成一个二维码，在手机上扫码预览，检查最真实的效果。通过时间机器调整时间，不仅可以预览这次变更在当前时间的效果，还可以预览将来某个时间的效果，因为不同的时间点，生效的数据不一样，因此时间维度的预览特别有用。另外管理平台对变更人员也做了权限控制，每个业务方人员只能变更自己负责的业务，不会改动到其他业务的页面，通过对接流程平台，让每次变更都有记录可查，防止线上数据随意更改。 有了页面发布、变更的稳定性保证，发布的效率也是下一个重要考虑的问题。定时发布可以让变更在指定时间生效，比如双十一的时候很多东西要0点生效，如果0点做变更、预览、再上线，风险很大，有了定时发布，可以提前做好准备。一键下线的功能，可以做多版本里的某个共用卡片批量下线，特别是紧急情况。批量复制创建卡片和版本通配，都是为了解决新版本发布时候的效率，目前我们针对一个版本客户端就发布一份页面配置数据，有了版本通配，可以减少页面配置的数量，有了批量复制创建，可以在要创建新版本页面的时候复制页面。 快速试错，这是近年来非常热门的一个领域，当页面要进行调整的时候，我们希望看到调整的效果，这个时候abtest就派上了用场。天猫有一套自己的试错平台，Tangram前后端都对接了这条试错平台，在管理平台可以将变更做成实验变更，然后导入到试错平台下发到客户端，进入到实验分桶的用户就可以访问到实验变更，同时试验平台在端上也做了数据采集，这样可以在小范围内先试验变更的效果，根据数据来做接下来的决策。 小结本次分享整体性的介绍了Tangram的技术方案和一些开发经验，内容比较多，很多地方只能在整体思路上进行介绍，后续我们会逐步将一些细节开放出来分享。]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tangram知识图谱]]></title>
    <url>%2Fposts%2Fa76b266e.html</url>
    <content type="text"><![CDATA[为了方便大家对 Tangram 有个全局的了解，做了一张图谱做指导。 相关开源库Android Tangram-Android Virtualview-Android vlayout UltraViewPager iOS Tangram-iOS Virtualview-iOS LazyScrollView 工具 virtualview_tools]]></content>
      <categories>
        <category>Android</category>
        <category>Tangram</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tangram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node升级的正确方法]]></title>
    <url>%2Fposts%2Fc2ade9d5.html</url>
    <content type="text"><![CDATA[安装方法:1.查看node版本，没安装的请先安装；12 $ brew install node $ node -vn 2.清楚node缓存；1$ sudo npm cache clean -f 3.安装node版本管理工具’n’;1$ sudo npm install n -g 4.使用版本管理工具安装指定node或者升级到最新node版本；123$ sudo n stable （安装node最新版本）$ sudo n 8.9.4 （安装node指定版本8.9.4） 5.使用node -v查看node版本，如果版本号改变为你想要的则升级成功。若版本号未改变则还需配置node环境变量1.查看通过n安装的node的位置；1$ which node (如：/usr/local/n/versions/node/6.12.3） 2.cd进入/usr/local/n/versions/node/ 你应该能看到你刚通过n安装的node版本这里如：8.9.4；编辑/etc/profile;1$ vim /etc/profile 3.将node安装的路径（这里为：/usr/local/n/versions/node/8.9.4）添加到文件末尾；12345set node pathexport NODE_HOME=/usr/local/n/versions/node/8.9.4export PATH=$NODE_HOME/bin:$PATH 4.wq退出保存文件，编译/etc/profile;1$ source /etc/profile 5.再次使用node -v查看node版本，不出意外版本号应该变为你想要的。]]></content>
      <categories>
        <category>前端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式的优点与缺点概况]]></title>
    <url>%2Fposts%2Fb5467332.html</url>
    <content type="text"><![CDATA[设计模式标签（空格分隔）： 设计模式优点 应用场景 单例模式优点： 只有一个实例，减少了内存开支； 可以避免对系统资源的多重占用； 可以在系统中设置全局的访问点，优化和共享资源访问； 缺点： 没有接口，扩展困难； 对测试开发不利； 应用场景： 要求生成唯一序列号的场景； 需要一个共享访问点； 创建一个对象需要消耗过多的资源时 需要定义大量的静态常量和静态方法时（也可直接声明为static的方式）； 工厂方法模式优点： 良好的封装性，代码结构清晰； 扩展非常好； 屏蔽产品类； 应用场景： 是new一个对象的替代品； 需要灵活的，可扩展的框架时； 使用在测试驱动开发的框架下； 抽象工厂模式优点： 封装性； 产品族内部的约束为非公开状态； 缺点： 产品族扩展困难； 模板方法模式优点： 封装不变部分，扩展可变部分，把不变的算法封装到父类实现，可变的部分则通过继承来扩展； 提取公共部分代码，便于维护； 行为由父类控制，子类实现; 缺点： 子类对父类产生影响，子类执行的结果影响了父类的结果; 应用场景： 多个子类有公有的方法，且逻辑相同时； 重要，复杂的算法，可以把核心算法设计为模板方法； 重构时，把相同的代码抽取到父类，然后通过钩子函数结束其行为； 建造者模式优点： 封装性，使得客户端不必知道产品内部的组成细节，我们不用关心每一个具体的模型内部是如何实现的。 建造者独立，容易扩展 便于控制细节风险，由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响; 建造者模式的应用场景： 相同的方法，不同的执行顺序，会产生不同的结果时； 多个部件或零件，都可以装配到一个对象中，但产生的运行结果又不相同时，如Android中的AlertDialog的构造; 产品类非常复杂，或产品类的的调用顺序不同产生不同的效果； 代理模式优点： 职责清晰，其实的角色就是实现实际的业务的逻辑，不用关心其他非本职责的事务； 高扩展性，具体主题角色随时都会发生变化，但只要它实现了接口，我们的代理类就可以在完全不做任何修改的情况下使用； 原型模式（通过实现Cloneable接口）优点： 性能优良，原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好，特别是要在循环体内产生大量对象时， 避免构造函数的约束，直接是在内存中拷贝的，构造函数是不会执行的。 应用场景： 类初始化需要消化非常多的资源时 性能和安全要求的场景，通过 new产生一个对象需要非常繁琐的数据准备和访问权限时； 一个对象多个修改者的场景，一个对象需要提供给多个对象访问，而且各个调用者都可以修改其值时； 注意地方：浅拷贝与深拷贝Java的Object类提供的clone方法只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，其他的原始类型如int,char等都会被拷贝，拷贝后的对象与原生对象共享内部元素的地址（浅拷贝），如果拷贝后的对象修改了原生对象的数组，则原生对象也会看到修改。如果需要进行深拷贝，则需要在复写的clone方法里对私有的类变量（内部数组，引用对象）进行独立的拷贝。并且使用final关键字修饰的变量不能被拷贝； 中介者模式优点： 减少了类间的依赖，把原有的一对多的依赖变成了一对一的依赖； 缺点： 中介者会膨胀得很大，而且逻辑复杂；原本N个对象的依赖关系转换为中介者与对象的依赖关系； 命令模式优点： 类间解耦，调用者与接收者之间没有任何依赖关系，调用者实现功能时不需要了解到底是哪个接收者执行，只需调用Command抽象类的execute方法就可以了； 可扩展性，Command的子类可以非常容易扩展，并且调用者和高层模块不产生严重的代码耦合； 缺点： Command类膨胀厉害，如果有N个命令，则Command类的子类就为N个； 应用场景：如Android中各种事件的处理； 责任链模式优点： 请求与处理分开，请求者可以不用知道是谁处理的，处理者可以不用知道请求的全貌； 缺点： 性能问题，每个请求都是从链头遍历到链尾的，当这个责任链比较长时，遍历开销会比较大； 应用场景: 如Android事件的传递机制； 装饰器模式优点： 装饰类和被装饰类可以独立发展，而不会互相耦合； 装饰模式是继承关系的一个替代方案，不管装饰多少层，最终返回的也还是那个对象； 装饰模式可以动态地扩展一个实现类的功能； 缺点： 多层的装饰比较复杂，当使用多层装饰出现问题时，排查问题的工作量比较大 应用场景： 需要扩展一个类的功能，或给一个类增加附加功能； 需要为一批兄弟类进行改装或加装功能； 策略模式优点： 算法可以自由切换，只要实现抽象策略，它就成为策略家庭的一个成员； 避免使用多重条件判断， 扩展性良好，在现有的系统中增加一个策略太容易，只要实现接口就可以了; 缺点： 策略类数量多，每一个策略都是一个类，复用的可能性很小； 所有的策略类都需要对外暴露，上层模块必须知道有哪些策略，然后决定使用哪一个策略； 应用场景： 多个类只有在算法或行为上稍有不同的场景； 算法需要自由切换的场景； 需要屏蔽算法规则的场景； 适配器模式优点： 让两个没有任何联系的类在一起运行； 增加了类的透明性； 提高了类的复用度； 灵活性好，当不需要适配器时，只要删掉这个适配器就可以了， 应用场景： 修改一个已经投产的接口时， Android中各种Adapter， 迭代器模式 迭代器模式是为解决遍历容器中的元素而诞生的，没有人会单独写一个迭代器，使用Java提供的Itreator就可以满足要求了； 组合模式优点： 高层模块调用简单，高层模块不需要关心自己处理的是单个对象还是整个组合结构， 节点可以自由增加； 缺点： 调用时会直接使用实现类，不符合面向接口编程思想； 应用场景： 维护和展示部分-整体关系的场景，如树型菜单，文件和文件夹的管理； 只要是树型结构，就要考虑使用组合模式； 观察者模式优点： 观察者与被观察者之间是抽象耦合，不管是增加观察者还是被观察者都非常容易扩展； 建立一套触发机制； 缺点： 一个被观察者，多个观察者，开发与调度会比较复杂，在Java中消息的通知默认是顺序执行，其中一个观察者卡壳，会影响整体的执行效率，一般要考虑采用异步的方式； 应用场景： 关联行为场景，如Android中数据变化会引起UI的变化； 事件多级触发场景； 跨系统的消息交换场景； 门面模式优点： 减少系统的相互依赖，所有的依赖都是与门面对象的依赖，与子系统无关。 提高了灵活性； 提高了安全性，想让你访问子系统的哪些业务就开通哪些逻辑； 缺点： 不符合开闭原则，当出现bug后，只能通过修改门面角色的代码来修复； 应用场景： 为一个复杂的模块或子系统提供一个供外界访问的接口，如Android的Context类只是一个抽象类，所有的功能都是在ContextImpl类实现的，我们不会察觉到ContextImpl的存在，只需要调用Context就可以了； 子系统相对独立，外界对子系统的访问只要黑箱操作即可； 预防低水平开发人员带来的风险，被限定在指定的子系统开发； 备忘录模式应用场景： 需要保存和恢复数据的相关状态场景； 提供一个可回滚的操作场景； 需要监控的副本场景中； 数据库连接的事务管理就是用的备忘录模式； 注意事项： 备忘录的生命期，要主动管理它的生命周期，建立就要使用，不使用就删除； 备忘录的性能，不要在频繁建立备份的场景中使用备忘录模式；（对象的创建是需要消耗资源的） 访问者模式优点： 符合单一职责原则，具体元素角色负责数据的加载，而访问者类则负责数据的呈现； 优秀的扩展性， 灵活性非常高； 缺点： 具体元素对访问者公布细节，访问者要访问一个类就必须要求这个类公布一些方法和数据； 具体元素变更比较困难；具体元素角色的增加、删除、修改都是比较困难； 违背了依赖倒置原则，访问者依赖的是具体的元素，而不是抽象的元素； 应用场景 ： 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作； 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作”污染“这些对象的类； 业务规则要求遍历多个不同的对象； 状态模式优点： 结构清晰，避免了过多的switch...case或if...else语句的使用； 遵循设计原则，每个状态就是一个子类； 封装性非常好，将状态变换放置到类的内部来实现； 缺点： 子类会太多，也就是类膨胀，有多少个状态，就会有多少个子类； 应用场景： 行为随状态改变而改变的场景，如权限设计； 条件、分支判断语句的替代者，通过扩展子类实现条件的判断处理； 状态的个数最好不要超过5个； 解释器模式（现在使用较少）优点： 扩展性好， 缺点： 解释器模式会引起类膨胀； 采用了递归调用方法； 享元模式优点： 大大减少应用程序创建的对象，降低程序内存的占用; 缺点： 提高了系统复杂性，需要分离出内部和外部状态； 应用场景： 系统中存在大量的相似对象； 需要缓冲池的场景； 细粒度的对象都具有较接近的外部状态；且内部状态与环境无关 桥梁模式优点： 抽象与实现分离； 优秀的扩充能力； 实现细节对客户透明； 应用场景： 不希望或不适用继承的场景； 接口或抽象类不稳定的情况； 重要性要求较高的场景；]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之23种常用模式]]></title>
    <url>%2Fposts%2F8af7915a.html</url>
    <content type="text"><![CDATA[在常用的23种设计模式中，根据设计模式的功能，我们又可以把这23个设计模式分为三大类：创建类模式，结构类模式，行为类模式； 创建类模式 工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一类，使一个类的实例化 延迟到其子类； 建造者模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示； 抽象工厂模式，为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。 单例模式，确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例； 原型模式，通过对象复制来实现的模式就叫做原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 结构类模式 适配器模式,将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作； 桥梁模式，将抽象与实现解耦，使得两者可以独立地变化； 组合模式，将对象组合成树形结构以表示“部分-整体”的场次结构，使得用户对单个对象和组合对象的使用具有一致性。 装饰模式，动态地给一个对象添加一些额外的职责。就增加功能来说 ，装饰模式相比生成子类更为灵活； 门面模式，要求一个子系统的外部与其内部通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 享元模式，是池技术的重要实现方式，使得共享对象可有效地支持大量的细粒度的对象。 代理模式，为其他对象提供一种代理以控制对这个对象的访问。 行为类模式 责任链模式，使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止； 命令模式，这是一个高内聚的模式，将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能； 解释器模式，是一种按照规定语法进行解析的方案；定义为：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示业解释语言中的句子。 迭代器模式，，它提供一种方法访问一个容器对象中各个对象，而又不需暴露该对象的内部细节。（目前已经没落）； 中介者模式，用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 备忘录模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象恢复到原先保存的状态。通俗地讲，备忘录模式就是一个对象的备份模式，提供了一种程序数据的备份方法； 观察者模式，也叫做发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 状态模式，状态模式的核心是封装，状态的变更引起了行为的变更。当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。 策略模式，定义一组算法，将每个算法封装起来，并且使它们之间可以互换； 模板方法模式，定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些框架； 访问者模式，封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之6大设计原则]]></title>
    <url>%2Fposts%2Ffbde7e42.html</url>
    <content type="text"><![CDATA[单一职责原则单一职责的定义为：应该有且仅有一个可以引起类的变更，也就是一个职责一个接口（业务逻辑的划分）；好处： 类的复杂性降低； 可读性提高； 可维护性提高； 变更引起的风险降低；一个接口修改只对相应的实现类有影响，对其他接口没有影响 里氏替换原则通俗地说，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常；但反过来就不行，有子类出现的地方，父类未必就能适应；（因此在类中调用其他类时，就务必使用父类或接口，如果不能这样做，则说明类的设计已经违背了LSP原则了） 如果子类不能完整地实现实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖，聚集，组合等关系代替继承； 方法中的输入参数称为前置条件，并且子类中的方法的前置条件必须与父类中被覆写的方法的前置条件相同或者更宽松；（父类出现的地方，子类就可以出现） 依赖倒置原则最直接的理解就是：面向接口编程，抽象定义： 高层模块不应该依赖于低层模块，两者都应该依赖其抽象； 抽象不应该依赖细节； 细节应该依赖抽象； 在Java语言中的表现为： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的； 接口或抽象类不依赖于实现类； 实现类依赖接口或抽象类； 接口隔离原则接口的种类： 实例接口，如我们在Java中声明一个类，然后用new 关键字来产生一个实例，它是对一个类型的事物的供述，这是一个接口； 类接口，在Java中使用关键字interface定义的接口； 定义：说白了就是接口尽量细化，同时接口中的方法尽量少 迪米特法则也叫最少知识原则，简单说应该对其他对象有最少的了解，也就是说一个类应该对自己需要耦合或调用的类知道得最少；也就是类间解耦，弱耦合 开闭原则定义：软件实体应该对扩展开放，对修改关闭，也就是说软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化；如何应用到实际编程中？： 抽象约束，也就是通过接口或抽象类约束实现扩展，对扩展进行边界的限定，不允许出现在接口或抽象类中不存在的public 方法；并且参数的类型、引用对象尽量使用接口或者抽象类，最后就是抽象层尽量保持稳定，一旦确定就不允许修改； 元数据控制模块行为，也就是说用元数据来控制程序的行为，减少重复开发。元数据就是用来描述环境和数据的数据，也就是我们常说的配置参数； 制定项目章程，让团队的所有成员都遵守约定； 封装变化，将相同的变化封装到一个接口或抽象类中，不同的变化封装到不同的接口或变化；]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom_For_ReactNative]]></title>
    <url>%2Fposts%2F321ed7e5.html</url>
    <content type="text"><![CDATA[Atom下载链接https://atom.io/ Atom插件https://atom.io/packages常用插件：​ 浏览器浏览功能 open-in-browser (可以设置快捷键)​ 分页展示html页面效果 atom-html-preview (可以设置快捷键)​ 文件路径补全 autocomplete-path​ React官网https://facebook.github.io/react/]]></content>
      <categories>
        <category>Android</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ReactNative</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局弹框GlobalDialog]]></title>
    <url>%2Fposts%2F5bbd3c9c.html</url>
    <content type="text"><![CDATA[Demo地址：GlobalDialogDemo 全局弹框，比如异地登录提示。思路就是通过非 Activity 的 Context 来启动一个透明 activity， 然后使用这个 activity 来显示一个 dialog。 AndroidManifest.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.whohelp.globaldialogdemo"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".GlobalDialogActivity" android:theme="@style/Transparent" /&gt; &lt;/application&gt;&lt;/manifest&gt; styles.xml123456789101112131415161718&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name="Transparent" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt; &lt;item name="android:windowAnimationStyle"&gt;@android:style/Animation&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; MainActivity.java1234567891011121314public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void showDialog(View view) &#123; GlobalDialogActivity.start(this.getApplicationContext()); &#125;&#125; GlobalDialogActivity123456789101112131415161718192021222324252627282930313233public class GlobalDialogActivity extends AppCompatActivity &#123; public static void start(Context context) &#123; Intent starter = new Intent(context, GlobalDialogActivity.class); //设置启动方式 starter.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(starter); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_global_dialog); //显示dialog new AlertDialog.Builder(this) .setTitle("全局dialog") .setMessage("这是一个全局dialog") .setNegativeButton("取消", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setPositiveButton("确定", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;) .setCancelable(false) .show(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>GlobalDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextView文字加粗]]></title>
    <url>%2Fposts%2F752c11de.html</url>
    <content type="text"><![CDATA[xml加粗1android:textStyle="bold" 代码加粗推荐方式1textView.typeface = Typeface.defaultFromStyle(Typeface.BOLD) 非推荐方式1textView.paint.isFakeBoldText = true]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android启动模式和应用场景]]></title>
    <url>%2Fposts%2F7bd182af.html</url>
    <content type="text"><![CDATA[在一个项目中会包括着多个Activity，系统中使用任务栈来存储创建的Activity实例，任务栈是一种“后进先出”的栈结构。举个栗子，若我们多次启动同一个Activity。系统会创建多个实例依次放入任务栈中。当按back键返回时，每按一次，一个Activity出栈，直到栈空为止。当栈中无不论什么Activity。系统就会回收此任务栈。 上面这个样例中的Activity并没有设置启动模式，你会发现多次启动同一个Activity。而系统却创建了多个实例，白白浪费内存，这样的情况Android早就替我们考虑好了。Android为Activity 的创建提供了4种启动模式，而依据实际应用场景的不同。为Activity 选择不同的启动模式，最大化降低了每次都须要在栈中创建一个新的Activity的压力，降低内存使用。 启动模式的具体说明和使用场景？以下依据这篇博文来一一解惑。 一. Android启动模式具体解释 1. Standard 标准模式说明： Android创建Activity时的默认模式，假设没有为Activity设置启动模式的话，默觉得标准模式。每次启动一个Activity都会又一次创建一个新的实例入栈，无论这个实例是否存在。 生命周期：如上所看到的，每次被创建的实例Activity 的生命周期符合典型情况，它的onCreate、onStart、onResume都会被调用。 举例：此时Activity 栈中以此有A、B、C三个Activity，此时C处于栈顶，启动模式为Standard 模式。 若在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。结果是还有一个C Activity进入栈中，成为栈顶。 2. SingleTop 栈顶复用模式说明：分两种处理情况： 须要创建的Activity已经处于栈顶时，此时会直接复用栈顶的Activity。不会再创建新的Activity； 若须要创建的Activity不处于栈顶，此时会又一次创建一个新的Activity入栈，同Standard模式一样。 生命周期：若情况一中栈顶的Activity被直接复用时，它的onCreate、onStart不会被系统调用，由于它并没有发生改变。可是一个新的方法 onNewIntent会被回调（Activity被正常创建时不会回调此方法）。 举例：此时Activity 栈中以此有A、B、C三个Activity，此时C处于栈顶，启动模式为SingleTop 模式。情况一：在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。 结果是直接复用栈顶的C Activity。 情况二：在C Activity中加入点击事件，须要跳转到还有一个A Activity。结果是创建一个新的Activity入栈。成为栈顶。 3. SingleTask 栈内复用模式说明：若须要创建的Activity已经处于栈中时，此时不会创建新的Activity，而是将存在栈中的Activity上面的其他Activity所有销毁，使它成为栈顶。 生命周期：同SingleTop 模式中的情况一同样。仅仅会又一次回调Activity中的 onNewIntent方法 举例：此时Activity 栈中以此有A、B、C三个Activity。此时C处于栈顶，启动模式为SingleTask 模式。 情况一：在C Activity中加入点击事件，须要跳转到还有一个同类型的C Activity。结果是直接用栈顶的C Activity。情况二：在C Activity中加入点击事件，须要跳转到还有一个A Activity。 结果是将A Activity上面的B、C所有销毁，使A Activity成为栈顶。 4. SingleInstance 单实例模式说明： SingleInstance比較特殊，是全局单例模式，是一种加强的SingleTask模式。它除了具有它所有特性外，还加强了一点：具有此模式的Activity仅仅能单独位于一个任务栈中。 这个经常使用于系统中的应用，比如Launch、锁屏键的应用等等，整个系统中仅仅有一个！所以在我们的应用中一般不会用到。了解就可以。 举例：比方 A Activity是该模式，启动A后。系统会为它创建一个单独的任务栈，由于栈内复用的特性。兴许的请求均不会创建新的Activity，除非这个独特的任务栈被系统销毁。 二.启动模式的使用方式1. 在 Manifest.xml中指定Activity启动模式一种静态的指定方法，在Manifest.xml文件里声明Activity的同一时候指定它的启动模式，这样在代码中跳转时会依照指定的模式来创建Activity。样例例如以下： 123&lt;activity android:name="..activity.MultiportActivity" android:launchMode="singleTask"/&gt; 2. 启动Activity时。在Intent中指定启动模式去创建Activity一种动态的启动模式，在new 一个Intent后，通过Intent的addFlags方法去动态指定一个启动模式。样例例如以下： 1234Intent intent = new Intent();intent.setClass(context, MainActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);context.startActivity(intent); 注意：以上两种方式都能够为Activity指定启动模式，可是二者还是有差别的。 （1）优先级：动态指定方式即另外一种比第一种优先级要高，若两者同一时候存在，以另外一种方式为准。（2）限定范围：第一种方式无法为Activity直接指定 FLAG_ACTIVITY_CLEAR_TOP 标识，另外一种方式无法为Activity指定 singleInstance 模式。 三. Activity 的 Flags标记位既能够设定Activity的启动模式，如同上面介绍的，在动态指定启动模式，比方 FLAG_ACTIVITY_NEW_TASK 和 FLAG_ACTIVITY_SINGLE_TOP 等。它还能够影响Activity 的运行状态 ，比方 FLAG_ACTIVITY_CLEAN_TOP 和 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 等。 以下介绍几个基本的标记位，切勿死记，理解几个就可以，须要时再查官方文档。 1. FLAG_ACTIVITY_NEW_TASK作用是为Activity指定 “SingleTask”启动模式。跟在AndroidMainfest.xml指定效果同样。 2. FLAG_ACTIVITY_SINGLE_TOP作用是为Activity指定 “SingleTop”启动模式，跟在AndroidMainfest.xml指定效果同样。 3. FLAG_ACTIVITY_CLEAN_TOP具有此标记位的Activity，启动时会将与该Activity在同一任务栈的其他Activity出栈。一般与SingleTask启动模式一起出现。它会完毕SingleTask的作用。但事实上SingleTask启动模式默认具有此标记位的作用 4.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS具有此标记位的Activity不会出如今历史Activity的列表中，使用场景：当某些情况下我们不希望用户通过历史列表回到Activity时，此标记位便体现了它的效果。它等同于在xml中指定Activity的属性： 1android:excludeFromRecents="trure" 四. 启动模式的实际应用场景这四种模式中的Standard模式是最普通的一种，没有什么特别注意。而SingleInstance模式是整个系统的单例模式，在我们的应用中一般不会应用到。所以，这里就具体解说 SingleTop 和 SingleTask模式的运用场景： 1. SingleTask模式的运用场景最常见的应用场景就是保持我们应用开启后仅仅有一个Activity的实例。最典型的样例就是应用中展示的主页（Home页）。 假设用户在主页跳转到其他页面，运行多次操作后想返回到主页，假设不使用SingleTask模式，在点击返回的过程中会多次看到主页，这明显就是设计不合理了。 2. SingleTop模式的运用场景假设你在当前的Activity中又要启动同类型的Activity，此时建议将此类型Activity的启动模式指定为SingleTop，能够降低Activity的创建，节省内存！ 3. 注意：复用Activity时的生命周期回调这里还须要考虑一个Activity跳转时携带页面參数的问题。 由于当一个Activity设置了SingleTop或者SingleTask模式后，跳转此Activity出现复用原有Activity的情况时，此Activity的onCreate方法将不会再次运行。onCreate方法仅仅会在第一次创建Activity时被运行。 而一般onCreate方法中会进行该页面的数据初始化、UI初始化，假设页面的展示数据无关页面跳转传递的參数，则不必操心此问题，若页面展示的数据就是通过getInten() 方法来获取，那么问题就会出现：getInten()获取的一直都是老数据，根本无法接收跳转时传送的新数据！ 以下，通过一个样例来具体解释： 1234&lt;activity android:name=".activity.CourseDetailActivity" android:launchMode="singleTop" android:screenOrientation="portrait" /&gt; 12345678910111213141516171819202122public class CourseDetailActivity extends BaseActivity&#123; ...... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_course_detail_layout); initData(); initView(); &#125; //初始化数据 private void initData() &#123; Intent intent = getIntent(); mCourseID = intent.getStringExtra(COURSE_ID); &#125; //初始化UI private void initView() &#123; ...... &#125; ......&#125; 以上代码中的CourseDetailActivity在配置文件里设置了启动模式是SingleTop模式，依据上面启动模式的介绍可得知，当CourseDetailActivity处于栈顶时。再次跳转页面到CourseDetailActivity时会直接复用原有的Activity，并且此页面须要展示的数据是从getIntent(）方法得来，可是initData()方法不会再次被调用，此时页面就无法显示新的数据。 当然这样的情况系统早就为我们想过了，这时我们须要另外一个回调 onNewIntent（Intent intent）方法。此方法会传入最新的intent，这样我们就能够解决上述问题。这里建议的方法是又一次去setIntent。然后又一次去初始化数据和UI。代码例如以下所看到的： 12345678910/** 复用Activity时的生命周期回调*/ @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); setIntent(intent); initData(); initView(); &#125; 这样，在一个页面中能够反复跳转并显示不同的内容。 启动模式事实上是初学Android时会学到的知识点，曾经也是一知半懂，有些知识点事实上跟设计模式一样，你不去使用而仅仅是学习并不是能够掌握到精髓，仅仅有真正去使用才会将这些变成你自己的，文章部分内容參考了《Android开发艺术探索》。好书推荐。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IPC 进程间通信]]></title>
    <url>%2Fposts%2Fef58aead.html</url>
    <content type="text"><![CDATA[什么是IPCIPC(Inter-Process Communication) 进程间通信，是指两个不同进程之间数据交换的过程。 在明确其之前，需要先搞懂几个概念: 线程：CPU可调度的最小单位，是程序执行流的最小单元；线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。 进程： 一个执行单元，在PC 和移动设备上一般指一个程序或者应用，一个进程可以包含多个线程。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。 在Android程序中，一般情况下一个程序就是一个进程（在无特别的代码实现下），UI线程即主线程。如果有耗时操作，则会导致主线程堵死。而在Android中主线程负责UI，和用户交互，如果堵塞UI线程会影响用户体验。所以Android要求要将耗时操作放在子线程中执行。 IPC 使用场景 程序因为自身原因，需要采用多进程模式来实现。 有些模块由于特殊原因需要运行运行在单独的进程中。 为了加大一个应用可使用的内存所以需要通过多进程来获取内存空间。 当前应用需要向其他应用获取数据。由于是两个应用，即两个进程。 在Android 中，每一个应用可使用的内存大小有限制，早起的一些版本在16M左右，不同的设备有不同的大小。可以通过多进程获取多份内存空间。 Android多进程如何开启多进程Android中开启多进程只有一种方法，便是给四大组件指定android:process属性，除此之外没有其他方法。 请注意，不能指定某一个线程或者实体类指定其所运行的进程。 通过jni调用底层去开启多进程也是一种方法，但属于特殊情况，不进行考虑。 首先编写三个Activity，并在AndroidManifest.xml中注册： 12345678910111213141516&lt;activity android:name=".MainActivity" android:label="@string/app_name" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name="com.example.ipc.SecondActivity" android:process=":remote" /&gt;&lt;activity android:name="com.example.ipc.ThirdActivity" android:process=".remote" /&gt; 对MainActivity不进行指定，则默认为当前进程。 对SecondActivity指定属性android:process=”:remote”。 对ThirdActivity指定属性android:process=”.remote”。 注意SencodActivity和ThirdActivity的进程参数不同。 把三个页面都打开，通过DDMS可以看到三个进程的开启： 那么SecondActivity和ThirdActivity ，进程名不同有什么区别吗； 如果进程名以：开始，表示是要在当前的进程名前附加上当前的包名，表示该进程是本应用的私有进程，其他应用不可以和其跑在同一个进程。如果进程名不以:开始，表示不需附加包名信息，是一个完全的命名。同时该进程是全局进程，其他应用可以通过ShareUID和其跑在同一个进程中。 开启多进程存在的问题通过如上方式，很简单的变开启了多进程，但是，如果仅仅这样的话，会有大问题。 看下面一个例子。 添加一个公有的类，添加静态字段： 12345public class PublicContant &#123; public static int m = 1;&#125; 在MainActivity中Log一下并修改字段： 12345678910@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.i("info", PublicContant.m+""); PublicContant.m++; &#125; 在SecondActivity中打印log： 1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.i("info", PublicContant.m+""); &#125; 根据上面的逻辑，Log信息应该是1，和2 。但是呢，不是这样的。 原因分析： Android 为每一个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同虚拟机中访问同一个类对象会产生多个副本。 对于当前来说，进程com.example.ipc和com.example.ipc:remote都存在一个PublicContant类，并且这两个类是相互不干扰的，一个进程中修改了该值的对象，对其他进程中的该值不会造成任何影响。 运行在同一个进程中的组件是属于同一个虚拟机和同一个Application的。同理，运行在不同进程中的组件是属于两个不同的虚拟机和Application的。 根据如上所述，多进程所造成的问题分为如下几个方面： 静态成员和单例模式完全失效；如上分析，创建了不同的内存，多个对象，当然单例什么的都无效了。 线程同步机制完全失效 ；不是一块内存区域，线程锁当然无效了。 SharedPreference的可靠性下降 ；sharedPreference的底层实现是通过读写XML文件，两个进程去读写，并发显然是可能出现问题的。 Application会多次创建。 序列化和反序列化在了解多进程通信之前，我们需要了解两个基础的概念，序列化和反序列化。 序列化：将对象转化为可保存的字节序列（注意是对象）； 反序列：将字节序列恢复为对象的过程。 序列化和反序列的用途： 以某种存储形式使自定义对象序列化； 将对象从一个地方传递到另一个地方； 通过序列化在进程间传递对象。 在Android中实现序列化的方式有两种，Serializable和Parcelable。 SerializableSerializable是Java提供的一个序列化接口，他是一个空接口，是类实现该接口即可实现序列化。 123456789101112131415/** * Serializable 序列化对象 */public class Book implements Serializable &#123; /** * 序列化和反序列的关键 */ private static final long serialVersionUID = 1L; public int bookId; public String bookName;&#125; 在实现Serializable时候，编译器会提示，让我们添加serialVersionUID字段，该字段是一个关键的字段，后面会说。 相应的实现好了，那么如何写入和读取呢？ 写入： 1234567891011121314public void writeSerializable() &#123; try &#123; // 构造对象 Book book = new Book(); // 构造序列化输出字节流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("xxx.txt")); // 序列化对象 oos.writeObject(book); // 关闭流 oos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 读取： 12345678910111213public void readSerializable() &#123; try &#123; // 创建序列化读取字节流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream( "xxx.txt")); // 反序列化（读取）对象 Book book = (Book) ois.readObject(); // 关闭流 ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 在序列化时，如果我们序列化对象之后，改变了我们的类结构（添加或改变字段），甚至是修改了字段的类型，修改了类名，那么我们能反序列化成功吗。 那么关键就在于serialVersionUID字段。 如果我们不指定的话。在序列化时，会计算当前类结构的hash值并将该值赋给serialVersionUID，当反序列时，会比对该值是否相同，如果不相同，则无法序列化成功。 我们也可以手动指定，手动指定的好处是在类结构发生变化时，能够最大程度的反序列，当然前提是只是删除或添加了字段，如果是变量类型发生了变化，则依然无法反序列成功。 serialVersionUID 的工作机制：序列化时系统会把当前类的serialVersionUID写入序列化文件中，当反序列化时候系统会去检测文件中的serialVersionUID,看它是否和当前类的serialVersionUID一致，如果一致说明序列化类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化的类相比发生了某些变化。所以，我们最好指定serialVersionUID，避免他自定生成。 ParcelableParcelable是Android中特有的一种序列化方式，在intent传值时，通常使用该方式。 该方式实现序列化，依然实现Parcelable，然后实现一些该接口的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Book implements Parcelable &#123; public int bookId; public String bookName; @Override public int describeContents() &#123; // 返回当前对象的内容描述。几乎所有情况下都是返回0 return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; // 将当前对象写入到序列化结构中 dest.writeInt(bookId); dest.writeString(bookName); &#125; public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Parcelable.Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel source) &#123; //从序列化后的对象中创建原始的值 Book book = new Book(); book.bookId = source.readInt(); book.bookName = source.readString(); return book; &#125; @Override public Book[] newArray(int size) &#123; //创建指定长度的原始对象数组 return new Book[size]; &#125; &#125;;&#125; Parcelable实现两个方法，创建一个字段： 实现describeContents()：返回当前对象的内容描述。几乎所有情况下都是返回0。 实现public void writeToParcel(Parcel dest, int flags)：// 将当前对象写入到序列化结构中 构造Parcelable.Creator字段，该对象需要实现两个方法： public Book createFromParcel(Parcel source)：从序列化后的对象中创建原始的值。 public Book[] newArray(int size)：创建指定长度的原始对象数组。 Serializable和Parcelable的比较 Serializable是Java中的序列化接口，其使用起来简单但是开销较大，序列化和反序列化需要大量的I/O操作。 Parcelable是Android中的序列化方式，更适用于Android的平台上，他的缺点是使用起来稍微麻烦，但是效率很高。 Parcelable适合进程间的通信，运行期。Serializable适合文件存储即网络传输。 Android 进程间通信的方式使用Bundle 传输数据Android中的四大组件中，其中有三大组件（Activity,Service,Receiver）都支持Intent中传递Bundle数据，如果看其源码，会发现其也是实现了Parcelable接口，所以其能够在不同进程中传输。 当然在传输的过程中，其所传输的数据必须支持序列化。比如基本数据类型，字符串，Parcelable的实现类，Serializable的实现类。由于该方法非常常用，不在多说。 文件共享文件共享： 将对象序列化之后保存到文件中，在通过反序列，将对象从文件中读取。 在MainActvity中写写入对象 1234567891011121314151617181920212223/** * 写入序列化对象 */ public void wirte() &#123; Book book = new Book(); book.bookId = 1; book.bookName = "si"; try &#123; // 构造序列化输出字节流 ObjectOutputStream oos = new ObjectOutputStream( new FileOutputStream(PATH)); // 序列化对象 oos.writeObject(book); // 关闭流 oos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(book); &#125; 在SecondActivity中，读取文件（反序列化） 12345678910111213141516public void read() &#123; Book book = null; try &#123; // 创建序列化读取字节流 ObjectInputStream ois = new ObjectInputStream(new FileInputStream( MainActivity.PATH)); // 反序列化（读取）对象 book = (Book) ois.readObject(); // 关闭流 ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(book); &#125; 输出结果如下： 1206-28 09:20:47.916: com.example.ipc(进程名) I/System.out(12399): Book [bookId=1, bookName=si]06-28 09:20:53.376: com.example.ipc:remote（进程名） I/System.out(12866): Book [bookId=1, bookName=si] 分属不同的进程成功的获取到了共享的数据。 通过共享文件这种方式来共享数据对文件的格式是没有具体的要求的。比如可以是文件，也可以是Xml、JSON 等。只要读写双方约定一定的格式即可。 同文件共享方式也存在着很大的局限性。即并发读/ 写的问题。读/写会造成数据不是最新。读写很明显会出现错误。 文件共享适合在对数据同步要求不高的进程之间进行通信。并且要妥善处理并发读写的问题。 SharedPreference 底层文件的方式。不适合在多进程中共享数据。 MessengerMessenger 可以翻译为信使，通过该对象，可以在不同的进程中传递Message对象。注意，两个单词不同。 下面就通过服务端（Service）和客户端(Activity)的方式进行演示。 客户端向服务端发送消息，可分为以下几步。 服务端 创建Service 构造Handler对象，实现handlerMessage方法。 通过Handler对象构造Messenger信使对象。 通过Service的onBind()返回信使中的Binder对象。 客户端 创建Actvity 绑定服务 创建ServiceConnection,监听绑定服务的回调。 通过onServiceConnected()方法的参数，构造客户端Messenger对象 通过Messenger向服务端发送消息。 实现服务端 1234567891011121314151617181920212223242526public class MessengerService extends Service &#123; /** * 构建handler 对象 */ public static Handler handler = new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; // 接受客户端发送的消息 String msgClient = msg.getData().getString("msg"); Log.i("messenger","接收到客户端的消息--"+msgClient); &#125;; &#125;; // 通过handler 构建Mesenger 对象 private final Messenger messenger = new Messenger(handler); @Override public IBinder onBind(Intent intent) &#123; // 返回binder 对象 return messenger.getBinder(); &#125;&#125; 注意：MessengerService需要在AndroidManifest.xml中注册。 实现客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class MessengerActivity extends AppCompatActivity &#123; /** * Messenger 对象 */ private Messenger mService; private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // IBinder 对象 // 通过服务端返回的Binder 对象 构造Messenger mService = new Messenger(service); Log.i("messenger", "客户端以获取服务端Messenger对象"); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger); // 启动服务 Intent intent = new Intent(this, MessengerService.class); bindService(intent, conn, BIND_AUTO_CREATE); &#125; /** * 布局文件中添加了一个按钮，点击该按钮的处理方法 * @param view */ public void send(View view) &#123; try &#123; // 向服务端发送消息 Message message = Message.obtain(); Bundle data = new Bundle(); data.putString("msg", "lalala"); message.setData(data); // 发送消息 mService.send(message); Log.i("messenger","向服务端发送了消息"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出结果如下： 注释很清楚，不在多说，按照流程实现即可。 其中有一点需要注意： 我们是通过Message作为媒介去携带数据的。但是，Message的obj 并没有实现序列化（实现Serializable或Parcelable）,也就是其不能保存数据。必须使用message.setData()方法去传入一个Bundle对象，Bundle中保存需要传入的数据。 传递时使用的是Messenger.send(Message)方法。 服务端向客户端发送了消息，那么服务端向客户端发送消息也类似： 关键点： 客户端向服务端发送消息是，通过msg.replyTo将客户端Messenger对象传给服务端。 客户端代码进行修改： 创建客户端Handler和Messenger对象。 修改send()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 构建handler 对象 */ public static Handler handler = new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; // 接受服务端发送的消息 String msgService = msg.getData().getString("msg"); Log.i("messenger","接收到服务端的消息--"+msgService); &#125;; &#125;; // 通过handler 构建Mesenger 对象 private final Messenger messengerClient = new Messenger(handler); /** * 布局文件中添加了一个按钮，点击该按钮的处理方法 * @param view */ public void send(View view) &#123; try &#123; // 向服务端发送消息 Message message = Message.obtain(); Bundle data = new Bundle(); data.putString("msg", "lalala"); message.setData(data); // ----- 传入Messenger 对象 message.replyTo = messengerClient; // 发送消息 mService.send(message); Log.i("messenger","向服务端发送了消息"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 服务端代码修改： 123456789101112131415161718192021222324252627282930313233/** * 构建handler 对象 */ public static Handler handler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; // 接受客户端发送的消息 String msgClient = msg.getData().getString("msg"); Log.i("messenger", "接收到客户端的消息--" + msgClient); // 获取客户端Messenger 对象 Messenger messengetClient = msg.replyTo; // 向客户端发送消息 Message message = Message.obtain(); Bundle data = new Bundle(); data.putString("msg", "ccccc"); message.setData(data); try &#123; // 发送消息 messengetClient.send(message); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;; &#125;; 结果不再演示了。 AIDLAIDL是一种接口定义语言，用于约束两个进程间的通讯规则，供编译器生成代码，实现Android设备上的两个进程间通信(IPC)。 进程之间的通信信息，首先会被转换成AIDL协议消息，然后发送给对方，对方收到AIDL协议消息后再转换成相应的对象。 AIDL的关键便是Binder,关于Binder，后面的博客会分析。在这里之将如何使用它。 因为需要服务端和客户端共用aidl文件，所以最好单独建一个包，适合拷贝到客户端。 服务端： 添加如下包名：com.example.ipc.aidl 创建BookAidl.java,该对象需要作为传输。所以需要实现Parcelable。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class BookAidl implements Parcelable &#123; public int bookId; public String bookName; public BookAidl() &#123; super(); &#125; public BookAidl(int bookId, String bookName) &#123; super(); this.bookId = bookId; this.bookName = bookName; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(bookId); dest.writeString(bookName); &#125; public static final Parcelable.Creator&lt;BookAidl&gt; CREATOR = new Creator&lt;BookAidl&gt;() &#123; @Override public BookAidl[] newArray(int size) &#123; return new BookAidl[size]; &#125; @Override public BookAidl createFromParcel(Parcel source) &#123; BookAidl book = new BookAidl(); book.bookId = source.readInt(); book.bookName = source.readString(); return book; &#125; &#125;; @Override public String toString() &#123; return "BookAidl [bookId=" + bookId + ", bookName=" + bookName + "]"; &#125;&#125; 创建.aidl文件。因为需要用到BookAidl对象，所以需要先声明。 创建BookAidl.aidl文件，并手动添加。 123package com.example.ipc.aidl;Parcelable BookAidl; 创建IBookManager.aidl文件，接口文件，面向客户端调用： 12345678package com.example.ipc.aidl;import com.example.ipc.aidl.BookAidl;interface IBookManager&#123; List&lt;BookAidl&gt; getBookList(); void addBook(in BookAidl book);&#125; 写完之后clean一下工程，之后会在gen目录下生成对应的java文件。此java中的具体含义后面会解释，在此不做多述。 继续编写服务端，创建Service类。 12345678910111213141516171819202122232425262728293031323334353637383940public class BookService extends Service &#123; /** * 支持线程同步，因为其存在多个客户端同时连接的情况 */ private CopyOnWriteArrayList&lt;BookAidl&gt; list = new CopyOnWriteArrayList&lt;&gt;(); /** * 构造 aidl中声明的接口的Stub对象，并实现所声明的方法 */ private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;BookAidl&gt; getBookList() throws RemoteException &#123; return list; &#125; @Override public void addBook(BookAidl book) throws RemoteException &#123; list.add(book); Log.i("aidl", "服务端添加了一本书"+book.toString()); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); //加点书 list.add(new BookAidl(1, "java")); list.add(new BookAidl(2, "android")); &#125; @Override public IBinder onBind(Intent intent) &#123; // 返回给客户端的Binder对象 return mBinder; &#125;&#125; 在Service中，主要干了两件事情： 实现aidl文件中的接口的Stub对象。并实现方法。 将Binder对象通过onBinder返回给客户端。 为了省事，在这里不在另起一个工程了，直接将Service在另一个进程中运行。 123&lt;service android:name="com.example.ipc.BookService" android:process=":remote" /&gt; 开始编写客户端 因为在同一个工程中，不需要拷贝aidl包中的文件。如果不在同一个工程，需要拷贝。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class BookActivity extends AppCompatActivity&#123; /** * 接口对象 */ private IBookManager mService; /** * 绑定服务的回调 */ private ServiceConnection conn = new ServiceConnection()&#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // 获取到书籍管理的对象 mService = IBookManager.Stub.asInterface(service); Log.i("aidl", "连接到服务端，获取IBookManager的对象"); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_book); // 启动服务 Intent intent = new Intent(this,BookService.class); bindService(intent, conn, BIND_AUTO_CREATE); &#125; /** * 获取服务端书籍列表 * @param view */ public void getBookList(View view)&#123; try &#123; Log.i("aidl","客户端查询书籍"+mService.getBookList().toString()); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; /** * 添加书籍 */ public void add(View view)&#123; try &#123; // 调用服务端添加书籍 mService.addBook(new BookAidl(3,"iOS")); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 客户端的代码和之前的Messenger很类似： 绑定服务，监听回调。 将回调中的IBinder service通过IBookManager.Stub.asInterface（）转化为借口对象。 调用借口对象的方法。 效果 总结来说可分为如下几步 服务端： 服务端创建.aidl文件和声明接口 创建类，继承Service，并实现onBind方法 在Service类中定义aidl中声明接口的Stub对象，并实现aidl接口中声明的方法 在onBind方法中返回Stub对象 在AndroidManifest.xml中注册Service并声明其Action 客户端 使用服务端提供的aidl文件 在Activity定义aidl接口对象 定义ServiceConnection对象，监听绑定服务的回调 回调中通过方法获取借口对象 ContentProvider作为android 四大组件之一，虽然用的地方不是太多。但是其确实是多进程通信的一种方式。例如，获取通讯录信息，这明显跨应用了，肯定是多进程通信啊。 其底层实现和Messenger一样，都是通过Binder,后面会专门分析Binder对象。 ContentProvider很多介绍，在这不在多提。 SocketSocket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据报套接字，分别对应于网络传输中的传输控制层的TCP和UDP。 该方面使用的是JAVA 方面的知识。该举例只是说明一个思路。不做细致的实现。 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class SocketService extends Service &#123; /** * 连接的状态 */ private boolean isConnState = true; @Override public void onCreate() &#123; super.onCreate(); // 启动TCP 服务 new Thread(new TCPServer()).start(); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onDestroy() &#123; // 结束TCP 服务 isConnState = false; super.onDestroy(); &#125; /** * 服务端TCP 服务，相当于服务器，接受Socket 连接 * @author MH * */ class TCPServer implements Runnable&#123; @Override public void run() &#123; try &#123; // 监听本地的12345 端口 ServerSocket ss = new ServerSocket(12345); while(isConnState)&#123; // 获取客户端的Socket 对象 Socket socket = ss.accept(); // 获取输入流 --- BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 通过输入流读取客户端的消息 //String line = br.readLine(); // 输出流 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); // 通过输出流向客户端发送消息 //bw.write("...."); // 关闭连接 socket.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 服务启动时，在onCreate方法中启动了TCPServer，该线程时刻接受客户端的请求。 客户端 1234567891011121314151617public void conn()&#123; try &#123; // 指定ip和端口 Socket s = new Socket("localhost", 12345); // ----- 和服务端类似 BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream())); //String line = br.readLine(); // 输出流 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream())); //bw.write("...."); // 关闭连接 s.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 关于Socket，在此只是一个简单的示范。 Android 进程间通信不同方式的比较 Bundle:四大组件间的进程间通信方式，简单易用，但传输的数据类型受限。 文件共享： 不适合高并发场景，并且无法做到进程间的及时通信。 Messenger: 数据通过Message传输，只能传输Bundle支持的类型 ContentProvider：android 系统提供的。简单易用。但使用受限，只能根据特定规则访问数据。 AIDL:功能强大，支持实时通信，但使用稍微复杂。 Socket：网络数据交换的常用方式。不推荐使用。 Binder 的细致分析在实现多进程通信时，其中Messenger,ContentProvider,AIDL的底层实现都是Binder，很有必要对其进行继续分析。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle使用总结（二）]]></title>
    <url>%2Fposts%2F1f4ffc21.html</url>
    <content type="text"><![CDATA[一、自定义Android gradle工程1、defaultConfig默认配置 defaultConfig 是默认的配置，是一个ProductFlavour。对于多渠道打包，等情况，如果不针对自定义的是一个ProductFlavour单独配置的话，则默认使用defaultConfig的配置 （1）applicationId指定生成的app包名，对应值是 String，如：applicationId &quot;com.android.xx&quot; （2）minSdkVersionApp最低支持的Android操作系统版本，对应值是 int型（即对于sdk 的ApiLevel）如，minSdkVersion 25 （3）targetSdkVersion配置当前是基于哪个sdk版本进行开发，可选值与 minSdkVersion一样 （4）versionCode内部版本号，对应值是int型，用于配置Android App内部版本号，通常用于版本的升级 （5）versionName用于配置app的版本名称，对应值是String，如”v1.0.0”，让用户知道当前app版本。versionCode是内部使用，versionName是外部使用，一起配合完成app的版本升级控制。 （6）testApplicationId配置测试app的包名，默认是 applicationId + “.test”，一般情况下，用默认的即可。 （7）testInstrumentationRunner用于配置单元测试时使用的Runner，默认使用android.test.InstrumentationTestRunner。 （8）signingConfig配置默认的签名信息，对生成的app进行签名。对应值是SigningConfig对象。 具体使用，查看*配置签名信息*部分。 （9）proguardFile 和 proguardFiles两者都是配置混淆规则文件，区别是proguardFile接受一个文件对象，而proguardFiles可以同时接受多个。 （10）multiDexEnabled是否启动自动拆分多个Dex的功能，用于突破方法超过65535的设置，后面再具体介绍 1multiDexEnabled true 2、配置签名信息 Android Gradle 提供了signingConfigs{}配置块，用于生成多个签名配置信息，其类型是NamedDomainObjectContainer，因此，我们在signingConfigs{}中定义的都是一个SigningConfig的对象实例。 一个SigningConfig，即签名配置，可配置的元素有：storeFile: 签名文件位置；storeType：签名证书类型（可不填）；storePassword：签名证书密码；keyAlias：签名证书密钥别名；keyPassword：签名证书中的密钥的密码。如： 12345678signingConfigs&#123; release&#123; //生成了release的签名配置 storeFile file('../John.jks') storePassword '12345678' keyAlias 'key0' keyPassword '12345678' &#125; &#125; 注：debug签名文件一般位于$HOME/.android/debug.keystore 对于生成的签名配置，可以应用到 defaultConfig中的signingConfig进行默认签名配置或应用到buildTypes中针对构建类型进行签名配置。如： 1234567891011121314151617buildTypes &#123; release &#123; signingConfig signingConfigs.release //配置release类型签名 minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; defaultConfig &#123; applicationId "com.example.john.tapeview" minSdkVersion 24 targetSdkVersion 28 versionCode 1 versionName "1.0" signingConfig signingConfigs.release //配置默认签名 testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; 3、构建类型（buildTypes） buildTypes{} 和signingConfigs{}一样，都是Android 的一个方法，接收到也是域对象 NamedDomainObjectContainer，添加的每一个都是BuildType类型。 每一个BuildType都会生成一个SourceSet，默认位置是src//，因此，可以单独为其指定Java源代码和res资源等。且，新增的BuildType不能命名为 main 或 androidTest（因android默认已经生成），且相互之间不能同名。 （1）applicationIdSuffix用于配置基于applicationId的后缀，如applicationId为 com.John.gradle.sample , 在debug的buildType中指定 applicationIdSuffix &quot;.debug&quot;，则生成的debug的包名为com.John.gradle.sample.debug （2）signingConfig配置签名信息，使用同前面提到的 defaultConfig一样。 （3）启动zipAlign优化zipalign是android提供的整理优化apk的工具，能提高系统和应用的运行效率，更快读写apk资源，降低内存，所以，对于发布的apk，一般开启 zipAlignEnabled true //true为开启 （4）资源清理shrinkResources用于配置是否自动清理未使用的资源，true为开启，false为关闭。需结合混淆使用。 （5）使用混淆 minifyEnabled启用混淆可以优化代码，同时结合shrinkResources清理资源，可以缩小apk包，还可以混淆代码。一般发布的都是要混淆的。 开启混淆：minifyEnabled true //true为开启；使用proguardFile和proguardFiles设置混淆规则文件，两者区别如前面defaultConfig中说明。 注：对于多渠道打包，每个productFlavor都可以单独配置混淆规则文件（通过各自的proguardFile和proguardFiles）。 （6）multiDexEnabled是否启动自动拆分多个Dex的功能，用于突破方法超过65535的设置，后面再具体介绍 1multiDexEnabled true （7）debuggable 和 jniDebuggabledebuggable：是否生成一个可供调试的apk，对应值为boolean类型； jniDebuggable：是否生成一个可供调试Jni（C/C++）代码的apk，对应值为boolean类型； 二、Android gradle高级自定义1、批量修改生成的apk文件名Android Gradle提供了3个属性，applicationVariants（仅仅适用于Android 应用Gradle插件），和libraryVariants（仅仅适用于Android库gradle插件），testVariants（以上两种都适用） applicationVariants是一个集合，每一个元素都是一个生成的产物，即 xxxRelease 和 xxxDebug 等（即生成apk） ，它有一个outputs作为输出集合。遍历，若名字以.apk结尾，那么就是要修改的apk输出。 1234567891011//动态改变生成的apk的名字： 项目名_渠道名_v版本名_构建日期.apk applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; output -&gt; if (output.outputFile != null &amp;&amp; output.outputFile.name.endsWith('.apk') &amp;&amp;'release'==(variant.buildType.name)) &#123; def flavorName = variant.flavorName.startsWith("_") ? variant.flavorName.substring(1) : variant.flavorName def apkFileName = "Example92_$&#123;flavorName&#125;_v$&#123;variant.versionName&#125;_$&#123;buildTime()&#125;.apk" outputFileName = apkFileName &#125; &#125; &#125; 2、多方式配置 VersionCode 和 VersionName（1）通过应用脚本插件（apply from） 新建一个version.gradle（当前存放在项目路径下的gradle文件夹中），并设置自定义属性 1234ext&#123; appVersionCode = 1 appVersionName = '1.0.2'&#125; 在rootProject中应用该脚本文件 1apply from : 'gradle/version.gradle' 可在任意子工程中引用该设置： （2）直接在属性文件（xxx.properties）中定义使用 在工程目录下的gradle.properties中定义 可在任意子工程中引用该设置： （3）从 git 的 tag 上获取 VersionName 和 versionCode12345678910111213141516171819202122232425/** * 以git tag的数量作为其版本号 * @return tag的数量 */def static getAppVersionCode()&#123; def stdout = new ByteArrayOutputStream() exec &#123; commandLine 'git','tag','--list' standardOutput = stdout &#125; return stdout.toString().split("\n").size()&#125;/** * 从git tag中获取应用的版本名称 * @return git tag的名称 */def static getAppVersionName()&#123; def stdout = new ByteArrayOutputStream() exec &#123; commandLine 'git','describe','--abbrev=0','--tags' standardOutput = stdout &#125; return stdout.toString().replaceAll("\n","")&#125; 3、动态配置AndroidManifest文件 在构建过程，动态修改AndroidManifest文件中的内容 android gradle 提供了非常便捷的方法替换AndroidManifest文件中的内容，即manifestPlaceholder、Manifest占位符。 manifestPlaceholders是ProductFlavor的一个属性，Map类型，所以可以同时配置多个占位符。 定义占位符： 123456789101112...productFlavors&#123; google&#123; manifestPlaceholders.put("UMENG_CHANNEL","google") &#125; baidu&#123; manifestPlaceholders.put("UMENG_CHANNEL","baidu") &#125;&#125;... 在AndroidManifes中使用这个占位符 “UMENG_CHANNEL” 1234567...&lt;application&gt; ... &lt;meta-data android:value="$&#123;UMENG_CHANNEL&#125;" android:name = "UMENG_CHANNEL"/&gt; ...&lt;/application&gt;... 亦可以迭代修改占位符 1234567891011...productFlavors&#123; google&#123; &#125; baidu&#123; &#125; &#125;productFlavors.all&#123;flavor-&gt; manifestPlaceholders.put("UMENG_CHANNEL",flavor.name)&#125;... 4、自定义BuildConfigAndroid gradle提供了buildConfigField(Srting type,String name ,String value) 来实现添加常量到BuildConfig中。一般在productFlavors或buildTypes中使用: 注：对于value是String类型的，双引号一定得加上，这里写了什么，buildConfig会原封不动放上去 1234567891011...productFlavors&#123; google&#123; //对于value是String类型的，双引号一定得加上，这里写了什么，buildConfig会原封不动放上去 buildConfigField 'String','name','"google"' &#125; baidu&#123; buildConfigField 'String','name','"baidu"' &#125;&#125;... 5、动态添加自定义的资源Android gradle提供了resValue(String type,String name,String value)来 添加资源。只能在productFlavors或buildTypes中使用 注：这里写了什么，编译出来后也会原封不动放上去 6、Dex选项配置123456789101112android &#123; ... dexOptions &#123; incremental true //android studio3.x以上已废弃，是否开启dx增量模式 javaMaxHeapSize '4g' //提高java执行dx命令时的最大分配内存 jumboMode true //强制开启jumboMode模式，让方法超过65535也构建成功 pre &#125; ...&#125; 7、编译选项和adb操作选项123456789101112131415android &#123; ... compileOptions &#123; encoding = 'utf-8' sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125; adbOptions&#123; timeOutInMs = 5000 //设置超时时间，单位 ms installOptions '-r','-s'//安装选项，一般不使用 &#125; ...&#125; 8、突破方法超过65535的限制 在defaultConfig或buildTypes或productFlavors中，开启multiDexEnabled：multiDexEnabled true 增加依赖：implementation &#39;com.android.support:multidex:1.0.3&#39; 在自定义的 Application 中设置（5.0以上天然支持）： 使自定义的Application继承MultiDexApplication 或直接在java代码中修改： 1234567...@Overrideprotected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this);&#125;... 多渠道构建 一个构建产物（apk），即Build Variant = BuildType + ProductFlavor，其中ProductFlavor又进一步划分dimensions，即Build Variant = BuildType + ProductFlavor’s dimensions 1、多渠道构建ProductFlavor属性1234567...productFlavors&#123; google&#123; applicationId "com.john.xxx" &#125;&#125;... （1）applicationId，跟前面所述一样。（2）manifestPlaceholders，跟前面所述一样。（3）multiDexEnabled，跟前面所述一样。（4）proguardFiles，跟前面所述一样。（5）signingConfig，跟前面所述一样。（6）testApplicationId，跟前面所述一样。（7）versionCode 和 versionName，跟前面所述一样。（8）dimension 作为ProductFlavor的维度，可理解为ProductFlavor的分组 如，free 和 paid 属于version分组，而x86 和 arm属于架构分组： 1234567891011121314151617181920android&#123; ... flavorDimensions "version","abi" //定义分组 productFlavors&#123; free&#123; dimension 'version' &#125; paid&#123; dimension 'version' &#125; x86&#123; dimension 'abi' &#125; arm&#123; dimension 'abi' &#125; &#125; ...&#125; 对于以上的设置，Build Variant = BuildType + ProductFlavor’s dimensions，则生成的assemble任务， 即variant： ArmFreeDebug ArmFreeRelaese ArmPaidDebug ArmPaidRelease X86FreeDebug X86FreeRelaese X86PaidDebug X86PaidRelease 参考链接Android Developer官网]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle使用总结（一）]]></title>
    <url>%2Fposts%2F2f5910f9.html</url>
    <content type="text"><![CDATA[Gradle是一款优秀的构建系统工具，它的DSL(领域特定语言)基于Groovy实现，可以方便地通过代码控制这些DSL来达到构建的目的。 注：执行gradle命令时，默认加载当前目录下的build.gradle文件，亦可以通过-b 指定要加载的执行文件，如： gradlew -b ./app/build.gradle assemble Gradle常用基础1、记得使用帮助（1）查看所有可执行的任务（Tasks）1gradlew tasks Gradle会以分组的方式列出task列表，比如构建类的 assemable，帮助类的 help等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283------------------------------------------------------------All tasks runnable from root project------------------------------------------------------------Android tasks-------------androidDependencies - Displays the Android dependencies of the project.signingReport - Displays the signing info for each variant.sourceSets - Prints out all the source sets defined in this project.Build tasks-----------assemble - Assembles all variants of all applications and secondary packages.assembleAndroidTest - Assembles all the Test applications.assembleDebug - Assembles all Debug builds.assembleRelease - Assembles all Release builds.build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it.buildNeeded - Assembles and tests this project and all projects it depends on.bundleDebug - Creates all Debug bundles.bundleRelease - Creates all Release bundles.clean - Deletes the build directory.cleanBuildCache - Deletes the build cache directory.compileDebugAndroidTestSourcescompileDebugSourcescompileDebugUnitTestSourcescompileReleaseSourcescompileReleaseUnitTestSourcesBuild Setup tasks-----------------init - Initializes a new Gradle build.wrapper - Generates Gradle wrapper files.Cleanup tasks-------------lintFix - Runs lint on all variants and applies any safe suggestions to the source code.Help tasks----------buildEnvironment - Displays all buildscript dependencies declared in root project 'tapeView'.components - Displays the components produced by root project 'tapeView'. [incubating]dependencies - Displays all dependencies declared in root project 'tapeView'.dependencyInsight - Displays the insight into a specific dependency in root project 'tapeView'.dependentComponents - Displays the dependent components of components in root project 'tapeView'. [incubating]help - Displays a help message.model - Displays the configuration model of root project 'tapeView'. [incubating]projects - Displays the sub-projects of root project 'tapeView'.properties - Displays the properties of root project 'tapeView'.tasks - Displays the tasks runnable from root project 'tapeView' (some of the displayed tasks may belong to subprojects).Install tasks-------------installDebug - Installs the Debug build.installDebugAndroidTest - Installs the android (on device) tests for the Debug build.installRelease - Installs the Release build.uninstallAll - Uninstall all applications.uninstallDebug - Uninstalls the Debug build.uninstallDebugAndroidTest - Uninstalls the android (on device) tests for the Debug build.uninstallRelease - Uninstalls the Release build.Verification tasks------------------check - Runs all checks.connectedAndroidTest - Installs and runs instrumentation tests for all flavors on connected devices.connectedCheck - Runs all device checks on currently connected devices.connectedDebugAndroidTest - Installs and runs the tests for debug on connected devices.deviceAndroidTest - Installs and runs instrumentation tests using all Device Providers.deviceCheck - Runs all device checks using Device Providers and Test Servers.lint - Runs lint on all variants.lintDebug - Runs lint on the Debug build.lintRelease - Runs lint on the Release build.lintVitalRelease - Runs lint on just the fatal issues in the release build.test - Run unit tests for all variants.testDebugUnitTest - Run unit tests for the debug build.testReleaseUnitTest - Run unit tests for the release build.To see all tasks and more detail, run gradle tasks --allTo see more detail about a task, run gradle help --task &lt;task&gt;BUILD SUCCESSFUL in 18s1 actionable task: 1 executed （2）Gradle Help任务gradle内置的help任务，可以了解每一个Task的使用帮助，用法是gradlew help --task &lt;taskName&gt; 如：gradlew help --task assemable 2、强制刷新依赖1gradlew --refresh-dependencies assemable 3、多任务执行只需按顺序以空格分开即可，如gradlew clean jar，先执行clean再执行生成jar 4、自定义属性自定义属性具有更广泛的作用域，可以跨Project，跨Task访问。只要能访问这些属性所属的对象，那么这些属性就可以被访问到。 123456789101112131415161718192021222324252627282930313233343536373839apply plugin: "java"ext.age = 18 //自定义一个属性//自定义多个属性ext&#123; phone = '020' address = '' dep = [android : "androidan"] //map&#125;sourceSets.all&#123; ext.resourcesDir = null&#125;sourceSets &#123; main&#123; resourcesDir="main/res" &#125; test&#123; resourcesDir="test/res" &#125;&#125;task customProperty&#123; doLast&#123; println "age: $&#123;age&#125;" println "phone: $phone" println "address: $address" println "android: $&#123;dep.android&#125;" sourceSets.each&#123; println"$&#123;it.name&#125;'s resourcesDir is: $&#123;it.resourcesDir&#125;" &#125; &#125; &#125; 5、任务的禁用和开启任务禁用时，当执行到该任务，会skip掉 1234567task task1&#123; doLast&#123; println 'xxx' &#125;&#125;task1.enabled = false; //false:禁用，true:开启 6、任务的onlyif 断言任务有一个onlyIf方法，接收一个闭包作为参数，如果该闭包返回true，则该任务执行，否则跳过 以键值对的形式添加属性：-PK=V，中间不能有空格 ，如：gradle -Pbuild_apps=shoufa build 12345678910111213141516171819202122232425262728293031323334final String BUILD_APPS_ALL="all";final String BUILD_APPS_SHOUFA="shoufa";final String BUILD_APPS_EXCLUDE_SHOUFA="exclude_shoufa";task QQRelease&#123; doLast&#123; println "QQRelease" &#125; &#125;task BaiduRelease&#123; doLast&#123; println "BaiduRelease" &#125; &#125;task build&#123; group BasePlugin.BUILD_GROUP description '打渠道包' dependsOn QQRelease,BaiduRelease&#125;QQRelease.onlyIf&#123; if (project.hasProperty('build_apps')) &#123; Object buildApps = project.property("build_apps") if (BUILD_APPS_SHOUFA.equals(buildApps)) &#123; return false &#125; &#125; return true;&#125;//gradle -Pbuild_apps=shoufa build; //以键值对的形式添加属性：-PK=V，中间不能有空格 7、脚本即代码，代码也是脚本虽然Gradle是个脚本文件，但写的依旧是代码，Groovy是兼容Java的，能灵活实现很多功能。如，给生成的apk以当前时间命名： 12345def buildTime()&#123; def date = new Date() def formattedDate = data.format('yyyyMMdd') return formattedDate&#125; Groovy基础1、字符串单引号和双引号都能定义字符串。区别在于，单引号表示纯粹的字符串常量，而双引号具有运算能力。 如: 1234def name = "John"println '单引号$&#123;name&#125;' //输出: 单引号$&#123;name&#125;println "双引号$&#123;name&#125;" //输出: 双引号Johnprintln "双引号$name" //输出: 双引号John 一个美元符号紧接着一对花括号，花括号里放表达式，如${name}，当只有一个变量时，可以省略花括号，如$name; 2、集合（1）List12345def nums = [1,2,3,4] //定义arrayListprintln nums[1] //下标索引访问nums.each&#123; println it //forEach,其中it变量为正在迭代的元素&#125; （2）Map123456def map = ['width':1024,'height':768] //定义mapprintln map['width'] //访问println map.height //访问map.each&#123; println "Key:$&#123;it.key&#125;,Value:$it.value" //forEach,被变量的是Map.Entry&#125; （3）方法 括号是可以忽略的 12345method1(2,3) //method1 2,3 //可忽略括号，def method1(int a,int b)&#123; println a+b&#125; return 是可以不写的，最后一句代码作为其返回值 1234567def method2(int a,int b)&#123; if(a&gt;b)&#123; a //即return a; &#125;else &#123; b //即return b; &#125;&#125; 代码块/方法是可以作为参数传递的 12345678910111213141516171819202122//呆板写法nums.each(&#123;println it&#125;)//格式化一些nums.each(&#123; println it&#125;)//Groovy中，如果方法的最后一个参数是 闭包，则可以放到方法外面nums.each()&#123; println it&#125;//然后省略括号，则变成常见的样式nums.each&#123; println it&#125;//多参数调用eachMap&#123;k,v-&gt; println "$k is $v"&#125; JavaBean,可以很容易地访问和修改属性值，而不用通过getter/setter，因Groovy内部已帮我们搞定好。 12345678def Person p = new Person()println "name is $p.name" //输出nullp.name = "John" println "name is $p.name" //输出Johnclass Person &#123; private String name&#125; 闭包委托 Groovy的闭包有thisObject、owner和delegate三个属性，一般是thisObject&gt;owner&gt;delegate，但可以修改delegate。一般指定delegate为当前it，这样就可以在闭包内对该it进行配置，或调用其方法。 12345678910111213141516171819202122232425262728293031task delegate&#123; doLast&#123; person&#123; name = "cap" //在闭包内对该it进行配置 age = 20 //在闭包内对该it进行配置 dumpPersion() //在闭包内对该it调用其方法 &#125; &#125;&#125;def dumpPersion()&#123; println "project delegate"&#125;class Person&#123; private String name private int age def dumpPersion()&#123; println "name:$&#123;name&#125;;age:$&#123;age&#125;" &#125;&#125;def person(Closure&lt;Person&gt; closure)&#123; Person p = new Person() closure.delegate = p //设置委托 closure.setResolveStrategy(Closure.DELEGATE_FIRST)//设置委托优先 closure(p)&#125; Gradle 插件1、Java Gradle 的sourceSets常用属性sourceSet，即源代码集合（Android的buildTypes和这个类似），用来描述和管理源代码和资源存放等功能。提供有sourceSets{}闭包放配置和生成sourceSet，如： 123456789101112131415sourceSets&#123; main&#123; //在这里可以对main sourceSet进行配置 java&#123; srcDir 'src/java' //更改了java源代码存放目录，默认是 src/main/java &#125; resources&#123; srcDir 'src/resources' //更改了资源文件存放目录，默认是 src/main/resources &#125; &#125; vip&#123; //生成了新的 vip sourceSet &#125;&#125; SourceSet常用属性： 属性名 类型 描述 name String 只读，如，main java SourceDirectorySet 该源集的java源文件 java.srcDirs Set 该源集的java源文件所在目录 resources SourceDirectorySet 该源集的资源文件 resources.srcDirs Set 该源集的资源文件的所在目录 output.classesDir File 该源集编译后的class文件目录 output.resourcesDir File 编译后生成的资源目录 compileClassPath FileCollection 编译该源集时所需的classPath 2、Android Gradle插件分类和三个sourceSetAndroid Gradle插件的分类是根据Anroid工程的属性分类的，在Android中，有3类： App应用工程插件id: com.android.application Library库工程插件id: com.android.library Test测试工程插件id: com.android.test 注：src目录下的androidTest，main，test分别是3个sourceSet，分别对应，Android单元测试代码，Android app主代码和资源，普通单元测试代码。 在main中，特有AndroidManifest.xml和res这两个Android特有的，用于描述Android App 配置和资源文件。]]></content>
      <categories>
        <category>Android</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨平台Flutterr，RN，Weex和原生Android的比较]]></title>
    <url>%2Fposts%2F59072e32.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常用库和插件]]></title>
    <url>%2Fposts%2Fbb30f1ae.html</url>
    <content type="text"><![CDATA[下拉刷新PullLoadMoreRecyclerView 实现RecyclerView下拉刷新和上拉加载更多以及RecyclerView线性、网格、瀑布流效果演示 https://github.com/WuXiaolong/PullLoadMoreRecyclerView start 1247 android-Ultra-Pull-To-Refresh 这是现在已经停止维护的下拉刷新项目的替代方案。继承于ViewGroup可以包含任何View。功能比SwipeRefreshLayout强大。使用起来非常简单。良好的设计，如果你想定制自己的UI样式，非常简单，就像给ListView加一个Header View那么简单。 https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh start 9322 SmartRefreshLayout 下拉刷新、上拉加载、二级刷新、淘宝二楼、RefreshLayout、OverScroll，Android智能下拉刷新框架，支持越界回弹、越界拖动，具有极强的扩展性，集成了几十种炫酷的Header和 Footer。 https://github.com/scwang90/SmartRefreshLayout start 14453 一个实用的多条件筛选菜单DropDownMenu 一个实用的多条件筛选菜单，在很多App上都能看到这个效果，如美团，爱奇艺电影票等 https://github.com/dongjunkun/DropDownMenu start 2997 强大易用的安卓工具类库AndroidUtilCode 是一个强大易用的安卓工具类库，它合理地封装了安卓开发中常用的函数，具有完善的 Demo 和单元测试，利用其封装好的 APIs 可以大大提高开发效率，如今它主要包括两部分模块，其一是主工具类模块：utilcode，其中的工具类是开发中常用到的；其二是子工具类模块：subutil，它包含的工具类并不是很常用，它的出现是为了防止主工具类的臃肿。 https://github.com/Blankj/AndroidUtilCode start 20125 SuperUtils 囊括了一大部分Android应用开发过程当中常用的工具类。工具类来源整理自网络和自己编写。 https://github.com/AllenCoder/SuperUtils start 310 Android第三方相册选择器Matisse 知乎开源相册 https://github.com/hamuamu0/Matisse start 7881 ImagePicker 完全仿微信的图片选择 https://github.com/jeasonlzy/ImagePicker start 3262 PictureSelector 一款针对android平台下的图片选择器，支持从相册或拍照选择图片或视频、音频，支持动态权限获取、裁剪(单图or多图裁剪)、压缩、主题自定义配置等功能、适配android 6.0+系统的开源图片选择框架。 https://github.com/LuckSiege/PictureSelector start 4762 ImagePicker 一款功能超强的图片选择器。支持超大图预览(比如10000*5000的图)，支持图片裁剪，可配置头像模式和普通模式，支持动态配置ImageLoader以支持多种图片加载库，以及实现流畅的跳转动画 https://github.com/martin90s/ImagePicker start 832 TakePhoto 一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 https://github.com/crazycodeboy/TakePhoto start 5553 Album https://github.com/yanzhenjie/Album start 1802 可用于动态生成验证码，常见于金融类appVerificationCodeView https://github.com/Freshman111/VerificationCodeView start 354 类似于微信侧滑返回上一级Activity的工具SwipeBackHelper https://github.com/Jude95/SwipeBackHelper/blob/master/README_ch.md start 1266 SwipeBackLayout https://github.com/ikew0ng/SwipeBackLayout start 5352 Banner轮播ViewPagerandroid-auto-scroll-view-pager https://github.com/Trinea/android-auto-scroll-view-pager start 1603 UltraViewPager UltraViewPager是一个封装多种特性的ViewPager，主要是为多页面切换场景提供统一解决方案。支持横划竖划；支持一屏内显示多页；支持循环滚动；支持定时滚动，计时器使用Handler实现 https://github.com/alibaba/UltraViewPager start 3942 ViewPagerIndicator Indicator 取代 tabhost，实现网易顶部tab，新浪微博主页底部tab，引导页，无限轮播banner等效果，高度自定义tab和特效 https://github.com/LuckyJayce/ViewPagerIndicator start 2166 RecyclerViewPager 扩形式的recyclerView，配合ViewPager实现各种效果 https://github.com/lsjwzh/RecyclerViewPager start 3149 banner Android广告图片轮播控件，支持无限循环和多种主题，可以灵活设置轮播样式、动画、轮播和切换时间、位置、图片加载框架等！ https://github.com/youth5201314/banner start 6938 XBanner 支持图片无限轮播，支持自定义指示点、显示提示文字、切换动画等 https://github.com/xiaohaibin/XBanner start 516 BGABanner-Android 引导界面滑动导航 + 大于等于1页时无限轮播 + 各种切换动画轮播效果 https://github.com/bingoogolapple/BGABanner-Android start 2914 Android图片压缩工具Luban(鲁班) 可能是最接近微信朋友圈的图片压缩算法 https://github.com/Curzibn/Luban start 8469 侧滑菜单SlidingRootNav https://github.com/yarolegovich/SlidingRootNav start 2385 选择器Android-PickerView 一款仿iOS的PickerView控件，有时间选择和选项选择，并支持一二三级联动，支持自定义样式 https://github.com/Bigkoo/Android-PickerView start 8346 android-picker 安卓选择器类库，包括日期选择器、时间选择器、单项选择器、城市选择器、颜色选择器、文件选择器、目录选择器、数字选择器、星座选择器、生肖选择器等，可自定义顶部及底部界面，可自定义窗口动画。 https://github.com/sevenli777/android-picker start 36 MultiType-FilePicker 第三方选择器，可以选择文件、图片 https://github.com/fishwjy/MultiType-FilePicker 简洁验证码输入框，能自定义输入框个数和样式VerificationCodeInput https://github.com/liuguangli/VerificationCodeInput start 257 RecyclerViewIndexRecyclerView 一款联系人选择的recyclerView列表，支持顶部悬浮和侧边滑动首字母选择 https://github.com/jiang111/IndexRecyclerView start 1114 ExpandableLayout 点击可扩大隐藏列表 https://github.com/traex/ExpandableLayout start 1499 SwipeRecyclerView 侧滑菜单，长按拖拽，滑动删除，自动加载更多，和ViewPager结合使用，和任何下拉刷新框架结合使用。 https://github.com/yanzhenjie/SwipeRecyclerView start 3446 IndexableRecyclerView 轻轻松实现：选择城市，选择联系人等需要索引的功能松实现：选择城市，选择联系人等需要索引的功能 https://github.com/YoKeyword/IndexableRecyclerView start 982 Android换肤／夜间模式的Android框架MultipleTheme https://github.com/dersoncheng/MultipleTheme start 1521 强大的RecyclerAdapter框架BaseRecyclerViewAdapterHelper https://github.com/CymChad/BaseRecyclerViewAdapterHelper start 3215 SuperAdapter https://github.com/byteam/SuperAdapter start 629 更换主题、设置状态栏的工具类StatusBarUtil (实现沉浸栏状态栏颜色状态) https://github.com/laobie/StatusBarUtil start 6211 MagicaSakura Android 多主题框架 https://github.com/Bilibili/MagicaSakura start 2915 DialogBasePopup 打造通用的popupwindow https://github.com/razerdp/BasePopup start 1618 AndroidBottomSheet 底部弹出popupwindow https://github.com/michael-rapp/AndroidBottomSheet start 300 BottomDialog 自定义的从底部弹出的dialog，仿照微博的分享弹框 https://github.com/Curzibn/BottomDialog start 375 AndroidSuperDialog 支持自定义边框圆角、背景透明度、字体大小与色值等 https://github.com/mylhyl/AndroidSuperDialog start 131 material-dialogs md风格的dialog https://github.com/afollestad/material-dialogs start 14288 Android-AlertView 仿iOS的AlertViewController 几乎完美还原iOS 的 AlertViewController ，同时支持Alert和ActionSheet模式，每一个细节都是精雕细琢，并把api封装成懒到极致模式，一行代码就可以进行弹窗. https://github.com/Bigkoo/Android-AlertView start 1212 加载LoadingLoadingLayout 项目里都会遇到几种页面，分别为加载中、无网络、无数据、出错四种情况，经常要使用，所以封成库引用了 https://github.com/weavey/LoadingLayoutDemo start 634 NumberProgressBar 带数字的进度条滚动 https://github.com/daimajia/NumberProgressBar start 5162 KProgressHUD 仿iOS加载 https://github.com/Kaopiz/KProgressHUD start 1128 GifLoadingView https://github.com/Rogero0o/GifLoadingView start 1177 音乐播放Timber MD风格的音乐播放 https://github.com/naman14/Timber start 5145 CustomLrcView-master 自定义显示歌词的控件，实现了歌词的平滑向上滚动，当高亮歌词宽度超过了view的宽的时候，水平滚动 https://github.com/android-lili/CustomLrcView-master start 109 LyricViewDemo 歌词显示 https://github.com/zhengken/LyricViewDemo start 576 数据库LitePal https://github.com/LitePalFramework/LitePal start 5343 realm-java https://github.com/realm/realm-java start 9941 greenDAO https://github.com/greenrobot/greenDAO start 10559 动画库lottie-android 支持跨平台动画库，由UI设计指定切json，将json加载出来实现动画 https://github.com/airbnb/lottie-android start 22620 TransitionHelper 一个简单的Activity转场动画 工具类 https://github.com/ImmortalZ/TransitionHelper start 1569 TranslationCompat 页面过渡动画兼容库，兼容Android5.0之后转场动画至Android4.0。 https://github.com/zhangke3016/TranslationCompat start 259 android-pathview SVG动画库 https://github.com/geftimov/android-pathview start 2485 图表类工具MPAndroidChart 股票折线图、饼状图等 https://github.com/PhilJay/MPAndroidChart start 24227 KChartView 股票k线图 https://github.com/tifezh/KChartView start 356 hellocharts-android https://github.com/lecho/hellocharts-android start 6126 波浪效果WaveView https://github.com/gelitenight/WaveView start 1328 Android开源项目及库TimLiu-Android https://github.com/Tim9Liu9/TimLiu-Android#UI start 2334 播放器PLDroidPlayer 七牛推出的一款免费的适用于 Android 平台的播放器 SDK，采用全自研的跨平台播放内核，拥有丰富的功能和优异的性能，可高度定制化和二次开发 https://github.com/pili-engineering/PLDroidPlayer start 3518 标题导航栏ByeBurger 这是一个极其简便的快速实现隐藏标题栏和导航栏的库。 https://github.com/githubwing/ByeBurger start 1061 网络加载okhttp-OkGo 全新完美支持RxJava，比Retrofit更简单易用。该库是封装了okhttp的标准RESTful风格的网络框架，支持大文件上传下载，上传进度回调，下载进度回调，表单上传（多文件和多参数一起上传），链式调用，可以自定义返回对象，支持Https和自签名证书，支持超时自动重连，支持cookie的持久化和自动管理，支持五种缓存模式缓存网络数据，支持301和302重定向，扩展了统一的上传管理和下载管理功能 https://github.com/jeasonlzy/okhttp-OkGo start 8221 NoHttp Android实现Http标准协议框架，支持多种缓存模式，底层可动态切换OkHttp、URLConnection。 https://github.com/yanzhenjie/NoHttp start 3525 OkHttpFinal OkHttp封装的一个简单易用HTTP请求 https://github.com/pengjianbo/OkHttpFinal start 770 okhttputils okhttp的辅助类 https://github.com/hongyangAndroid/okhttputils start 6402 二维码android-zxingLibrary 几行代码快速集成二维码扫描功能 https://github.com/yipianfengye/android-zxingLibrary start 3531 QRCode-Android 二维码、条形码通用扫描 https://github.com/XuDaojie/QRCode-Android start 362 QrCodeScan Android手机客户端二维码扫描 https://github.com/chentao0707/QrCodeScan start 1080 自定义键盘CustomizeKeyboard 完全自定义的Android安全键盘 https://github.com/StomHong/CustomizeKeyboard start 312 蓝牙操作库BluetoothHelper https://github.com/a-voyager/BluetoothHelper start 1111 版本更新CheckVersionLib 版本检测升级（更新）库。 https://github.com/AlexLiuSheng/CheckVersionLib start 1432 UpdateApp 开箱即用的app更新，主要负责软件下载、软件安装等 Permission和Service默认添加在aar包里面的，如果使用gradle不需要 在意下面的配置了。 https://github.com/yaming116/UpdateApp start 327 缓存ASimpleCache 一个为android制定的 轻量级的 开源缓存框架。轻量到只有一个java文件（由十几个类精简而来） https://github.com/yangfuhai/ASimpleCache start 3147 权限管理AndPermission https://github.com/yanzhenjie/AndPermission start 4525 FcPermissions https://github.com/lypeer/FcPermissions start 406 RxPermissions https://github.com/tbruyelle/RxPermissions start 7166 Tag标签AndroidTagGroup https://github.com/2dxgujun/AndroidTagGroup start 2168 手势密码解锁LockPattern 仿支付宝手势密码解锁 https://github.com/sym900728/LockPattern start 184 PatternLockView MD风格的手机密码解锁 https://github.com/aritraroy/PatternLockView start 2219 BlurLockView 高斯模糊锁屏界面 https://github.com/Nightonke/BlurLockView start 987 AppLock AppLock应用锁，保护你的隐私。 https://github.com/lizixian18/AppLock start 463 LolliPin Pin解锁 https://github.com/omadahealth/LolliPin start 1480 PinLockView MD风格Pin解锁 https://www.cnblogs.com/abao0/p/6726763.html start 1145]]></content>
      <categories>
        <category>Android</category>
        <category>插件库</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio自定义注释模板]]></title>
    <url>%2Fposts%2Fd339abc3.html</url>
    <content type="text"><![CDATA[代码的注释是我们平时必须面对的问题，今天我们就来看看如何自定义属于自己的注释模板，提高我们的开发效率。 1.新建的类自动生成的注释； 2.自定义注释模板。 新建类自动生成的注释1.打开相应的设置：​ File–&gt;Settings–&gt;Editor–&gt;File and code Template。 选择Files中的Class 在上面添加你想要添加的注释： 下面有一些变量可以选择： {USER} ：表示你系统名字；{DATE}： 表示当前时间；{NAME}:表示类名。而且后面都有注释，相信大家也都能看得懂。 这是设置后的结果画面： 这边有许多变量可以引用，想要哪些变量，或者想自定义成什么样的注释，就看你自己的想象力了。 万能注释模板 Java篇1.打开相应位置： File–&gt;Setting–&gt;Editor–&gt;LiveTemplate： 2.新建一个Live Group: 点击右边的+号，选择Template Group,命名自己的一个注释包。我自己命名为Zm Template Group。 3.新建一个LIve Template： 在你刚刚新建的group下点击+号，新建一个Live Template: Abbraviation:是你设置的快捷键，我的快捷键是z。 Expand with :补全你的注释的快捷键，默认为TAB,我改为了Enter。 4.添加你的注释： 在下面自定义你想要的注释，这边的注释有点不同了，这边可以自定义变量名，格式和我的一样，用双$包起来。 123456/** * @author $user$ * @email zm@zhangmiao.cc * @date $date$ $time$ * @describe $desc$ */ 5.点击Edit Variables，在Expression选择你需要方法，相当于给你的变量赋值: 6.选择你要运用的地方： 你可以选择Java，C++ 等等。 点击Apply。就成功了，下面让我们来看看效果：]]></content>
      <categories>
        <category>Android</category>
        <category>注释模板</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>注释模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android编译implement、api和compile区别]]></title>
    <url>%2Fposts%2Fde9d44d2.html</url>
    <content type="text"><![CDATA[2017 年google 后，Android studio版本更新至3.0，更新中，连带着com.android.tools.build:gradle 工具也升级到了3.0.0，在3.0.0中使用了最新的Gralde 4.0 里程碑版本作为gradle的编译版本，该版本gradle编译速度有所加速，更加欣喜的是，完全支持Java8。 当然，对于Kotlin的支持，在这个版本也有所体现，Kotlin插件默认是安装的。 我们来看看新建一个项目在Moudle中的 dependencies 中的变化。 12345678dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;&#125; 下面我们来看看他们之前的差异： 首先是2.x版本的依赖方式 再来看看3.0的 可以看到在Android studio3.0中，compile依赖关系已被弃用，被implementation和api替代，provided被compile only替代，apk被runtime only替代。 我们先来看看implementation和api的区别： api：跟 2.x 版本的 compile完全相同implementation：使用了该命令编译的依赖，它仅仅对当前的Moudle提供接口。例如我们当前项目结构如下 LibraryA 中引用了 LibraryC 的库，如果对 LibraryC 的依赖用的是 implementation 关键字。 如下： 1234dependencies &#123; . . . . implementation project（path：&apos;：libraryC&apos;）&#125; 那么LibraryC 中的接口，仅仅只能给 LibraryA 使用，而我们的 App Moudle 是无法访问到 LibraryC 提供的接口的，也就是将该依赖隐藏在内部，而不对外部公开。这就是implementation关键字的作用。 api 指令 完全等同于compile指令，没区别，你将所有的compile改成api，完全没有错。 implement指令 这个指令的特点就是，对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开。 建议在Google IO 相关话题的中提到了一个建议，就是依赖首先应该设置为implement的，如果没有错，那就用implement，如果有错，那么使用api指令，这样会使编译速度有所增快。 那为什么要这么做呢？答案是： 1. 加快编译速度。2. 隐藏对外不必要的接口。 为什么能加快编译速度呢？ 这对于大型项目含有多个Moudle模块的， 以上图为例，比如我们改动 LibraryC 接口的相关代码，这时候编译只需要单独编译LibraryA模块就行， 如果使用的是api或者旧时代的compile，由于App Moudle 也可以访问到 LibraryC,所以 App Moudle部分也需要重新编译。当然这是在全编的情况下。 还不熟悉 2.x 版本依赖的可以看看下面的说明，括号里对应的是 3.0 版本的依赖方式。 compile（api）这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。 当我们依赖一些第三方的库时，可能会遇到com.android.support冲突的问题，就是因为开发者使用的compile依赖的com.android.support包，而他所依赖的包与我们本地所依赖的com.android.support包版本不一样，所以就会报All com.android.support libraries must use the exact same version specification (mixing versions can lead to runtime crashes这个错误。 解决办法可以看这篇博客：com.android.support冲突的解决办法 provided（compileOnly）只在编译时有效，不会参与打包 可以在自己的moudle中使用该方式依赖一些比如com.android.support，gson这些使用者常用的库，避免冲突。 apk（runtimeOnly）只在生成apk的时候参与打包，编译时不会参与，很少用。 testCompile（testImplementation）testCompile 只在单元测试代码的编译以及最终打包测试apk时有效。 debugCompile（debugImplementation）debugCompile 只在 debug 模式的编译和最终的 debug apk 打包时有效 releaseCompile（releaseImplementation）Release compile仅仅针对 Release 模式的编译和最终的 Release apk 打包。 参考链接： Android Studio3.x新的依赖方式（implementation、api、compileOnly） 还再用compile依赖？那你就落后啦 android gradle tools 3.X 中依赖，implement、api 指令]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android快速开发框架推荐10个框架]]></title>
    <url>%2Fposts%2F7a5476f9.html</url>
    <content type="text"><![CDATA[一、 Afinal官方介绍： Afinal是一个Android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。详情请通过以下网址查看。 Afinal 是一个android的sqlite orm 和 ioc 框架。同时封装了android中的http框架，使其更加简单易用； 使用finalBitmap，无需考虑bitmap在android中加载的时候oom的问题和快速滑动的时候图片加载位置错位等问题。 Afinal的宗旨是简洁，快速。约定大于配置的方式。尽量一行代码完成所有事情。 项目地址：https://github.com/yangfuhai/afinal 功能： 一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。 优点：功能比较全面，文档完善，代码效率比较高。 缺点：没有项目demo，框架的时间比较久，代码冗余比较多（这也是无可避免的），文档比较老跟不上代码更新进度。 （这个评价是其他高人评的，他自己也有写了框架。我个人觉得以前Afinal算是经典了 用的人多）。 二、 xUtilsGit地址：https://github.com/wyouflf/xUtils xUtils：可以说是Afinal的升级版。 xUtils 包含了很多实用的android工具。 xUtils 支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响… xUitls 最低兼容android 2.2 (api level 8) 三、 ThinkAndroid项目地址：https://github.com/white-cat/ThinkAndroid 官方介绍： ThinkAndroid是一个免费的开源的、简易的、遵循Apache2开源协议发布的Android开发框架，其开发宗旨是简单、快速的进行Android应用程序的开发，包含Android mvc、简易sqlite orm、ioc模块、封装Android httpclitent的http模块,具有快速构建文件缓存功能，无需考虑缓存文件的格式，都可以非常轻松的实现缓存，它还基于文件缓存模块实现了图片缓存功能，在android中加载的图片的时候，对oom的问题，和对加载图片错位的问题都轻易解决。他还包括了一个手机开发中经常应用的实用工具类，如日志管理，配置文件管理，android下载器模块，网络切换检测等等工具 优点：功能看起来比较完善。个人觉得名字起的好。 缺点：从2013年就停止维护了，没有项目文档。 四、 LoonAndroid官方介绍： 如果你想看ui方面的东西，这里没有，想要看牛逼的效果这里也没有。这只是纯实现功能的框架，它的目标是节省代码量，降低耦合，让代码层次看起来更清晰。整个框架一部分是网上的，一部分是我改的，为了适应我的编码习惯，还有一部分像orm完全是网上的组件。在此感谢那些朋友们。 整个框架式的初衷是为了偷懒，之前都是一个功能一个jar，做项目的时候拉进去，这样对于我来说依然还是比较麻烦。最后就导致我把所有的jar做成了一个工具集合包。 有很多框架都含有这个工具集合里的功能，这些不一定都好用，因为这是根据我个人使用喜欢来实现的，如果你们有自己的想法，可以自己把架包解压了以后，源码拉出来改动下。 目前很多框架都用到了注解，除了androidannotations没有入侵我们应用的代码以外，其他的基本上都有，要么是必须继承框架里面的activity,要么是必须在activity的oncreat里面调用某个方法。 整个框架式不同于androidannotations，Roboguice等ioc框架，这是一个类似spring的实现方式。在整应用的生命周期中找到切入点，然后对activity的生命周期进行拦截，然后插入自己的功能。 开源地址：https://github.com/gdpancheng/LoonAndroid 功能： 1自动注入框架（只需要继承框架内的application既可） 2图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性） 3网络请求模块（继承了基本上现在所有的http请求） 4 eventbus（集成一个开源的框架） 5验证框架（集成开源框架） 6 json解析（支持解析成集合或者对象） 7 数据库（不知道是哪位写的 忘记了） 8 多线程断点下载（自动判断是否支持多线程，判断是否是重定向） 9 自动更新模块 10 一系列工具类 有点：功能多 缺点：文档方面 五、 KJFrameForAndroid项目地址：https://github.com/kymjs/KJFrameForAndroid 官方介绍： KJFrameForAndroid 又叫KJLibrary，是一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用；KJFrameForAndroid的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。我们提倡用最少的代码，完成最多的操作，用最高的效率，完成最复杂的功能。 功能： 一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用； KJFrameForAndroid开发框架的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。总共分为五大模块：UILibrary，UtilsLibrary，HttpLibrary，BitmapLibrary，DBLibrary。 优点：功能比较全面，代码效率很高，文档完善，有项目demo，出来的比较晚借鉴了很多大型框架经验。 缺点：项目文档是html页面，查看起来很不方便，项目交流平台没多少人说话（难道大神都是不说话的？） （这两个评价是KJFrameForAndroid的作者对自己的评价，个人觉得作者是个天才。他的评价可能刚写完网上发布后写的。我在给他更新评价。因为现在已经过去了几个月一直在时不时更新。功能很全，项目文档也很全面，而且代码里注释最多 这方面这个很难得。交流平台人很多挺热闹，作者希望更热闹这样框架越来越完善。对于初学者希望看到Demo更完善） 六、 dhroid官方介绍： dhroid 是基于android 平台, 极速开发框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展.使你更快,更好的开发商业级别应用 开源地址: http://git.oschina.net/tengzhinei/dhroid 功能： 1.Ioc容器: (用过spring的都知道)视图注入,对象注入,接口注入,解决类依赖关系 2.Eventbus: android平台事件总线框架,独创延时事件,事件管理轻松 3.Dhnet: 网络http请求的解决方案,使用简单,减少代码,自带多种网络访问缓存策略 4.adapter模块: 数据绑定轻松,不用写多余的adapter,天生网络支持(一行代码搞定加载,刷新问题) 5.DhDb: android中sqlite的最轻量orm框架(增删改查轻松搞定) 6.Perference: android自带Perference 升级版,让你的Perference更强大,更方便 工具集合 JSONUtil(安全处理json),ViewUtil(数据绑定更快) ThreadWorker(异步任务工具)… 优点：功能全面，有demo，作者也是为公司开发的框架。 缺点：文档方面现在不是很好，就eoe上的那些。 七、 SmartAndroid项目地址：http://www.aplesson.com/smartAndroid/demos 官方介绍： SmartAndroid是一套给 Android开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库以及简单的接口和逻辑结构，其目的是使开发人员更快速地进行项目开发。使用 SmartAndroid可以减少代码的编写量，并将你的精力投入到项目的创造性开发上。 功能： SmartAndroid 拥有全范围的类库，可以完成大多数通常需要的APP开发任务，包括： 异步网络操作相关所有功能、强大的图片处理操作、轻量级ORM数据库Sqlite库、zip操作 、动画特效、Html等解析采集、事件总线EventBus/Otto、Gson(Json)、AQuery、主流所有UI控件（例如：ActionbarSherlock，SlidingMenu，BottomView，Actionbar，DragListView等10多种UI库）等。 优点：功能非常全，超出你索要、文档完善（作者很全面，官方网站是web响应式网站，框架里功能有UI各种特效应该最全了，一直更新中） 缺点：jar包大点？（功能多不可避免，不是问题），在线文档（随响应式的手机访问也方便，但是网速慢就不好了，页面打开不是很流畅） 八、 andBase官方介绍： andbase是为Android开发者量身打造的一款开源类库产品 开源地址：https://code.jd.com/zhaoqp2010_m/andbase 功能： 1.andbase中包含了大量的开发常用手段。 如网络下载，多线程与线程池的管理，数据库ORM，图片缓存管理，图片文件下载上传，Http请求工具，常用工具类（字符串，日期，文件处理，图片处理工具类等），能够使您的应用在团队开发中减少冗余代码，很大的提高了代码的维护性与开发高效性，能很好的规避由于开发疏忽而导致常犯的错误。 2.andbase封装了大量的常用控件。 如list分页，下拉刷新，图片轮播，表格，多线程下载器，侧边栏，图片上传，轮子选择，图表，Tab滑动，日历选择器等。 3.强大的AbActivity，您没有理由不继承它。 继承它你能够获得一个简单强大可设置的操作栏，以及一系列的简单调用，如弹出框，提示框，进度框，副操作栏等。 4.提供效率较高图片缓存管理策略，使内存大幅度节省，利用率提高，效率提高。 程序中要管理大量的图片资源，andbase提供简单的方法，几步完成下载与显示，并支持缩放，裁剪，缓存功能。 5.封装了大量常见工具类。 包括日期，字符，文件，图片等各种处理函数，多而全。 6.用andbase大量减少handler的使用，而采用回调函数，代码更整洁。 handler会产生大量代码，并且不好维护，andbase对handler进行了封装。 7.简单轻量支持注解自动建表的ORM框架（支持一/多对多的关联操作）。 写sql，建表，工作量大，andbase提供更傻瓜异步增删改查工具类。 8.异步请求http框架，网络请求标准化，支持文件上传下载，get，post，进度显示。 包含了异步与http请求的工具类，实用。 9.热情的支持群体。 优点：功能很全，demo做的好 、API文档完善、接近完美 缺点：希望文档更详细些。 九、 AndroidAnnotations项目地址：https://github.com/excilys/androidannotations 功能： 完全注解框架，一切皆为注解：声明控件，绑定控件，设置监听，setcontentview，长按事件，异步线程，全部通过注解实现。 优点：完全的注解，使开发起来更加便利，程序员写的代码也更少。 缺点：文档是全英文的加上功能比较少没有具体研究，由于一切都是注解，感觉效率不高，不过根据官方介绍说并不是使用的反射加载，所以效率比一般注解高很多。 十、 volley项目地址： https://github.com/smanikandan14/Volley-demo 功能： Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮异步加载网络图片、网络数据 优点：Google官方推荐，请看去年的开发者大会介绍。 缺点：功能比较少，只有网络数据加载和网络图片加载 十一、 android-async-http 项目地址：https://github.com/loopj/android-async-http文档介绍：http://loopj.com/android-async-http/ (1) 在匿名回调中处理请求结果 (2) 在UI线程外进行http请求 (3) 文件断点上传 (4) 智能重试 (5) 默认gzip压缩 (6) 支持解析成Json格式 (7) 可将Cookies持久化到SharedPreferences 有点：很简单很实用 缺点：功能比较少， （只是针对的功能不是什么缺点） 最后来个总结吧： ​ 以上的开发框架网上都可以下载源码，也有demo实例的。当然我没分析和对比框架的效率性能，但是都非常实用，其作者大部分是个人，都是些牛人或天才。你可以直接使用，也可以把有用跳出来用，至少有很多使用工具。如果有发现Bug，作者希望把bug交给他。 ​ Afinal 和 xUtils简单实用但是demo和更新的问题。 KJFrameForAndroid 算是新出的，功能也多，效率也应该好，代码也注释多 用起来也很方便。 Dhroid 作者自己公司的框架，也可以直接请教。 SmartAndroid 强劲的框架功能俱全。 andBase 出来早各个方面算是完整的吧。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 项目最新架构]]></title>
    <url>%2Fposts%2Fb043c117.html</url>
    <content type="text"><![CDATA[前言为了帮助开发着打造一款优秀的APP，Google可谓费尽心力，推出了各种诸如MVP,MVVM等等项目架构的思路，帮助开发者更加高效的开发，尽管这样，Google还是接着推出了一个新的项目架构，以便给予开发者更多的选择，至于这种架构思路和MVP等框架的优劣，各位看完文章或许自有定论。 1.生命周期在移动操作系统上开发软件其实是十分复杂的一件事情，因为我们随时需要面对系统和用户的各种不可预料的操作，很多时候，事情并不向着我们预设的方向方向进展。因此系统向我们提供了核心组件的生命周期这种东西，告知我们的APP正处在什么样的状况中，以便于我们做出相应的处理。 如上图。虽然Google给出了Activity非常详尽的生命周期结构，因此我们对根据生命周期做出相应的合理的安排，比如添加和移除实时GPS位置监听： 可是随着业务的逐渐复杂，我们可能在添加监听之间需要向服务器验证某些用户信息，等返回信息正确才去监听定位。那么在网络异步回调的时候，我们就很难知道当前的activity的生命周期状态。 如果发生上图的情况，那么我们的占用的相关资源就可能永远无法移除了。这还只是冰山一角，大家尽可以想想，当我们的异步调用面对无法预知的用户操作和系统处理的时候，什么问题都可能发生。 总而言之，由于我们对于UI实时的状态做不到了如指掌，以至于对数据和逻辑的处理就无法尽善尽美。这是类似隐患得不到很好的解决根本原因。 2. Google大礼包这次Google推出了一套新的项目架构组件和架构思路，从UI到Data,帮助我们更加精准的开发自己的APP。 2.1 核心：Lifecycle Components这套架构最核心的就是生命周期组件，：Lifecycle Components用于管理UI控制器（Activity/Freagment）的生命周期，方便查询当前组件生命周期的状态。 可查询的状态如下： 具体的使用方式有两种： 继承LifecycleActivity/LifecycleFragment即可 自己实现LifecycleRegistryOwner接口 java 1234// 通过继承，就已经将自己的生命周期的交给了Lifecycle Components管理了。public class MainActivity extends LifecycleActivity &#123;&#125; 那我们如何使用呢？ 12345678910111213141516171819202122232425262728293031323334353637// 通过继承LifecycleObserver，保证我们可以通过注解或者接口查询UI的生命周期public class MyTest implements LifecycleObserver &#123; private Lifecycle lifecycle; // Lifecycle包含了当前组件的生命周期 public MyTest(Lifecycle lifecycle)&#123; lifecycle.addObserver(this); this.lifecycle=lifecycle; &#125;// 当onResume发生的时候，该方法被调用 @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void resume()&#123; Log.i(&quot;TAG&quot;,&quot;it called when resume &quot;); &#125; public void doTest(String s)&#123; // 随时可以查询当前的UI状态 if(lifecycle.getCurrentState().equals(Lifecycle.State.RESUMED))&#123; Log.i(&quot;TAG&quot;,&quot;resume&quot;); &#125;else&#123; Log.i(&quot;TAG&quot;,&quot;is not resume !! &quot;); &#125; &#125;&#125;public class MainActivity extends LifecycleActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //将当前Activity的生命周期传递到MyTest中即可 MyTest myTest=new MyTest(this.getLifecycle()); &#125;&#125; 看到这里，你一定心头一喜，如果有这个组件，那么我们就完全有能力将Activity作为一个UI的控制器，仅仅用来显示UI和相应用户操作，把Activity的大小缩小至最小。不用着急，大礼包远不止这些。 3.ViewModel和LiveData ViewModel 是一个UI相关数据的暂存器，当所有相关的UI都finish掉的时候，它才会清除自己的数据。 LiveData则是一个持有具体数据并且可被观察，能感知生命周期的组件（它就像RxJava中一个能遵循组件生命周期的Observable） 他俩的关系，就是，ViewModel负责管理着不同的LiveData,并把它提供给UI。 3.1 LiveData我们可以先来说说LiveData。由于它已经能够感知生命周期，也就意味着我们并不需要在去查询当前UI的生命周期，由于可被观察，也就意味着当它持有的数据发生改变，观察者可以立即受到信息。livedata最重要的方法是一下几个： 12345678 onActive() // 当前LiveData有超过一个的活跃的观察者时，被调用onInactive() // 当前没有任何活跃的观察时，着被调用setValue() // 勇于改变当前数据，这样观察者可以受到改变后的数据。// 观察数据变化，并感知当前UI的生命周期observe(LifecycleOwner owner, Observer&lt;T&gt; observer) 这里有一个活跃的观察者的概念，我们不妨把它放在后面来看。LiveData的用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LocationLiveData extends LiveData&lt;Location&gt; &#123; private LocationManager locationManager; private SimpleLocationListener listener = new SimpleLocationListener() &#123; @Override public void onLocationChanged(Location location) &#123; setValue(location); &#125; &#125;; public LocationLiveData(Context context) &#123; locationManager = (LocationManager) context.getSystemService( Context.LOCATION_SERVICE); &#125; @Override protected void onActive() &#123; locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener); &#125; @Override protected void onInactive() &#123; locationManager.removeUpdates(listener); &#125;&#125;public class MainActivity extends LifecycleActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); LiveData&lt;Location&gt; myLocationListener = new LocationLiveData(); /* * observe(LifecycleOwner owner, Observer&lt;T&gt; observer) * 这个方法就是向LiveData中添加观察者， * LiveData则可以通过LifecycleOwner来判断 * 当前传入的观察者是否是活跃的（也就是UI是否可见了） */ myLocationListener.observe(this, new Observer&lt;Location&gt;() &#123; @Override public void onChanged(@Nullable Location location) &#123; // update //当LiveData中通过setValue()修改了数据时， //这里将会受到修改后的数据 &#125; &#125;); &#125;&#125; 好了，LiveData基本的用法讲完了，由于有了LiveData，我们的data更加“智能”了。当UI不可见的时候，改变的数据将不会被更新到UI上。 而且如果数据在不同的UI界面都会被用到的时候，我们还可以一个单例的LiveData，为不同的UI提供统一的数据。这些操作就不去细讲了。 现在回头看LiveData，我们发现它至少有以下几个优点： 可以避免内存泄露：由于 Observer 和 Lifecycle 绑定，当 Lifecycle 被销毁后，Observer 自动被清理。 避免在 Activity 被销毁后更新数据导致的崩溃情况 数据可共享 数据更新更智能：当数据在UI不可见的时候更新了，在恢复可见的时候，最新的数据会及时更新到UI上。 不需要在Activity中额外处理生命周期事件 一颗赛艇！ 3.2 ViewModelViewModel则相对简单些，因为他的作用是暂存UI相关的数据，保证即使Activity配置更改，重新创建时，数据依然能够被保存好。 基本用法如下： 1234567891011121314151617181920212223242526public class MyViewModel extends ViewModel &#123; // MyViewModel用于管理不同的LiveData private MutableLiveData&lt;List&lt;User&gt;&gt; users; public LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123; if (users == null) &#123; users = new MutableLiveData&lt;List&lt;Users&gt;&gt;(); loadUsers(); &#125; return users; &#125; private void loadUsers() &#123; // do async operation to fetch users &#125;&#125;public class MyActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; // 通过了ViewModelProviders来获取ViewModel // 用户获取和Activity绑定的ViewModel MyViewModel model = ViewModelProviders.of(this).get(MyViewModel.class); model.getUsers().observe(this, users -&gt; &#123; // update UI &#125;); &#125;&#125; 这是ViewModel的最基本的用法，它负责从各个地方获取数据，然后把数据装到LiveData中，提供给UI；当然ViewModel也可以在不同的Fragment中共享，在这里就不多讲了。 由于ViewModel的本身和activity/fragment的生命周期绑定，当与之绑定的最后一个UI 销毁时，ViewModel才会clean自身的数据。 如图所示 4.数据持久化：RoomRoom是Google提供的SQLite的ORM的解决方案，其实本质上和其他的ORM框架没什么特别大的差别，没有太多新意，因此只给出大体的架构图，有兴趣的同学可以自行去学习 5.总结我们现在回头看整个架构 其实最有有趣的就是UI-ViewModel这个部分，这套架构至少可以帮助我们做到一下几点： UI与Data真正分离 异步调用和逻辑控制可以更加精细（因为对生命周期感知更多） 实现Model驱动UI 6.勘误暂无 附录android官网： https://developer.android.com/topic/libraries/architecture/index.html]]></content>
      <categories>
        <category>Android</category>
        <category>设计架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - Glide4.x的使用]]></title>
    <url>%2Fposts%2F6944411e.html</url>
    <content type="text"><![CDATA[最近从Glidev3升级到了Glide4.x，我用的是最新的Glide4.1.1哈，由于3.x到4.x的变化还是很大的，在此记录一下，也和需要的朋友分享一下。 Glide官方学习地址 使用1、在app的build.gradle中添加如下配置 12345dependencies &#123;//Glide框架引入 compile 'com.github.bumptech.glide:glide:4.1.1' annotationProcessor 'com.github.bumptech.glide:compiler:4.1.1'&#125; 2、在project的build.gradle中添加如下仓库地址** 1234repositories &#123; mavenCentral() maven &#123; url 'https://maven.google.com' &#125;&#125; 3、自定义AppGlideModule： 为运用程序定义一个带有@GlideModule注解的AppGlideModule，运用程序会使用和AppGlideMoudle同一个包下的GlideApp类。通过GlideApp.with()方式使用Glide的Generated API。具体操作，就是新建一个类，继承与AppGlideModule，还必须带有@GlideModule注解， 1234@GlideModulepublic final class MyAppGlideModule extends AppGlideModule &#123; &#125; 注意： 必需带有@GlideModule注解。 官方文档明确说明，这个类，你可以让它保留空白，不用实现任何方法，就可以使用Glide的Generated API。当然你也可以实现一些方法，具体参考官方文档。 4、Glide加载圆形图片，和Glide3.x差异不大 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455** * Glide圆形图片 */public class GlideCircleTransform extends BitmapTransformation &#123; public GlideCircleTransform() &#123; super(); &#125; @Override public Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; // TODO this could be acquired from the pool too Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125;&#125;//调用/** * 加载圆形图片 */public static void loadCircleImg(Context context, String url, final ImageView imageView) &#123; GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .transform(new GlideCircleTransform()) .into(imageView); &#125; 5、Glide加载圆角图片 说道这个我不得不吐槽一下网上的各路大神了，4.x和3.x加载圆角真不一样了，下面举个网上的例子，和3.x差不多 12public class GlideRoundTransform extends BitmapTransformation &#123;&#125; 尼玛，根本显示不了圆角啊，后来查资料才发现原来是Glide圆角和centerCrop的冲突，不过也得到了解决，感谢这位作者 Glide .centerCrop() 和transform圆角图片不能同时存在解决方法 下面贴出我的加载圆角的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 圆角图片 */public class GlideRoundTransform extends CenterCrop &#123; private static float radius = 0f; public GlideRoundTransform() &#123; this(4); &#125; public GlideRoundTransform(int dp) &#123; super(); this.radius = Resources.getSystem().getDisplayMetrics().density * dp; &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; Bitmap transform = super.transform(pool, toTransform, outWidth, outHeight); return roundCrop(pool, transform);// return roundCrop(pool, toTransform); &#125; private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); canvas.drawRoundRect(rectF, radius, radius, paint); return result; &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125;&#125;//调用/** * 加载圆角图片 * * @param context * @param url * @param imageView */ public static void loadRoundImg(Context context, String url, final ImageView imageView) &#123; GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .transform(new GlideRoundTransform(8)) .into(imageView); &#125; 6、Glide加载图片进度的监听 12345678910111213141516171819GlideApp.with(context) .load(url) .placeholder(R.mipmap.ic_launcher) .error(R.mipmap.ic_launcher) .centerCrop() .listener(new RequestListener&lt;Drawable&gt;() &#123; @Override public boolean onLoadFailed(@Nullable GlideException e, Object o, Target&lt;Drawable&gt; target, boolean b) &#123; Log.i(TAG, "图片加载失败 "); return false; &#125; @Override public boolean onResourceReady(Drawable drawable, Object o, Target&lt;Drawable&gt; target, DataSource dataSource, boolean b) &#123; Log.i(TAG, "图片加载完成: "); return false; &#125; &#125;) .into(imageView);]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 图片处理之Glide4.0版本]]></title>
    <url>%2Fposts%2Faf2ff32e.html</url>
    <content type="text"><![CDATA[前言一般项目我都会使用Glide作为我的图片加载框架，他和Picasso ,真的很像，郭大神早就分析过了，很详细，这里也就简单做个记录。小白白一枚，学习路上 Android图片加载框架最全解析（一），Glide的基本用法 Android图片加载框架最全解析（二），从源码的角度理解Glide的执行流程 Android图片加载框架最全解析（三），深入探究Glide的缓存机制 Android图片加载框架最全解析（四），玩转Glide的回调与监听 Android图片加载框架最全解析（五），Glide强大的图片变换功能 Android图片加载框架最全解析（六），探究Glide的自定义模块功能 Android图片加载框架最全解析（七），实现带进度的Glide图片加载功能 Android图片加载框架最全解析（八），带你全面了解Glide 4的用法 一：GitHubbumptech/glide二：下载使用点击，跳转到官网，介绍很详细 1. Gradle1234repositories &#123; mavenCentral() maven &#123; url 'https://maven.google.com' &#125;&#125; 1234dependencies &#123; compile 'com.github.bumptech.glide:glide:4.4.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'&#125; 2. Android SDK 要求 Min Sdk Version - 使用 Glide 需要 min SDK 版本 API 14 (Ice Cream Sandwich) 或更高。 Compile Sdk Version - Glide 必须使用 API 26 (Oreo) 或更高版本的 SDK 来编译。 Support Library Version - Glide 使用的支持库版本为 27。 否则会出现异常 解决方案12345dependencies &#123; implementation 'com.android.support:appcompat-v7:27.0.2' //这个版本的就可以了 implementation 'com.github.bumptech.glide:glide:4.4.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.4.0'&#125; 3.权限1234&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 二：apply &amp;&amp; RequestOptions4.0之前最常用的方式，当然现在也是哈 123Glide.with(this) .load(url) .into(img); 4.0之后，有一个新的东西 1234 Glide.with(this) .load(url)// .apply(RequestOptions options) .into(img); 比如 我们加载占位图和错误图 1234567RequestOptions options = new RequestOptions() .error(R.drawable.error) .placeholder(R.drawable.loading);Glide.with(this) .load(url) .apply(options) .into(imageView); 小伙伴们没看错，这样的方式，摆脱了，以前链式写法中，Glide很长很长，现在的话，我们可以传入一个RequestOptions，对象，就有小伙伴问了，有啥用，我觉得，比较容易封装， 例如 123456789101112public class GlideUtil &#123; public static void load(Context context, String url, ImageView imageView, RequestOptions options) &#123; Glide.with(context) .load(url) .apply(options) .into(imageView); &#125;&#125; 三：API 介绍 API 介绍 占位符(Placeholder) 当请求正在执行时被展示的 Drawable 错误符(Error) 请求永久性失败时展示 后备回调符(Fallback) 在请求的url/model为 null 时展示 override 指定了一个图片的尺寸,Target.SIZE_ORIGINAL加载图片的原始尺寸 skipMemoryCache(true) 禁用内存缓存功能 diskCacheStrategy(DiskCacheStrategy.NONE) 禁用硬盘缓存功能,参数列表如下 四（1） asBitmap() 只允许加载静态图片,。如果传入的是GIF图,会展示GIF图的第一帧 asFile() 指定文件格式 注意事项 如下 四（2） asDrawable() 指定Drawable格式 submit() 使用如下四（3） transforms 图片变换，Glide 默认有3个，如下四（4） 四： 补充说明1. diskCacheStrategy参数补充 参数 说明 DiskCacheStrategy.NONE 表示不缓存任何内容。 DiskCacheStrategy.DATA 表示只缓存原始图片。 DiskCacheStrategy.RESOURCE 表示只缓存转换过后的图片。 DiskCacheStrategy.ALL 表示既缓存原始图片，也缓存转换过后的图片。 DiskCacheStrategy.AUTOMATIC 表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）。 2. asBitmap()注意坑熟悉Glide 3的朋友对asBitmap()方法肯定不会陌生对吧？但是千万不要觉得这里就没有陷阱了，在Glide 3中的语法是先load()再asBitmap()的，而在Glide 4中是先asBitmap()再load()的。乍一看可能分辨不出来有什么区别，但如果你写错了顺序就肯定会报错了 3. submit()通过如下代码，可以获取到，下载好的图片放在哪，可以看到 都在cache下 1234567891011121314151617181920 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; File file = Glide.with(MainActivity.this) .asFile() .load(url) .submit() .get(); Log.e("Tag", "path--&gt;" + file.getPath()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();E/Tag: path--&gt;/data/user/0/com.allens.glidedemo/cache/image_manager_disk_cache/309df01e6362ddc8939a4e3c549e8276dffb0446a89f2facee371909301fe76a.0 4. transforms内置有这3个 12345678RequestOptions options = new RequestOptions() .centerCrop();RequestOptions options = new RequestOptions() .fitCenter();RequestOptions options = new RequestOptions() .circleCrop();//圆形 一般我们还会自己去定义，以下是常用的3种转换 使用起来也很简单 1234567891011RequestOptions options = new RequestOptions() .skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.NONE); //圆形 .transforms(new CircleTransform(mContext,2, Color.DKGRAY))//外圈宽度，外圈颜色 //黑白 .transforms(new BlackWhiteTransformation()); //高斯模糊 范围在 0 -- 25 越大模糊程度越高 .transforms(new BlurTransformation(mContext, 25)); // (0 &lt; r &lt;= 25) //可以使用多种 .transforms(new BlurTransformation(mContext, 25),new CircleTransform(mContext,2, Color.DKGRAY)) （1） 转成黑白123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.allens.lib_glide.Transformation;import android.graphics.Bitmap;import android.media.ThumbnailUtils;import android.support.annotation.NonNull;import android.view.animation.Transformation;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 黑白 * Created by allens on 2018/1/8. */public class BlackWhiteTransformation extends BitmapTransformation &#123; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return convertToBlackWhite(toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap convertToBlackWhite(Bitmap bmp) &#123; int width = bmp.getWidth(); // 获取位图的宽 int height = bmp.getHeight(); // 获取位图的高 int[] pixels = new int[width * height]; // 通过位图的大小创建像素点数组 bmp.getPixels(pixels, 0, width, 0, 0, width, height); int alpha = 0xFF &lt;&lt; 24; for (int i = 0; i &lt; height; i++) &#123; for (int j = 0; j &lt; width; j++) &#123; int grey = pixels[width * i + j]; //分离三原色 int red = ((grey &amp; 0x00FF0000) &gt;&gt; 16); int green = ((grey &amp; 0x0000FF00) &gt;&gt; 8); int blue = (grey &amp; 0x000000FF); //转化成灰度像素 grey = (int) (red * 0.3 + green * 0.59 + blue * 0.11); grey = alpha | (grey &lt;&lt; 16) | (grey &lt;&lt; 8) | grey; pixels[width * i + j] = grey; &#125; &#125; //新建图片 Bitmap newBmp = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565); //设置图片数据 newBmp.setPixels(pixels, 0, width, 0, 0, width, height); Bitmap resizeBmp = ThumbnailUtils.extractThumbnail(newBmp, 380, 460); return resizeBmp; &#125;&#125; （2）高斯模糊1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.allens.lib_glide.Transformation;import android.annotation.TargetApi;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Paint;import android.os.Build;import android.renderscript.Allocation;import android.renderscript.Element;import android.renderscript.RSRuntimeException;import android.renderscript.RenderScript;import android.renderscript.ScriptIntrinsicBlur;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: 高斯模糊 * &lt;p&gt; * Created by allens on 2018/1/8. */public class BlurTransformation extends BitmapTransformation &#123; private Context context; private float blurRadius; public BlurTransformation(Context context, float blurRadius) &#123; this.context = context; this.blurRadius = blurRadius; &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return blurBitmap(context, toTransform, blurRadius, outWidth, outHeight); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; /** * @param context 上下文对象 * @param image 需要模糊的图片 * @param outWidth 输入出的宽度 * @param outHeight 输出的高度 * @return 模糊处理后的Bitmap */ @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public Bitmap blurBitmap(Context context, Bitmap image, float blurRadius, int outWidth, int outHeight) &#123; // 将缩小后的图片做为预渲染的图片 Bitmap inputBitmap = Bitmap.createScaledBitmap(image, outWidth, outHeight, false); // 创建一张渲染后的输出图片 Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap); // 创建RenderScript内核对象 RenderScript rs = RenderScript.create(context); // 创建一个模糊效果的RenderScript的工具对象 ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间 // 创建Allocation对象的时候其实内存是空的,需要使用copyTo()将数据填充进去 Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap); Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap); // 设置渲染的模糊程度, 25f是最大模糊度 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &#123; blurScript.setRadius(blurRadius); &#125; // 设置blurScript对象的输入内存 blurScript.setInput(tmpIn); // 将输出数据保存到输出内存中 blurScript.forEach(tmpOut); // 将数据填充到Allocation中 tmpOut.copyTo(outputBitmap); return outputBitmap; &#125;&#125; （3） 圆形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.allens.lib_glide.Transformation;import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 圆形 * Created by allens on 2018/1/8. */public class CircleTransform extends BitmapTransformation &#123; private Paint mBorderPaint; private float mBorderWidth; public CircleTransform(Context context) &#123; super(context); &#125; public CircleTransform(Context context, int borderWidth, int borderColor) &#123; super(context); mBorderWidth = Resources.getSystem().getDisplayMetrics().density * borderWidth; mBorderPaint = new Paint(); mBorderPaint.setDither(true); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(borderColor); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setStrokeWidth(mBorderWidth); &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) &#123; return null; &#125; int size = (int) (Math.min(source.getWidth(), source.getHeight()) - (mBorderWidth / 2)); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); if (mBorderPaint != null) &#123; float borderRadius = r - mBorderWidth / 2; canvas.drawCircle(r, r, borderRadius, mBorderPaint); &#125; return result; &#125;&#125; 4.0 圆角123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.starot.spark.transformation;import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import android.support.annotation.NonNull;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;import java.security.MessageDigest;/** * 描述: * &lt;p&gt; 圆形 * * @author allens * @date 2018/1/8 */public class CircleTransform extends BitmapTransformation &#123; private Paint mBorderPaint; private float mBorderWidth; public CircleTransform(Context context) &#123; super(context); &#125; public CircleTransform(Context context, int borderWidth, int borderColor) &#123; super(context); mBorderWidth = Resources.getSystem().getDisplayMetrics().density * borderWidth; mBorderPaint = new Paint(); mBorderPaint.setDither(true); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(borderColor); mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setStrokeWidth(mBorderWidth); &#125; @Override protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; @Override public void updateDiskCacheKey(MessageDigest messageDigest) &#123; &#125; private Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) &#123; return null; &#125; int size = (int) (Math.min(source.getWidth(), source.getHeight()) - (mBorderWidth / 2)); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); if (mBorderPaint != null) &#123; float borderRadius = r - mBorderWidth / 2; canvas.drawCircle(r, r, borderRadius, mBorderPaint); &#125; return result; &#125;&#125; 5.Generated API如果4.0用的不爽，就想使用3.0版本的那种链式写法,将Glide 关键字改成 GlideApp即可 123456789GlideApp.with(this) .load(url) .placeholder(R.drawable.loading) .error(R.drawable.error) .skipMemoryCache(true) .diskCacheStrategy(DiskCacheStrategy.NONE) .override(Target.SIZE_ORIGINAL) .circleCrop() .into(imageView);]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android：时间工具类 -- 时间戳转换成日期，日期转换成时间戳]]></title>
    <url>%2Fposts%2F29c9b34b.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486 public class DateUtils &#123; public static String getTodayDateTime() &#123; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()); return format.format(new Date()); &#125; /** * 掉此方法输入所要转换的时间输入例如（"2014年06月14日16时09分00秒"）返回时间戳 * * @param time * @return */ public String data(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒", Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; public static String getTodayDateTimes() &#123; SimpleDateFormat format = new SimpleDateFormat("MM月dd日", Locale.getDefault()); return format.format(new Date()); &#125; /** * 获取当前时间 * * @return */ public static String getCurrentTime_Today() &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); return sdf.format(new java.util.Date()); &#125; /** * 调此方法输入所要转换的时间输入例如（"2014-06-14-16-09-00"）返回时间戳 * * @param time * @return */ public static String dataOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss", Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; public static String getTimestamp(String time, String type) &#123; SimpleDateFormat sdr = new SimpleDateFormat(type, Locale.CHINA); Date date; String times = null; try &#123; date = sdr.parse(time); long l = date.getTime(); String stf = String.valueOf(l); times = stf.substring(0, 10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014年06月14日16时09分00秒"） * * @param time * @return */ public static String times(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014-06-14 16:09:00"） * * @param time * @return */ public static String timedate(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014年06月14日16:09"） * * @param time * @return */ public static String timet(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日 HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeslash(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy/MM/dd,HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeslashData(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy/MM/dd"); @SuppressWarnings("unused") long lcc = Long.valueOf(time);// int i = Integer.parseInt(time); String times = sdr.format(new Date(lcc * 1000L)); return times; &#125; /** * @param time斜杠分开 * @return */ public static String timeMinute(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String tim(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyyMMdd HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String time(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd HH:mm"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; // 调用此方法输入所要转换的时间戳例如（1402733340）输出（"2014年06月14日16时09分00秒"） public static String times(long timeStamp) &#123; SimpleDateFormat sdr = new SimpleDateFormat("MM月dd日 # HH:mm"); return sdr.format(new Date(timeStamp)).replaceAll("#", getWeek(timeStamp)); &#125; private static String getWeek(long timeStamp) &#123; int mydate = 0; String week = null; Calendar cd = Calendar.getInstance(); cd.setTime(new Date(timeStamp)); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 if (mydate == 1) &#123; week = "周日"; &#125; else if (mydate == 2) &#123; week = "周一"; &#125; else if (mydate == 3) &#123; week = "周二"; &#125; else if (mydate == 4) &#123; week = "周三"; &#125; else if (mydate == 5) &#123; week = "周四"; &#125; else if (mydate == 6) &#123; week = "周五"; &#125; else if (mydate == 7) &#123; week = "周六"; &#125; return week; &#125; // 并用分割符把时间分成时间数组 /** * 调用此方法输入所要转换的时间戳输入例如（1402733340）输出（"2014-06-14-16-09-00"） * * @param time * @return */ public String timesOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; public static String timesTwo(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); return times; &#125; /** * 并用分割符把时间分成时间数组 * * @param time * @return */ public static String[] timestamp(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); @SuppressWarnings("unused") long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); String[] fenge = times.split("[年月日时分秒]"); return fenge; &#125; /** * 根据传递的类型格式化时间 * * @param str * @param type * 例如：yy-MM-dd * @return */ public static String getDateTimeByMillisecond(String str, String type) &#123; Date date = new Date(Long.valueOf(str)); SimpleDateFormat format = new SimpleDateFormat(type); String time = format.format(date); return time; &#125; /** * 分割符把时间分成时间数组 * * @param time * @return */ public String[] division(String time) &#123; String[] fenge = time.split("[年月日时分秒]"); return fenge; &#125; /** * 输入时间戳变星期 * * @param time * @return */ public static String changeweek(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); Date date = null; int mydate = 0; String week = null; try &#123; date = sdr.parse(times); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 获取日期和星期 例如：２０１４－１１－１３ １１:００ 星期一 * * @param time * @param type * @return */ public static String getDateAndWeek(String time, String type) &#123; return getDateTimeByMillisecond(time + "000", type) + " " + changeweekOne(time); &#125; /** * 输入时间戳变星期 * * @param time * @return */ public static String changeweekOne(String time) &#123; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); long lcc = Long.valueOf(time); int i = Integer.parseInt(time); String times = sdr.format(new Date(i * 1000L)); Date date = null; int mydate = 0; String week = null; try &#123; date = sdr.parse(times); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 获取当前时间 * * @return */ public static String getCurrentTime() &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm"); return sdf.format(new java.util.Date()); &#125; /** * 输入日期如（2014年06月14日16时09分00秒）返回（星期数） * * @param time * @return */ public String week(String time) &#123; Date date = null; SimpleDateFormat sdr = new SimpleDateFormat("yyyy年MM月dd日HH时mm分ss秒"); int mydate = 0; String week = null; try &#123; date = sdr.parse(time); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; /** * 输入日期如（2014-06-14-16-09-00）返回（星期数） * * @param time * @return */ public String weekOne(String time) &#123; Date date = null; SimpleDateFormat sdr = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss"); int mydate = 0; String week = null; try &#123; date = sdr.parse(time); Calendar cd = Calendar.getInstance(); cd.setTime(date); mydate = cd.get(Calendar.DAY_OF_WEEK); // 获取指定日期转换成星期几 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (mydate == 1) &#123; week = "星期日"; &#125; else if (mydate == 2) &#123; week = "星期一"; &#125; else if (mydate == 3) &#123; week = "星期二"; &#125; else if (mydate == 4) &#123; week = "星期三"; &#125; else if (mydate == 5) &#123; week = "星期四"; &#125; else if (mydate == 6) &#123; week = "星期五"; &#125; else if (mydate == 7) &#123; week = "星期六"; &#125; return week; &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 音频amr文件时长]]></title>
    <url>%2Fposts%2F45412865.html</url>
    <content type="text"><![CDATA[一、文件时长获取 1234567891011public int getDurations()&#123; String curAudioFile = “XXX.amr”; MediaPlayer mediaPlayer = new MediaPlayer(); mediaPlayer.setDataSource(curAudioFile); mediaPlayer.prepare(); return mediaPlayer.getDuration();// 单位毫秒&#125; 二、文件时长转换** 1234567891011121314151617181920212223242526272829303132333435private static String getAudioDuration(int nDuration0) &#123; DecimalFormat df = new DecimalFormat("#.00"); String fileSizeString = ""; String wrongSize = "0ms"; if (nDuration0 == 0) &#123; return wrongSize; &#125; if (nDuration0 &lt; 1000) &#123; fileSizeString = df.format((double) nDuration0) + "ms"; &#125; else if (nDuration0 &lt; 60000) &#123; fileSizeString = df.format((double) nDuration0 / 1000) + "s"; &#125; else if (nDuration0 &lt; 3600000) &#123; fileSizeString = df.format((double) nDuration0 / 60000) + "min"; &#125; else &#123; fileSizeString = df.format((double) nDuration0 / 3600000) + "h"; &#125; return fileSizeString;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中实现延时执行操作的几种方法]]></title>
    <url>%2Fposts%2Ffdc60895.html</url>
    <content type="text"><![CDATA[在Android开发中我们可能会有延时执行某个操作的需求，例如我们启动应用的时候，一开始呈现的是一个引导页面，过了两三秒后，会自动跳转到主界面。这就是一个延时操作。下面是实现延时执行操作的几种方法： 使用线程的休眠实现延时操作12345678910new Thread() &#123; @Override public void run() &#123; super.run(); Thread.sleep(3000);//休眠3秒 /** * 要执行的操作 */ &#125; &#125;.start(); 使用TimerTask实现延时操作**12345678910TimerTask task = new TimerTask() &#123; @Override public void run() &#123; /** *要执行的操作 */ &#125; &#125;; Timer timer = new Timer(); timer.schedule(task, 3000);//3秒后执行TimeTask的run方法 使用Handler的postDelayed方法实现延时操作123456789Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; /** *要执行的操作 */ &#125; &#125;, 3000);//3秒后执行Runnable中的run方法]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android判断文件是否存在,新建、删除]]></title>
    <url>%2Fposts%2F547382f.html</url>
    <content type="text"><![CDATA[123456public static boolean fileIsExists(String fileName) &#123; File folder = new File(fileName); if (!folder.exists()) &#123; folder.mkdir(); &#125; &#125; 1234567891011121314//判断文件是否存在 public boolean fileIsExists(String strFile) &#123; try &#123; File f = new File(strFile); if (!f.exists()) &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; return true;&#125; 123456789101112131415 /** * 要删除的文件夹的所在位置 */ public static void deleteFile(File file) &#123; if (file.isDirectory()) &#123; File[] files = file.listFiles(); for (int i = 0; i &lt; files.length; i++) &#123; File f = files[i]; deleteFile(f); &#125;// file.delete();//如要保留文件夹，只删除文件，请注释这行 &#125; else if (file.exists()) &#123; file.delete(); &#125; &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android知识点归纳总结提纲]]></title>
    <url>%2Fposts%2F9a278d8c.html</url>
    <content type="text"><![CDATA[Android部分 一、Android四大组件 二、Fragment相关 三、动画相关 四、布局相关 五、数据存储 六、线程、进程 七、网络 八、WebView 九、图片 十、Camera相关 十一、音视频相关 十二、ViewPager相关 十三、RecyclerView相关 十四、Canvas相关 十五、传感器相关 十六、性能优化 十七、UI适配 十八、Android中的Context 十九、序列化与反序列化 二十、JSON解析 二十一、二维码 二十二、Permission权限 二十三、Activity工作原理 二十四、View事件分发机制 二十五、View的绘制流程 二十六、自定义view基本流程 二十七、Apk的打包/安装过程 二十八、App混淆 二十九、App冷启动优化 三十、子线程不能更新UI 三十一、Android Studio Gradle 三十二、adb相关 三十三、逆向安全 三十四、NDK开发 三十五、设计模式 三十六、架构模式 RxJava Kotlin Dagger 2 Flutter Weex Hybrid 混合开发 OpenGL 测试工具其他冷门知识其他补充：Java部分 一、Java基础 二、Java数据结构和算法 Android部分 一、Android四大组件1：Activity相关， Activity生命周期理解，Activity启动另一个Activity返回的完整生命周期， Activity四种启动模式，Activity任务栈理解（先进后出），Activity的显示隐式启动，Activity的隐式启动（理解Scheme跳转协议），Activity之间的跳转与回调，Activity之间的intent数据传递，理解Activity工作原理Activity与Window之间的关系，Activity和dectorView等2：Service相关， Service生命周期方法，Service的两种启动方式的使用，start与bind的区别，何时需要停止Service, Service的使用场景理解, 后台Service与前台Service，如何提高后台服务的存活率，如何保证一个后台服务不被kill, IntentService的使用等3：BroadcastReceiver相关，广播的两种注册方式（隐式/显示广播），广播的注册/反注册注意事项，有序广播、本地广播，接收到广播Action后的处理方法等4：ContentProvider相关，ContentProvider的使用，如何使用ContentProvider实现应用间的数据共享，ContentProvider使用的content URI形式的理解等 二、Fragment相关虽然Fragment不属于Android四大组件（也有人说它是第五大组件），但是作为Android日常开发使用的高频组件之一，必须要了解Fragment的使用方法和注意事项 1：Fragment的生命周期，以及Fragment生命周期与其宿主Activity生命周期的对应关系2：如何通过FragmentTransaction实现Fragment的添加、移除、替换、显示、隐藏等3：Fragment之间的跳转，Fragment如何与Activity交互4：如何管理Fragment回退栈5：没有视图的Fragment的用处6：FragmentManager可提供使用的方法7：v4包与app包提供的Fragment使用的区别注意项8：Fragment使用的其他坑 三、动画相关1：帧动画（FrameAnimation），帧动画的使用方式，xml和代码两种实现方式，帧动画使用注意事项，利弊等2：补间动画（TweenAnimation）, 四种常用的补间动画：alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）的使用方式，xml和代码两种实现方式，相关属性的理解与注意事项，动画的监听设置，使用AnimatorSet播放多个组合动画等3：属性动画（PropertyAnimation）, 属性动画的使用方法，ValueAnimator与ObjectAnimator的使用，相关属性的理解，AnimatorSet同时播放多个动画，Interpolator（动画差值器）的理解与使用，AnimatorListener的设置，属性动画的工作原理等4：如何利用Canvas绘制动画5：了解Android 矢量动画实现6：转场动画，触摸反馈动画，其他自定义动画 四、布局相关1：常用布局LinearLayout、RelativeLayout、FrameLayout, xml与代码两种使用方式，相关属性的理解，会在代码中动态的设置与改变LayoutParams的相关属性控制view2：非常用布局AbsoluteLayout、TableLayout、GridLayout的使用3：百分比布局，PercentRelativeLayout、PercentLinearLayout、PercentFrameLayout的了解与使用4：ConstraintLayout（约束布局）的使用，相关属性的理解5：FlexboxLayout（流动布局）的使用，相关属性的理解6：CoordinatorLayout的使用，会使用support.design库提供的CoordinatorLayout布局来实现常见的滑动折叠/展开浸入式联动特效，理解Behavior解决嵌套滑动冲突与事件拦截处理的原理，理解NestedScroll机制7：界面布局类型的选择和性能优化 五、数据存储1：SharedPreferences，sp的使用场景，sp的常用方法，sp能保存的数据类型，sp的保存位置，注意事项等文件存储，常规文件操作（I/O读写操作、文件的创建/删除/复制）、外置sdcard卡的文件存储，读写权限， 如何使用FileProvider适配Android 7.0 (file uri exposed问题)，应用目录下文件的创建存取（应用私有文件），压缩文件（zip/rar）的压缩与解压缩2：SQLite数据库存储，SQLiteOpenHelper的使用，数据库需要升级时的注意事项（新老数据的保留），数据库表的创建/删除/清空，SQL语句语法（增删改查、排序、多表联查），利用execSql和系统提供的增删改查api两种方式操作，多线程操作数据库安全问题（加锁同步），大量频繁数据库操作使用事务，第三方的基于数据库的开源库方案3：ContentProvider，自定义ContentProvider的使用，ContentProvider的抽象方法增删改查的实现，ContentProvider如何在应用间共享数据，ContentProvider涉及的Uri概念理解，有哪些系统的ContentUrl，什么是ContentResolver，如何用ContentResolver查询手机的存储信息（如联系人、多媒体图片、音视频等）4：网络存储，如何读取文件流上传文件（表单方式），如何下载文件并保存，如何提交json格式的数据，如何解析服务器返回的json数据，网络传输数据的加密解密，常规的数据提交方式（GET/POST）以及 Content-type的几种常见方式的理解（具体参考网络部分总结） 六、线程、进程1：什么是进程，什么是线程，理解进程和线程的区别和联系（默认一个android应用是系统的一个进程，线程共享进程的所有资源，app的默认工作线程是主线程UI线程）2：如何在app创建多进程/子进程，子进程与主进程的关系，进程间通信方式IPC（文件共享/Messenger/AIDL/ContentProvider/饿了么HermesEventBus等），app开启多进程有哪些好处/坏处，Android进程的优先级（前台/可见/服务/后台/空），如何提升app自身的进程优先级，进程保活方案，多进程情况下Application创建的区别（onCreate）3：如何在app创建子线程，子线程与主线程的通信方式（共享内存变量/Handler/runOnUiThread/EventBus等），线程池的使用，如何手动创建线程池，线程池各个参数的合理设置，系统提供的四种线程池的使用，Thread和Runnable的区别，如何安全的取消/终止一个线程的运行（有几种方式），Thread类的wait() sleep() notify()，线程/线程池有上限吗4：线程同步，多线程访问共享资源会带来的安全问题，线程死锁，线程同步的几种方式（同步方法/同步代码块/volatile/ThreadLocal/阻塞队列/原子变量）5：AsyncTask的使用，AsyncTask三个方法的解析，AsyncTask源码实现原理解析，什么情况下AsyncTask的doInBackground会不被执行，为什么new AsyncTask只能执行一次，如何避免AsyncTask导致内存泄露、销毁Activity后它内部的AsyncTask一定会终止运行吗，如何取消AsyncTask6：Handler, Handler发消息的所有使用方式及区别，为什么不能直接在子线程中直接new Handler ，如何Handler实现主线程给子线程发消息，Handler的消息队列实现原理，Handler与Looper、Message的关系，如何避免Handler内存泄漏，HandlerThread的使用7：AIDL的实现使用，AIDL的原理分析（Binder机制）8：EventBus实现原理分析 七、网络1：七层网络结构OSI，每层的含义理解2：域名解析的过程，一次网络请求的完整流程3：HTTP协议，什么是HTTP协议，HTTP1.0与2.0的区别，http完整报文的格式（请求头、请求正文、响应头、响应正文），请求头和响应头中常用字段的含义解析，GET/POST，上传文件、上传json格式与普通文本数据的get/post方式的区别（报文角度解析），HTTP响应头各个状态码的含义, 常见网络框架是如何解析响应头/响应正文的，可以自定义响应头中的ResponseCode吗, Cookie和Session, 长连接和短连接4：TCP三次握手, TCP与UDP的区别，Android代码实现TCP和UDP通信（Socket api实现），Socket，如何使用Socket自定义协议（如可以用Socket api实现http协议，或任何双方约定好的自定义协议），使用Websocket实现收发消息等5：常见网络请求库（OkHttp3/Volley/Retrofit）及实现原理解析，原生的网络请求使用，理解异步请求和同步请求6：Https安全通信，与Http的区别，TSL/SSL加密协议，CA证书，防止运营商劫持7：如何自己实现一个网络请求框架 八、WebView1：WebView的基本使用和设置方法2：WebView JS与原生代码交互的几种方式（方法互调、传参、返回值），优缺点/安全性，JSBridge, 如何自定义协议实现一个JSBridge3：WebView的各种坑，避免WebView内存泄漏4：WebView安全漏洞，不同Android版本的差异，如何避免WebView安全漏洞5：Hybrid App混合开发的原理，Hybrid与原生开发有哪些优势与不足，H5/CSS/JS语法了解 九、图片1：主流图片格式（png jpg gif bmp wbmp ）的区别，ARGB_8888，RGB_888，RGB_565, RGB_444等色彩格式的区别2：如何计算一张图片（Bitmap）在Android中占用的内存大小分析（加载网络/sdcard图片与加载drawable下的图片两种），3：图片的压缩，从图片尺寸（节约内存），图片大小（节约流量），图片格式（色彩像素大小）三方面考虑4：加载大图注意事项，OOM5：图片缓存，三级缓存，LRU Cache原理，缓存大小是如何调整的，Android提供的LRUCache解析6：图片加载库（Glide/Picasso/Fresco）的使用方法，实现原理（如何做到保证跟Activity/Fragment生命周期一致的），使用的缓存策略，内存策略，如何自己实现一个图片加载库7：如何从图片文件/资源图片文件加载Bitmap. Bitmap压缩存储到文件8：图片剪裁、旋转、缩放9：圆角图片的实现（几种方式）以及其他各种形状图片10：图片选择库，第三方开源的与调用系统的 十、Camera相关1：利用系统Camera api自定义一个Camera的流程，如何配合Surfaceview/TextureView使用，Camera参数的设置，Camera预览，预览大小拍照大小的选择，预览画面旋转角度问题的处理，闪光灯，前置摄像头与后置摄像头切换，自动对焦问题，Camera坐标系，如何捕获Camera预览数据保存为图片（拍照功能的实现），保存图片时旋转角度问题的处理，何时需要释放Camera资源（不释放会导致什么问题），如何打开系统相机进行拍照/录视频（需要注意什么），Camera录制视频（配置MediaRecorder使用）2：Camera2，Camera2与Camera的区别，Camera2中常用的类，如何利用Camera2实现预览、拍照等功能 十一、音视频相关1：使用MediaRecorder录制音频2：使用MediaRecorder录制视频（配合Camera使用）3：使用AudioRecord录制音频，特殊格式如Mp3格式的录制，Android常见哪些音频格式, 哪些是同时可以兼容IOS平台的4：使用MediaPlayer播放视频/音频5：使用AudioTrack播放音频6：音视频编解码，常见的音视频的编码格式，硬解与软解/硬编与软编的区别及常用解决方案（目前硬件编解码主要是用Android的MediaCodec，软解编解码一般是采用开源库FFMpeg）7：视频的特效实现（如滤镜、合成、转场、涂鸦、水印、美颜、叠加等），美拍、抖音、直播等视频特效，市场主流的短视频SDK8：Android视频直播的实现（推流、播放），流媒体，主要的流媒体协议（RTMP、RTSP等），跟HTTP区别是什么，市场主流的直播SDK9：视频播放器，自定义实现播放功能（MediaPlayer或VideoView）, 播放本地视频/在线视频，常见开源播放器引擎（如bilibili的ijkPlayer的，Google的ExoPlayer）的学习使用源码解析，如何实现常见视频app软件的弹幕、音量调节、亮度调节、 倍速调节、 清晰度切换等功能（可以参考主流开源库GSYVideoPlayer、JiaoZiVideoPlayer等的实现）10：录屏（视频/Gif），截屏 十二、ViewPager相关1：ViewPager + PagerAdapter+View的使用方式2：ViewPager + FragmentPagerAdapter + Fragment的使用方式3：ViewPager的页面预加载特性，如何防止/进行数据预加载（View和Fragment两种），PagerAdapter/FragmentPagerAdapter 的缺陷，ViewPager刷新问题（PagerAdapter/FragmentPagerAdapter）, POSITION_NONE问题4：ViewPager的常见特效实现，如无限循环滑动的Banner广告条，单页显示3个Item的ViewPager炫酷切换效果，ViewPager换页滑动特效（PageTransformer应用动画效果）5：ViewPager的左右滑动监听，PageChangeListener中的几个方法解析，ViewPager指示器，自定义实现，常见开源库（ViewPagerIndicator、MagicIndicator） 十三、RecyclerView相关1：RecyclerView的基本使用方式，如何使用RecyclerView的三种布局管理器LinearLayoutManager、GridLayoutManager、StaggeredGridLayoutManager实现以前ListView、GridView以及瀑布流的效果，RecyclerViewAdapter的使用，多类型布局的、分组布局的Adapter使用（可以参考RecyclerViewAdapter简化使用开源库BRVAH），RecyclerView设置header/footer, RecyclerView上拉刷新、下拉刷新（配合SwipeRefreshLayout），RecyclerView设置分割线（ItemDecoration），RecyclerView点击事件2：RecyclerView的源码解析，与ListView相比的差异， ViewHolder3：RecyclerView的局部刷新，如何只刷新某一项，只刷新某一项中的某个控件，与ListView的局部刷新比较 十四、Canvas相关1：Canvas基本使用方法，画笔Paint的使用，Canvas绘制各种形状、文字、图片、曲线，Canvas画笔设置，Canvas剪裁，Canvas的现场保存/恢复，Canvas的变换、平移、缩放、旋转等2：Canvas在自定义View当中的使用 十五、传感器相关1：GPS, 如何使用Android原始代码实现GPS定位的获取（LocationManager），权限，注意事项（耗电量高，不能一直开着），拓展：LBS基站定位（国内常用的地图SDK高德/百度等定位都是以上两种方式的组合）2：其他手机支持的常见传感器，如加速度传感器、方向传感器、陀螺仪传感器、重力传感器、加速度传感器、距离传感器、计步传感器、光线传感器等，如何代码中设置监听器实时监听这些传感器的变化参数值，SensorManager，注册/反注册监听 十六、性能优化1：ANR, 什么是ANR, Activity/BroadcastReceiver/Service对ANR的响应时间，ANR产生的根本原因是什么，如何避免ANR, 如何避免在UI线程执行耗时任务，哪些日常操作任务是耗时任务（文件I/O、数据库、网络、解析等等）、有哪些方式可以异步处理耗时任务（线程、Aynctask等），区分UI线程和子线程，哪些日常场景是在UI线程中运行的（如四大组件都是在UI线程执行的），在不确定是UI还是非UI线程的运行环境中如何判断当前是否是主线程？（有几种方法）2：OOM，什么是OOM, 哪些情况容易产生OOM，如何避免OOM3：ListView优化，理解ListView的重用item机制原理，利用ViewHolder缓存view减少getView的执行时间，减少ItemView的布局层次，减少getView方法中的判断/计算/耗时逻辑，item中的图片避免每次都重新加载，做好图片缓存（使用图片加载库），快速滑动时不加载图片, 数据分页加载，图片错乱问题4：UI 卡顿，UI 卡顿的原因，帧率，16ms, 过渡绘制，耗时任务，如何布局优化，减少布局嵌套5：内存泄漏，GC垃圾回收机制，可能造成Android内存泄漏的几种情况，如何避免内存泄漏，Java内存分配管理的机制，堆内存和栈内存的区别，Android系统会为一个应用分配多大内存，如何提高应用内存，内存泄漏的排查方法/工具6：内存优化，弱引用与软引用（Weakreference、Softreference）, 避免对Activity作为Context的长时间引用或静态引用(如创建Handler AsyncTask的正确姿势)，SparseArray, 为什么Android推荐使用SparseArray来替代1：HashMap? 优越在哪里7：Crash崩溃异常，ForceClose，各种运行时异常（如空指针），如何避免，发生Crash时如何在app中捕获并保存本地或上传服务器8：广播和Service中可以进行网络请求吗，可以执行耗时任务吗9：AS哪些工具可以用来排查性能问题10：电池优化，网络优化 （缓存/离线） 十七、UI适配1：px、dp、sp、像素密度density和屏幕分辨率以及屏幕尺寸之间的关系，res/drawable-xxx各个文件夹与屏幕像素密度之间的关系2：保证不同屏幕展示的效果最好用Android系统提供的布局属性，不要写死固定大小，图片按照比例放在不同密度的drawable文件下或只用一套3：使用百分比布局（PercentxxxLayout）4：使用约束布局（ConstraintLayout）5：目前主流适配方案，今日头条屏幕适配方案和smallestWidth限定符适配方案分析6：目前市面上流行的刘海屏幕适配方法目前市面上流行的刘海屏幕适配方法 十八、Android中的Context1：理解Context的含义，Activity、Context、Application的区别和使用场景， ContextWrapper解析，getActivity()/getContext()/getApplication()/getApplicationContext()的区别2：避免Context静态持有，避免内存泄漏 十九、序列化与反序列化1：Serializable实现，实现方法，Intent传递与获取Serializable的方法2：Parcelable实现，实现方法，，Intent传递与获取Parcelable的方法3：Serializable和Parcelable区别，适合的使用场景（存储在内存中，推荐使用parcelable，存储在硬盘上，推荐使用Serializable） 二十、JSON解析1：理解json格式的定义，什么是合法/不合法的json格式，什么样的json格式利于/不利于客户端开发的解析2：Json的解析，使用原生代码解析，使用第三方库解析（Gson、FastJson、Jackson），Java类与Json字符串互转，注意事项，同一个字段多类型的json解析 二十一、二维码1：二维码扫描，基于ZXing或Zbar开源库的开发（如开源库BGAQRCode-Android），如何提高二维码扫描的识别率，生成二维码 二十二、Permission权限1：Android 6.0以后的权限适配，动态检查是否有某项权限，动态申请权限，申请权限的回调处理（有哪些第三方库可简化处理）、明确哪些行为是危险权限需要动态申请的，6.0以前的权限处理方式对比 二十三、Activity工作原理1：从手指点击桌面的app开始到界面呈现发生了哪些过程，第一个Activity对象是如何被创建的，Application对象是如何被创建的，默认的工作线程（UI线程）是如何创建的，主线程Looper的如何创建的，Activity与Window的关系，WindowManager解析，Android系统是如何通过WindowManager管理窗口的 二十四、View事件分发机制1：Touch事件的各个Action含义，何时会被触发2：Touch事件在View之间的传递过程（View、ViewGroup、Activity）,分发与处理的流程，何时会被消费，何时会被拦截，如何解决滑动冲突, onTouch 和 onTouchEvent区别，onClick与onTouch的关系3：Android手势处理，双指缩放、双击、单击，多点触控 二十五、View的绘制流程1：Activity的setContentView()做了什么，Window&amp;PhoneWindow&amp;DectorView&amp;ViewRoot&amp;contentView之间的关系2：View绘制的三个阶段measure，layout, draw的解析3：requestLayout，onLayout, onDraw, drawChild的区别与联系4：invalidate与postInvalidate的区别与联系 二十六、自定义view基本流程1：自定义属性，onMesure()，onLayout(ViewGroup) , onDraw(), TouchEvent的处理2：组合控件的自定义方式 二十七、Apk的打包/安装过程1：apk的打包过程，经过哪些步骤，每个步骤做了什么，AS的打包过程执行哪些task，每个task干了什么，apk签名（签名文件生成，AS打包apk时v1与v2选项的区别），apk对齐，apk加固（第三方都是如何实现的）2：apk的安装过程，系统在安装之前会做哪些工作？校验哪些信息？（不同Android版本之间的差异），安装apk的过程做了什么，会生成哪些文件，apk会被安装到系统哪个路径，app的私有数据（sp/数据库/私有文件）存储在哪个路径，哪些情况下安装apk会不成功，覆盖安装时（app升级）与app的包名、签名、版本号versionCode之间的关系, 什么是ART, Android 5.0以后ART替代之前的Dalvik虚拟机有哪些优点，AOT，为啥5.0以后安装的时候时间特别长但是运行速度比以前快3：app的卸载过程发生了什么，系统会删除哪些与apk相关的东西 二十八、App混淆1：混淆常用基本语法，混淆类、成员、方法，哪些类需要混淆，哪些类不能被混淆的，混淆文件的配置2：如何根据混淆之后的错误日志定位混淆之前的代码 二十九、App冷启动优化1：冷启动与热启动的区别，从点击桌面app图标到app的第一个Activity页面呈现经历了什么，优化哪个地方能加快页面的呈现2：如何实现app冷启动秒开，如何避免冷启动白屏/黑屏/缓慢，有哪些优化方案 三十、子线程不能更新UI1：正常情况下子线程不能更新UI，“子线程不能更新UI”这句话是一定的吗？什么情况下子线程可以更新UI？（如这个UI控件是由这个线程创建时，SurfaceView也可以在单独线程中刷新，OpenGL可以在渲染线程中绘制）2：view.postDelay(Runnable r)方法是运行在子线程中的吗？区分哪些场景是在主线程中的 三十一、Android Studio Gradle1：build.gradle常用配置，minSdkVersion、targetSdkVersion、compileSdkVersion三者的关系区别，这三个值对app代码开发/安装运行/版本更新时的影响，包名/签名/混淆/源码路径的配置、如何利用BuildConfig添加自定义的属性配置，从gradle中加载properties配置文件，如何在gradle中开启/关闭混淆/调试/Log输出，如何使用gradle任务打包，如何在dependence中添加依赖(本地jar包、aar包、so库依赖，远程依赖)，3.0以后的implementation、api、compileOnly与3.0以前的compile provided的区别，如何配置product falvor实现Build Variant变体打包，简单的Gradle task定义，指定task依赖任务，Android Studio的Gradle任务分析，Gradle插件，Gradle版本/仓库配置，groovy语法了解 三十二、adb相关1：掌握常用的adb命令，如使用adb pull/push从手机中拉取/推送文件，adb 截屏，使用adb 抓取log日志, 使用adb 安装/卸载应用，adb命令下调试应用等等 三十三、逆向安全1：app敏感数据的存储，如账户密码，请求的秘钥等，银行类交易类自定义输入键盘（避免拦截），设备唯一标识（Android目前有哪几种方式）2：反编译 apk, 反编译so等, 混淆3：app加固4：如何防止app网络请求被第三方抓包（socket/https）5：WebView开发JS交互避免远程执行漏洞6：加密算法（DES,AES,RSA,MD5,SHA1,Base64）,对称加密与非对称加密7：视频加密 三十四、NDK开发1：JNI基本数据类型，jni函数签名，jni注册native函数的两种方式（静态、动态）2：java与jni互调，java如何调用jni层，jni层如何调用java代码, JNI各种层数据类型与Java/C层各种数据类型互转调用3：Android.mk文件编写，如何连接源文件、.a .so库文件，如何编译生成动态链接库so文件，编译不同平台的so, 编译生成arm64位平台so时注意什么（指针要long型存）, Application.mk, build过程解析4：Android Studio环境下如何使用CMake方式进行NDK开发 三十五、设计模式1：UML类图、时序图2：OO六大设计原则，面向对象的三个基本特征3：23种设计模式，了解常用常见的设计模式并在项目中实践，Android源码中的设计模式4：如何优化代码，如何重构代码，去除重复代码，代码规范 三十六、架构模式1：MVP模式， MVP、 MVC、MVVM（数据绑定式的MVP）的区别, MVP + Clean模式2：模块化（从功能/业务上区分）3：组件化的开发架构，组件化带来的问题，模块之间的跳转，路由，ARouter4：插件化的开发架构，插件化的核心原理，虚拟机(内存管理，类加载，双亲委派), 主流插件化框架原理分析5：热修复核心原理，主流热修复框架原理分析 RxJava 实现原理，什么是响应式编程，观察者/订阅模式，RxJava是如何实现线程自由切换的, RxJava在空间和时间维度上重新组织事件的能力 Kotlin Kotlin学习了解，与Java的区别，哪个更好用 Dagger 2 依赖注入框架，使用与原理解析 Flutter Flutter学习了解，跨平台，同时支持iOS和Android Weex Weex学习了解，跨平台，同时支持iOS和Android Hybrid 混合开发 除H5以外，有哪些混合开发方式（weex，小程序，React Native等了解） OpenGL OpenGL了解，了解OpenGL 的渲染流程（顶点着色器、片元着色器、光栅化、顶点坐标系、法向量、光照、投影、剪裁等等） 学习Android系统中OpenGL ES 2.0/3.0的Api，使用OpenGL配合GLSurfaceView、Render等绘制点、线、面、纹理贴图等等 测试工具 内存分析:MAT,DDMS,Leakcanary(Square) 静态分析:Find Bugs,Lint 压力测试:Monkey 自动化测试: UiAutomator,MonkeyRunner,Rubotium,Athrun(淘宝) 其他冷门知识 Android近场通信NFC、Wifi、蓝牙、USB串口通信等开发 Android内核移植、嵌入式终端开发(非手机，如定制的平板、TV，定制的点餐平台，显示器等), 或基于终端系统之上的应用开发 手机开发(非app开发，这里指手机厂商，如华为，小米，需要精通framework层以及Android系统底层源码)，手机操作系统定制 Android游戏开发（这个不算冷门，只是平时接触比较少） 其他补充： Notification Dialog Bitmap对象的理解 AndroidManifest的作用与理解 App中唤醒其他进程/应用的实现方式 ButterKnife实现原理 Dagger依赖注入 Android 多进程和Application关系 Android页面恢复 如何监听Home键和back键点击 apk多入口 第三方消息推送SDK 地图 硬件加速 Emoji 多国语言适配（不单单指语言strings.xml适配 布局也可能要支持RTL） 正则表达式 armeabi/armeabi-v7a/arm64-v8a等so库兼容问题 类的加载机制 Android 65K问题，分包，引入第三方包冲突解决方案 计时器/定时任务（Android有哪几种实现方式） Theme 和 Styles 多点触控 闹钟 音乐播放器 输入法软键盘相关 分屏 夜间模式 待续… Java部分一、Java基础1：Java基础数据类型，各占用多少字节，数据类型之间的相互转换，数据类型之间的比较==和equals的区别2：String、StringBuffer、StringBuilder区别，哪个是线程安全的，何时需要使用后面两个（有什么区别），String属于Java的基础数据类型吗，字符串操作（分隔、拼接、替换、查找），字符串比较，String与其他基础数据类型的包装类型之间的互转，String与char或byte Array之间的互转，创建字符串变量有几种方式有什么区别，什么是字符串池，为什么说Java字符串是不可变对象3：Java集合相关，集合的排序/遍历/复制， HashMap原理，HashMap 和 HashTable 区别，LinkedHashMap源码分析， HashCode 作用，如何重载hashCode方法，ArrayList与LinkList区别与联系, List与数组[]相互转换，List,Set,Map的区别，ConcurrentHashMap的实现原理，要存储一个数据元素不重复的集合该使用哪种集合，要存储一个数据元素是有序的集合该使用哪种集合，ArrayList和HashMap 等集合是如何扩容的4：Java反射相关，方法、成员变量5：Java注解相关6：Java线程同步相关，Java死锁产生的原因及避免，方法锁、对象锁、类锁的意义和区别，线程同步的方法：Synchronized、lock、reentrantLock分析，Synchronized原理，Volatile实现原理，ThreadLocal的原理和用法，ThreadPool的用法和示例，wait()和sleep()的区别，wait/notify关键字的理解7：Java枚举相关8：Java内存管理，虚拟机 ，GC机制，Java引用类型，循环引用，Java内存泄漏，Java内存模型（堆内存 栈内存 常量池），Java中new 一个对象是存在哪里的9：JVM类加载机制，ClassLoader(类加载器)的理解，Android中的区别10：什么是多态，Java封装、继承和多态的理解11：什么是内部类？内部类的作用，静态内部类的作用12：什么是抽象类，抽象类和接口区别，抽象类是否可以没有方法和属性，接口的意义13：Java泛型相关，如何通过泛型传递Java类作为参数14：序列化的方式 Serializable 和Parcelable 的区别15：静态属性和静态方法是否可以被继承？重写？以及原因？16：final，finally，finalize的区别17：utf-8编码中的中文占几个字节；int型几个字节？，java unicode编码，中文与unicode互转18：什么是深拷贝和浅拷贝19：如何实现多线程断点续传20：Class.forName()和ClassLoader的区别21：待续… 二、Java数据结构和算法1：栈和队列，栈和队列的概念理解，Java代码实现栈LIFO（后进先出）和队列FIFO（先进先出），实现思路，入栈/出栈，栈顶/栈底，入队/出队，队头/队尾，栈/队的遍历，循环队列，判断栈/队列是否为空2：数组和链表，数组和链表的特点和区别，Java代码实现链表结构，数组和链表分别实现查找、插入，删除等操作以及各自的时间复杂度和空间复杂度，链表的反序，两个有序链表的合并，双向链表结构的实现，双向链表的插入、删除等，自定义一个动态数组，Java 类中哪些结构属于数组/链表3：排序算法，Java八大排序算法的实现思路（选择排序，快速排序，冒泡排序，堆排序，希尔排序，归并排序，直接插入排序，基数排序）以及各自的时间复杂度和空间复杂度，最快的排序算法是哪个？ 哪些是稳定/不稳定的排序算法，快排的优化，手写冒泡、快排代码4：查找算法，Java代码实现顺序查找和二分查找，实现思路5：二叉树，二叉树排序，二叉树遍历、查找、删除，哈夫曼树、红黑树6：Hash表，及Hash冲突的解决7：Java有向图的遍历，BFS遍历和DFS遍历（深度优先搜索算法和广度优先搜索算法）、Prim、Dijkstra算法8：经典问题：海量数据的处理 （10亿个数中找出最大的10000个数 TOP K问题）9：两个不重复的数组集合中，两个集合都是海量数据，内存中放不下，求共同元素10：烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？11：时针走一圈，时针分针重合几次12：N*N的方格纸,里面有多少个正方形13：待续…]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView中添加的HeadView隐藏时仍然占用空间的解决方法]]></title>
    <url>%2Fposts%2Fdf7e47f7.html</url>
    <content type="text"><![CDATA[今天在开发的时候遇到了一个ListView中添加的HeadView隐藏时仍然占用空间的解决方法； 具体问题如下：listView.addHeadView(headView); 但是在执行headView.setVisibility(View.GONE);后headView虽然隐藏了，但是仍然占用了空间； 解决方法： 在添加HeadView之前首先创建一个父布局parentView,即： 12345LinearLayout parentView=new LinearLayout (Context context);parentView.addView(headView);listView.addHeadView(parentView); 之后再进行隐藏： 12//就可以实现以上所说的效果了。headView.setVisibility(View.GONE);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android APP分享微信小程序]]></title>
    <url>%2Fposts%2F83fb494f.html</url>
    <content type="text"><![CDATA[需求：APP端 将公司的微信小程序 分享至微信好友 最近，微信小程序比较火热，公司也在做这一块，目前公司的小程序都是由H5端开发的，我们Android端也接到一个任务，那就是Android端应支持微信小程序的分享，并且通过分享出去的小程序可以启动我们的APP； 今天我们先来完成：Android端应支持微信小程序的分享！！！ 分析： 微信开放平台SDK支持小程序类型分享，详见官方文档： https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419317340&amp;token=&amp;lang=zh_CN a) 要求发起分享的App与小程序属于同一微信开放平台帐号； b) 支持分享小程序类型消息至好友会话，不支持“分享至朋友圈” “收藏”； c) 微信客户端版本要求：6.5.6及以上微信客户端版本，若客户端版本低于6.5.6，小程序类型分享将自动转成网页类型分享。开发者必须填写网页链接字段，确保低版本客户端能正常打开网页链接； d) 支持分享大图卡片样式，自定义图片建议长宽比是 5:4。6.5.9及以上版本微信客户端小程序类型分享使用大图卡片样式。 e)支持分享开发版/体验版小程序，为支持开发者调试，开发者工具包支持分享开发版/体验版小程序至微信，开发者可控制分享的小程序版本。 把文档看了一遍，发现限制是比较多的，但是功能实现还是很简单的，下面让我们开始吧！！！ 开发： 前期准备 小程序与APP主体账号绑定开发人员希望通过APP分享小程序，需要先将小程序与APP主体账号（即APP的微信开放平台账号）绑定，APP才具有分享对应小程序的能力。如果没有与主体账号绑定，分享时是报错的，如下图：​ 登录APP所在的微信开放平台：https://open.weixin.qq.com/绑定小程序 由上图可以看到，绑定小程序的数量是有限制的。我们点击【绑定小程序】按钮，打开的新页面 输入小程序开发的主账号和密码，输入验证码提交就可以了，然后再通过手机微信扫码验证一下。 绑定成功后，直接就能在绑定列表中看到已绑定的小程序！！！ 代码实现小程序端提供参数：12miniProgram.userName="xxx"; //小程序IDminiProgram.path="pages/xxx/xxx"; //小程序路径 配置gradle123dependencies &#123; compile 'com.tencent.mm.opensdk:wechat-sdk-android-with-mta:+'&#125; 分享小程序的核心代码12345678910111213141516171819202122232425262728293031323334public void shareMinP(ShareMiniPModel shareModel)&#123; if (shareModel == null) return; WXMiniProgramObject miniProgramObj = new WXMiniProgramObject(); miniProgramObj.webpageUrl = shareModel.getWebPageUrl(); // 兼容低版本的网页链接 miniProgramObj.miniprogramType = shareModel.getMiniProgramType(); // 分享小程序版 正式版:0，测试版:1，体验版:2 miniProgramObj.userName = shareModel.getMiniId(); // 小程序原始id miniProgramObj.path = shareModel.getMiniPath(); // 小程序页面路径 localWXMediaMessage = new WXMediaMessage(miniProgramObj); localWXMediaMessage.title = shareModel.getTitle(); // 小程序消息title localWXMediaMessage.description = shareModel.getDescription(); // 详细描述 if (!TextUtils.isEmpty(shareModel.getImageUrl()))&#123; inflateImage(shareModel.getImageUrl(), new Callback() &#123; // 小程序图片 @Override public void onLoadingComplete(String s, View view, Bitmap bitmap) &#123; thumbBmp = bitmap; localWXMediaMessage.thumbData = bmpToByteArray(thumbBmp, true); if (localWXMediaMessage.thumbData.length &lt; 131072)&#123; WXsendReq(SendMessageToWX.Req.WXSceneSession, localWXMediaMessage); &#125; else &#123; LogUtils.e("分享小程序，缩略图不得超过128kb"); &#125; &#125; &#125;); &#125; else if (shareModel.getImageBitmap() != null)&#123; thumbBmp = shareModel.getImageBitmap(); localWXMediaMessage.thumbData = bmpToByteArray(thumbBmp, true); if (localWXMediaMessage.thumbData.length &lt; 131072)&#123; WXsendReq(SendMessageToWX.Req.WXSceneSession, localWXMediaMessage); &#125; else &#123; LogUtils.e("分享小程序，缩略图不得超过128kb"); &#125; &#125;&#125; Demo演示为了避免麻烦，我们直接下载使用官方Demo，在其源代码上直接修改，修改的内容主要如下： a. 包名（必须修改，使用你项目APP的实际包名） b. 配置gradle（微信sdk包、签名文件） c. 增加分享小程序的按钮和事件下载微信开放平台官方Demo https://open.weixin.qq.com/zh_CN/htmledition/res/dev/download/sdk/WeChatSDK_sample_Android.zip 修改包名 使用Androidstudio打开demo，目录结构如下图，修改其包名 如上图，取消compact empty middle packages的默认选中在对应包名的文件夹上，直接右键修改名称，改成包名对应的名称，并全部应用可参考：https://www.jianshu.com/p/557e1906db1a修改后的包名，必须是你项目APP的实际包名，且已通过微信开放平台审核的APP包名； 配置gradle（修改依赖、修改签名） 签名必须使用你项目APP对应的签名文件，即你申请微信开放平台时APP对应的签名文件； 修改APP_ID12345678910public class Constants &#123; // APP_ID 替换为你的应用从官方网站申请到的合法appId public static final String APP_ID = "wxf666676666636666"; public static class ShowMsgActivity &#123; public static final String STitle = "showmsg_title"; public static final String SMessage = "showmsg_message"; public static final String BAThumbData = "showmsg_thumb_data"; &#125;&#125; 增加分享小程序的按钮和事件 测试 选择分享的人员 收到分享的小程序卡片]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Snackbar的使用]]></title>
    <url>%2Fposts%2F30a2bcae.html</url>
    <content type="text"><![CDATA[Snackbar是design support library中的组件的其中之一，它的使用效果与Toast类似，但更加灵活Snackbar拥有的特性： 显示一段时间或当用户与之进行交互后，会自动消失 通过CoordinatorLayout可以实现向右滑动消除Snackbar的效果 同一时间只能显示一个Snackbar 与Toast类似地使用LENGTH_LONG 和 LENGTH_SHORT设置显示时间 提供Action属性供添加点击事件监听 提供回调函数可以对Snackbar进行监听 想要使用Snackbar，首先需要添加com.android.support:design依赖项 一、 Snackbar的最简单用法是和Toast一样声明1Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT).show(); 大部分属性与Toast相同，不过第一个参数传入的不是Context，而应该是一个View，因为Snackbar需要一个控件容器用来容纳自身，这里使用一个TextView所以，主布局文件可修改为 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:text="Snackbar" /&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="点击按钮" /&gt;&lt;/LinearLayout&gt; MainActivity 修改为如下所示，当点击了Button后弹出Snackbar 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity &#123; private TextView textView; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.text); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 二、 此外，Snackbar可以通过Action来与之进行交互1234567891011121314button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(textView, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .show(); &#125; &#125;); 三、 官方推荐使用CoordinatorLayout作为Snackbar的容纳容器，这样就可以实现向右滑动消除Snackbar的效果将主布局文件修改为 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id="@+id/layoutRoot" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="按钮" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/LinearLayout&gt; MainActivity 文件修改为 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; private CoordinatorLayout layout; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); layout = (CoordinatorLayout) findViewById(R.id.layoutRoot); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .show(); &#125; &#125;); &#125;&#125; 四、 可以设置Snackbar的出现消失监听函数在Snackbar出现和消失时分别弹出一个Toast进行提示 123456789101112131415161718192021222324252627button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT) .setAction("Action", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, "点击了Action", Toast.LENGTH_SHORT).show(); &#125; &#125;) .setActionTextColor(Color.parseColor("#375ED1")) .setCallback(new Snackbar.Callback() &#123; @Override public void onDismissed(Snackbar snackbar, int event) &#123; super.onDismissed(snackbar, event); Toast.makeText(MainActivity.this, "消失了", Toast.LENGTH_SHORT).show(); &#125; @Override public void onShown(Snackbar snackbar) &#123; super.onShown(snackbar); Toast.makeText(MainActivity.this, "出现了", Toast.LENGTH_SHORT).show(); &#125; &#125;) .show(); &#125; &#125;); 五、改变Snackbar的背景色想要设置Snackbar的背景色，就要通过getView()方法了，这里Snackbar需要换一种声明方式 123456789button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar snackbar = Snackbar.make(layout, "消息", Snackbar.LENGTH_SHORT); //设置背景色 snackbar.getView().setBackgroundColor(Color.parseColor("#375ED1")); snackbar.show(); &#125; &#125;); 六、Snackbar不一定只能从屏幕底端出现Snackbar会沿着View 的树状路径，找到第一个合适的布局或窗口视图，作为父 View因此，我们可以改变Snackbar的父View位置，从而改变Snackbar的出现位置修改主布局文件，将屏幕平均分为上下两个空间 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.zy.snackbartest.MainActivity"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id="@+id/layoutRoot" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="按钮" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="#adc"&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View坐标详解]]></title>
    <url>%2Fposts%2Fbc32efd9.html</url>
    <content type="text"><![CDATA[转：https://blog.csdn.net/yanbober/article/details/50419117 背景学习自定义控件以此为基础，先总结一下自定义控件的一个核心知识点——坐标系。 很多人可能不屑一顾Android的坐标系，但是如果你想彻底学会自定义控件，我想说了解Android各种坐标系及一些API的坐标含义绝对算一个小而不可忽视的技能；所谓Android自定义View那几大主要onXXX()方法的重写实质其实大多数都是在处理坐标逻辑运算，所以我们就先来就题重谈一下Android坐标系。 android坐标系说到Android坐标系其实就是一个三维坐标，Z轴向上，X轴向右，Y轴向下。这三维坐标的点处理就能构成Android丰富的界面或者动画等效果，所以Android坐标系在整个Android界面中算是盖楼房的尺寸草图，下面我们就来看看这些相关的概念。 android屏幕区域划分我们先看一副图来了解一下Android屏幕的区域划分 通过上图我们可以很直观的看到Android对于屏幕的划分定义。下面我们就给出这些区域里常用区域的一些坐标或者度量方式。如下： 12345//获取屏幕区域的宽高等尺寸获取DisplayMetrics metrics = new DisplayMetrics();getWindowManager().getDefaultDisplay().getMetrics(metrics);int widthPixels = metrics.widthPixels;int heightPixels = metrics.heightPixels; 123//应用程序App区域宽高等尺寸获取Rect rect = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect); 1234//获取状态栏高度Rect rect= new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);int statusBarHeight = rectangle.top; 123//View布局区域宽高等尺寸获取Rect rect = new Rect(); getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect); 特别注意：上面这些方法最好在Activity的onWindowFocusChanged ()方法或者之后调运，因为只有这时候才是真正的显示OK，不懂的可以看我之前关于setContentView相关的博客。 android view绝对相对坐标系上面我们分析了Android屏幕的划分，可以发现我们平时开发的重点其实都在关注View布局区域，那么下面我们就来细说一下View区域相关的各种坐标系。先看下面这幅图： 通过上图我们可以很直观的给出View一些坐标相关的方法解释，不过必须要明确的是上面这些方法必须要在layout之后才有效，如下： View的静态坐标方法 解释 getLeft() 返回View自身左边到父布局左边的距离 getTop() 返回View自身顶边到父布局顶边的距离 getRight() 返回View自身右边到父布局左边的距离 getBottom() 返回View自身底边到父布局顶边的距离 getX() 返回值为getLeft()+getTranslationX()，当setTranslationX()时getLeft()不变，getX()变。 getY() 返回值为getTop()+getTranslationY()，当setTranslationY()时getTop()不变，getY()变。 同时也可以看见上图中给出了手指触摸屏幕时MotionEvent提供的一些方法解释，如下： MotionEvent坐标方法 解释 getX() 当前触摸事件距离当前View左边的距离 getY() 当前触摸事件距离当前View顶边的距离 getRawX() 当前触摸事件距离整个屏幕左边的距离 getRawY() 当前触摸事件距离整个屏幕顶边的距离 上面就解释了你在很多代码中看见各种getXXX方法进行数学逻辑运算判断的含义。不过上面只是说了一些相对静止的Android坐标点关系，下面我们来看看几个和上面方法紧密相关的View方法。如下： View宽高方法 解释 getWidth() layout后有效，返回值是mRight-mLeft，一般会参考measure的宽度（measure可能没用），但不是必须的。 getHeight() layout后有效，返回值是mBottom-mTop，一般会参考measure的高度（measure可能没用），但不是必须的。 getMeasuredWidth() 返回measure过程得到的mMeasuredWidth值，供layout参考，或许没用。 getMeasuredHeight() 返回measure过程得到的mMeasuredHeight值，供layout参考，或许没用。 上面解释了自定义View时各种获取宽高的一些含义，下面我们再来看看关于View获取屏幕中位置的一些方法，不过这些方法需要在Activity的onWindowFocusChanged ()方法之后才能使用。如下图： 下面我们就给出上面这幅图涉及的View的一些坐标方法的结果（结果采用使用方法返回的实际坐标，不依赖上面实际绝对坐标转换，上面绝对坐标只是为了说明例子中的位置而已），如下： View的方法 上图View1结果 上图View2结果 结论描述 getLocalVisibleRect() (0, 0 - 410, 100) (0, 0 - 410, 470) 获取View自身可见的坐标区域，坐标以自己的左上角为原点(0,0)，另一点为可见区域右下角相对自己(0,0)点的坐标，其实View2当前height为550，可见height为470。 getGlobalVisibleRect() (30, 100 - 440, 200) (30, 250 - 440, 720) 获取View在屏幕绝对坐标系中的可视区域，坐标以屏幕左上角为原点(0,0)，另一个点为可见区域右下角相对屏幕原点(0,0)点的坐标。 getLocationOnScreen() (30, 100) (30, 250) 坐标是相对整个屏幕而言，Y坐标为View左上角到屏幕顶部的距离。 getLocationInWindow() (30, 100) (30, 250) 如果为普通Activity则Y坐标为View左上角到屏幕顶部（此时Window与屏幕一样大）；如果为对话框式的Activity则Y坐标为当前Dialog模式Activity的标题栏顶部到View左上角的距离。 到此常用的相关View的静态坐标获取处理的方法和含义都已经叙述完了，下面我们看看动态的一些解释（所谓动静只是我个人称呼而已）。 Android View动画相关坐标系其实在我们使用动画时，尤其是补间动画时，你会发现其中涉及很多坐标参数，一会儿为相对的，一会儿为绝对的，你可能会各种蒙圈。那么不妨看下《Android应用开发之所有动画使用详解 》这篇博客，这里面详细介绍了关于Android动画相关的坐标系统，这里不再累赘叙述。 Android View滑动相关坐标系关于View提供的与坐标息息相关的另一组常用的重要方法就是滚动或者滑动相关的，下面我们给出相关的解释（特别注意：View的scrollTo()和scrollBy()是用于滑动View中的内容，而不是改变View的位置；改变View在屏幕中的位置可以使用offsetLeftAndRight()和offsetTopAndBottom()方法，他会导致getLeft()等值改变。），如下： View的滑动方法 效果及描述 offsetLeftAndRight(int offset) 水平方向挪动View，offset为正则x轴正向移动，移动的是整个View，getLeft()会变的，自定义View很有用。 offsetTopAndBottom(int offset) 垂直方向挪动View，offset为正则y轴正向移动，移动的是整个View，getTop()会变的，自定义View很有用。 scrollTo(int x, int y) 将View中内容（不是整个View）滑动到相应的位置，参考坐标原点为ParentView左上角，x，y为正则向xy轴反方向移动，反之同理。 scrollBy(int x, int y) 在scrollTo()的基础上继续滑动xy。 setScrollX(int value) 实质为scrollTo()，只是只改变Y轴滑动。 setScrollY(int value) 实质为scrollTo()，只是只改变X轴滑动。 getScrollX()/getScrollY() 获取当前滑动位置偏移量。 关于Android View的scrollBy()和scrollTo()参数传递正数却向坐标系负方向移动的特性可能很多人都有疑惑，甚至是死记结论，这里我们简单给出产生这种特性的真实原因—-源码分析，如下： 12345678910111213public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125; View的该方法注释里明确说明了调运他会触发onScrollChanged()和invalidated()方法，那我们就将矛头转向invalidated()方法触发的draw()过程，draw()过程中最终其实会触发下面的invalidate()方法，如下： 123456public void invalidate(int l, int t, int r, int b) &#123; final int scrollX = mScrollX; final int scrollY = mScrollY; //scroller时为何参数和坐标反向的真实原因 invalidateInternal(l - scrollX, t - scrollY, r - scrollX, b - scrollY, true, false);&#125; 核心就在这里，相信不用我解释大家也知道咋回事了，自行脑补。 scrollTo()和scrollBy()方法特别注意：如果你给一个ViewGroup调用scrollTo()方法滚动的是ViewGroup里面的内容，如果想滚动一个ViewGroup则再给他嵌套一个外层，滚动外层即可。 总结可以发现，上面只是说明了一些View里常用的与坐标相关的概念，关于自定义控件了解学习这些坐标概念只是一个基础，也是一个后续内容的铺垫，所以有必要先完全吃透此部分内容才能继续拓展学习新的东东。 View中还有一些其他与坐标获取相关的方法，但是一般都比较不常用，所以用到时可以现查API或者Debug看现象进行学习即可，这里篇幅和时间有限就不一一道来了。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 控件 RecyclerView]]></title>
    <url>%2Fposts%2F4fcbe74a.html</url>
    <content type="text"><![CDATA[转自：https://www.jianshu.com/p/4f9591291365 概述RecyclerView是什么从Android 5.0开始，谷歌公司推出了一个用于大量数据展示的新控件RecylerView，可以用来代替传统的ListView，更加强大和灵活。RecyclerView的官方定义如下： A flexible view for providing a limited window into a large data set. 从定义可以看出，flexible（可扩展性）是RecyclerView的特点。 RecyclerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字Recyclerview即回收view也可以看出。 RecyclerView的优点RecyclerView并不会完全替代ListView（这点从ListView没有被标记为@Deprecated可以看出），两者的使用场景不一样。但是RecyclerView的出现会让很多开源项目被废弃，例如横向滚动的ListView, 横向滚动的GridView, 瀑布流控件，因为RecyclerView能够实现所有这些功能。 比如：有一个需求是屏幕竖着的时候的显示形式是ListView，屏幕横着的时候的显示形式是2列的GridView，此时如果用RecyclerView，则通过设置LayoutManager一行代码实现替换。 RecylerView相对于ListView的优点罗列如下： RecyclerView封装了viewholder的回收复用，也就是说RecyclerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的逻辑被封装了，写起来更加简单。 直接省去了listview中convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。 提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecyclerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。 设置布局管理器以控制Item的布局方式，横向、竖向以及瀑布流方式 例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还StaggeredGridLayoutManager等)。也就是说RecyclerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。 可设置Item的间隔样式（可绘制） 通过继承RecyclerView的ItemDecoration这个类，然后针对自己的业务需求去书写代码。 可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecyclerView有其自己默认的实现。 但是关于Item的点击和长按事件，需要用户自己去实现。 基本使用123456789101112recyclerView = (RecyclerView) findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this ); //设置布局管理器 recyclerView.setLayoutManager(layoutManager); //设置为垂直布局，这也是默认的 layoutManager.setOrientation(OrientationHelper. VERTICAL); //设置Adapter recyclerView.setAdapter(recycleAdapter); //设置分隔线 recyclerView.addItemDecoration( new DividerGridItemDecoration(this )); //设置增加或删除条目的动画 recyclerView.setItemAnimator( new DefaultItemAnimator()); 在使用RecyclerView时候，必须指定一个适配器Adapter和一个布局管理器LayoutManager。适配器继承RecyclerView.Adapter类，具体实现类似ListView的适配器，取决于数据信息以及展示的UI。布局管理器用于确定RecyclerView中Item的展示方式以及决定何时复用已经不可见的Item，避免重复创建以及执行高成本的findViewById()方法。 可以看见RecyclerView相比ListView会多出许多操作，这也是RecyclerView灵活的地方，它将许多动能暴露出来，用户可以选择性的自定义属性以满足需求。 基本使用引用在build.gradle文件中引入该类。 1compile &apos;com.android.support:recyclerview-v7:23.4.0&apos; 布局Activity布局文件activity_rv.xml … Item的布局文件item_1.xml … 创建适配器标准实现步骤如下： ① 创建Adapter：创建一个继承RecyclerView.Adapter的Adapter类（VH是ViewHolder的类名） ② 创建ViewHolder：在Adapter中创建一个继承RecyclerView.ViewHolder的静态内部类，记为VH。ViewHolder的实现和ListView的ViewHolder实现几乎一样。 ③ 在Adapter中实现3个方法： onCreateViewHolder()这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。 需要注意的是在onCreateViewHolder()中，映射Layout必须为 1View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false); 而不能是： 1View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, null); onBindViewHolder()这个方法主要用于适配渲染数据到View中。方法提供给你了一viewHolder而不是原来的convertView。 getItemCount()这个方法就类似于BaseAdapter的getCount方法了，即总共有多少个条目。 可以看出，RecyclerView将ListView中getView()的功能拆分成了onCreateViewHolder()和onBindViewHolder()。 基本的Adapter实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940// ① 创建Adapterpublic class NormalAdapter extends RecyclerView.Adapter&lt;NormalAdapter.VH&gt;&#123; //② 创建ViewHolder public static class VH extends RecyclerView.ViewHolder&#123; public final TextView title; public VH(View v) &#123; super(v); title = (TextView) v.findViewById(R.id.title); &#125; &#125; private List&lt;String&gt; mDatas; public NormalAdapter(List&lt;String&gt; data) &#123; this.mDatas = data; &#125; //③ 在Adapter中实现3个方法 @Override public void onBindViewHolder(VH holder, int position) &#123; holder.title.setText(mDatas.get(position)); holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //item 点击事件 &#125; &#125;); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; @Override public VH onCreateViewHolder(ViewGroup parent, int viewType) &#123; //LayoutInflater.from指定写法 View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false); return new VH(v); &#125;&#125; 设置RecyclerView创建完Adapter，接着对RecyclerView进行设置，一般来说，需要为RecyclerView进行四大设置，也就是后文说的四大组成： Layout Manager(必选) Adapter(必选) Item Decoration(可选，默认为空) Item Animator(可选，默认为DefaultItemAnimator) 如果要实现ListView的效果，只需要设置Adapter和Layout Manager，如下： 1234List&lt;String&gt; data = initData();RecyclerView rv = (RecyclerView) findViewById(R.id.rv);rv.setLayoutManager(new LinearLayoutManager(this));rv.setAdapter(new NormalAdapter(data)); 四大组成RecyclerView的四大组成是： Layout Manager：Item的布局。 Adapter：为Item提供数据。 Item Decoration：Item之间的Divider。 Item Animator：添加、删除Item动画。 Layout Manager布局管理器在最开始就提到，RecyclerView 能够支持各种各样的布局效果，这是 ListView 所不具有的功能，那么这个功能如何实现的呢？其核心关键在于 RecyclerView.LayoutManager 类中。从前面的基础使用可以看到，RecyclerView 在使用过程中要比 ListView 多一个 setLayoutManager 步骤，这个 LayoutManager 就是用于控制我们 RecyclerView 最终的展示效果的。 LayoutManager负责RecyclerView的布局，其中包含了Item View的获取与回收。 RecyclerView提供了三种布局管理器： LinerLayoutManager 以垂直或者水平列表方式展示Item GridLayoutManager 以网格方式展示Item StaggeredGridLayoutManager 以瀑布流方式展示Item 如果你想用 RecyclerView 来实现自己自定义效果，则应该去继承实现自己的 LayoutManager，并重写相应的方法，而不应该想着去改写 RecyclerView。 LayoutManager 常见 API关于 LayoutManager 的使用有下面一些常见的 API（有些在 LayoutManager 实现的子类中） 123456789101112canScrollHorizontally();//能否横向滚动canScrollVertically();//能否纵向滚动scrollToPosition(int position);//滚动到指定位置setOrientation(int orientation);//设置滚动的方向getOrientation();//获取滚动方向findViewByPosition(int position);//获取指定位置的Item ViewfindFirstCompletelyVisibleItemPosition();//获取第一个完全可见的Item位置findFirstVisibleItemPosition();//获取第一个可见Item的位置findLastCompletelyVisibleItemPosition();//获取最后一个完全可见的Item位置findLastVisibleItemPosition();//获取最后一个可见Item的位置 上面仅仅是列出一些常用的 API 而已，更多的 API 可以查看官方文档，通常你想用 RecyclerView 实现某种效果，例如指定滚动到某个 Item 位置，但是你在 RecyclerView 中又找不到可以调用的 API 时，就可以跑到 LayoutManager 的文档去看看，基本都在那里。 另外还有一点关于瀑布流布局效果 StaggeredGridLayoutManager 想说的，看到网上有些文章写的示例代码，在设置了 StaggeredGridLayoutManager 后仍要去 Adapter 中动态设置 View 的高度，才能实现瀑布流，这种做法是完全错误的，之所以 StaggeredGridLayoutManager 的瀑布流效果出不来，基本是 item 布局的 xml 问题以及数据问题导致。如果要在 Adapter 中设置 View 的高度，则完全违背了 LayoutManager 的设计理念了。 LinearLayoutManager源码分析 这里我们简单分析LinearLayoutManager的实现。 对于LinearLayoutManager来说，比较重要的几个方法有： onLayoutChildren(): 对RecyclerView进行布局的入口方法。 fill(): 负责填充RecyclerView。 scrollVerticallyBy():根据手指的移动滑动一定距离，并调用fill()填充。 canScrollVertically()或canScrollHorizontally(): 判断是否支持纵向滑动或横向滑动。 onLayoutChildren()的核心实现如下： 1234public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; detachAndScrapAttachedViews(recycler); //将原来所有的Item View全部放到Recycler的Scrap Heap或Recycle Pool fill(recycler, mLayoutState, state, false); //填充现在所有的Item View&#125; RecyclerView的回收机制有个重要的概念，即将回收站分为Scrap Heap和Recycle Pool，其中Scrap Heap的元素可以被直接复用，而不需要调用onBindViewHolder()。detachAndScrapAttachedViews()会根据情况，将原来的Item View放入Scrap Heap或Recycle Pool，从而在复用时提升效率。 fill()是对剩余空间不断地调用layoutChunk()，直到填充完为止。layoutChunk()的核心实现如下： 123456public void layoutChunk() &#123; View view = layoutState.next(recycler); //调用了getViewForPosition() addView(view); //加入View measureChildWithMargins(view, 0, 0); //计算View的大小 layoutDecoratedWithMargins(view, left, top, right, bottom); //布局View&#125; 其中next()调用了getViewForPosition(currentPosition)，该方法是从RecyclerView的回收机制实现类Recycler中获取合适的View，在后文的回收机制中会介绍该方法的具体实现。 如果要自定义LayoutManager，可以参考： 创建一个 RecyclerView LayoutManager – Part 1 创建一个 RecyclerView LayoutManager – Part 2 创建一个 RecyclerView LayoutManager – Part 3 Adapter适配器Adapter的使用方式前面已经介绍了，功能就是为RecyclerView提供数据，这里主要介绍万能适配器的实现。其实万能适配器的概念在ListView就已经存在了，即base-adapter-helper。 这里我们只针对RecyclerView，聊聊万能适配器出现的原因。为了创建一个RecyclerView的Adapter，每次我们都需要去做重复劳动，包括重写onCreateViewHolder(),getItemCount()、创建ViewHolder，并且实现过程大同小异，因此万能适配器出现了。 万能适配器这里讲解下万能适配器的实现思路。 我们通过public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;定义万能适配器QuickAdapter类，T是列表数据中每个元素的类型，QuickAdapter.VH是QuickAdapter的ViewHolder实现类，称为万能ViewHolder。 首先介绍QuickAdapter.VH的实现： 1234567891011121314151617181920212223242526272829static class VH extends RecyclerView.ViewHolder&#123; private SparseArray&lt;View&gt; mViews; private View mConvertView; private VH(View v)&#123; super(v); mConvertView = v; mViews = new SparseArray&lt;&gt;(); &#125; public static VH get(ViewGroup parent, int layoutId)&#123; View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false); return new VH(convertView); &#125; public &lt;T extends View&gt; T getView(int id)&#123; View v = mViews.get(id); if(v == null)&#123; v = mConvertView.findViewById(id); mViews.put(id, v); &#125; return (T)v; &#125; public void setText(int id, String value)&#123; TextView view = getView(id); view.setText(value); &#125;&#125; 其中的关键点在于通过SparseArray&lt;View&gt;存储item view的控件，getView(int id)的功能就是通过id获得对应的View（首先在mViews中查询是否存在，如果没有，那么findViewById()并放入mViews中，避免下次再执行findViewById()）。 QuickAdapter的实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class QuickAdapter&lt;T&gt; extends RecyclerView.Adapter&lt;QuickAdapter.VH&gt;&#123; private List&lt;T&gt; mDatas; public QuickAdapter(List&lt;T&gt; datas)&#123; this.mDatas = datas; &#125; public abstract int getLayoutId(int viewType); @Override public VH onCreateViewHolder(ViewGroup parent, int viewType) &#123; return VH.get(parent,getLayoutId(viewType)); &#125; @Override public void onBindViewHolder(VH holder, int position) &#123; convert(holder, mDatas.get(position), position); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; public abstract void convert(VH holder, T data, int position); static class VH extends RecyclerView.ViewHolder&#123; private SparseArray&lt;View&gt; mViews; private View mConvertView; private VH(View v)&#123; super(v); mConvertView = v; mViews = new SparseArray&lt;&gt;(); &#125; public static VH get(ViewGroup parent, int layoutId)&#123; View convertView = LayoutInflater.from(parent.getContext()).inflate(layoutId, parent, false); return new VH(convertView); &#125; public &lt;T extends View&gt; T getView(int id)&#123; View v = mViews.get(id); if(v == null)&#123; v = mConvertView.findViewById(id); mViews.put(id, v); &#125; return (T)v; &#125; public void setText(int id, String value)&#123; TextView view = getView(id); view.setText(value); &#125; &#125;&#125; 其中： getLayoutId(int viewType)是根据viewType返回布局ID。 convert()做具体的bind操作。 就这样，万能适配器实现完成了。 通过万能适配器能通过以下方式快捷地创建一个Adapter： 123456789101112mAdapter = new QuickAdapter&lt;String&gt;(data) &#123; @Override public int getLayoutId(int viewType) &#123; return R.layout.item; &#125; @Override public void convert(VH holder, String data, int position) &#123; holder.setText(R.id.text, data); //holder.itemView.setOnClickListener(); 此处还可以添加点击事件 &#125;&#125;; 是不是很方便。当然复杂情况也可以轻松解决。 123456789101112131415161718192021222324252627282930313233mAdapter = new QuickAdapter&lt;Model&gt;(data) &#123; @Override public int getLayoutId(int viewType) &#123; switch(viewType)&#123; case TYPE_1: return R.layout.item_1; case TYPE_2: return R.layout.item_2; &#125; &#125; @Override public int getItemViewType(int position) &#123; if(position % 2 == 0)&#123; return TYPE_1; &#125; else&#123; return TYPE_2; &#125; &#125; @Override public void convert(VH holder, Model data, int position) &#123; int type = getItemViewType(position); switch(type)&#123; case TYPE_1: holder.setText(R.id.text, data.text); break; case TYPE_2: holder.setImage(R.id.image, data.image); break; &#125; &#125;&#125;; 结论 在一些场景下，如界面初始化，滑动等，ListView和RecyclerView都能很好地工作，两者并没有很大的差异： 数据源频繁更新的场景，如弹幕：http://www.jianshu.com/p/2232a63442d6等RecyclerView的优势会非常明显； 进一步来讲，结论是： 列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。 扩展阅读 Google I/O 2016: RecyclerView Ins and Outs RecyclerView优秀文章集 引用： ★★★★RecyclerView 必知必会 ★★★★Android ListView 与 RecyclerView 对比浅析–缓存机制 ★★★RecyclerView使用完全指南，是时候体验新控件了（一） ★★★RecyclerView使用完全指南，是时候体验新控件了（二） 一篇博客理解Recyclerview的使用 RecyclerView使用全解析 Demo地址： RecyclerView基本用法 RecyclerViewDemo Demo1: RecyclerView添加HeaderView和FooterView，ItemDecoration范例。 Demo2: ListView实现局部刷新。 Demo3: RecyclerView实现拖拽、侧滑删除。 Demo4: RecyclerView闪屏问题。 Demo5: RecyclerView实现setEmptyView()。 Demo6: RecyclerView实现万能适配器，瀑布流布局，嵌套滑动机制。]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向忙碌开发者的Android]]></title>
    <url>%2Fposts%2F793c26e.html</url>
    <content type="text"><![CDATA[面向忙碌开发者的 Android 视频教程（Tuts+） Android 开发资源列表（Sharif Ahmed） 我如何在23天内开发了一款 Android 游戏？（Bigosaur） Android 学习教程 Android Bootstrap [PDF] Android 性能小贴士（Romain Guy &amp; Chet Haase） [PDF] Android 应用中使用 Dagger（Jake Wharton） Android 应用性能优化 《Android 测试与调试实战》参考资料（@施懿民） [视频] Android 入门教程（@多贝公开课） Android 测试入门（Corey Scott） Android 事件传递机制（@唐韧_Ryan） [PDF] Android 开发技巧新整理（@51CTO技术社区） AndroidQuery - 一个处理异步任务的开源项目（Peter Liu） Android 开发者必备的42个链接（Mikail） 一些有用的 Android adb 命令（Daniel Imms） Android 布局优化（@唐韧_Ryan） 系列文章：前端之 Android 入门 (ct) Android 设计指南非官方简体中文版 系列教程：开发你的第一个 Android 应用 (Matt Luedke) 写给 iOS 开发者的 Android 教程 (Stuart Hall) [slide] Android 函数响应式编程 (Yaroslav Heriatovych) 面向 iOS 开发者的 Android 系列教程 [译] Android 通知中心（@唯木念） 使用 Android API 最佳实践 (MeetMe) 《50 Android Hacks》读书笔记 (Vector_Yi) [译] 响应式 Android 应用 (Daisyyaya) Android 开源项目分类汇总 (@Trinea) 系列文章：Android 开发小贴士 (Dan Lew) Android Arsenal - 一个 Android 学习资源网站 [译] Android 开发者必知的 5 个开源库（刘璐璐） SEAndroid 安全机制简要介绍和学习计划（@罗升阳） Material Design 中文版 Android 学习之路 (@googdev) SEAndroid 安全机制对 Binder IPC 的保护分析（罗升阳） 最流行的 Android 组件大全 (@colobu) [译] 2014 年 Android 碎片化报告 (boxi) 系列文章：Android UI 开发（@张兴业TBOW） Android 插件化 (@Trinea) [代码] 模仿 QQ 讨论组头像（@网易孔楠） Android 中 Java 和 JavaScript 交互 (androidyue) [视频合辑] 3 个月系统学习 Android 开发（极客学院） 正确使用 Android 性能分析工具——TraceView (@白瓦力) [译] 理解 Android 中垃圾回收日志信息 (@Android月) 放弃 WebView，使用 Crosswalk 做富文本编辑器 (GavinCT) 教你用 Visual Studio 2015 做 Android 应用 十大 Material Design 开源项目 (唐小引) Android Studio 系列教程 (@googdev) 创新、严肃、好玩的 Android 应用程序开发 Android 批量打包提速 (@GavinCT) 学 Android 开发仅用 3 个月，就是这么任性！ 代码规范和 Android 项目中的一些可用工具 (刘聪) 学 Android 开发仅用 3 个月，就是这么任性！ [译] Android 性能优化课程（一）：渲染性能 (@刘智勇同学) Java for Android Android 性能优化典范 (@胡凯me) Context-Menu.Android - Android 动画上下文菜单 (Yalantis) 大量 Material Design 学习资源 (@light_sky) 系列文章：50 个 Android 开发技巧 (fwy19930618) Android 开发教程大全（视频 + 源码） Android 开源项目源码解析 (android-cn) 深聊 Material Design 复杂响应式设计 Navigation drawer - 一个 Material Design 的抽屉式导航库 (Rudson Lima) Android 开发最佳实践 使用 Chrome 调试 Android App (@googdev) [译] 一次 Material Design 的设计探索 (郭楠) 系列文章：全面理解 Android 安全机制 (@stackvoid) [译] 关于 Material Design 你需要知道的一切 (DATS设计翻译组) Android 源码设计模式分析 (@MrSimp1e) [译] Android xUtils 源码解析 (@code-KK) [译] Android 性能优化后续 (@高建武_Gracker) 开源 Android 应用集锦 (Joker) Fresco - 一个强大的 Android 应用图片管理库 (Facebook) Euclid - 一个用户 Profile 界面动画的 Android 实现 (Yalantis) [译] 使用 Kotlin 创建一个 Android 应用 (Lollypo) 系列文章：Android 内存优化 (@高建武_Gracker) 深入理解 Android 中的自定义属性 (鸿洋_) Android 性能优化之内存篇 (@胡凯me) 一堆 Android 开发资源链接 (Anirudh S) 《Android 开发学习路径图》2.0 版 [译] Android Lollipop 5.1.1 面世 (@MrSimp1e) [译] Instagram 是如何提升 TextView 渲染性能的？ (@archieyang) Android 应用内社区 SDK 技术架构浅析 (liubin) Android 性能优化典范（第 2 季） (@胡凯me) 系列译文：Android 的 MVP 模式开发 (shadev) 一个 Mac 上的 Android 工具 (mortenjust) SquiDB - 一个用于 Android 的 SQLite 数据库框架 系列译文：Android 研发工程师高级进阶 (asce1885) Android 加载不同 DPI 资源与内存消耗之间的关系 (Will) MaterialViewPager - 一个易于使用的 Material Design ViewPager 库 (florent37) Android RecyclerView 使用完全解析 (鸿洋_) Android 中的 MVP (@鄭曉鵬-Rocko) Material 适配（二）：高级篇 (@GavinCT) Anko - 一个让 Android 应用开发更快、更简单的库 Android 开发中，可能会导致内存泄露的问题 (@给立乐) Android 布局优化之 ViewStub、include、merge 使用与源码分析 (@MrSimp1e) 腾讯手机管家 Android 版实战分析：内存突增是为神马？ (腾讯Bugly) 大量 Material Design 学习资源 (@light_sky) Google I/O 2015 为 Android 开发者带来了哪些福利？ (代码家) 系列文章：Android 内核开发之系统编译输出的镜像文件 (@卢_俊) [译] MVP 框架 Ted Mosby 的软件架构（Android） (@MrSimp1e) FlyRefresh：超赞的刷新动画（Android） (@谢权1991) Android 系统架构之微服务架构 (MrSimple) Android 异步指南 (@alexhilton) Gradle Android Plugin 使用手册（中文版） (@ChaosLeong) Android 开发教程大全（视频 + 源码） [译] Material Design 开发利器：Android Design Support Library 介绍 Android UITestRunner - 一个非常简单的用于测试 UI 的单元测试框架 (chengkai) FlyRefresh：让人眼前一亮的下拉刷新 (Android笔记) 浅谈 MVP 实现 Android 应用层开发 (工匠若水) 教你写 Android 网络框架之基本架构 (@MrSimp1e) Android 实现速度仪，仪表盘效果 (谢权1991) Android Studio 新手完全指引 (ASCE1885) 教你写 Android 网络框架之 HTTP 请求的分发与执行 (@MrSimp1e) 美团 Android DEX 自动拆包及动态加载简介 (xijianshuai &amp; lixiaoyang) 短信验证码助手：一款新的开源轻 App（Android） (Dracut) SublimePicker：Android Material 风格时间选择器 (vikramkakkar) 使用 Kotlin 进行 Android 开发 (@RagnarokStack) Android 应用程序 UI 硬件加速渲染的动画执行过程分析 (@罗升阳) [译] Android 开发最佳实践 (andyiac) [译] Android Design Support Library 的代码实验 (MrFu) Android 开源项目源码解析（第二期） (@code-KK) [译] Android 中的帧动画 (jianghejie) 推荐几个有用的 Android Studio 插件和工具 (@googdev) Dexposed：阿里巴巴开源的无侵入运行期 AOP 框架（Android） 小米开源的内核源代码 很棒的下拉刷新项目 Android Ultra Pull To Refresh 源码解析 (grumoon) Android 应用使用自定义字体的一些探究 (@码农明明桑) 一个 Demo 学会用 Android 兼容包新控件 (@安卓猴) Android 常用开发工具以及 Mac 常用软件 (肥肥鱼) DynamicLoadApk 源码解析 (code-KK) InstalMaterial 学习笔记之 Reveal 效果 (程序亦非猿) 快速提高 Android 开发效率的 Web 工具 (@技术小黑屋) [译] Android UI 自动化测试 (DorisMinmin) 系列译文：使用 Kotlin 开发 Android 应用 (ASCE1885) 使用 Gradle 管理你的 Android Studio 工程 (飞雪无情) [译] 学习 Android 开发的二十套免费理想资源 (核子可乐) HTTPDNSLib - 一个支持 DNSPod D+ 和自定义 HttpDNS 服务的 HttpDNS SDK（Android） (SinaMSRE) 一个优秀的 Android 应用从建项目开始 (Jude95) [译] 检测和解决 Android 应用的性能问题 (@MrSimp1e) Android 中 TextView 预渲染研究 (RagnarokStack) Android 开发者的浏览器书签 (鄭曉鵬-Rocko) Android 代码内存优化建议：OnTrimMemory 优化 (Android Performance) Android APK 加固技术方案调研 (ASCE1885) 使用 Android lint 发现并解决高版本 API 问题 (技术小黑屋) Smalidea 无源码调试 Android 应用 (瘦蛟舞) 如果让我重新设计一款 Android App (aspook) 探究 android:largeHeap (技术小黑屋) 跟我一起写 EventBus（一） (mcxiaoke) 一步一步教你 150 行代码实现简书滑动返回效果 (程序亦非猿) Android Material Design 动画实现 (阳春面) Android Gradle 插件中文指南 (飞雪无情) Android 多渠道打包工具 Gradle 插件 (mcxiaoke) AWebDB 可以在浏览器操作 Android 数据库啦 (Bai) 一个上传 APK 到 fir 的 Gradle 插件 (码农明明桑) Cool Android Apis 整理（一） (@Oak_Zmm) Android 应用开发之所有动画使用详解 (@工匠若水) Android 视频录制 App 解决方案汇总 (老牛) 5 种优化你的 Android 5.0 Lollipop 代码的方法 Android 项目中如何用好构建神器 Gradle？ (寒江不钓) 通过蓝牙* LE (BLE) 从 Android 连接到英特尔 EDISON Android 平台免 Root 无侵入 AOP 框架 Dexposed 使用详解 (ASCE1885) BatchPackApk：Apk 批量快速打包工具 (MasonLiuChn) SlideBottomPanel：底部划出视图，轻松实现“知乎日报 β 版”效果 (NeXT___) CNode 社区第三方 Android 客户端 (TakWolf) 开源中国 Maven 库 一个超赞超全的 Android Library (Huqiu Liao) Android 性能优化典范（第 3 季） (@胡凯me) 最美应用：从 Android 研发工程师的角度之“厨房故事” (ASCE1885) [译] 深入讲解 Android 中 Activity launchMode (技术小黑屋) [译] Android 中的 AOP 编程 (byronwind) 面向 Android* 目标的英特尔 INDE OpenCV 入门 Android 技术文档翻译：工具属性 (飞雪无情) Jenkin + Git + Gradle 为 Android 项目搭建 CI 环境 (离星运动) Google Places for Android 入门指南 (@汤奇V) [英] Parse 开源其所有 SDK（Android &amp; iOS） (Nikita Lutsenko) xBus 使用指南 (mcxiaoke) LayoutCast：把代码和资源文件的改动直接同步到手机上，应用不需要重启 (mmin18) Android 6.0 中新的新技术 (@Android笔记) Android 诀窍：Layouts 与 Views (llitfk@DockOne) Android NestedScrolling 实战 (Android笔记) Android 反编译的工具和方法 (@杨剑同學) Next 库使用指南之 Core 模块（Android） (mcxiaoke) [译] CoordinatorLayout 与快速返回的实现（Android） (hejie) SimpleCropView - 一个简单的图片剪裁库（Android） (IsseiAoki) TransitionPlayer - 一个 Android 引导动画库 (XMFE-TEAM) 微信 Android 客户端：会话速度提升 70% 的背后 (charven) [译] 使用 TDD 的方式开发一个 Hacker News Android 客户端 (Anthonyeef) 改变 support 中 AlertDialog 的样式（Android） (码农明明桑) 为什么 Android 中不建议使用 Enums (Lusfold) Android 逆向工程工具集 (J.D.Song) DroidPlugin：360 手机助手在 Android 系统上实现的一种新的插件机制 (Qihoo360) Android Log 最佳实践 (@天之界线2010) 剖析 Android 中进程与线程调度之 nice (技术小黑屋) Android OkHttp 文件上传与下载的进度监听扩展 (lizhangqu) 基于英特尔架构使用 Linderdaum* 引擎开发 C++ 安卓* NDK 游戏 (英特尔开发人员专区) 全平台反编译工具 Jadx (程序亦非猿) 积木：帮助你快速搭建属于自己的应用 (汤奇V) Android Tips：填坑必备 (汤奇V) React Native for Android on GitHub (Facebook) Android 图标资源生成器 (JuneLegency) XLog：Android 调试神器 (promeG) DecompileApk：一键反编译 APK，输出所有反编译后的代码、资源 (MasonLiuChn) Colorful：基于 Theme 的 Android 动态换肤库 (@MrSimp1e) Otto 事件总线框架的使用 (Sunzxyong) React Native For Android 初体验 (ASCE1885) Android 进程线程调度之 cgroups (技术小黑屋) Gradle 多渠道打包 (安卓猴) Android 项目收集 (snowdream) Android 性能优化视频、文档和工具收集 (J.D.Song) [译] Retrofit 2.0：有史以来最大的改进 (hejie) 深入讲解 WebView（上） (张涛) [译] Android 6.0 新特性详解（运行时权限、存储、电源管理） (黑山龘) Android 开发最佳实践 (@胡凯me) AndroidCat：Android 开发相关的网址导航 (大花猫) Android 仿搜狗浏览器加载动画 (@_邓士伟) StatusBarColor：Android 4.4+ 设置状态栏、导航栏颜色、侧滑菜单沉浸 (MasonLiuChn) KJBitmap 与 KJHttp 的深度用法 (张涛) App 启动加速，以及使用 FSA 来处理状态转换避免 Activity State Loss (Piasy) RecyclerView 的通用适配器，和滚动时不加载图片的封装 (张涛) Android GC 那点事 Android 性能优化学习小结 Android 6.0 Runtime Permission 测试 一步一步带你仿各大主流 App 地图定位移动选址功能（Android） KJFrameForAndroid 2.25 发布，支持 6.0 网络请求 很少有人会告诉你的 Android 开发基本常识 Android Handler 消息机制的理解 Android UI：机智的远程动态更新策略 Android 快速开发框架 FastDev4Android 介绍（一） [译] Android 架构演化之路 Android 项目重构之路（架构篇） Android 开发中，有哪些坑需要注意？ [译] 通过 Hardware Layer 提升 Android 动画性能 关于 Android Log 的一些思考 Android Support Library 23.1 的变化 AVLoadingIndicatorView：Android 加载动画合集 移植 C 程序到 Android MVVM_Android-CleanArchitecture Android 打包的那些事 Android 6.0 运行时权限处理 TextViewForFullHtml：对原生 TextView 解析 HTML 格式文本的增强 DynamicAPK：携程 App 的插件化和动态加载框架 #Kotlin# 你好怪兽 TraceView 自动化抓取方案实践 InteractiveCanvas：炫酷的跨屏幕 Canvas 动画 Android 快捷方式解密 Android 微信上的 Wear 的开发总结 Android 分辨率相关知识 Android 热更新实现原理 如何姿势正确地做一个充满果味的 Android 应用 再议携程 Android 动态加载框架 DynamicAPK Treasure - 一个 Android 平台上基于 SharePreferences 的偏好存储库 Nuwa：热修复你的 Android 应用 EasyImage：Android 图片选择控件 [译] 掌握 Coordinator Layout BlurImageView：实现类 Medium 的图片加载 天猫 Android App 线上热修复方案 Andriod 性能优化之列表卡顿：以“简书” APP 为例 AndroidAutoLayout：Android 屏幕适配方案 WXTabBarController：实现 Android 版微信 TabBar 的滑动切换功能（OC） EZScalpel：Android 视图层级查看利器 实践自定义 UI：RLF Backboard - 一个基于 Facebook Rebound 的动效框架 加快 Android 编译速度 如何开发一个 Android App dex 分包变形记 面向对象六大原则 1000 个 Android 开源项目集合 Gradle 脚本基础全攻略 stetho-js-rhino：Facebook Stetho 插件，为 Android 提供 JavaScript 调试窗口 记一次 ListView 性能优化过程 XhsParallaxWelcome：小红书欢迎引导页实现（第二版） 微信抢红包插件源码解析（Android） [译] 每个 Android 开发者都应该了解的资源列表 Android 图片选择器 OverscrollScale：仿小米列表拉伸效果（Android） [译] 使用 Systrace 分析 UI 性能 [译] 开发安全的 Android 应用 说说 Android 的 MVP 模式 面试时，问哪些问题能试出一个 Android 应用开发者真正的水平？ 动态 Android 编程 EventBus 源码研读（上） 使用 Picasso 加载图片的内存优化实践 高仿微信 JustWeEngine：Android 轻量级游戏框架 Android 下拉刷新开源库对比 Android View 总结 关于 Android 中工作者线程的思考 Android 6.0 系统学习之 JNI Android Studio 你不知道的调试技巧 Android 开发者站点资源 [PDF] 深入理解 Android 之 Dalvik Android 代码质量检查利器 用黑客思维做测试：神器 Xposed 框架介绍 Android 单元测试研究与实践 构建更高质量的 Android 应用：2015 Playtime 之 Build Better 2015 年十大热门 Android 开源新项目 Android 软键盘和 emoji 表情切换方案 PeriscopeLayout - 一个类似 Android Periscope 点赞效果的 Layout HTextView：Android TextView 动画效果 值得推荐的 Android 应用性能检测工具列表 Android 生态的破与立 AndResGuard：微信的 Android 资源混淆方案 GalleryFinal：史上最强的图片选择器（Android） Android 性能优化典范 Android targetSdkVersion 原理 Android Linker 学习笔记 Android 应用开发架构概述 [译] Android UI 性能优化详解 Android 平台的崩溃捕获机制及实现 Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？ BasePedo - 一个稳定的 Android 计步源代码 一个非官方版的干净的 “ONE • 一个” BrokenView：玻璃破碎的效果（Android） Small：强大的轻量级 Android 插件框架 Binder 学习指南]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xBus-简洁的EventBus实现]]></title>
    <url>%2Fposts%2F9105b80c.html</url>
    <content type="text"><![CDATA[Demo地址：MyXBus 基于发布订阅(Pub/Sub)模式的一个事件消息库，使用通用的 register(target), unregister(target), post(event) 消息通信接口，能有效的减少甚至消除Android应用中异步任务逻辑和界面更新之间的耦合，实现模块化，提高开发效率。 2015.09.15 1.0.2 - 修复多线程发送事件的同步问题 2015.08.18 1.0.1 - 修复 unresiger() 的空指针问题 2015.08.08 1.0.0 - 基本功能全部完成，发布1.0.0正式版 使用指南Gradle集成1compile &apos;com.mcxiaoke.xbus:bus:1.0.+&apos; 接收事件123456789101112131415161718192021222324252627282930313233343536public class SimpleActivity extends Activity &#123; @Override protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 注册 Bus.getDefault().register(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消注册 Bus.getDefault().unregister(this); &#125; @BusReceiver public void onStringEvent(String event) &#123; // handle your event // 这里处理事件 &#125; @BusReceiver public void onSomeEvent(SomeEventClass event) &#123; // SomeEventClass表示任意的自定义类 // handle your event // 这里处理事件 &#125; @BusReceiver public void onObjectEvent(Object event) &#123; // 不建议使用Object，会收到所有类型的事件 // handle your event // 这里处理事件 &#125;&#125; 发送事件然后在需要的地方调用 post(event) 发送事件通知，如 Service 或某个线程里，可以在任何地方发送事件： 123456789101112131415// 比如在IntentService里public class SimpleService extends IntentService &#123; public SimpleService() &#123; super("SimpleService"); &#125; @Override protected void onHandleIntent(final Intent intent) &#123; // 这里是举例，可以在任何地方发送事件 Bus.getDefault().post("String Event"); Bus.getDefault().post(new SomeEventClass()); Bus.getDefault().post(new Object()); &#125;&#125; 高级用法任何地方注册你还可以选择在 onStart() 里注册，在 onStop() 里取消注册。你完全可以在任何地方注册和取消注册，没有任何限制。但是建议你在生命周期事件方法里注册和取消注册，如 Activity/Fragment/Service 的 onCreate/onDestroy 方法里， register() 和 unregister() 建议配对使用，避免内存泄露。 12345678910111213@Overrideprotected void onStart() &#123; super.onStart(); // you can also register here Bus.getDefault().register(this);&#125;@Overrideprotected void onStop() &#123; super.onStop(); // you can also unregister here Bus.getDefault().unregister(this);&#125; 自定义 Bus你也可以不使用默认的 Bus.getDefault()，改用自己创建的 Bus 对象： 12345678910111213public class MainApp extends Application &#123; private Bus mBus = new Bus(); @Override public void onCreate() &#123; super.onCreate(); &#125; public Bus getBus() &#123; return mBus; &#125;&#125; Debug默认不输出任何LOG信息，可以这样启用调试模式： 1public Bus setDebug(final boolean debug) MethodFinder默认使用注解(@BusReceiver)识别事件接收器方法，可以这样修改 ： 1public Bus setMethodFinder(final MethodFinder finder) 默认使用的是 AnnotationMethodFinder，只有使用了 @BusReceiver 的方法才可以接受事件。 可选使用 NamedMethodFinder ，NamedMethodFinder 使用方法名识别，默认方法名是 onEvent ，你可以指定其它的方法名。 使用 NamedMethodFinder 会比使用 AnnotationMethodFinder 效率高一点，因为它忽略注解，直接使用方法名字符串匹配。一般使用，两者差别不大。 你还可以实现 MethodFinder 接口，自定义其它的事件接收器方法匹配模式： 1234interface MethodFinder &#123; Set&lt;MethodInfo&gt; find(final Bus bus, final Class&lt;?&gt; targetClass);&#125; StrictMode宽泛匹配模式默认情况下， Bus 使用宽泛的事件类型匹配模式，事件参数会匹配它的父类和接口，如果你调用 post(String)，那么这几个方法都会收到举例： 123456789101112// 如果你调用这个方法，发送一个StringBuilder类型的事件Bus.getDefault().post(new StringBuilder("Event"));// 这几个方法会收到事件public void onEvent1(StringBuilder event) // 匹配，类型相符public void onEvent2(Object event) // 匹配，StringBuilder是Object的子类public void onEvent3(CharSequence event) // 匹配，StringBuilder是CharSequence的实现类public void onEvent4(Serializable event) // 匹配，StringBuilder实现了Serializable接口// 这几个方法不会收到事件public void onEvent5(Exception event) 不匹配，Exception与String完全无关public void onEvent6(String event) // 不匹配，StringBuilder不能转换成String类型 对于 post(event) 和 onEvent(EventType) ，匹配规则是：如果 event.getClass() 可以强制转换成 EventType，那么匹配成功，能收到事件。 严格匹配模式可以使用下面的方法更改默认行为，使用严格的事件类型匹配模式： 1public Bus setStrictMode(final boolean strictMode) 启用严格匹配模式后，发送和接受方法的参数类型必须严格匹配才能收到事件，举例： 123456789// setStrictMode(true) 启用严格模式后：Bus.getDefault().post(new StringBuilder("Event"));// 只有 onEvent1 能收到事件public void onEvent1(StringBuilder event)public void onEvent2(Object event)public void onEvent3(CharSequence event)public void onEvent4(Serializable event)public void onEvent5(Exception event)public void onEvent6(String event) 对于 post(event) 和 onEvent(EventType) ，严格模式的匹配规则是当且仅当 event.getClass().equals(EventType) 时才能收到事件。 说明：启用严格模式效率会稍微高一点，因为不会递归查找 event 的父类和实现的接口，但是由于 Bus 内部使用了缓存，对于同一个事件类型，并不会重复查找，所以实际使用几乎没有差别。 StickyEvent可以使用下面的方法发送 Sticky 事件，这种事件会保留在内存中，当下一个注册者注册时，会立即收到上一次发送的该类型事件，每种类型的事件只会保留一个， Sticky 事件使用严格匹配模式。 1public &lt;E&gt; void postSticky(E event) 一般不需要使用 Sticky 事件，但在某些场景下可以用到，比如一个网络状态监听服务，会不断的发送网络状态信息，接受者一旦注册就可以立即收到一个事件，可以知道当前的网络状态。 @BusEvent还有一个注解 @BusEvent 可用于标注某个类是事件类，这个像 @Override 注解一样，纯标注用，没有其它用途，没有运行时消耗。 实现教程 跟我一起写EventBus（一） 跟我一起写EventBus（二） 跟我一起写EventBus（三） 跟我一起写EventBus（四） xBus使用教程]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>EventBus</tag>
        <tag>XBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android框架之路——EventBus的使用]]></title>
    <url>%2Fposts%2F6037db63.html</url>
    <content type="text"><![CDATA[一、简介EventBus是由greenrobot 组织贡献的一个Android事件发布/订阅轻量级框架。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。 官网地址：http://greenrobot.org/eventbus/翻译：http://blog.csdn.net/poorkick/article/details/55099311 二、添加依赖1compile &apos;org.greenrobot:eventbus:3.0.0&apos; 三、解锁技能 EventBus的三要素 Event：事件，可以是任意类型的对象。 Subscriber：事件订阅者，在EventBus3.0之前消息处理的方法只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，他们分别代表四种线程模型。而在EventBus3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为POSTING）。 Publisher：事件发布者，可以在任意线程任意位置发送事件，直接调用EventBus的post(Object)方法。可以自己实例化EventBus对象，但一般使用EventBus.getDefault()就好了，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。 EventBus的四种线程模型（ThreadMode） POSTING（默认）：如果使用事件处理函数指定了线程模型为POSTING，那么该事件在哪个线程发布出来的，事件处理函数就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。在线程模型为POSTING的事件处理函数中尽量避免执行耗时操作，因为它会阻塞事件的传递，甚至有可能会引起应用程序无响应（ANR）。 MAIN：事件的处理会在UI线程中执行。事件处理时间不能太长，长了会ANR的。 BACKGROUND：如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。在此事件处理函数中禁止进行UI更新操作。 ASYNC：无论事件在哪个线程发布，该事件处理函数都会在新建的子线程中执行，同样，此事件处理函数中禁止进行UI更新操作。 使用步骤 注册：EventBus.getDefault().register(this); 解注册（为防止内存泄漏）：EventBus.getDefault().unregister(this); 构造发送消息类： 123456789public class MessageEvent &#123; public String name; public String password; public MessageEvent(String name, String password) &#123; this.name = name; this.password = password; &#125;&#125; 发布消息：EventBus.getDefault().post(new MessageEvent(“name”,”password”)); 接收消息：可以有四种线程模型选择 1234@Subscribe(threadMode = ThreadMode.MAIN)public void messageEventBus(MessageEvent event)&#123; tv_result.setText("name:"+event.name+" passwrod:"+event.password);&#125; 粘性事件​ 之前说的使用方法，都是需要先注册(register)，再post,才能接受到事件；如果你使用postSticky发送事件，那么可以不需要先注册，也能接受到事件，也就是一个延迟注册的过程。​ 普通的事件我们通过post发送给EventBus，发送过后之后当前已经订阅过的方法可以收到。但是如果有些事件需要所有订阅了该事件的方法都能执行呢？例如一个Activity，要求它管理的所有Fragment都能执行某一个事件，但是当前我只初始化了3个Fragment，如果这时候通过post发送了事件，那么当前的3个Fragment当然能收到。但是这个时候又初始化了2个Fragment，那么我必须重新发送事件，这两个Fragment才能执行到订阅方法。​ 粘性事件就是为了解决这个问题，通过 postSticky 发送粘性事件，这个事件不会只被消费一次就消失，而是一直存在系统中，知道被 removeStickyEvent 删除掉。那么只要订阅了该粘性事件的所有方法，只要被register 的时候，就会被检测到，并且执行。订阅的方法需要添加 sticky = true 属性。 构造发送信息类： 1234567public class StickyEvent &#123; public String msg; public StickyEvent(String msg) &#123; this.msg = msg; &#125;&#125; 发布消息：EventBus.getDefault().postSticky(new StickyEvent(“我是粘性事件”)); 接收消息：和之前的方法一样，只是多了一个 sticky = true 的属性。 1234@Subscribe(threadMode = ThreadMode.MAIN, sticky = true)public void onEvent(StickyEvent event)&#123; tv_c_result.setText(event.msg);&#125; 注册： 1EventBus.getDefault().register(CActivity.this); 解注册： 12EventBus.getDefault().removeAllStickyEvents();EventBus.getDefault().unregister(CActivity.class); ### 四、举个栗子 主线程发送事件： 自定义事件（类似定义JavaBean），包含用户的姓名和密码； 123456789101112131415161718192021222324252627282930313233343536public class UserEvent &#123; private String name; private String password; public UserEvent() &#123; &#125; public UserEvent(String name, String password) &#123; this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "UserEvent&#123;" + "name='" + name + '\'' + ", password='" + password + '\'' + '&#125;'; &#125;&#125; 在onCreate方法中注册订阅者，在onDestroy中解注册。 123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.jump) Button mJump; @BindView(R.id.send) Button mSend; @BindView(R.id.tv_result) TextView mTvResult; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); //注册订阅者 EventBus.getDefault().register(this); &#125; @OnClick(&#123;R.id.jump, R.id.send&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.jump: startActivity(new Intent(MainActivity.this, SecActivity.class)); break; case R.id.send: break; &#125; &#125; //定义处理接收的方法 @Subscribe(threadMode = ThreadMode.MAIN) public void userEventBus(UserEvent userEvent)&#123; mTvResult.setText(userEvent.toString()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //注销注册 EventBus.getDefault().unregister(this); &#125;&#125; 在另一个activity中发送事件，让订阅者能够接收； 123456789101112@OnClick(&#123;R.id.sendData, R.id.receive&#125;)public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.sendData: //发送事件 EventBus.getDefault().post(new UserEvent("Mr.sorrow", "123456")); finish(); break; case R.id.receive: break; &#125;&#125; 实现结果： 发送粘性事件： MainActivity中发送粘性事件； 1234case R.id.send: EventBus.getDefault().postSticky(new MessageEvent("粘性事件", "urgent")); startActivity(new Intent(MainActivity.this, SecActivity.class)); break; SecActivity中接受注册并处理； 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SecActivity extends AppCompatActivity &#123; @BindView(R.id.sendData) Button mSendData; @BindView(R.id.receive) Button mReceive; @BindView(R.id.tv_receive) TextView mTvReceive; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sec); ButterKnife.bind(this); &#125; @OnClick(&#123;R.id.sendData, R.id.receive&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.sendData: //发送事件 EventBus.getDefault().post(new UserEvent("Mr.sorrow", "123456")); finish(); break; case R.id.receive: //要接收时开始注册 EventBus.getDefault().register(SecActivity.this); break; &#125; &#125; //处理事件逻辑 @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) public void receiveEventBus(MessageEvent messageEvent) &#123; mTvReceive.setText(messageEvent.toString()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //解注册 EventBus.getDefault().removeAllStickyEvents(); EventBus.getDefault().unregister(SecActivity.this); &#125;&#125; 实现效果]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android常用三方框架]]></title>
    <url>%2Fposts%2F4514f8cf.html</url>
    <content type="text"><![CDATA[1.下拉刷新Android-Ptr-Comparison-Android 下拉刷新开源库对比，非常nice！！ Android-PullToRefresh- 最经典、最多人用的下拉刷新、加载更多。 PullDownListView- 一个下拉刷新的控件，实现了仿微信下拉中眼睛动画的效果。 DragTopLayout- 实现整个layout下拉刷新。 ZrcListView- 一个顺滑又漂亮的Android下拉刷新与加载更多列表组件，增加下拉刷新及滚动到底部自动加载的功能；增加越界回弹效果；增加自定义列表项动画的功能。 TwitterCover-Android- Twitter Android客户端的下拉封面模糊效果。 android-Ultra-Pull-To-Refresh- 实现整个layout下拉刷新，没有加载更过，Demo，源码分析。 StikkyHeader- 【Android控件源码：头部固定的控件列表效果】这是一个可以支持头部固定的控件列表功能，源码StikkyHeader，StikkyHeader是一个可以在滚动的时候将头部固定的控件，还可以将动画效果和StikkyHeader一起使用，api非常简单， 支持ListView,RecyclerView,ScrollView。支持2.3一下设备使用的StikkyHeader PullDownListView- 实现了模仿微信眼睛下拉效果，源码PullDownListView，下拉刷新，上拉加载，模仿微信眼睛。 CircleRefreshLayout- 又一个下拉刷新的实现，水滴效果。 BGARefreshLayout-Android- 多种下拉刷新效果、上拉加载更多、可配置自定义头部广告位，目前已经实现了四种下拉刷新效果:新浪微博下拉刷新风格、慕课网下拉刷新风格、美团下拉刷新风格、类似qq好友列表黏性下拉刷新风格。 Pull-to-Refresh.Rentals-Android- 提供一个简单可以自定义的下拉刷新实现。 Pull-to-Refresh.Tours- Taurus，很精美的下拉刷新。 ParallaxListView- 模仿Path的下拉刷新，Head头部图片下拉放大。 WaveRefreshForAndroid- 下拉刷新水波纹动画。 CoordinatorLayoutDemos- 收集了不少资源写了一个基于CoordinatorLayout实现的下拉刷新效果。 Android_PullToRefreshLibrary_Collection- 下拉刷新开源库集锦 。 HitBlockRefresh- 下拉刷新：打砖块和打坦克。 jd_tmall_refresh_demo- 仿写京东、天猫下拉刷新。 android-Ultra-Pull-To-Refresh- 下拉刷新框架，非常强大，可扩展性非常强，兼容各种view的下拉刷新事件。 2.卫星菜单android-satellite-menu- 点击主按钮，会弹出多个围绕着主按钮排列的子按钮，从而形成一个弹出式菜单。子按钮弹出和消失的动画效果都很棒。这种弹出式菜单按钮应用在Path app中。 ArcMenu- 实现弹出式按钮群（菜单）。点击主按钮，会在住按钮旁边弹出多个按钮（菜单）。弹出的按钮有两种排列形式，一种是围绕着主按钮成圆弧形排列，一种是和主按钮并排成一字型排列， 仿Path 2.0 (for iOS)。 Radial Menu Widget- 实现各种圆形或者半圆形菜单，以及圆形进度条。 android-circlebutton- 圆形按钮，有动画点击效果 CircularFloatingActionMenu- 卫星菜单。 ElasticDownload- 挺酷的下载进度条。 android-snake-menu- 仿 Tumblr 的 Android 可拖拽蛇形动画菜单。 3.节选器SegmentView- 类似iOS的Segment Control控件，第一种方式是使用 RadioGroup 实现，O网页链接。 SHSegmentControl- 类似iOS的Segment Control控件，此种方式的可定制化更好。 android-segmentedradiobutton- 在Android中实现类似iOS的分段单选按钮（segmented control），本人以前项目一直使用，值得拥有。 android-segmented-control- RadioGroup实现类似ios的分段选择(UISegmentedControl)控件。 4.模糊效果BlurNavigationDrawer- 背景模糊的Navigation Drawer。 5.HUD与Toastandroid-UCToast- 在不申请任何权限的情况下在 Android 应用中弹出悬浮窗,实现文档。 sweet-alert-dialog- sweet-alert-dialog是一款清新文艺的 Android 弹窗, 灵感来自于 JS 版的 SweetAlert。 6.进度条easyloadingbtn- 模仿了一个Dribbble上的Material Design效果，环形loading， 进度条、进度圈。 android-square-progressbar- 一个不错的方形进度条。 Radial Menu Widget- 实现各种圆形或者半圆形菜单，以及圆形进度条。 AnimatedCircleLoadingView- 一个有限／无限加载动画效果。基于Nils Banner的android-watch-loading-animation设计图。该设计本来是针对智能手表的。 circular-progress-button- 带动态效果的Button(按钮)可要比静态的按钮炫酷的多了，大家看到效果图就知道了 CircularBarPager- Android实现的动态效果，一个数字圆圈进度效果，源码CircularBarPager，material 风格的数字圆圈进度显示库（api10 +）。 dotted-progress-bar- 一个小清新的进度条。 WhorlView- 一个炫酷的漩涡加载效果自定义View。 AVLoadingIndicatorView- AVLoadingIndicatorView整合了一些漂亮的 Android 动画加载效果。 MagicProgressWidget- 渐变的圆形进度条与轻量横向进度条。 GBSlideBar- GBSlideBar类似uber/滴滴等app的滑动选择工具条。 GifLoadingView- 一些好看的 loadingview。 HouseLoading- 一个有趣的android加载loading动画。实现原理 7.UI其他MixtureTextView- 富文本，支持Android图文混排、文字环绕图片等效果。 android-ActionQueue- Action Queue 用于执行有次序的队列操作，比如按次序弹出对话框，这在 Android 中尤其有用。 WheelView-Android- WheelView-Android 是一款开源的 Android 滚动选择控件, 适用于不少应用场景。 Android Wheel- 带有刻度的旋转器：日历、三级联动。 CharacterPickerView- 可实现三级联动的选择器，高仿iOS的滚轮控件,可实现单项选择，并支持一二三级联动效果。 Highlight- Highlight一款可应用于 Android 应用上的指向性功能高亮的库, 可以快速的给应用添加上应用引导的效果。 HeaderAndFooterRecyclerView- 支持addHeaderView、 addFooterView、分页加载的RecyclerView解决方案 。 CleverRecyclerView- 是一个基于RecyclerView的扩展库，提供了与ViewPager类似的滑动效果并且添加了一些有用的特性。 drag-select-recyclerview- 实现了类似 Google Photos 风格的图片多选效果。 FlycoTabLayout- 一个Android TabLayout库,目前有两个TabLayout:SlidingTabLayout、CommonTabLayout。 AndroidChangeSkin- 一种完全无侵入的 Android 应用换肤方式，支持插件式和应用内换肤，无需重启 Activity。 Lobsterpicker- Lobsterpicker 为 Android 开发者提供了满足 Material Design 风格的颜色选择器。 FlycoRoundView- 一个扩展原生控件支持圆角矩形框背景的库,可以减少相关shape资源文件使用。 FlowingDrawer- FlowingDrawer 一个弹性效果的抽屉菜单，图片是概念图，实际效果实现了70%（侧滑菜单）。 TextSurface-是用 Java 写的一款借助酷炫的动画效果来完成消息展示的微型动画框架。 android-animate-RichEditor-android-animate-RichEditor是一款支持图片插入动画效果的 Android 富文本编辑器。 FlycoPageIndicator- android-animate-RichEditor是一款支持图片插入动画效果的 Android 富文本编辑器。 AndroidMosaicLayout- 马赛克效果 Layout,磁片风格View 自适应大小。 DropDownMenu- 一个实用的多条件筛选菜单，在很多App上都能看到这个效果，如美团，爱奇艺电影票等。 Swipe-Deck- 仿 Tinder 的可以左右滑动消除卡片效果的自定义控件。 IntlPhoneInput- 一个支持国际化的电话号码输入的自定义控件。 AndroidUI4Web- AndroidUI4Web是一个高性能的WebApp框架, 在移动浏览器上有与原生App一致的体验。 SmoothCheckBox- SmoothCheckBox带有切换动画的CheckBox。 AndroidTimelineViewx- AndroidTimelineViewx仿微信朋友圈 时间轴。 CityPicker- CityPicker仿美团等选择城市列表。 material-intro- Material Design 风格的引导页。 EmphasisTextView- 支持部分文字高亮的 TextView。 greedo-layout-for-android- 深度定制的 LayoutManager，在显示网格布局的时候会考虑屏幕宽高比。 Rosie- 可以让你创建遵循 Clean Architecture 的应用的框架。 CreditCardView- 一个交互很赞的信用卡自定义 View。 android-md-core- Material风格bootstrap的框架。 SwipeCardView- 一个带渐变层叠动画的左右滑动效果（类似于探探左右刷脸）。 SwipeSelector- 可以左右滑动切换 item 的 Selector。 ForegroundViews- 类似于 FrameLayout 的支持的前景自定义 View。 android-material-chips- Material Design 的 Chips 控件实现。 XhsEmoticonsKeyboard- 表情键盘解决方案。 JKeyboardPanelSwitch- 一套 Android 键盘面板冲突, 布局闪动的处理方案。 GestureLibray- 九宫格解锁。 RecyclerItemDecoration- RecyclerView相关的ItemDecorstion仍然保持高度定制性，易用性。 materiallogindemo- 一个炫酷的Material Design 风格的登录和注册页面 。教程 ScrollablePanel- 一个二维可拖动的面板控件，交互像一个二维的RecyclerView，用法也非常简单和RecyclerView的用法基本一样，横向竖向滑动也都实现了View的复用。 如果你想做房态、计划表、待办事项、课程表等需要一个二维的面板的话，这个控件应该是比较适合的。 VerificationCodeView- 可用于动态生成验证码，常见于金融类app。 ShimmerRecyclerView- 类似 Facebook 加载时，条目的闪烁效果，酷酷的。 StatusView- 简洁优雅的网络状态提示。 8.动画Android应用开发之所有动画使用详解- Android应用开发之所有动画使用详解。 动画特效大全- Android 动画特效大全。 SwitchLayout- 国内开发者， Android的Activity切换动画特效库SwitchLayout，视图切换动画库，媲美IOS。 ActivityOptionsICS- 一个低版本activity动画兼容库——ActivityOptionsICS，可以很好的实现MD的动画效果。 SwipeBack- 一个可以通过手势返回到上一个Activity的开源库，支持上下左右四个方向返回，支持多个View为Child。 SpringIndicator- 模仿Morning Routine的引导页效果SpringIndicator；基于模仿红点拖拽的Demo实现：BezierDemo；sample中使用到 快速创建ViewPager和ListView等的第三方库：MultipleModel。 XhsWelcomeAnim- 国内开发者， 华丽酷炫欢迎引导界面 动画没有之一。 Material-Animations- Material风格动画，可以定义两个Activity之间的动画。 android-shapeLoadingView- android-shapeLoadingView实现高仿新版58 加载动画，loading。 一个绚丽的loading- 一个绚丽的loading动效分析与实现。 TransitionPlayer- 一个 Transition 动画控制控制库，可以让你很轻松的创建一个可交互的动画。 loading-balls- loading-balls 一款支持高度配置的 Android 加载进度球。 SogoLoading- 仿搜狗浏览器加载动画，实现说明。 ExplosionField- Android中View 炸裂特效的实现分析。 AZExplosion- AZExplosion：模仿ExplosionField的粒子破碎效果。 BrokenView-玻璃碎裂动画效果。 SwipeCardView- SwipeCardView一个带渐变层叠动画的左右滑动效果（类似于探探左右刷脸）。类似SwipeCard CRAudioVisualizationView- 水波纹效果的声音可视化自定义 View。 LoadingDrawable- 一些酷炫的加载动画， 可以与任何View配合使用，作为加载动画或者Progressbar, 此外很适合与RecyclerRefreshLayout 配合使用作为刷新的loading 动画。 Depth-LIB-Android-- 一款酷炫的 Android 界面过渡动画效果。 SwipeCaptcha- 自定义View，仿一个斗鱼web端滑动验证码。博文 AndroidAHRSView- 显示飞行器姿态的Android控件。 Material-Animations- 炫酷的Activity切换效果，共享元素。 BGASwipeBackLayout-Android- 修改 v4 包中 SlidingPaneLayout 的源码来实现滑动返回布局。 android-snowfall- 漂亮的下雪效果。 ViewSpreadTranslationController- 两行代码搞定Android视图扩散切换效果。 9.网络相关9.1网络连接​ ion- 一个异步网络请求和图片加载的库，一个库能搞定几乎所有的网络请求。 ​ 多线程下载- Android 实现多线程下载 完美代码。 ​ opandroid- android p2p的开源实现。 ​ okio- square出的Okio这个库，尤其擅长处理二进制数据。如果觉得Java的输入输出流实在太复杂啰嗦，不妨试试Okio。 ​ okhttp- square出的okhttp库。 ​ okhttp-OkGo- 全新完美支持RxJava，比Retrofit更简单易用。该库是封装了okhttp的标准RESTful风格的网络框架。 ​ OkHttpPlus- OkHttp 的一个工具类开源项目OkHttpPlus——支持GET、POST、UI线程回调、JSON格式解析、链式调 用、文件上传下载 ，OkHttpPlus介绍。https://github.com/jeasonlzy/okhttp-OkGo ​ Android-Download-Manager-Pro- 一个下载管理库，如果你的 App 有大量的下载工作，这个库能帮到你。 ​ FileDownloader- 文件下载引擎，稳定、高效、简单易用。 ​ jchat-android- 一个聊天 App,具有完备的即时通讯功能,JChat 的功能基于极光 JMessage SDK 来开发。 ​ RxDownload- 基于RxJava和Retrofit打造的下载工具, 支持多线程下载和断点续传, 智能判断是否支持断点续传等功能。 9.2网络测试​ augmented-traffic-control- Facebook宣布开源移动网络测试工具ATC，该工具支持利用Wi-Fi网络模拟2G、2.5G、3G以 及LTE 4G移动网络环境，让测试工程师们能够快速对智能手机和App在不同国家地区和应用环境下的性能表现进行测 试。 10.图像获取glide- glide google出品，使用教程、GlidePalette。5 个顶级 Android 开源库 Universal Image Loader- Universal Image Loader 是一个强大的、可高度定制的图片缓存，简称：UIL，可以高度配置的网络图片缓存库，非常灵活，用户量最多 。 picasso- picasso 功能单一，没有缓存过期，同androidQuery一样链式调用，载入本地文件速度慢（没有生成thumbnails） ,Picasso and Android-Universal-Image-Loader,另外的一些诸如裁剪图片：Picasso.with(context) .load(url) .resize(50, 50) .centerCrop() .into(imageView)。 fresco- Facebook 又放出的一个新项目，一个类似 Picasso, Glide 的库，不过比他们做的更好。 强烈推荐！［Fresco集成示例］（https://github.com/liaohuqiu/fresco-demo-for-gradle）。 tape- 类似于图片加载库（例如UIL、Picasso等）实现异步加载，但是加载的不一定是图片。！ ImageLoader- ImageLoader 。 Volley- Volley 综合框架,包含图片部分，Volley与Picasso的对比 enif- enif 。 wqgallery- wqgallery实现类似微信选择照片功能，可以通过相机或相册选择，支持单张裁剪，支持单选模式、支持多选模式。 httplite- A android http library。Android网络框架httplite使用指南 PanoramaImageView- 通过监听手腕旋转进行交互，自动滚动图片。 11.响应式编程RxAndroid- RxAndroid：函数响应式编程 ，RxJava- Rx和RxJava文档中文翻译项目,RxJava 详解，RxJava资料汇总。Rxjava+Retrofit 实现全局过期 Token 自动刷新 12.地图百度地图- Android百度地图 线路规划，模拟运动轨迹，及全景效果。 AirMapView- 支持多个本地地图提供者包括谷歌地图V2和亚马逊地图V2。如果设备没有任何受支持的本地地图提供者,AirMapView会回退到基于web的地图提供者(目前谷歌地图)。 13.数据库ORMLite- ORMLite做的最棒但是学习成本有点儿高，ORMLite的文档有点儿烂。 SugarORM- SugarORM比较轻便， 支持Has a 和 Has many映射，但无法保存集合，没有映射关系。 GreenDAO- GreenDAO要先建立一个java项目来生成对应的表，一变动又要生成，很不方便。 ActiveDriod- ActiveDriod也不错官网。 ORMDroid- ormdroid 。 sqlbrite- 良心企业Square的又一开源项目，当你不想给用ContentProvider，只想简单监听SQLite表增删改的数据变更时可以试试它。 sqlbrite- DBExecutor android ORM数据库 1.使用了读写锁，支持多线程操作数据。 2.支持操作多个数据库 3.支持事务 4.缓存Sql，缓存表结构。 Iron- 一个快速和易用的 NoSQL 数据存储框架。 hawk- 一个快速和易用的键值对数据存储框架，支持AES加密，支持SharedPreferences或Sqlite存储，支持Gson解析。 AndroidKeyValueStore- 一个基于 SQLite 的 Key/Value 存储框架。 DBFlow- 一个速度极快，功能强大，而且非常简单的 Android 数据库 ORM 库，为你编写数据库代码,DBFlow 已被证明是最好的解决方案。5 个顶级 Android 开源库 14.图像浏览及处理MPAndroidChart- MPAndroidChart是一个功能强大的图表开源类库：曲线图、柱形图、环形图。 XCL-Charts- (国人开发)基于Android Canvas来绘制各种图表,使用简便,定制灵活。 WilliamChart- 绘制图表的库，支持LineChartView、BarChartView和StackBarChartView三中图表类型，并且支持 Android 2.2及以上的系统。 CropImageView- 原生ImageView只支持centerCrop，这里有支持9个方向裁剪的ImageView。 SimpleCropView- 一个Android的图片裁剪库，使用简单，易于定制。 DrawableView- DrawableView实现画板功能，可以改变画笔粗细，颜色，支持撤销功能。 ImageCoverFlow- ImageCoverFlow效果不错的画廊控件 可以设置画廊一次可见图片的张数，和其他第三方Gallery控件不同的是，该控件直接继承自View，而不是sdk中的Gallery控件。 FancyCoverFlow- 支持Item切换动画效果的类似Gallery View。改进版本可以无限轮播，可以选择自动轮播或者 手动滑动。 BGABanner-Android- demo中演示了引导页、以及通过fresco、android-async-http、gson实现广告条的自动轮播效果（splash 、 ViewPager切换动画） 。 RecyclerViewPager- 重写后的 RecyclerViewPager 完全继承自RecyclerView，可以自定义触发翻页的距离，可自定义翻页速度，支持VerticalViewPager，支持Fragment。 StickerCamera- 可以说是一个完整的相机、图片编辑的 APP，集成了大部分市面上有的同类 APP 的功能，裁剪、滤镜、贴纸应有尽有。 demo6_PhotoRiver- 图片流动显示的demo，可以点击流动中的图片放大显示，双击空白处图片以九宫格排列。 glide-transformations- 一个基于Glide的transformation库，拥有裁剪，着色，模糊，滤镜等多种转换效果。 ColoringLoading- 一个用纯代码实现自动绘画效果动画的项目。 SmartDrawing- 一个轻量级的手绘板，加入了一点截图功能。这只是一个Demo。并不能作为类库，也不是完整的项目工程，仅供学习或参考使用。 SlidingCard- 漂亮的卡片滑动翻页特效。 LargeImage- 加载大图 可以高清显示10000*10000像素的图片。 GalleryFinal- 自定义相册，实现了拍照、图片选择（单选/多选）、 裁剪（单/多裁剪）、旋转、ImageLoader无绑定任由开发者选 择、功能可配置、主题样式可配置。GalleryFinal为你定制相册。 AndroidAlbum- AndroidAlbum图片选择器：1、MVP结构设计；2、工厂模式对载图框架进行封装抽象，方便替换其他载图框架；3、闪退日志的搜集，方便揪BUG。 uCrop- uCrop 是 Yalantis 推出的又一款力作, 用于裁剪 Android 系统上的图片, 致力于打造最佳的图片裁剪体验。 crop-image-layout- crop-image-layout：图片裁切布局。 RenderscriptHistogramEqualization-RenderScript :简单而快速的图像处理 15.视频音频处理ijkplayer- B站开源的视频播放器，支持Android和iOS。 DanmakuFlameMaster- 这里是Android上最好的开源弹幕引擎·烈焰弹幕使。 YouTubePlayerActivity- 一个可以播放YouTube视频的Activity，支持屏幕旋转、声音控制、播放失败处理、可以自定义Activity关闭动画以及在横屏播放的时候自动隐藏status bar。 AndroidVideoPlayer- 开源的 Android 视频播放器，支持 DLNA。 Hide-Music-Player- Hide音乐播放器。 JamsMusicPlayer- 是一个功能强大的 Android 开源播放器, 作者将原本收费的项目拿出来开源, 实在令人敬佩。 RxAndroidAudior- RxAndroidAudior目前最鲁棒的Android声音录制和播放封装库了,说明。 Timber- 一款遵循了Material Design并且设计精美的播放器 Timber Music Player，已经在google play上架。 LandscapeVideoCamera- 一款功能强大的 Android 视频录制库, 仅允许横屏录制, 提供细粒度控制视频的质量与文件大小。 MovieHub- 非常漂亮的一款 Android Movie 工具。 LyricViewDemo- 歌词显示控件，支持多行显示、拖曳播放、自动识别歌词文件的编码。 16.测试及调试DevelopQuickSetting- 快速开启关闭开发者设置的工具，提供了app界面和桌面widget，能快速打开关闭overdraw，layout border，gpu rendering，adb wifi，不保存activity实例等功能。 decompileandroid- 在线反编译apk文件。 jadx- 一个Android反编译神器，不同于常见的dex2jar，这个反编译器生成代码的try/catch次数更少，View也不再是数字id了，可读性更高。 Androguard- Androguard使用Python写的一系列逆向工具集，功能很强大哦，对逆向工程感兴趣的小伙伴可以这个系列，教程。 logger- 一个简单、漂亮、功能强大的Android日志程序。 stf- WEB 端批量移动设备管理控制工具 STF 的环境搭建和运行，使用说明。 DecompileApk- 一键反编译 APK，输出所有反编译后的代码、资源，使用方便。 AppCrashTracker- 一个异常追踪器，可以生成一个 JSON 格式的日志并可以上传到服务器。 preferator- 开发辅助工具，帮助你快速的在 Android 端修改 SharedPreference，以达到测试的目的。 17.动态更新热更新dexposed- 淘宝 支付宝的Android底层技术团队即将为Dexposed开源项目贡献一个重要的扩展能力 —— 方法粒度的完整替换，大幅度降低基于AOP方式替换大型方法的开发成本，使用教程，Android平台免Root无侵入AOP框架Dexposed使用详解。Android Hotpatch系列之-项目介绍-客户端例子实现,服务器简易实现。热更新。 Xposed- Xposed是一款可以在不修改APK的情况下影响程序运行的框架服务,Android Hook神器：XPosed入门与登陆劫持演示。热更新。 code-push-大微软推出的一套可以为用 React Native 和 Cordova 开发的 App 提供代码热更新的方案。 DynamicAPK- 实现Android App多apk插件化和动态加载，支持资源分包和热修复。 AndFixDemo- AndFix是alibaba出品的开源热更新技术。 gradle_plugin_android_aspectjx- 通过Gradle Transform和aspectj来实现代码动态修改，业务逻辑数据埋点、性能数据统计等侵入性修改从此不再需要修改业务代码，完美解决Dexposed兼容性问题，实现代码自动插桩。AspectJX-Demo RoboAspectJ- 美团出品的开源热更新技术。 18.消息推送与即时通讯即时通讯和sns开源项目汇总- 源码提供！Android即时通讯和sns开源项目汇总，github地址。 19.完整项目SuesNews新闻客户端- 腾飞新闻，一个符合 Google Material Design 的 Android 校园新闻客户端 ，新闻客户端说明。 新闻客户端- Android应用源码比较不错的新闻客户端，本项目启动引导登录注册用户中心列表显示文章分页下拉刷新文章收藏更新反馈等新闻客户端常见的功能都有，项目分层合理，代码质量较高。 materialistic- Material Desgin风格的Hacker News客户端。 Telegram- Telegram 是一款专注于速度、安全的短信息应用，快速、简单、免费。Telegram 支持群组聊天，最高200人，最高支持分享1GB的视频，其它图片等等更是不在话下。而且所有信息全部支持同步。由于频发的隐私问题，所以 Telegram 也很注重通信安全。 SuZhouTong-client-for-android- 苏州通android客户端，非常多的UI效果。 ele_demo- 仿【饿了么】订餐软件的一个demo。 MD-BiliBili- Material Design 版 BiliBili Android 客户端。 AisenWeiBo- Aisen微博是新浪微博的第三方客户端，UI遵循Material Design：遵循Material Design、发布多图、离线下载、私信（触屏版、颜色主题切换、手势返回，4.4、5.0状态栏变色、离线编辑，定时发布多图、gif、长微博预览。FrescoDemo。 快递查询- 使用了爱查快递www.ickd.cn的api接口，可以查询申通、EMS、顺风、圆通、中通、韵达、天天、汇通、全锋、德邦、宅急送等11种快递的单号信息，支持手动输入单号和扫描单号(红米测试的时候扫描单号有点问题)，可以保存单号查询记录方便下次查询，，另外还包括了网络状态判断、快递自动更新、软件更新等功能，项目完美运行，有很详细的中文注释和逻辑分层。 SmartCall- SmartCall Android 企业通讯录。 Android-高仿大众点评客户端源码- Android-高仿大众点评客户端源码。 八个Android项目源码- 八个Android项目源码，大部分功能相信可以在实战项目中直接使用，供大家下载学习，大部分项目是基于Android Studio开发，IDE为Eclipse的童鞋可通过网上教程自行转换，这里就不多说了。大家可以下载下来学习看看！百度云盘下载地址。 minicat- 一个简洁的饭否App，支持Android 4.0以上版本。 SimplifyReader- 一款基于Google Material Design设计开发的Android客户端，包括新闻简读，图片浏览，视频爽看 ，音乐轻听以及二维码扫描五个子模块。 GithubTrends- 是一个用来看查看 GitHub 热门项目的 Android App, 遵循 Material Design, 支持订阅 50 多种编程语言, 9 种颜色主题切换, 可在上面收藏喜欢的项目。 jianshi- jianshi简诗是国人开发的一个用于记录文字信息的 Android 完整应用, 作者仅用了一天便将其开发出来, 并将开发的流程记录成文放到了简书上。 BuildingBlocks- 积木： 一个以知乎日报作为数据展现内容；以抽屉菜单作为功能扩展入口；依循 Material Design 作为主导设计 UI 的应用。 Douya- 开源的 Material Design 豆瓣客户端。 TranslateApp- 一个实现『划词翻译』功能的 Android 开源应用。 likequanmintvp- 基于MVP的Retrofit2(okhttp3)+rxjava+dagger2+greendao+glide+rtmp直播。该项目系仿全民TV。 20.插件Android Studio 插件和工具- 5个 推荐几个有用的 Android Studio 插件和工具（ButterKnife、selectorChapek、GsonFormat、ParcelableGenerator、LeakCanary）。 8 个最优秀的 Android Studio 插件- 8 个最优秀的 Android Studio 插件（H.A.X.M（硬件加速执行管理器）、Genymotion、Android Drawable Importer、Android ButterKnife Zelezny、Android Holo Colors Generator、Robotium Recorder、jimu Mirror、Strings-xml-tools）。 smalidea- 一款 IntelliJ IDEA/Android Studio 的 smali 插件～ ，Smalidea 无源码调试 Android 应用。 gradle-fir-plugin- 一个上传apk到fir的gradle插件，使用说明。 android-butterknife-zelezny- 一个ButterKnife的Android Studio插件, 该插件可以让你手动生成上述注入代码。 GradleDependenciesHelperPlugin- Gradle 依赖自动补全插件。 android-selector-intellij-plugin- 可以根据指定颜色生成Selector Drawable的插件。 7个最佳的Android模拟器- 7个最佳的Android模拟器。 gradle-android-javadoc-plugin- 可以生成 java doc 的 Gradle 插件。 gradle-android-junit-jacoco-plugin- 可以生成代码单元测试覆盖率报告的 Gradle 插件。 gradle-android-apk-size-plugin- 可以将 Apk 大小记录到 CSV 文件的 Gradle 插件。 几款实用的Android Studio 插件- 几款实用的Android Studio 插件：1、android-butterknife-zelezny；2、Gsonformat：可根据json数据快速生成java实体类；3、Android Postfix Completion；4、AndroidAccessors；5、Lifecycle Sorter：根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K；6、JsonOnlineViewer；7、CodeGlance；8、findBugs-IDEA：帮你一起找bug的；9、ADB WIFI：使用wifi无线调试你的app，无需root权限。 Leisure- 闲暇(Leisure)是一款集”知乎日报”、“果壳科学人”、“新华网新闻”以及“豆瓣图书”于一体的阅读类Android应用。 果壳、知乎和豆瓣在国内拥有大量用户，这些社区的用户每天都产生很多高质量内容。闲暇以其简介的风格将这几大社区 的优质内容整合于一体，使得用户能有效地获取这些内容，大大节省了用户的时间。酷安下载地址. LayoutFormatter插件- 可自动将乱序的布局文件进行重新属性排序并格式化，比如 style 和 android:id 必须排在前面，紧接着 layout、padding，而值设定如 text 只能排在最后。 21.著名框架xUtils- xUtils 包含了很多实用的android工具。支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响。最低兼容android 2.2 (api level 8)。目前xUtils主要有四大模块：DbUtils模块、ViewUtils模块、HttpUtils模块、BitmapUtils模块。 afinal- Afinal是一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。 ButterKnife- ButterKnife是一个专注于Android系统的View注入框架，让你从此从这些烦人臃肿的代码中解脱出来，ButterKnife–View注入框架。5 个顶级 Android 开源库 EventBus- EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息.优点是开销小，代码更优雅。以及将发送者和接收者解耦。xBus- xBus - 简洁的EventBus实现。 Small- 做最轻巧的跨平台插件化框架，目前已支持Android、iOS以及html5插件。并且三者之间可以通过同一套javascript接口进行通信。 LayoutCast- LayoutCast可以在应用不重启的情况下，将res文件夹下的改动直接同步到手机上。使用LayoutCast，可以节约Android开发者的大量编译等待时间，非常适合真机调试界面的时候使用，推荐每一位开发者安装该利器。BUCK很快，但入侵性强，项目改动大，LayoutCast对项目改动小。 retrofit- retrofit将 REST API 转换为 Java 接口。5 个顶级 Android 开源库 Dagger2- Dagger 2 是著名的依赖注入库Dagger的继承者，我们强烈推荐它。文档，5 个顶级 Android 开源库 22.其他java-zhconverter- java-zhconverter是一个简繁体中文互换的Java开源类库。 joda-time-android- 一个超赞的时间处理的库，Joda-Time ！ 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。java版本 AssistiveTouch- 配合Android手机沉浸式隐藏虚拟按键后快捷操作 (Nexus5屏幕变大了)。 S-Tools- S-Tools一个可以实时查看的CPU状态和手机各类传感器数据，还有一些例如颜色选择、指南针和设备信息等功能。 JsBridge- 模仿微信webview的JsBridge，安全方便的实现js和Java的互相调用，主要通过loadUrl和shouldOverrideUrl实现。 Sample Of All Samples- 提供大部分Android5.0组件的示例应用。 Android-Package-Channel- 美团网做的把Android多渠道打包工具，打包时间缩短到一分钟，python脚本。 fast-apk-packaging- Android不需要重新编译打渠道包。 android_gradle_script- gradle批量打包脚本，用txt配置一下，就可以支持多个渠道打包，适合国内这种动不动上百个渠道包的环境。目前有个问题，一次打包脚本超过80个就会GC问题。 BatchPackApk- 免签名直接打包工具。 Android多渠道打包工具Gradle插件- Android多渠道打包工具Gradle插件。 Android批量打包极速版- 用python实现的在META-INF目录内添加空文件的方式，实现批量快速打包Android应用。 Gradle-Plugin-User-Guide-Chinese-Verision- Gradle插件使用指南中文版。 gradle-guide.books- Android Gradle 插件中文指南（GitBook）。 Android-package_tool- 该工程用于编译多渠道Android应用，替换相应的标签，然后重新打包，用perl脚本实现。 兰贝壳儿- Android多渠道打包解决方案(兰贝壳儿)，eclipse插件。 Algorithms- 常见算法问题的Java实现。 java-design-patterns- 一个常见设计模式的java实现。 PreferenceInjector- SharedPreference注入开源库，SharedPreference key与某个变量绑定、监听key变化、初始化key都可以通过注解完成。 prettytime- 一个实用的人性化的时间显示，比如：几分钟前，几天前。 Material-Movies- Material Design 下的Movie App（电影展示），可供学习，或者直接二次开发。 Clean-Contacts- 充满技术含量的一个 Contact App（联系人）。 RedEnvelopeAssistant- 完全免费开源的抢红包软件、做这个软件纯粹是发现Android的模拟点击十分好玩，然后顺道写了一个，有此基础，可以再扩展其他的很多模拟点击程序 。 superCleanMaster- 一键清理开源版，包括内存加速，缓存清理，自启管理，软件管理等。 LoadViewHelper- 切换加载中，加载失败，加载成功布局，定义一个LoadViewHelper所有界面通用。 android-best-practices- android最佳实践 Android最佳实践- 安卓最佳实践（1）：安卓开发–中文。 Android最佳实践- 从Futurice公司Android开发者中学到的经验。 遵循以下准则，避免重复发明轮子。若您对开发iOS或Windows Phone 有兴趣， 请看iOS Good Practices 和 Windows client Good Practices 这两篇文章。 如何安装ACRA- 如何安装ACRA-一个Android应用Crash跟踪系统—在自己的服务器上。 Android ocr识别文字介绍- Android ocr识别文字介绍 。 DaVinci- DaVinci是一个适用于Android Wear平台的图片下载和缓存library。 Point-of-Android- Android 一些重要知识点解析整理 。 AppStoreLibrary- 检测是否在appstore安装了应用，搜索应用。 LeakCanary- 利用此类库，排查内存泄露变得非常简单，LeakCanary 中文使用说明，LeakCanary: 让内存泄露无所遁形。 anko- 快速开发框架。 CommonAdapter- 通过对于原生Adapter的封装，产生了支持ListView，GridView，RecyclerView的简单通用的Adapter。这种方式将item变成独立的“视图”对象，方便操作，又增加了可扩展性。 MVPAndroidBootstrap- 一个Android MVP 模式实例项目。 json2notification- 一个多功能方便好用的notification通知栏通知开源库。 barcodescanner- 一个封装好的基于zxing二维码扫描库。 BGAQRCode-Android- 一个可高度定制二维码扫描界面、生成二维码、识别图片二维码库。 mqtt- MQTT 协议 3.1.1 中文翻译版。 Droid Plugin- DroidPlugin 是360手机助手在Android系统上实现了一种新的插件机制:它可以在无需安装、修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定的好处。 JsonAnnotation- 利用注解自动生成Gson‘s Model的库。 WeChatLuckyMoney- 微信抢红包插件。 android-support-23.2-sample- support 库在 23.2 版本新增内容示例项目。 Sunoath- 基于MVP+Retrofit+Material Design的Demo。 ActivityRouter- 一个url打开activity的Router库，支持指定参数类型，支持参数transfer，支持callback。 AnalysisApp- 一个快速分析 Android App 使用了哪些 SDK 的工具。 AndroidLuaExample- 封装了最新Lua代码的Android库。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cannot resolve method getSupportFragmentManager();]]></title>
    <url>%2Fposts%2F2ed74455.html</url>
    <content type="text"><![CDATA[在使用Fragment的时候，我们尝尝会用到Fragment管理器，那么初始化Fragment管理器的时候我们会遇到getSupportFragmentManager();方法找不到的情况，这里主要有两个原因： import android.support.v4.app.FragmentManager; 没有导入v4包下的Fragmanager. Activity没有继承FragmentActivity。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager轮播图（文字&图片）]]></title>
    <url>%2Fposts%2F3bedd12e.html</url>
    <content type="text"><![CDATA[Demo地址：MyViewPager ViewPager常用来实现图片的轮播，比如淘宝首页，会把一些促销的商品的图片和描述信息来回的播放，这就是典型的使用ViewPager实现的。 ViewPager属于布局管理器，允许用户通过页面翻转查看左右的数据，下面通过一个实例来讲解ViewPager实现图片轮播和手势滑动。 效果图 布局文件 activity_main.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="180dp"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/vp" android:layout_width="match_parent" android:layout_height="180dp"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_alignParentBottom="true" android:background="#6000" android:gravity="center_horizontal" android:orientation="vertical" android:padding="5dp"&gt; &lt;TextView android:id="@+id/tv_desc" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="#fff"/&gt; &lt;LinearLayout android:id="@+id/ll_point" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="5dp" android:orientation="horizontal"&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 小圆点选择器point_enable.xml 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;corners android:radius="8dp"/&gt; &lt;solid android:color="#fff"/&gt;&lt;/shape&gt; point_disable.xml 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="oval"&gt; &lt;corners android:radius="8dp"/&gt; &lt;solid android:color="@android:color/darker_gray"/&gt;&lt;/shape&gt; point_selector.xml 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_enabled="true" android:drawable="@drawable/point_enable"/&gt; &lt;item android:state_enabled="false" android:drawable="@drawable/point_disable"/&gt;&lt;/selector&gt; MainActivityMianActivity的代码如下，下面的代码主要是实现图片轮播和手势滑动，同时也提供里一个解决图片轮播到最后一个或滑动到最后一个（或第一个时）停了下来的问题，这个问题对用户体验来说是很糟糕的，所以要解决。同时提供了温习了一下MVC开发模型，这种模型能够让代码显得结构清晰。为了保证代码的连贯性，把代码写在了一个类中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197package com.zm.myviewpager;import android.os.Bundle;import android.support.v4.view.PagerAdapter;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import java.util.ArrayList;public class MainActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener &#123; private ViewPager vp; private LinearLayout ll_point; private TextView tv_desc; private int[] imageResIds; //存放图片资源id的数组 private ArrayList&lt;ImageView&gt; imageViews; //存放图片的集合 private String[] contentDescs; //图片内容描述 private int lastPosition; private boolean isRunning = false; //viewpager是否在自动轮询 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //使用M-V-C模型 //V--view视图 initViews(); //M--model数据 initData(); //C--control控制器(即适配器) initAdapter(); //开启图片的自动轮询 new Thread() &#123; @Override public void run() &#123; isRunning = true; while (isRunning) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //在子线程中开启子线程 //往下翻一页（setCurrentItem方法用来设置ViewPager的当前页） vp.setCurrentItem(vp.getCurrentItem() + 1); &#125; &#125;); &#125; &#125; &#125;.start(); &#125; /* 初始化视图 */ private void initViews() &#123; //初始化放小圆点的控件 ll_point = (LinearLayout) findViewById(R.id.ll_point); //初始化ViewPager控件 vp = (ViewPager) findViewById(R.id.vp); //设置ViewPager的滚动监听 vp.setOnPageChangeListener(this); //显示图片描述信息的控件 tv_desc = (TextView) findViewById(R.id.tv_desc); &#125; /* 初始化数据 */ private void initData() &#123; //初始化填充ViewPager的图片资源 imageResIds = new int[]&#123;R.mipmap.aa, R.mipmap.bb, R.mipmap.cc, R.mipmap.dd, R.mipmap.ee&#125;; //图片的描述信息 contentDescs = new String[]&#123; "忙碌的生活疏于彼此联系，但却无法冲淡对你的思念。相信我们的心电感应，会把我每一次祈祷和祝福悄悄传送。", "你会因为一首歌喜欢上一个人，因为一个人喜欢一个城市，因为一个城市喜欢上一种生活，然后成为一首歌，想念某个人。", "我们对亲人的思念是永不会停止的，而思念却是多种的，阿婆的伤痛，妈妈的文字，我的小女儿情绪，不管怎样，已故的亲人永远活在我们的心里。", "每一天醒来，你的清影就在我眼前转。不管手里干什么事，一会儿，准走神儿了，呆呆的只想你，算着你什么时候回来。", "在一年的每个日子，在一天每个小时，在一小时的每一分钟，在一分钟的每一秒，我都在想你。" &#125;; //保存图片资源的集合 imageViews = new ArrayList&lt;&gt;(); ImageView imageView; View pointView; //循环遍历图片资源，然后保存到集合中 for (int i = 0; i &lt; imageResIds.length; i++) &#123; //添加图片到集合中 imageView = new ImageView(this); imageView.setBackgroundResource(imageResIds[i]); imageViews.add(imageView); //加小白点，指示器（这里的小圆点定义在了drawable下的选择器中了，也可以用小图片代替） pointView = new View(this); pointView.setBackgroundResource(R.drawable.point_selector); //使用选择器设置背景 LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(8, 8); if (i != 0) &#123; //如果不是第一个点，则设置点的左边距 layoutParams.leftMargin = 10; &#125; pointView.setEnabled(false); //默认都是暗色的 ll_point.addView(pointView, layoutParams); &#125; &#125; /* 初始化适配器 */ private void initAdapter() &#123; ll_point.getChildAt(0).setEnabled(true); //初始化控件时，设置第一个小圆点为亮色 tv_desc.setText(contentDescs[0]); //设置第一个图片对应的文字 lastPosition = 0; //设置之前的位置为第一个 vp.setAdapter(new MyPagerAdapter()); //设置默认显示中间的某个位置（这样可以左右滑动），这个数只有在整数范围内，可以随便设置 vp.setCurrentItem(5000000); //显示5000000这个位置的图片 &#125; //界面销毁时，停止viewpager的轮询 @Override protected void onDestroy() &#123; super.onDestroy(); isRunning = false; &#125; //--------------以下是设置ViewPager的滚动监听所需实现的方法-------- //页面滑动 @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; //新的页面被选中 @Override public void onPageSelected(int position) &#123; //当前的位置可能很大，为了防止下标越界，对要显示的图片的总数进行取余 int newPosition = position % 5; //设置描述信息 tv_desc.setText(contentDescs[newPosition]); //设置小圆点为高亮或暗色 ll_point.getChildAt(lastPosition).setEnabled(false); ll_point.getChildAt(newPosition).setEnabled(true); lastPosition = newPosition; //记录之前的点 &#125; //页面滑动状态发生改变 @Override public void onPageScrollStateChanged(int state) &#123; &#125; /** * 自定义适配器，继承自PagerAdapter */ class MyPagerAdapter extends PagerAdapter &#123; //返回显示数据的总条数，为了实现无限循环，把返回的值设置为最大整数 @Override public int getCount() &#123; return Integer.MAX_VALUE; &#125; //指定复用的判断逻辑，固定写法：view == object @Override public boolean isViewFromObject(View view, Object object) &#123; //当创建新的条目，又反回来，判断view是否可以被复用(即是否存在) return view == object; &#125; //返回要显示的条目内容 @Override public Object instantiateItem(ViewGroup container, int position) &#123; //container 容器 相当于用来存放imageView //从集合中获得图片 int newPosition = position % 5; //数组中总共有5张图片，超过数组长度时，取摸，防止下标越界 ImageView imageView = imageViews.get(newPosition); //把图片添加到container中 container.addView(imageView); //把图片返回给框架，用来缓存 return imageView; &#125; //销毁条目 @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; //object:刚才创建的对象，即要销毁的对象 container.removeView((View) object); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之uri、file、path相互转化]]></title>
    <url>%2Fposts%2F6f91fcbd.html</url>
    <content type="text"><![CDATA[uri &amp; file 互转1File file = new File(new URI(uri.toString())); 1URI uri = file.toURI(); uri &amp; path 互转1234567private String getPath(Uri uri) &#123; String[] projection = &#123;MediaStore.Video.Media.DATA&#125;; Cursor cursor = managedQuery(uri, projection, null, null, null); int column_index = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA); cursor.moveToFirst(); return cursor.getString(column_index); &#125; 1Uri uri = Uri.parse(path); file &amp; path 互转1String path = file.getPath() 1File file = new File(path)]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丰宁坝上草原2日游线路行程]]></title>
    <url>%2Fposts%2Fabebff90.html</url>
    <content type="text"><![CDATA[丰宁坝上草原2日游线路行程第一天07：00 北京约定地点集合 12：00 到达目的地，20人以上团队我们安排马队欢迎仪式，鞭炮欢迎！！！但晚上无法进行此活动 12：10 分房，午餐 14：00 骑马出发前往影视基地情人谷（草原上的另一番景色望不到边际的白桦林），影视村（原汁原味草原上的老村庄）情人谷北影厂的外景地（章子怡主演的《我的父亲母亲》；黄宏主演的《25个孩子一个爹》；电视剧《暖春》等多部影视剧的拍摄外景地）。 草原的落日也是值得一看的美景，你会感受到离开喧嚣世界，真正回归自然的那份自由自在，怡然自得。观赏草原夕阳，然后准备共进草原晚餐。 19：00 晚餐吃烤全羊、篝火聚会、观赏烟花、篝火跳舞，KTV。大家一起喝酒聊天，唱起我们喜欢的歌曲，在欢快的歌声中让我们舞动身体，度过美好的草原之夜。 第二天06：00 晨观日出 07：30 早餐后，前往草原娱乐场（价值180元已含），进入蒙古人家，感受蒙族风情，喝马奶酒，参加蒙古仪式祭祀敖包；可玩滑草、射箭、滑索、飞斧、野战搏击、弹跳飞人、喷火神枪、海盗船、激情转马、流星炮车、疯狂斗牛、蒙古人家、杂技表演等娱乐项目。 10：00前往美丽的草原滦河源头【闪电湖】拍照、看草原。滦河上游最大的湖，因入湖前的河流为闪电河而得名。在天苍苍、野茫茫的草原上闪现出这样敞亮清澈美丽的湖水，当地人叫它闪电湖。 或10:00开始团建活动，免费团建装备：拔河、背夹球、草地足球、袋鼠跳跳袋、多人跳绳、巨人脚步、摸石过河砖、珠行千里、撕名牌、指压板等活动。 12：00 午餐后返程北京，沿途一路美景相伴，也不会觉得枯燥，从海拔2000米到平原地带，各路美景让您充分领略。 住宿吃餐 标准型方案 128元/人3正餐+1早餐+1晚住宿（草原风农家院 两星标准,双人/三人标间,独立卫浴,热水,有线电视,WiFi）+免费篝火专业音响 超值型方案 168元/人3正餐+1早餐+1晚住宿（草原风农家院 两星标准,双人/三人标间,独立卫浴,热水,有线电视,WiFi）+免费篝火专业音响+15项娱乐场套票 特惠型方案 268元/人3正餐+1早餐+1晚住宿（远山.别院 准四星酒店标准,双人/三人标间,独立卫浴淋浴房,观景房,热水,有线电视,WiFi）+免费篝火专业音响+15项娱乐场套票 15项娱乐套票入场门票10元；高山滑草20元；缆车40元；弹跳飞人30元；射箭20元； 真人CS30元；竹林迷宫20元；蒙古人家20元；敖包祈福20元；欢乐转马20元；登月飞车20元；桑巴汽球20元；小海盗船20元；草原飞斧(6把/人)20元；高尔夫球20元；价值330元 费用包含 住宿费：酒店双人或三人标间； 餐费：三正餐一早餐； 活动费：拔河、放风筝、草地足球、趣味运动会等； 篝火晚会费：满20人即可组织篝火晚会； 全程司机、领队食宿费等； 医用装备：医药箱、急救包等（领队医药箱中包含药品种类：云南、白药喷雾剂、云南白药粉、风油精、绿药膏、烫伤膏、体温计、创可贴、绷带、纱布块、酒精、棉签、医用胶布、小剪刀）如需特殊药物请提前自备； 赠送娱乐套票：15项娱乐场套票（滑草、射箭、滑索、飞斧、野战搏击、弹跳飞人、喷火神枪、海盗船、激情转马、流星炮车、疯狂斗牛、蒙古人家、杂技表演等），此票不退不换；坝上独家帐篷营地、野餐基地、野外烧烤基地，可根据您的需要安排。 费用不含 骑马：骑马50元/小时，牵马费20元/小时； 烤全羊：30元/斤，活羊称重； 租车费用：6-55座各型旅游车，正规车，手续齐全； 景点门票：情人谷 免费、柳树沟70元/人、千松坝森林公园100元/人、大汗行宫90元/人、闪电湖30元/人、老掌沟20元/人、草原天路 免费；以上门票住宿咱家都有折扣票。 发票：不含发票，开发票需要另外加6%税点； 坝上草原旅游注意事项1、坝上风大，早晚温差大，建议多带些衣物。2、草原阳光较晒，应戴太阳镜、帽子并涂抹防晒霜。3、草原常有雷雨天气，雨具应必备。4、坝上草原有很多的村庄，虽然已经多年接待游客，但是山村人质朴、单纯的性格还是给游客带来很多的温馨，你敬他一尺，他敬你一丈，反之也是一样。所以处事要以和为贵，能饶人处且饶人，千万不可感情用事，有事多和您所住的酒店旅馆、农家小院的负责人商量，求其帮助解决。来坝上草原，尽量避免周末人多的的时候，根据以往的经验，周一到周四号人相对少些，各方面的价格也相对低一些。5、开心之时要特别注意管理好自己的东西。由于旅游区人员较多、比较杂，要特别小心。骑马是很多人喜好的娱乐和健身活动。外出骑马是一定要放好自己的东西，尽量不要带手机和钱包，如果带一定要放在妥善的、不易丢掉的地方。因为骑马会上下颠簸，口袋里的东西很容易掉出来，所以，骑马丢手机、钱包、眼镜、照相机、手表、钥匙、打火机、香烟等的人不少。6、放鞭炮、开越野车、四驱、摩托车等都要注意安全，安全第一。]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[录音SoundRecording]]></title>
    <url>%2Fposts%2F58d30177.html</url>
    <content type="text"><![CDATA[效果图 首页 录音 播放 实现录音的 Service这个类可以说是这个包的核心了，如果理解了这个 Service，录音这一块基本就没什么问题了。 录音主要是利用 MediaRecoder 这个类，进行声音的记录，接下来我们一起来看看具体的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class RecordingService extends Service &#123; private static final String LOG_TAG = "RecordingService"; private String mFileName = null; private String mFilePath = null; private MediaRecorder mRecorder = null; private long mStartingTimeMillis = 0; private long mElapsedMillis = 0; private TimerTask mIncrementTimerTask = null; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; startRecording(); return START_STICKY; &#125; @Override public void onDestroy() &#123; if (mRecorder != null) &#123; stopRecording(); &#125; super.onDestroy(); &#125; public void startRecording() &#123; setFileNameAndPath(); mRecorder = new MediaRecorder(); mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mRecorder.setOutputFile(mFilePath); mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC); mRecorder.setAudioChannels(1); mRecorder.setAudioSamplingRate(44100); mRecorder.setAudioEncodingBitRate(192000); try &#123; mRecorder.prepare(); mRecorder.start(); mStartingTimeMillis = System.currentTimeMillis(); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125; &#125; public void setFileNameAndPath() &#123; int count = 0; File f; do &#123; count++; mFileName = getString(R.string.default_file_name) + "_" + (System.currentTimeMillis()) + ".mp4"; mFilePath = Environment.getExternalStorageDirectory().getAbsolutePath(); mFilePath += "/SoundRecorder/" + mFileName; f = new File(mFilePath); &#125; while (f.exists() &amp;&amp; !f.isDirectory()); &#125; public void stopRecording() &#123; mRecorder.stop(); mElapsedMillis = (System.currentTimeMillis() - mStartingTimeMillis); mRecorder.release(); getSharedPreferences("sp_name_audio", MODE_PRIVATE) .edit() .putString("audio_path", mFilePath) .putLong("elpased", mElapsedMillis) .apply(); if (mIncrementTimerTask != null) &#123; mIncrementTimerTask.cancel(); mIncrementTimerTask = null; &#125; mRecorder = null; &#125;&#125; 可以看到在 onStartCommand() 里面有一个 startRecording() 方法，在外部启动这个 RecordingService 的时候，便会调用这个 startRecording() 方法开始录音。 在 startRecording() 方法中先调用了 setFileNameAndPath 方法，初始化了录音文件的名字和保存的路径，为了让每个录音文件都有唯一的名字，我调用 System.currentMillis() 拼接到录音文件的名字里面。 12345678910111213public void setFileNameAndPath() &#123; int count = 0; File f; do &#123; count++; mFileName = getString(R.string.default_file_name) + "_" + (System.currentTimeMillis()) + ".mp4"; mFilePath = Environment.getExternalStorageDirectory().getAbsolutePath(); mFilePath += "/SoundRecorder/" + mFileName; f = new File(mFilePath); &#125; while (f.exists() &amp;&amp; !f.isDirectory());&#125; 设置好了文件的名字和保存路径之后，对 mRecorder 进行一系列参数的设置，这个mRecorder 是 MediaRecorder 的一个实例，专门用于录音的存储。 1234567891011121314151617181920public void startRecording() &#123; setFileNameAndPath(); mRecorder = new MediaRecorder(); mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mRecorder.setOutputFile(mFilePath); mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC); mRecorder.setAudioChannels(1); mRecorder.setAudioSamplingRate(44100); mRecorder.setAudioEncodingBitRate(192000); try &#123; mRecorder.prepare(); mRecorder.start(); mStartingTimeMillis = System.currentTimeMillis(); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125;&#125; 设置好参数之后，启动 mRecorder 开始录音，可以看到启动 mRecorder 开始录音后，我还将当前的时间赋值给 mStartingTimeMills，这里主要是为了记录录音的时长，等到录音结束后再获取一次当前的时间，然后将两个时间进行相减，就能得到录音的具体时长了。 等到录音结束，停止服务后，便会回调 RecordingService 的 onDestroy() 方法，这时候便会调用 stopRecording() 方法，关闭 mRecorder，并用 SharedPreferences 保存录音文件的信息，最后将 mRecorder 置空，防止内存泄露。 1234567891011121314151617public void stopRecording() &#123; mRecorder.stop(); mElapsedMillis = (System.currentTimeMillis() - mStartingTimeMillis); mRecorder.release(); getSharedPreferences("sp_name_audio", MODE_PRIVATE) .edit() .putString("audio_path", mFilePath) .putLong("elpased", mElapsedMillis) .apply(); if (mIncrementTimerTask != null) &#123; mIncrementTimerTask.cancel(); mIncrementTimerTask = null; &#125; mRecorder = null;&#125; 显示录音界面的 RecordAudioDialogFragment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class RecordAudioDialogFragment extends DialogFragment &#123; private static final String TAG = "RecordAudioDialogFragme"; private int mRecordPromptCount = 0; private boolean mStartRecording = true; private boolean mPauseRecording = true; long timeWhenPaused = 0; private FloatingActionButton mFabRecord; private Chronometer mChronometerTime; private ImageView mIvClose; private OnAudioCancelListener mListener; public static RecordAudioDialogFragment newInstance() &#123; RecordAudioDialogFragment dialogFragment = new RecordAudioDialogFragment(); Bundle bundle = new Bundle(); dialogFragment.setArguments(bundle); return dialogFragment; &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); &#125; @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_record_audio, null); initView(view); mFabRecord.setColorNormal(getResources().getColor(R.color.colorAccent)); mFabRecord.setColorPressed(getResources().getColor(R.color.colorAccent)); mFabRecord.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(getActivity() , new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO&#125;, 1); &#125; else &#123; onRecord(mStartRecording); mStartRecording = !mStartRecording; &#125; &#125; &#125;); mIvClose.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.onCancel(); &#125; &#125;); builder.setCancelable(false); builder.setView(view); return builder.create(); &#125; private void initView(View view) &#123; mChronometerTime = (Chronometer) view.findViewById(R.id.record_audio_chronometer_time); mFabRecord = (FloatingActionButton) view.findViewById(R.id.record_audio_fab_record); mIvClose = (ImageView) view.findViewById(R.id.record_audio_iv_close); &#125; Intent intent; private void onRecord(boolean start) &#123; intent = new Intent(getActivity(), RecordingService.class); if (start) &#123; // start recording mFabRecord.setImageResource(R.drawable.ic_media_stop); //mPauseButton.setVisibility(View.VISIBLE); Toast.makeText(getActivity(), "开始录音...", Toast.LENGTH_SHORT).show(); File folder = new File(Environment.getExternalStorageDirectory() + "/SoundRecorder"); if (!folder.exists()) &#123; //folder /SoundRecorder doesn't exist, create the folder folder.mkdir(); &#125; //start Chronometer mChronometerTime.setBase(SystemClock.elapsedRealtime()); mChronometerTime.start(); //start RecordingService getActivity().startService(intent); //keep screen on while recording// getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; else &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125; @Override public void onDestroyView() &#123; if (!mStartRecording) &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; super.onDestroyView(); &#125; public void setOnCancelListener(OnAudioCancelListener listener) &#123; this.mListener = listener; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED &amp;&amp; grantResults[1] == PackageManager.PERMISSION_GRANTED) &#123; onRecord(mStartRecording); &#125; break; &#125; &#125; public interface OnAudioCancelListener &#123; void onCancel(); &#125;&#125; 可以看到在 RecordAudioDialogFragment 有一个 newInstance(int maxTime) 的静态方法供外部调用，如果想设置录音的最大时长，直接传参数进去就行了。 这个对话框的重点部分就是在 onCreateDialog()中，我们先加载了我们自定义的对话框的布局，当点击录音的按钮的时候，先进行相关权限的申请，录音权限 android.permission.RECORD_AUDIO 1234567891011121314151617181920212223242526272829303132333435public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); final AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_record_audio, null); initView(view); mFabRecord.setColorNormal(getResources().getColor(R.color.colorAccent)); mFabRecord.setColorPressed(getResources().getColor(R.color.colorAccent)); mFabRecord.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(getActivity() , new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.RECORD_AUDIO&#125;, 1); &#125; else &#123; onRecord(mStartRecording); mStartRecording = !mStartRecording; &#125; &#125; &#125;); mIvClose.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mListener.onCancel(); &#125; &#125;); builder.setCancelable(false); builder.setView(view); return builder.create();&#125; 申请好权限之后便会调用 onRecord() 这个方法，然后将 boolean mStartRecording 进行反转，这样就不用写难看的 if else 了，直接改变 mStartRecording 的值，然后在 onRecord() 里面进行处理。 1234567891011121314151617181920212223242526272829303132333435363738private void onRecord(boolean start) &#123; intent = new Intent(getActivity(), RecordingService.class); if (start) &#123; // start recording mFabRecord.setImageResource(R.drawable.ic_media_stop); //mPauseButton.setVisibility(View.VISIBLE); Toast.makeText(getActivity(), "开始录音...", Toast.LENGTH_SHORT).show(); File folder = new File(Environment.getExternalStorageDirectory() + "/SoundRecorder"); if (!folder.exists()) &#123; //folder /SoundRecorder doesn't exist, create the folder folder.mkdir(); &#125; //start Chronometer mChronometerTime.setBase(SystemClock.elapsedRealtime()); mChronometerTime.start(); //start RecordingService getActivity().startService(intent); //keep screen on while recording// getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; else &#123; //stop recording mFabRecord.setImageResource(R.drawable.ic_mic_white_36dp); //mPauseButton.setVisibility(View.GONE); mChronometerTime.stop(); timeWhenPaused = 0; Toast.makeText(getActivity(), "录音结束...", Toast.LENGTH_SHORT).show(); getActivity().stopService(intent); //allow the screen to turn off again once recording is finished getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); &#125; &#125; 创建了保存录音文件的文件夹，然后根据 mStartRecording 的值进行 RecordingService 的启动和关闭罢了。在启动时还顺便开始了 mChronometer 的计时显示，这是一个 Android 原生的显示计时的一个控件。 播放录音的 PlaybackDialogFragment外部调用这个对话框的时候，只需要传入一个包含录音文件信息的 RecordingItem，因为包含的信息比较多，所以最好将 RecordingItem 进行序列化。 1234567public static PlaybackDialogFragment newInstance(RecordingItem item) &#123; PlaybackDialogFragment f = new PlaybackDialogFragment(); Bundle b = new Bundle(); b.putParcelable(ARG_ITEM, item); f.setArguments(b); return f;&#125; 来看看 onCreateDialog() 方法，在加载了布局之后，给 mSeekBar 设置监听，mSeekBar 是一个显示进度条的控件，当开始播放录音时候，将录音文件的时长，设置进 mSeekBar 里面，播放录音的同时，运行 mSeekBar，通过监听 mSeekBar 的进度，刷新显示的播放进度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public Dialog onCreateDialog(Bundle savedInstanceState) &#123; Dialog dialog = super.onCreateDialog(savedInstanceState); AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = getActivity().getLayoutInflater().inflate(R.layout.fragment_media_playback, null); mFileNameTextView = (TextView) view.findViewById(R.id.file_name_text_view); mFileLengthTextView = (TextView) view.findViewById(R.id.file_length_text_view); mCurrentProgressTextView = (TextView) view.findViewById(R.id.current_progress_text_view); mSeekBar = (SeekBar) view.findViewById(R.id.seekbar); ColorFilter filter = new LightingColorFilter (getResources().getColor(R.color.green), getResources().getColor(R.color.green)); mSeekBar.getProgressDrawable().setColorFilter(filter); mSeekBar.getThumb().setColorFilter(filter); mFileLengthTextView.setText(String.valueOf(mFileLength)); mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; if(mMediaPlayer != null &amp;&amp; fromUser) &#123; mMediaPlayer.seekTo(progress); mHandler.removeCallbacks(mRunnable); long minutes = TimeUnit.MILLISECONDS.toMinutes(mMediaPlayer.getCurrentPosition()); long seconds = TimeUnit.MILLISECONDS.toSeconds(mMediaPlayer.getCurrentPosition()) - TimeUnit.MINUTES.toSeconds(minutes); mCurrentProgressTextView.setText(String.format("%02d:%02d", minutes,seconds)); updateSeekBar(); &#125; else if (mMediaPlayer == null &amp;&amp; fromUser) &#123; prepareMediaPlayerFromPoint(progress); updateSeekBar(); &#125; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; if(mMediaPlayer != null) &#123; // remove message Handler from updating progress bar mHandler.removeCallbacks(mRunnable); &#125; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; if (mMediaPlayer != null) &#123; mHandler.removeCallbacks(mRunnable); mMediaPlayer.seekTo(seekBar.getProgress()); long minutes = TimeUnit.MILLISECONDS.toMinutes(mMediaPlayer.getCurrentPosition()); long seconds = TimeUnit.MILLISECONDS.toSeconds(mMediaPlayer.getCurrentPosition()) - TimeUnit.MINUTES.toSeconds(minutes); mCurrentProgressTextView.setText(String.format("%02d:%02d", minutes,seconds)); updateSeekBar(); &#125; &#125; &#125;); mPlayButton = (FloatingActionButton) view.findViewById(R.id.fab_play); mPlayButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onPlay(isPlaying); isPlaying = !isPlaying; &#125; &#125;); mFileNameTextView.setText(item.getName()); mFileLengthTextView.setText(String.format("%02d:%02d", minutes,seconds)); builder.setView(view); // request a window without the title dialog.getWindow().requestFeature(Window.FEATURE_NO_TITLE); return builder.create();&#125; 当点击播放录音的按钮之后，会调用 onPlay() 方法，然后根据 isPlaying（标识当前是否播放录音）的值，来调用不同的方法。 12345678910111213private void onPlay(boolean isPlaying)&#123; if (!isPlaying) &#123; //currently MediaPlayer is not playing audio if(mMediaPlayer == null) &#123; startPlaying(); //start from beginning &#125; else &#123; resumePlaying(); //resume the currently paused MediaPlayer &#125; &#125; else &#123; pausePlaying(); &#125;&#125; 我们最关心的，莫过于 startPlaying() 这个方法，这个方法便是来开启播放录音的，我们首先将外部传入的有关的录音信息，设置给 MediaPlayer，然后开始调用 mMediaPlayer.start() 进行录音的播放，然后调用 updateSeekbar() 实时更新进度条的内容。当 MediaPlayer 的内容播放完成后，调用 stopPlaying() 方法，关闭 mMediaPlayer。 12345678910111213141516171819202122232425262728293031private void startPlaying() &#123; mPlayButton.setImageResource(R.drawable.ic_media_pause); mMediaPlayer = new MediaPlayer(); try &#123; mMediaPlayer.setDataSource(item.getFilePath()); mMediaPlayer.prepare(); mSeekBar.setMax(mMediaPlayer.getDuration()); mMediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; mMediaPlayer.start(); &#125; &#125;); &#125; catch (IOException e) &#123; Log.e(LOG_TAG, "prepare() failed"); &#125; mMediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; stopPlaying(); &#125; &#125;); updateSeekBar(); //keep screen on while playing audio getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);&#125; 以上便是本文的全部内容，有关的代码我已经上传到 Github 上了，需要的 点击这里，喜欢的话，欢迎来波 star 和 fork。]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>录音</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[婚礼筹备]]></title>
    <url>%2Fposts%2F95cd02d2.html</url>
    <content type="text"><![CDATA[即将步入人生的第一件大事，在此记录下点滴事件：]]></content>
      <categories>
        <category>随笔记</category>
      </categories>
      <tags>
        <tag>随笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android Utils工具类方法大集合]]></title>
    <url>%2Fposts%2F1cc851d3.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460/** * 提供精确的小数位四舍五入处理，保留几位小数。 * * @param v 需要四舍五入的数字 * @param scale 小数点后保留几位 * @return 四舍五入后的结果 */ public static double round(double v, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException("The scale must be a positive integer or zero"); &#125; BigDecimal b = new BigDecimal(Double.toString(v)); BigDecimal one = new BigDecimal("1"); double bb = b.divide(one, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); return bb; &#125; /** * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 定精度，以后的数字四舍五入。 * * @param v1 被除数 * @param v2 除数 * @param scale 表示表示需要精确到小数点以后几位。 * @return 两个参数的商 */ public static double div(double v1, double v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException("The scale must be a positive integer or zero"); &#125; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125; /** * 提供精确的乘法运算。 * * @param v1 被乘数 * @param v2 乘数 * @return 两个参数的积 */ public static double mul(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); &#125; /** * 检查手机上是否安装了指定的软件 * * @param context * @param packageName ：应用包名 * @return */ public static boolean isAvilible(Context context, String packageName) &#123; // 获取packagemanager PackageManager packageManager = context.getPackageManager(); // 获取所有已安装程序的包信息 List&lt;PackageInfo&gt; packageInfos = packageManager.getInstalledPackages(0); // 用于存储所有已安装程序的包名 List&lt;String&gt; packageNames = new ArrayList&lt;String&gt;(); // 从pinfo中将包名字逐一取出，压入pName list中 if (packageInfos != null) &#123; for (int i = 0; i &lt; packageInfos.size(); i++) &#123; String packName = packageInfos.get(i).packageName; packageNames.add(packName); &#125; &#125; // 判断packageNames中是否有目标程序的包名，有TRUE，没有FALSE return packageNames.contains(packageName); &#125; /** * 根据一个网络连接(String)获取bitmap图像 * * @param imageUri * @return */ public static Bitmap getbitmap(String imageUri) &#123; Log.v("", "getbitmap:" + imageUri); // 显示网络上的图片 Bitmap bitmap = null; try &#123; URL myFileUrl = new URL(imageUri); HttpURLConnection conn = (HttpURLConnection) myFileUrl .openConnection(); conn.setDoInput(true); conn.connect(); InputStream is = conn.getInputStream(); bitmap = BitmapFactory.decodeStream(is); is.close(); Log.v("", "image download finished." + imageUri); &#125; catch (OutOfMemoryError e) &#123; e.printStackTrace(); bitmap = null; &#125; catch (IOException e) &#123; e.printStackTrace(); Log.v("", "getbitmap bmp fail---"); bitmap = null; &#125; return bitmap; &#125; /** * 将字符串转换成Bitmap类型 * * @param * @return */ public static Bitmap stringtoBitmap(String string) &#123; Bitmap bitmap = null; try &#123; byte[] bitmapArray; bitmapArray = Base64.decode(string, Base64.DEFAULT); bitmap = BitmapFactory.decodeByteArray(bitmapArray, 0, bitmapArray.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap; &#125; /** * 将Bitmap转换成字符串 * * @param bitmap * @return */ public static String bitmaptoString(Bitmap bitmap) &#123; String string = null; ByteArrayOutputStream bStream = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.PNG, 100, bStream); byte[] bytes = bStream.toByteArray(); string = Base64.encodeToString(bytes, Base64.DEFAULT); return string; &#125; /** * 返回当前程序版本名-V2 三段修改---ex 5.2---5.21 * support 7.8.8.1, 7.18.8.1, 17.18.8.1 modified by chenhong, 2018-5-25 */ public static String getAppVersionNameV2(Context context) &#123; String versionCode = ""; try &#123; PackageInfo pi = MyApp.getAppContext().getPackageManager().getPackageInfo(MyApp.getAppContext().getPackageName(), 0); versionCode = pi.versionName; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (!TextUtils.isEmpty(versionCode)) &#123; int firstDotIndex = versionCode.indexOf("."); if (firstDotIndex &gt; -1) &#123; String mainVersion = versionCode.substring(0, firstDotIndex); String subVersion = ""; if (versionCode.length() &gt; firstDotIndex + 1) &#123; subVersion = versionCode.substring(firstDotIndex + 1); subVersion = subVersion.replace(".", ""); &#125; versionCode = mainVersion + "." + subVersion; int length = versionCode.length(); int dotIndex = versionCode.indexOf("."); if (dotIndex == length - 1) &#123; versionCode += "00"; &#125; else if (dotIndex == length - 2) &#123; versionCode += "0"; &#125; &#125; else &#123; versionCode += ".00"; &#125; &#125; return versionCode; &#125; /** * 获取IP地址 * * @param context * @return */ public static String getIPAddress(Context context) &#123; NetworkInfo info = ((ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo(); if (info != null &amp;&amp; info.isConnected()) &#123; if (info.getType() == ConnectivityManager.TYPE_MOBILE) &#123;//当前使用2G/3G/4G网络 try &#123; //Enumeration&lt;NetworkInterface&gt; en=NetworkInterface.getNetworkInterfaces(); for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address) &#123; return inetAddress.getHostAddress(); &#125; &#125; &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; &#125; else if (info.getType() == ConnectivityManager.TYPE_WIFI) &#123;//当前使用无线网络 WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); String ipAddress = intIP2StringIP(wifiInfo.getIpAddress());//得到IPV4地址 return ipAddress; &#125; &#125; else &#123; //当前无网络连接,请在设置中打开网络 &#125; return null; &#125; /** * 将得到的int类型的IP转换为String类型 * * @param ip * @return */ public static String intIP2StringIP(int ip) &#123; return (ip &amp; 0xFF) + "." + ((ip &gt;&gt; 8) &amp; 0xFF) + "." + ((ip &gt;&gt; 16) &amp; 0xFF) + "." + (ip &gt;&gt; 24 &amp; 0xFF); &#125; /** * 获取屏幕高度 * * @param context * @return */ public static int getWindowHeight(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); int windowHeight = wm.getDefaultDisplay().getHeight(); return windowHeight; &#125; /** * 获取屏幕宽度 * * @param context * @return */ public static int getWindowWidth(Context context) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); int windowWidth = wm.getDefaultDisplay().getWidth(); return windowWidth; &#125; /** * json字符串转map * * @param jsonString * @return */ public static Map transStringToMap(String jsonString) &#123; Gson gson = new Gson(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map = gson.fromJson(jsonString, map.getClass()); return map; &#125; /** * 计算两个时间相隔多少天 * * @return */ public static String getDayNumberStr(String nowDate, String createDate) &#123; String str = ""; int strDay = 0; DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); try &#123; Date d1 = df.parse(nowDate); Date d2 = df.parse(createDate); long diff = d1.getTime() - d2.getTime();//这样得到的差值是微秒级别 long days = diff / (1000 * 60 * 60 * 24); long hours = (diff - days * (1000 * 60 * 60 * 24)) / (1000 * 60 * 60); long minutes = (diff - days * (1000 * 60 * 60 * 24) - hours * (1000 * 60 * 60)) / (1000 * 60);// System.out.println("" + days + "天" + hours + "小时" + minutes + "分"); str = days + ""; strDay = Integer.parseInt(str) + 1; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return strDay + ""; &#125; /** * 获得当天0点时间 */ public static int getTimesmorning() &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.HOUR_OF_DAY, 0); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.MILLISECOND, 0); return (int) (cal.getTimeInMillis() / 1000); &#125; /** * 获得当天24点时间 */ public static int getTimesnight() &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.HOUR_OF_DAY, 24); cal.set(Calendar.SECOND, 0); cal.set(Calendar.MINUTE, 0); cal.set(Calendar.MILLISECOND, 0); return (int) (cal.getTimeInMillis() / 1000); &#125; /** * 获得当天时间 */ public static String getTodayDate() &#123; SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");//设置日期格式 String date = df.format(new Date());// new Date()为获取当前系统时间 return date; &#125; /** * 判断当前时间是否在时间date之前 date1 7点 date2 8点 * 时间格式 2005-4-21 16:16:34 "yyyy-MM-dd HH:mm:ss" * * @param date * @return * @throws ParseException */ public static boolean isDateBefore(String date) throws ParseException &#123; Date date1 = new Date();//当前时间 DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return date1.before(df.parse(date)); &#125; /** * 判断当前时间是否在时间date之后 date1 8点 date2 5点 * * @param date * @return * @throws ParseException */ public static boolean isDateAfter(String date) throws ParseException &#123; Date date1 = new Date();//当前时间 DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return (df.parse(date)).before(date1); &#125; /** * 大小写转换 * * @param UpperCasestr * @return * @throws Exception */ public static String toUpperCase(String UpperCasestr) throws Exception &#123; return UpperCasestr.toUpperCase().toString(); &#125; /** * 去除字符串空格 * * @return */ public static String removeAllSpace(String str) &#123; String tmpstr = str.replace(" ", ""); return tmpstr; &#125; /** * 获取当前网络类型 * * @return */ public static String getNetworkTypeAll() &#123; String strNetworkType = ""; ConnectivityManager cm = (ConnectivityManager) MyApp.mContext.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = cm.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isConnected()) &#123; if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI) &#123; strNetworkType = "WIFI"; &#125; else if (networkInfo.getType() == ConnectivityManager.TYPE_MOBILE) &#123; String _strSubTypeName = networkInfo.getSubtypeName(); // TD-SCDMA networkType is 17 int networkType = networkInfo.getSubtype(); switch (networkType) &#123; case TelephonyManager.NETWORK_TYPE_GPRS: case TelephonyManager.NETWORK_TYPE_EDGE: case TelephonyManager.NETWORK_TYPE_CDMA: case TelephonyManager.NETWORK_TYPE_1xRTT: case TelephonyManager.NETWORK_TYPE_IDEN: //api&lt;8 : replace by 11 strNetworkType = "2G"; break; case TelephonyManager.NETWORK_TYPE_UMTS: case TelephonyManager.NETWORK_TYPE_EVDO_0: case TelephonyManager.NETWORK_TYPE_EVDO_A: case TelephonyManager.NETWORK_TYPE_HSDPA: case TelephonyManager.NETWORK_TYPE_HSUPA: case TelephonyManager.NETWORK_TYPE_HSPA: case TelephonyManager.NETWORK_TYPE_EVDO_B: //api&lt;9 : replace by 14 case TelephonyManager.NETWORK_TYPE_EHRPD: //api&lt;11 : replace by 12 case TelephonyManager.NETWORK_TYPE_HSPAP: //api&lt;13 : replace by 15 strNetworkType = "3G"; break; case TelephonyManager.NETWORK_TYPE_LTE: //api&lt;11 : replace by 13 strNetworkType = "4G"; break; default: if (_strSubTypeName.equalsIgnoreCase("TD-SCDMA") || _strSubTypeName.equalsIgnoreCase("WCDMA") || _strSubTypeName.equalsIgnoreCase("CDMA2000")) &#123; strNetworkType = "3G"; &#125; else &#123; strNetworkType = _strSubTypeName; &#125; break; &#125; &#125; &#125; return strNetworkType; &#125; /** * 获取sim卡运营商信息 */ public static String getSimOperator() &#123; String operator = ""; try &#123; TelephonyManager telManager = (TelephonyManager) MyApp.mContext.getSystemService(Context.TELEPHONY_SERVICE); operator = telManager.getSimOperator(); if (operator != null) &#123; if (operator.equals("46000") || operator.equals("46002") || operator.equals("46007")) &#123; operator = "中国移动"; &#125; else if (operator.equals("46001")) &#123; operator = "中国联通"; &#125; else if (operator.equals("46003")) &#123; operator = "中国电信"; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return operator; &#125; return operator; &#125; /** * 强制隐藏输入法键盘 * * @param context Context * @param view EditText */ public void hideInput(Context context, View view) &#123; InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), 0); &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android get请求和post请求区别]]></title>
    <url>%2Fposts%2Fcec09649.html</url>
    <content type="text"><![CDATA[Get请求与Post请求的区别Get是向服务器发索取数据的一种请求 Get是获取信息，而不是修改信息，类似数据库查询功能一样，数据不会被修改 Get请求的参数会跟在url后进行传递，请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&amp;相连,％XX中的XX为该符号以16进制表示的ASCII，如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。 Get传输的数据有大小限制，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了，不同的浏览器对URL的长度的限制是不同的。 GET请求的数据会被浏览器缓存起来，用户名和密码将明文出现在URL上，其他人可以查到历史浏览记录，数据不太安全。在服务器端，用Request.QueryString来获取Get方式提交来的数据 Post是向服务器提交数据的一种请求 Post请求则作为http消息的实际内容发送给web服务器，数据放置在HTML Header内提交，Post没有限制提交的数据。Post比Get安全，当数据是中文或者不敏感的数据，则用get，因为使用get，参数会显示在地址，对于敏感数据和不是中文字符的数据，则用post POST表示可能修改变服务器上的资源的请求，在服务器端，用Post方式提交的数据只能用Request.Form来获取]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 切换账户]]></title>
    <url>%2Fposts%2F7f469116.html</url>
    <content type="text"><![CDATA[问题 提交代码，但github上的绿格子没有变绿 新老账户切换 如果你不知道现在本地Git用的帐号是什么，你可以输入 Step 1 查看用户名1git config user.name Step 2 查看用户邮箱1git config user.email Step 3 修改用户名和邮箱的命令12git config --global user.name "Your_username"git config --global user.email "Your_email" 注意user.name，user.email 后面千万记得加空格，否则你就是提交了，Git也不会提醒你配置出错]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Webview里设置Cookie]]></title>
    <url>%2Fposts%2F3defa4a1.html</url>
    <content type="text"><![CDATA[Android中WebView加载网页，有时候需要通过cookie想网页传递信息，这时候这样操作。 Step 1 设置接收cookie123CookieManager.setAcceptFileSchemeCookies(true);CookieManager.getInstance().setAcceptCookie(true);CookieManager.setAcceptFileSchemeCookies(true); Step 2 设置cookie的值，通过setcookie方法123List&lt;String&gt; cookies = new ArrayList&lt;&gt;();cookies.add("app_key=" + App.getAppKey());cookies.add("os=" + "Android" + Build.VERSION.SDK_INT); Step 3 通过sync方法，将cookie同步12345678910111213141516171819if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context);&#125;CookieManager cookieManager = CookieManager.getInstance();cookieManager.setAcceptCookie(true);if (cookies != null) &#123; for (String cookie : cookies) &#123; cookieManager.setCookie(url, cookie); &#125;&#125;String s = "Domain=.***.com";String s1 = "Path=/";cookieManager.setCookie(url, s);cookieManager.setCookie(url, s1);if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123; CookieManager.getInstance().flush();&#125; else &#123; CookieSyncManager.getInstance().sync();&#125; &quot;;Domain=.xxxx.xxx.com&quot;+//作用域（在哪个域名下cookie起作用）&quot;;Path=/&quot;;//Domain这个作用域下的哪个文件夹，“/”代表所有文件夹 注意在调用设置Cookie之后不能再设置这类属性，否则设置Cookie无效。 12webView.getSettings().setBuiltInZoomControls(true); webView.getSettings().setJavaScriptEnabled(true); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class WebviewUtil &#123; public static void setWebCookie(Context context) &#123; CookieManager.setAcceptFileSchemeCookies(true); CookieManager.getInstance().setAcceptCookie(true); CookieManager.setAcceptFileSchemeCookies(true); setCookie(context); &#125; private static void setCookie(Context context) &#123; List&lt;String&gt; cookies = new ArrayList&lt;&gt;(); cookies.add("app_key=" + App.getAppKey()); cookies.add("plat=" + "2"); cookies.add("os=" + "Android" + Build.VERSION.SDK_INT); cookies.add("channel=" + AndroidUtil.getChannel()); cookies.add("cver=" + String.valueOf(App.getVersionCode())); cookies.add("ctype=" + 2); cookies.add("cspec=" + ""); if (AccountManager.hasLogin()) &#123; cookies.add("user_id=" + getUserId()); cookies.add("gz_id=" + getUserId()); &#125; syncCookie(context, ".7gz.com/", cookies); &#125; private static void syncCookie(Context context, String url, List&lt;String&gt; cookies) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123; CookieSyncManager.createInstance(context); &#125; CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); if (cookies != null) &#123; for (String cookie : cookies) &#123; cookieManager.setCookie(url, cookie); &#125; &#125; String s = "Domain=.7gz.com"; String s1 = "Path=/"; cookieManager.setCookie(url, s); cookieManager.setCookie(url, s1); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP_MR1) &#123; CookieManager.getInstance().flush(); &#125; else &#123; CookieSyncManager.getInstance().sync(); &#125; &#125; private static String getUserId() &#123; return AccountManager.getInstance().getAccount().id; &#125; //清空所有Cookie public static void removeAllCookie(Context context) &#123; CookieSyncManager.createInstance(context); //Create a singleton CookieSyncManager within a context CookieManager cookieManager = CookieManager.getInstance(); // the singleton CookieManager instance cookieManager.removeAllCookie();// Removes all cookies. CookieSyncManager.getInstance().sync(); // forces sync manager to sync now &#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Webview</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 圆角圆形ImageView]]></title>
    <url>%2Fposts%2F494f41c5.html</url>
    <content type="text"><![CDATA[效果预览 特点 基于AppCompatImageView扩展 支持圆角、圆形显示 可绘制边框，圆形时可绘制内外两层边框 支持边框不覆盖图片 可绘制遮罩 …… 支持的属性、方法 属性名 含义 默认值 对应方法 is_circle 是否显示为圆形（默认为矩形） false isCircle() corner_top_left_radius 左上角圆角半径 0dp setCornerTopLeftRadius() corner_top_right_radius 右上角圆角半径 0dp setCornerTopRightRadius() corner_bottom_left_radius 左下角圆角半径 0dp setCornerBottomLeftRadius() corner_bottom_right_radius 右下角圆角半径 0dp setCornerBottomRightRadius() corner_radius 统一设置四个角的圆角半径 0dp setCornerRadius() border_width 边框宽度 0dp setBorderWidth() border_color 边框颜色 #ffffff setBorderColor() inner_border_width 相当于内层边框（is_circle为true时支持） 0dp setInnerBorderWidth() inner_border_color 内边框颜色 #ffffff setInnerBorderColor() is_cover_src border、inner_border是否覆盖图片内容 false isCoverSrc() mask_color 图片上绘制的遮罩颜色 不设置颜色则不绘制 setMaskColor() 基本用法Step 1. 添加JitPack仓库 在项目根目录下的 build.gradle 中添加仓库: 123456allprojects &#123; repositories &#123; ... maven &#123; url "https://jitpack.io" &#125; &#125;&#125; Step 2. 添加项目依赖 123dependencies &#123; implementation 'com.github.zhangmiaocc:CircularImageView:1.0.0'&#125; **Step 3. 在布局文件中添加 CornerLabelView 1234567891011&lt;com.zm.library.CircularImageView android:layout_width="100dp" android:layout_height="100dp" android:src="@drawable/rabbit" app:border_color="#008B45" app:border_width="2dp" app:corner_radius="20dp" app:inner_border_color="#FF7F24" app:inner_border_width="4dp" app:is_circle="true" /&gt; 源码：CircularImageView]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>CircleImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AnimationDrawable使用简介]]></title>
    <url>%2Fposts%2Fd6df4d7b.html</url>
    <content type="text"><![CDATA[Drawable animation 可以加载 Drawable 资源实现帧动画。AnimationDrawable 是实现 Drawable animations 的基本类。推荐用 XML 文件的方法实现 Drawable 动画，不推荐在代码中实现。这种 XML 文件存放在工程中 res/drawable/目录下。XML 文件的指令(即属性)为动画播放的顺序和时间间隔。 ​ 在 XML 文件中元素为根节点，节点定义了每一帧，表示一个 drawable 资源的帧和帧间隔。下面是一个 XML 文件的实例: 1234567891011121314&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/loading1" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading2" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading3" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading4" android:duration="100" /&gt; &lt;item android:drawable="@drawable/loading5" android:duration="100" /&gt;&lt;/animation-list&gt; 设置Android:oneshot 属性为 true,表示此次动画只执行一次，最后停留在最后一帧。设置为 false 则动画循环播放。文件可以添加为 Image 背景，触发的时候播放。 下面简单通过一个例子，来给 ImageView 设置次动画效果，具体实现方法为 通过 View. setBackgroundResource(resID). animation.start(). 12345private AnimationDrawable animationDrawable; img = (ImageView) findViewById(R.id.img); img.setImageResource(R.drawable.anim_loading); animationDrawable = ((AnimationDrawable) img.getDrawable()); animationDrawable.start(); Demo 地址：https://github.com/zhangmiaocc/AnimationDrawable Blog 地址：https://zhangmiao.space/]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android加载PDF文件的使用]]></title>
    <url>%2Fposts%2F44884a58.html</url>
    <content type="text"><![CDATA[Android PdfViewerAndroidPdfViewer 1.x可在AndroidPdfViewerV1 repo上获得，可以独立开发。版本1.x使用不同的引擎在画布上绘制文档，因此如果您不喜欢2.x版本，请尝试1.x. 图书馆在Android上显示的PDF文档，用animations，gestures，zoom和double tap支持。它基于PdfiumAndroid来解码PDF文件。适用于API 11（Android 3.0）及更高版本。在Apache License 2.0下获得许可。 3.1.0-beta.1有什么新功能？ 合并拉取请求＃557用于捕捉页面（逐页滚动） 合并拉出请求＃618用于夜间模式 合并拉取请求＃566 OnLongTapListener 将PdfiumAndroid更新为1.9.0，而c++_shared不是使用gnustl_static 更新Gradle插件 将编译SDK和支持库更新到26 将最低SDK更改为14 3.0 API的变化 换成Contants.PRELOAD_COUNT了PRELOAD_OFFSET 删除PDFView#fitToWidth()（没有参数的变体） 删除Configurator#invalidPageColor(int)方法，因为无法呈现无效页面 从OnRenderListener#onInitiallyRendered(int)方法中删除了页面大小参数，因为文档可能具有不同的页面大小 删除PDFView#setSwipeVertical()方法 安装添加到build.gradle： compile &#39;com.github.barteksc:android-pdf-viewer:3.1.0-beta.1&#39; 或者如果你想使用更稳定的版本： compile &#39;com.github.barteksc:android-pdf-viewer:2.8.2&#39; 库在jcenter存储库中可用，可能它很快就会在Maven Central中。 ProGuard的如果您使用的是ProGuard，请将以下规则添加到proguard配置文件中： 1-keep class com.shockwave.** 在布局中包含PDFView1234&lt;com.github.barteksc.pdfviewer.PDFView android:id=&quot;@+id/pdfView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 加载PDF文件所有可用选项都带有默认值： 123456789101112131415161718192021222324252627282930313233343536373839404142pdfView.fromUri(Uri)orpdfView.fromFile(File)orpdfView.fromBytes(byte[])orpdfView.fromStream(InputStream) // stream is written to bytearray - native code cannot use Java StreamsorpdfView.fromSource(DocumentSource)orpdfView.fromAsset(String) .pages(0, 2, 1, 3, 3, 3) // all pages are displayed by default .enableSwipe(true) // allows to block changing pages using swipe .swipeHorizontal(false) .enableDoubletap(true) .defaultPage(0) // allows to draw something on the current page, usually visible in the middle of the screen .onDraw(onDrawListener) // allows to draw something on all pages, separately for every page. Called only for visible pages .onDrawAll(onDrawListener) .onLoad(onLoadCompleteListener) // called after document is loaded and starts to be rendered .onPageChange(onPageChangeListener) .onPageScroll(onPageScrollListener) .onError(onErrorListener) .onPageError(onPageErrorListener) .onRender(onRenderListener) // called after document is rendered for the first time // called on single tap, return true if handled, false to toggle scroll handle visibility .onTap(onTapListener) .onLongPress(onLongPressListener) .enableAnnotationRendering(false) // render annotations (such as comments, colors or forms) .password(null) .scrollHandle(null) .enableAntialiasing(true) // improve rendering a little bit on low-res screens // spacing between pages in dp. To define spacing color, set view background .spacing(0) .autoSpacing(false) // add dynamic spacing to fit each page on its own on the screen .linkHandler(DefaultLinkHandler) .pageFitPolicy(FitPolicy.WIDTH) .pageSnap(true) // snap pages to screen boundaries .pageFling(false) // make a fling change only a single page like ViewPager .nightMode(false) // toggle night mode .load(); 注意pages 是可选的，它允许您根据需要过滤和排序PDF页面 滚动手柄Scroll handle是从1.x分支替换ScrollBar。 从版本2.1.0将PDFView放在RelativeLayout中以使用ScrollHandle不是必需的，您可以使用任何布局。 要使用滚动手柄，只需使用方法注册它Configurator#scrollHandle()。此方法接受ScrollHandle接口的实现。 AndroidPdfViewer附带默认实现，您可以使用它 .scrollHandle(new DefaultScrollHandle(this))。 DefaultScrollHandle位于右侧（垂直滚动时）或底部（水平滚动时）。通过使用带有第二个参数（new DefaultScrollHandle(this, true)）的构造函数，可以将句柄放在左侧或顶部。 您还可以创建自定义滚动句柄，只需实现ScrollHandle界面。所有方法都记录为接口源上的Javadoc注释。 文件来源2.3.0版引入了文档源，它们只是PDF文档的提供者。每个提供程序都实现DocumentSource接口。预定义的提供程序可以在com.github.barteksc.pdfviewer.source包中找到，可以用作创建自定义提供程序的示例。 预定义的提供程序可以与速记方法一起使用： 12345pdfView.fromUri(Uri)pdfView.fromFile(File)pdfView.fromBytes(byte[])pdfView.fromStream(InputStream)pdfView.fromAsset(String) 自定义提供程序可与pdfView.fromSource(DocumentSource)方法一起使用。 链接3.0.0版引入了对PDF文档中链接的支持。默认情况下，使用DefaultLinkHandler 并单击引用同一文档中的页面的链接会导致跳转到目标页面并单击以某个URI为目标的链接导致在默认应用程序中打开它。 您还可以创建自定义链接处理程序，只需实现LinkHandler接口并使用Configurator#linkHandler(LinkHandler)方法进行设置 。查看DefaultLinkHandler 源以实现自定义行为。 页面符合政策从版本3.0.0开始，库支持以3种模式将页面装入屏幕： 宽度 - 最宽页面的宽度等于屏幕宽度 高度 - 最高页面的高度等于屏幕高度 BOTH - 基于最宽和最高的页面，每个页面都缩放为在屏幕上完全可见 除了选定的策略之外，每个页面都会缩放到相对于其他页面的大小。 可以使用适合的策略进行设置Configurator#pageFitPolicy(FitPolicy)。默认策略是WIDTH。 其他选项位图质量默认情况下，生成的位图使用格式压缩RGB_565以减少内存消耗。ARGB_8888可以使用pdfView.useBestQuality(true)方法强制渲染。 双击缩放有三种缩放级别：分钟（默认1），中间（默认1.75）和最大（默认3）。在第一次双击时，视图缩放到中等水平，在第二个到最大水平，第三个返回到最低水平。如果您处于中级和最高级别之间，则双击会导致缩放到最大值，依此类推。 可以使用以下方法更改缩放级别： 123void setMinZoom(float zoom);void setMidZoom(float zoom);void setMaxZoom(float zoom); 可能的问题为什么导致apk太大了？Android PdfViewer依赖于PdfiumAndroid，它是许多架构的本机库集（大约16 MB）。Apk必须包含所有这些库，以便在市场上的每个设备上运行。幸运的是，Google Play允许我们上传多个apks，例如每个架构一个。有一篇关于自动将您的应用程序拆分为多个apks的文章，可在此处获得。最重要的部分是使用APK Splits改进多个APK创建和版本代码处理，但整篇文章值得一读。您只需要在您的应用程序中执行此操作，无需分支PdfiumAndroid等。 为什么我无法从URL打开PDF？下载文件是一个长时间运行的过程，必须知道Activity生命周期，必须支持一些配置，数据清理和缓存，因此创建这样的模块可能最终会成为新的库。 如何在配置更改后显示上次打开的页面？您必须存储当前页码然后进行设置pdfView.defaultPage(page)，请参阅示例应用程序 如何将文档放入屏幕宽度（例如，方向更改）？FitPolicy.WIDTH如果要在具有不同页面大小的文档中放置所需页面，请使用策略或添加以下代码段： 123456Configurator.onRender(new OnRenderListener() &#123; @Override public void onInitiallyRendered(int pages, float pageWidth, float pageHeight) &#123; pdfView.fitToWidth(pageIndex); &#125;&#125;); 如何像ViewPager一样滚动浏览单个页面？您可以使用以下设置的组合来获得类似于ViewPager的滚动和拖动行为： 1234.swipeHorizontal(true).pageSnap(true).autoSpacing(true).pageFling(true) Demo地址：https://github.com/zhangmiaocc/AndroidPDFView 参考：https://github.com/barteksc/AndroidPdfViewer]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android日志框架Logger的详细使用（目前最新版2.1.1）]]></title>
    <url>%2Fposts%2Fe28061de.html</url>
    <content type="text"><![CDATA[前言在开发过程中，log日志是每个人多会用上的。平时在开发大项目的时候，几乎每个类多需要加log，然而在发布之前，要求全部删除，真是累。因为系统log暂时没有统一管理的方法。还有就是，特别是在调试的时候，对于线程并发或者子线程的调试，还是加log调试比较精确，用debug工具调试经常和实际不符合。那么，如果使用系统log，调试完又得找出来删除，累++。 作为程序猿，这种笨方法肯定是会鄙视的。对于这种需求，我们自己封装一个简单的工具包。当然这里介绍的是，github上很多人用log框架：logger。 相信很多人多用过，这里给还没有尝试过的人简单介绍下，使用也超级简单。 logger作为调试框架，可以支持多种格式： 线程的信息 类、方法的信息 格式化将 json、xml 输出 支持字符串格式参数 各种集合输出，list、map、array、set等，（只支持debug输出） 支持从日志跳转到源码 …… 如下图（引用原作者）： 可以看出，和系统对比，它最大的亮点是优雅的输出log信息，当然同时提供很多其他信息，一目了然，更清晰！ 如果你每天被log折磨的生不如死，那么让logger来拯救你吧~ 作者：Orhan Obut github：https://github.com/orhanobut/logger 目前，将近7.5k个star让他位列调试框架第二名，屈居facebook的stetho之后,8.5k个star。但这2个调试工具应用场景不用，所以简单的调试，logger是最佳选择了。这里简单介绍下stetho，它是一款提供在Chrome开发者工具上调试Android app的开源框架，可以在Chrome查看数据库，不用想以前那样把数据库导出，然后在用工具查看；配合网络框架可以直接打印查看网络请求的数据，而不需要一个一个添加打印出来，省去很多繁琐的事情。有兴趣的可以了解： 作者：FaceBook 官网地址： http://facebook.github.io/stetho/ github https://github.com/facebook/stetho 使用Logger使用框架，是比较简单的，如果可以看英文版，可以直接到https://github.com/orhanobut/logger了解。 logger目前的最新版本是2.1.1，网上也很多人使用1.15的版本，如果使用最新版，单独修改配置文件，是有报错的。因为，最新版在初始化这块和原来有了较大的改动。 主要是初始化、和控制Log打印这2方面。这里介绍2.11的版本使用，所以想升级的也可以往下看看哦。 3步，只要3步，你就学会使用Logger，请： 1.导入依赖 1compile 'com.orhanobut:logger:2.1.1' 1Logger.addLogAdapter(new AndroidLogAdapter()); 注：如果在Application中初始化，记得修改 AndroidManifest.xml 中 application 标签属性，添加 android:name=”.MyApplication” ，不然不会打印。 3.使用 1Logger.d("hello"); 如图： 当然，如果还有追求，继续往下看看它的其他功能。 支持的数据类型普通类型12345public void testNormal()&#123; Logger.d("DEBUG日志"); Logger.i("INFO日志"); Logger.e("ERROR日志");&#125; Format类型123public void testFormat()&#123; Logger.d("hello %s, luck number is %d", "world", 5); &#125; 集合类型首先看看List： 1234List list = new ArrayList();list.add("hello");list.add("world");Logger.d(list); 1Log.d(TAG, list.toString()); 首先是调用： 123@Override public void d(Object object) &#123; log(DEBUG, null, Utils.toString(object)); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static String toString(Object object) &#123; if (object == null) &#123; return "null"; &#125; if (!object.getClass().isArray()) &#123; return object.toString(); &#125; if (object instanceof boolean[]) &#123; return Arrays.toString((boolean[]) object); &#125; if (object instanceof byte[]) &#123; return Arrays.toString((byte[]) object); &#125; if (object instanceof char[]) &#123; return Arrays.toString((char[]) object); &#125; if (object instanceof short[]) &#123; return Arrays.toString((short[]) object); &#125; if (object instanceof int[]) &#123; return Arrays.toString((int[]) object); &#125; if (object instanceof long[]) &#123; return Arrays.toString((long[]) object); &#125; if (object instanceof float[]) &#123; return Arrays.toString((float[]) object); &#125; if (object instanceof double[]) &#123; return Arrays.toString((double[]) object); &#125; if (object instanceof Object[]) &#123; return Arrays.deepToString((Object[]) object); &#125; return "Couldn't find a correct type for the object"; &#125; 这样就不需要我们自己调用toString()，直接可以打印了。 其他的数据结构也是一样的，看图就可以了： 123456789101112131415161718192021222324public void testCollections()&#123; /** * Map */ Map map = new HashMap(); map.put("map1","hello"); map.put("map2","world"); Logger.d(map); /** * Set */ Set set = new HashSet(); set.add("hello"); set.add("world"); Logger.d(set); /** * Array */ String [] strs = &#123;"hello", "world"&#125;; Logger.d(strs); &#125; *注：打印集合的时候，特别是数组时，前面不要添加其他字符，如：Logger.d(“数组集合”+strs);这样会把整体当做一个参数，导致判断错误，不能正常输出数组类型。其次是，作者提示，打印集合时，使用DEBUG等级。* JSON数据123456public void testJson()&#123; String jsonDate = "&#123;\"id\":859,\"channelnumber\":681,\"bilingual\":0,\"name\":\"beIN Sports 2 English 600K H265\",\n" +" \"language\":\"EN\",\n" +" \"videotype\":\"MPEG2\",\"audiotype\":\"MPEP1\",\"callsign\":\"beIN Sports 2 English 600K H265\",\"country\":\"cn\"&#125;;"; Logger.json(jsonDate); Log.d(TAG, jsonDate); &#125; XML数据1234567891011121314public void testXml() &#123; String xmlDate = "&lt;province id=\"01\" name=\"北京\"&gt; \n" + " &lt;city id=\"0101\" name=\"北京\"&gt; \n" + " &lt;county id=\"010101\" name=\"北京\" weatherCode=\"101010100\"/&gt; \n" + " &lt;county id=\"010102\" name=\"海淀\" weatherCode=\"101010200\"/&gt; \n" + " &lt;county id=\"010103\" name=\"朝阳\" weatherCode=\"101010300\"/&gt; \n" + " &lt;county id=\"010110\" name=\"石景山\" weatherCode=\"101011000\"/&gt; \n" + " &lt;/city&gt; \n" + " &lt;/province&gt; "; Logger.xml(xmlDate); Log.d(TAG, xmlDate); &#125; 修改默认配置最新版修改配置，和旧版也是有不同，如下： 12345678FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder() .showThreadInfo(false) //（可选）是否显示线程信息。 默认值为true .methodCount(2) // （可选）要显示的方法行数。 默认2 .methodOffset(7) // （可选）设置调用堆栈的函数偏移值，0的话则从打印该Log的函数开始输出堆栈信息，默认是0 .logStrategy(customLog) //（可选）更改要打印的日志策略。 默认LogCat .tag("MyTAG") //（可选）每个日志的全局标记。 默认PRETTY_LOGGER（如上图） .build();Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy)); 具体配置大家可以自行去实践下。一般默认就可以了，这里说下，修改全局的TAG，和局部的TAG。 1.修改全局的TAG，在初始化的application中修改，如： 1234FormatStrategy formatStrategy = PrettyFormatStrategy.newBuilder() .tag("MyTAG") .build();Logger.addLogAdapter(new AndroidLogAdapter(formatStrategy)); 2.修改局部的TAG，哪里打印就在哪里修改，只对当前打印有效，如： 1234public void testNormal()&#123; Logger.t("hello").d("DEBUG日志"); Logger.i("INFO日志"); &#125; *注：如果尝试用局部的方法，在application初始化时修改。当然，这是有效果的，但只能用一次，其他打印还是会用全局的，可自行测试。* 控制打印开关这个功能是最喜欢的了，当我们发布软件，或者太多的log影响性能，那么就可以关闭logger打印，在application初始化的地方： 1234567Logger.addLogAdapter(new AndroidLogAdapter() &#123; @Override public boolean isLoggable(int priority, String tag) &#123; return BuildConfig.DEBUG; &#125;&#125;); 通过适配器控制打印，只要覆盖isLoggable()方法，返回BuildConfig.DEBUG即可。这样子，log就不再打印出来了。 *注：返回值导入的包是：import com.orhanobut.logger.BuildConfig; 有时顺手导入：com.gotechcn.frameworks，那就没有效果。* 保存log到文件1Logger.addLogAdapter(new DiskLogAdapter()); 通过打印，找到保存的路径： /storage/emulated/0 但手机里面就是没有这个文件夹，不知道什么原因，真机和模拟机多没有，知道可以留言噢，感谢！ 工作流程原理图logg框架的整体流程如图（作者原图）： 其他对Log信息的设置与过滤： Filter：编辑默认或者自定义的标签，过滤标签以外的信息； Disable：设置user soft wraps，即设置换行 Setting：设置log头部的信息，比如时间、线程PID、包名、TAG等开关设置 好了，对于Logger框架的介绍就到这里了。有时会更新，记得使用时看看GitHub升级了没有，同时在使用是否和以前兼容。对于一些其他的方法，可以直接看源码，具体是干什么用的。]]></content>
      <categories>
        <category>Android</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Log</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lottie Android For Animation]]></title>
    <url>%2Fposts%2F1444979e.html</url>
    <content type="text"><![CDATA[Lottie是一个支持Android、iOS、React Native，并由 Adobe After Effects制作aep格式的动画，然后经由bodymovin插件转化渲染为json格式可被移动端本地识别解析的Airbnb开源库。Lottie实时呈现After Effects动画效果，让应用程序可以像使用静态图片一样轻松地使用动画。Lottie支持API 14及以上。 一、预览 二 、基本使用 在自己项目module的build.gradle文件中添加如下代码： 123dependencies &#123; compile 'com.airbnb.android:lottie:2.0.0-beta4'&#125; LottieAnimationView使用最简单的方法是: 1234567&lt;com.airbnb.lottie.LottieAnimationView android:id="@+id/animation_view" android:layout_width="wrap_content" android:layout_height="wrap_content" app:lottie_fileName="hello-world.json" app:lottie_loop="true" app:lottie_autoPlay="true" /&gt; 其中lottie_loop属性为是否重复无限期动画，当为true时，动画无限次数播放，为false时，播放一次。 或者把json资源放在app/src/main/assets下，也可以这样使用它: 1234LottieAnimationView animationView = (LottieAnimationView) findViewById(R.id.animation_view);animationView.setAnimation(&quot;hello-world.json&quot;);animationView.loop(true);animationView.playAnimation(); 该方法将加载文件并在后台解析动画，在完成后异步开始呈现。 如果您希望重用一个动画，例如在列表的每个项目中，或者从一个网络请求JSONObject中加载它: 123456789LottieAnimationView animationView = (LottieAnimationView) findViewById(R.id.animation_view);...Cancellable compositionCancellable = LottieComposition.Factory.fromJson(getResources(), jsonObject, (composition) -&gt; &#123; animationView.setComposition(composition); animationView.playAnimation();&#125;);// 取消异步加载// compositionCancellable.cancel(); 你也可以控制动画添加监听： 1234567891011121314151617181920animationView.addAnimatorUpdateListener((animation) -&gt; &#123; // Do something.&#125;);animationView.playAnimation();...if (animationView.isAnimating()) &#123; // Do something.&#125;...animationView.setProgress(0.5f);...// 自定义动画速度和时长ValueAnimator animator = ValueAnimator.ofFloat(0f, 1f) .setDuration(500);animator.addUpdateListener(animation -&gt; &#123; animationView.setProgress(animation.getAnimatedValue());&#125;);animator.start();...animationView.cancelAnimation(); 你可以给整个动画，一个特定的图层，或者一个图层的特定内容添加一个颜色过滤器。 1234567891011121314// 任何符合颜色过滤界面的类final PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.LIGHTEN);// 在整个视图中添加一个颜色过滤器animationView.addColorFilter(colorFilter);//在特定的图层中添加一个颜色滤镜animationView.addColorFilterToLayer("hello_layer", colorFilter);// 添加一个彩色过滤器特效“hello_layer”上的内容animationView.addColorFilterToContent("hello_layer", "hello", colorFilter);// 清除所有的颜色滤镜animationView.clearColorFilters(); 注意:颜色过滤器只适用于图层，如图像层和实层，以及包含填充、描边或组内容的内容。 在引擎盖下,LottieAnimationView使用LottieDrawable呈现其动画。如果需要，您可以直接使用可绘制的表单: 1234LottieDrawable drawable = new LottieDrawable();LottieComposition.Factory.fromAssetFileName(getContext(), "hello-world.json", (composition) -&gt; &#123; drawable.setComposition(composition);&#125;); 如果你的动画会经常重用,LottieAnimationView内置了一个可选的缓存策略。使用LottieAnimationView .setAnimation(String,CacheStrategy)。CacheStrategy可以Strong, Weak, 或者None。LottieAnimationView对加载和解析的动画持有强或弱的参考。弱或强表示缓存中组合的GC参考强度。 三、Image 支持如果您的动画是从assets中加载的，并且您的图像文件位于assets 的子目录中，那么您可以对图像进行动画。你可以用LottieAnimationView或者LottieDrawable对象调用setImageAssetsFolder(String)方法，明确assets相对文件夹内的路径,确保图像bodymovin出口与他们的名字不变,文件夹应该img_ 开头。如果直接使用LottieDrawable,当你完成时您必须调用recycleBitmaps。 如果你需要提供你自己的位图，如果你从网络或其他地方下载，你可以提供一个委托来做这个: 12345animationView.setImageAssetDelegate(new ImageAssetDelegate() &#123; @Override public Bitmap fetchBitmap(LottieImageAsset asset) &#123; getBitmap(asset); &#125; &#125;); 四、性能和内存如果该组合没有遮罩或mattes，那么性能和内存开销应该相当不错。没有创建任何位图，大多数操作都是简单的画布绘制操作。如果这个组合有遮罩或mattes，就会使用屏幕外的缓冲区，并且会有一个性能打击。 如果在你的动画列表中使用,推荐使用CacheStrategy，在调用LottieAnimationView.setAnimation(String, CacheStrategy)的时候，所以动画不需要每次都反序列化。 五、Lottie官方Demo下载https://fir.im/lottiedemo 六、参考资料http://airbnb.design/lottie/ http://www.lottiefiles.com/ https://github.com/airbnb/lottie-android http://www.adobe.com/cn/products/aftereffects.html https://github.com/bodymovin/bodymovin https://github.com/airbnb/lottie-react-native https://github.com/airbnb/lottie-ios https://github.com/airbnb]]></content>
      <categories>
        <category>Android</category>
        <category>Animation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android App的设计架构：MVC,MVP,MVVM与架构经验谈]]></title>
    <url>%2Fposts%2Faf73114b.html</url>
    <content type="text"><![CDATA[和MVC框架模式一样，Model模型处理数据代码不变在Android的App开发中，很多人经常会头疼于App的架构如何设计： 我的App需要应用这些设计架构吗？ MVC,MVP等架构讲的是什么？区别是什么？ 本文就来带你分析一下这几个架构的特性，优缺点，以及App架构设计中应该注意的问题。 1.架构设计的目的通过设计使程序模块化，做到模块内部的高聚合和模块之间的低耦合。这样做的好处是使得程序在开发的过程中，开发人员只需要专注于一点，提高程序开发的效率，并且更容易进行后续的测试以及定位问题。但设计不能违背目的，对于不同量级的工程，具体架构的实现方式必然是不同的，切忌犯为了设计而设计，为了架构而架构的毛病。 举个简单的例子： 一个Android App如果只有3个Java文件，那只需要做点模块和层次的划分就可以，引入框架或者架构反而提高了工作量，降低了生产力； 但如果当前开发的App最终代码量在10W行以上，本地需要进行复杂操作，同时也需要考虑到与其余的Android开发者以及后台开发人员之间的同步配合，那就需要在架构上进行一些思考！ 2.MVC设计架构 MVC简介MVC全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。 Android中的MVCAndroid中界面部分也采用了当前比较流行的MVC框架，在Android中： 视图层(View) 一般采用XML文件进行界面的描述，这些XML可以理解为AndroidApp的View。使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。 控制层(Controller) Android的控制层的重任通常落在了众多的Activity的肩上。这句话也就暗含了不要在Activity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Actiivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 模型层(Model) 我们针对业务模型，建立的数据结构和相关的类，就可以理解为AndroidApp的Model，Model是与View无关，而与业务相关的（感谢@Xander的讲解）。对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。就是应用程序中二进制的数据。 MVC代码实例我们来看看MVC在Android开发中是怎么应用的吧！ 先上界面图 Controller控制器&amp;View 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends ActionBarActivity implements OnWeatherListener, View.OnClickListener &#123; private WeatherModel weatherModel; private EditText cityNOInput; private TextView city; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); weatherModel = new WeatherModelImpl(); initView(); &#125; //初始化View private void initView() &#123; cityNOInput = findView(R.id.et_city_no); city = findView(R.id.tv_city); ... findView(R.id.btn_go).setOnClickListener(this); &#125; //显示结果 public void displayResult(Weather weather) &#123; WeatherInfo weatherInfo = weather.getWeatherinfo(); city.setText(weatherInfo.getCity()); ... &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_go: weatherModel.getWeather(cityNOInput.getText().toString().trim(), this); break; &#125; &#125; @Override public void onSuccess(Weather weather) &#123; displayResult(weather); &#125; @Override public void onError() &#123; Toast.makeText(this, 获取天气信息失败, Toast.LENGTH_SHORT).show(); &#125; private T findView(int id) &#123; return (T) findViewById(id); &#125;&#125; 从上面代码可以看到，Activity持有了WeatherModel模型的对象，当用户有点击Button交互的时候，Activity作为Controller控制层读取View视图层EditTextView的数据，然后向Model模型发起数据请求，也就是调用WeatherModel对象的方法 getWeather（）方法。当Model模型处理数据结束后，通过接口OnWeatherListener通知View视图层数据处理完毕，View视图层该更新界面UI了。然后View视图层调用displayResult（）方法更新UI。至此，整个MVC框架流程就在Activity中体现出来了。 Model模型 来看看WeatherModelImpl代码实现 123456789101112131415161718192021222324252627282930public interface WeatherModel &#123; void getWeather(String cityNumber, OnWeatherListener listener);&#125;................public class WeatherModelImpl implements WeatherModel &#123; /*这部分代码范例有问题，网络访问不应该在Model中，应该把网络访问换成从数据库读取*/ @Override public void getWeather(String cityNumber, final OnWeatherListener listener) &#123; /*数据层操作*/ VolleyRequest.newInstance().newGsonRequest(http://www.weather.com.cn/data/sk/ + cityNumber + .html, Weather.class, new Response.Listener&lt;weather&gt;() &#123; @Override public void onResponse(Weather weather) &#123; if (weather != null) &#123; listener.onSuccess(weather); &#125; else &#123; listener.onError(); &#125; &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; listener.onError(); &#125; &#125;); &#125;&#125; 以上代码看出，这里设计了一个WeatherModel模型接口，然后实现了接口WeatherModelImpl类。controller控制器activity调用WeatherModelImpl类中的方法发起网络请求，然后通过实现OnWeatherListener接口来获得网络请求的结果通知View视图层更新UI 。至此，Activity就将View视图显示和Model模型数据处理隔离开了。activity担当contronller完成了model和view之间的协调作用。 至于这里为什么不直接设计成类里面的一个getWeather（）方法直接请求网络数据？你考虑下这种情况：现在代码中的网络请求是使用Volley框架来实现的，如果哪天老板非要你使用Afinal框架实现网络请求，你怎么解决问题？难道是修改 getWeather（）方法的实现？ no no no，这样修改不仅破坏了以前的代码，而且还不利于维护， 考虑到以后代码的扩展和维护性，我们选择设计接口的方式来解决着一个问题，我们实现另外一个WeatherModelWithAfinalImpl类，继承自WeatherModel，重写里面的方法，这样不仅保留了以前的WeatherModelImpl类请求网络方式，还增加了WeatherModelWithAfinalImpl类的请求方式。Activity调用代码无需要任何修改。 3.MVP设计架构在App开发过程中，经常出现的问题就是某一部分的代码量过大，虽然做了模块划分和接口隔离，但也很难完全避免。从实践中看到，这更多的出现在UI部分，也就是Activity里。想象一下，一个2000+行以上基本不带注释的Activity，我的第一反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负与用户之间的操作交互，界面的展示，不是单纯的Controller或View。而且现在大部分的Activity还对整个App起到类似IOS中的【ViewController】的作用，这又带入了大量的逻辑代码，造成Activity的臃肿。为了解决这个问题，让我们引入MVP框架。 MVC的缺点在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户 界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。 什么是MVP?MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。 MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）： View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity) Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合) Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。 *View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试 Tips：*View interface的必要性 回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用 户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。 MVC → MVP当我们将Activity复杂的逻辑处理移至另外的一个类（Presenter）中时，Activity其实就是MVP模式中的View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由 Presenter处理）。 MVP的Presenter是框架的控制者，承担了大量的逻辑操作，而MVC的Controller更多时候承担一种转发的作用。因此在App中引入MVP的原因，是为了将此前在Activty中包含的大量逻辑操作放到控制层中，避免Activity的臃肿。 两种模式的主要区别： （最主要区别）View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。 因此我们可以发现MVP的优点如下： 1、模型与视图完全分离，我们可以修改视图而不影响模型； 2、可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部； 3、我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁； 4、如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。 具体到Android App中，一般可以将App根据程序的结构进行纵向划分，根据MVP可以将App分别为模型层(M)，UI层(V)和逻辑层(P)。 UI层一般包括Activity，Fragment，Adapter等直接和UI相关的类，UI层的Activity在启动之后实例化相应的Presenter，App的控制权后移，由UI转移到Presenter，两者之间的通信通过BroadCast、Handler或者接口完成，只传递事件和结果。 举个简单的例子，UI层通知逻辑层（Presenter）用户点击了一个Button，逻辑层（Presenter）自己决定应该用什么行为进行响应，该找哪个模型（Model）去做这件事，最后逻辑层（Presenter）将完成的结果更新到UI层。 MVP的变种：Passive ViewMVP的变种有很多，其中使用最广泛的是Passive View模式，即被动视图。在这种模式下，View和Model之间不能直接交互，View通过Presenter与Model打交道。Presenter接受View的UI请求，完成简单的UI处理逻辑，并调用Model进行业务处理，并调用View将相应的结果反映出来。View直接依赖Presenter，但是Presenter间接依赖View，它直接依赖的是View实现的接口。 相对于View的被动，那Presenter就是主动的一方。对于Presenter的主动，有如下的理解： Presenter是整个MVP体系的控制中心，而不是单纯的处理View请求的人； View仅仅是用户交互请求的汇报者，对于响应用户交互相关的逻辑和流程，View不参与决策，真正的决策者是Presenter； View向Presenter发送用户交互请求应该采用这样的口吻：“我现在将用户交互请求发送给你，你看着办，需要我的时候我会协助你”，不应该是这样：“我现在处理用户交互请求了，我知道该怎么办，但是我需要你的支持，因为实现业务逻辑的Model只信任你”； 对于绑定到View上的数据，不应该是View从Presenter上“拉”回来的，应该是Presenter主动“推”给View的； View尽可能不维护数据状态，因为其本身仅仅实现单纯的、独立的UI操作；Presenter才是整个体系的协调者，它根据处理用于交互的逻辑给View和Model安排工作。 MVP架构存在的问题与解决办法 加入模板方法（Template Method） 转移逻辑操作之后可能部分较为复杂的Activity内代码量还是不少，于是需要在分层的基础上再加入模板方法（Template Method）。 具体做法是在Activity内部分层。其中最顶层为BaseActivity，不做具体显示，而是提供一些基础样式，Dialog，ActionBar在内的内容，展现给用户的Activity继承BaseActivity，重写BaseActivity预留的方法。如有必要再进行二次继承，App中Activity之间的继承次数最多不超过3次。 Model内部分层 模型层（Model）中的整体代码量是最大的，一般由大量的Package组成，针对这部分需要做的就是在程序设计的过程中，做好模块的划分，进行接口隔离，在内部进行分层。 强化Presenter 强化Presenter的作用，将所有逻辑操作都放在Presenter内也容易造成Presenter内的代码量过大，对于这点，有一个方法是在UI层和Presenter之间设置中介者Mediator，将例如数据校验、组装在内的轻量级逻辑操作放在Mediator中；在Presenter和Model之间使用代理Proxy；通过上述两者分担一部分Presenter的逻辑操作，但整体框架的控制权还是在Presenter手中。Mediator和Proxy不是必须的，只在Presenter负担过大时才建议使用。 最终的架构如下图所示： MVP代码实例我们来看看MVP在Android开发中是怎么应用的吧！！ 我们用另一个例子来解释。 先来看包结构图 建立Bean 1234567891011121314public class UserBean &#123; private String mFirstName; private String mLastName; public UserBean(String firstName, String lastName) &#123; this. mFirstName = firstName; this. mLastName = lastName; &#125; public String getFirstName() &#123; return mFirstName; &#125; public String getLastName() &#123; return mLastName; &#125;&#125; 建立Model （处理业务逻辑，这里指数据读写），先写接口，后写实现 1234567891011public interface IUserModel &#123; void setID(int id); void setFirstName(String firstName); void setLastName(String lastName); int getID(); UserBean load(int id);// 通过id读取user信息,返回一个UserBean&#125; 实现不在这里写了 Presenter控制器 建立presenter（主导器，通过iView和iModel接口操作model和view），activity可以把所有逻辑给presenter处理，这样java逻辑就从手机的activity中分离出来。 123456789101112131415161718192021public class UserPresenter &#123; private IUserView mUserView; private IUserModel mUserModel; public UserPresenter(IUserView view) &#123; mUserView = view; mUserModel = new UserModel(); &#125; public void saveUser( int id, String firstName, String lastName) &#123; mUserModel.setID(id); mUserModel.setFirstName(firstName); mUserModel.setLastName(lastName); &#125; public void loadUser( int id) &#123; UserBean user = mUserModel.load(id); mUserView.setFirstName(user.getFirstName()); // 通过调用IUserView的方法来更新显示 mUserView.setLastName(user.getLastName()); &#125;&#125; View视图 建立view（更新ui中的view状态），这里列出需要操作当前view的方法，也是接口 1234567891011public interface IUserView &#123; int getID(); String getFristName(); String getLastName(); void setFirstName(String firstName); void setLastName(String lastName);&#125; activity中实现iview接口，在其中操作view，实例化一个presenter变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainActivity extends Activity implements OnClickListener,IUserView &#123; UserPresenter presenter; EditText id,first,last; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout. activity_main); findViewById(R.id. save).setOnClickListener( this); findViewById(R.id. load).setOnClickListener( this); id = (EditText) findViewById(R.id. id); first = (EditText) findViewById(R.id. first); last = (EditText) findViewById(R.id. last); presenter = new UserPresenter( this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id. save: presenter.saveUser(getID(), getFristName(), getLastName()); break; case R.id. load: presenter.loadUser(getID()); break; default: break; &#125; &#125; @Override public int getID() &#123; return new Integer( id.getText().toString()); &#125; @Override public String getFristName() &#123; return first.getText().toString(); &#125; @Override public String getLastName() &#123; return last.getText().toString(); &#125; @Override public void setFirstName(String firstName) &#123; first.setText(firstName); &#125; @Override public void setLastName(String lastName) &#123; last.setText(lastName); &#125;&#125; 因此，Activity及从MVC中的Controller中解放出来了，这会Activity主要做显示View的作用和用户交互。每个Activity可以根据自己显示View的不同实现View视图接口IUserView。 通过对比同一实例的MVC与MVP的代码，可以证实MVP模式的一些优点： 在MVP中，Activity的代码不臃肿； 在MVP中，Model(IUserModel的实现类)的改动不会影响Activity(View)，两者也互不干涉，而在MVC中会； 在MVP中，IUserView这个接口可以实现方便地对Presenter的测试； 在MVP中，UserPresenter可以用于多个视图，但是在MVC中的Activity就不行。 4.MVC、MVP与MVVM的关系首先介绍下MVVM。 MVVMMVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。 在比较之前，先从图上看看三者的异同。 刚开始理解这些概念的时候认为这几种模式虽然都是要将view和model解耦，但是非此即彼，没有关系，一个应用只会用一种模式。后来慢慢发现世界绝对不是只有黑白两面，中间最大的一块其实是灰色地带，同样，这几种模式的边界并非那么明显，可能你在自己的应用中都会用到。实际上也根本没必要去纠结自己到底用的是MVC、MVP还是MVVP，不管黑猫白猫，捉住老鼠就是好猫。 MVC-&gt;MVP-&gt;MVVM演进过程MVC -&gt; MVP -&gt; MVVM 这几个软件设计模式是一步步演化发展的，MVVM 是从 MVP 的进一步发展与规范，MVP 隔离了MVC中的 M 与 V 的直接联系后，靠 Presenter 来中转，所以使用 MVP 时 P 是直接调用 View 的接口来实现对视图的操作的，这个 View 接口的东西一般来说是 showData、showLoading等等。M 与 V已经隔离了，方便测试了，但代码还不够优雅简洁，所以 MVVM 就弥补了这些缺陷。在 MVVM 中就出现的 Data Binding 这个概念，意思就是 View 接口的 showData 这些实现方法可以不写了，通过 Binding 来实现。 同如果把这三者放在一起比较，先说一下三者的共同点，也就是Model和View： Model：数据对象，同时，提供本应用外部对应用程序数据的操作的接口，也可能在数据变化时发出变更通知。Model不依赖于View的实现，只要外部程序调用Model的接口就能够实现对数据的增删改查。 View：UI层，提供对最终用户的交互操作功能，包括UI展现代码及一些相关的界面逻辑代码。 异三者的差异在于如何粘合View和Model，实现用户的交互操作以及变更通知 Controller Controller接收View的操作事件，根据事件不同，或者调用Model的接口进行数据操作，或者进行View的跳转，从而也意味着一个Controller可以对应多个View。Controller对View的实现不太关心，只会被动地接收，Model的数据变更不通过Controller直接通知View，通常View采用观察者模式监听Model的变化。 Presenter Presenter与Controller一样，接收View的命令，对Model进行操作；与Controller不同的是Presenter会反作用于View，Model的变更通知首先被Presenter获得，然后Presenter再去更新View。一个Presenter只对应于一个View。根据Presenter和View对逻辑代码分担的程度不同，这种模式又有两种情况：Passive View和Supervisor Controller。 ViewModel 注意这里的“Model”指的是View的Model，跟MVVM中的一个Model不是一回事。所谓View的Model就是包含View的一些数据属性和操作的这么一个东东，这种模式的关键技术就是数据绑定（data binding），View的变化会直接影响ViewModel，ViewModel的变化或者内容也会直接体现在View上。这种模式实际上是框架替应用开发者做了一些工作，开发者只需要较少的代码就能实现比较复杂的交互。 一点心得MVP和MVVM完全隔离了Model和View，但是在有些情况下，数据从Model到ViewModel或者Presenter的拷贝开销很大，可能也会结合MVC的方式，Model直接通知View进行变更。在实际的应用中很有可能你已经在不知不觉中将几种模式融合在一起，但是为了代码的可扩展、可测试性，必须做到模块的解耦，不相关的代码不要放在一起。网上有一个故事讲，一个人在一家公司做一个新产品时，一名外包公司的新员工直接在View中做了数据库持久化操作，而且一个hibernate代码展开后发现竟然有几百行的SQL语句，搞得他们惊讶不已，一时成为笑谈。 个人理解，在广义地谈论MVC架构时，并非指本文中严格定义的MVC，而是指的MV*，也就是视图和模型的分离，只要一个框架提供了视图和模型分离的功能，我们就可以认为它是一个MVC框架。在开发深入之后，可以再体会用到的框架到底是MVC、MVP还是MVVM。 5. 基于AOP的框架设计AOP(Aspect-Oriented Programming, 面向切面编程)，诞生于上个世纪90年代，是对OOP(Object-Oriented Programming, 面向对象编程)的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（Cross-Cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。 5.1 AOP在Android中的使用AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。在Android App中，哪些是我们需要的横切关注点？个人认为主要包括以下几个方面：Http, SharedPreferences, Json, Xml, File, Device, System, Log, 格式转换等。Android App的需求差别很大，不同的需求横切关注点必然是不一样的。一般的App工程中应该有一个Util Package来存放相关的切面操作，在项目多了之后可以将其中使用较多的Util封装为一个Jar包供工程调用。 在使用MVP和AOP对App进行纵向和横向的切割之后，能够使得App整体的结构更清晰合理，避免局部的代码臃肿，方便开发、测试以及后续的维护。 6. 干货：AndroidApp架构的设计经验首先是作者最最喜欢的一句话，也是对创业公司特别适用的一句话，也是对不要过度设计的一种诠释： 先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了先实现，再重构吧。直接考虑代码不臃肿得话，不知道什么时候才能写好了（重要的事情说三遍) 6.1 整体架构代码和文档规范，根据需求进行模块划分，确定交互方式，形成接口文档，这些较为通用的内容不再细说。做Android App时，一般将App进行纵向和横向的划分。纵向的App由UI层，逻辑层和模型层构成，整体结构基于MVP思想(图片来自网络)。 UI层内部多用模板方法，以Activity为例一般有BaseActivity，提供包括一些基础样式，Dialog，ActionBar在内的内容，展现的Activity都会继承BaseActivity并实现预留的接口，Activity之间的继承不超过3次；为避免Activity内代码过多，将App的整体控制权后移，也借鉴了IOC做法，大量的逻辑操作放在逻辑层中，逻辑层和UI层通过接口或者Broadcast等实现通信，只传递结果。一般Activity里的代码量都很大，通过这两种方式一般我写的单个Activity内代码量不超过400行。 逻辑层实现的是绝大部分的逻辑操作，由UI层启动，在内部通过接口调用模型层的方法，在逻辑层内大量使用了代理。打个比方，UI层告诉逻辑层我需要做的事，逻辑层去找相应的人(模型层)去做，最后只告诉UI这件事做的结果。 模型层没什么好说的，这部分一般由大量的Package组成，代码量是三层中最大的，需要在内部进行分层。 横向的分割依据AOP面向切面的思想，主要是提取出共用方法作为一个单独的Util，这些Util会在App整体中穿插使用。很多人的App都会引入自己封装的Jar包，封装了包括文件、JSON、SharedPreference等在内的常用操作，自己写的用起来顺手，也大幅度降低了重复作业。 这样纵，横两次对于App代码的分割已经能使得程序不会过多堆积在一个Java文件里，但靠一次开发过程就写出高质量的代码是很困难的，趁着项目的间歇期，对代码进行重构很有必要。 6.2 类库的使用现在有很多帮助快速开发的类库，活用这些类库也是避免代码臃肿和混乱的好方法，下面给题主推荐几个常用类库。 减少Activity代码量的依赖注入框架ButterKnife: https://github.com/JakeWharton/butterknife 简化对于SQlite操作的对象关系映射框架OrmLite: https://github.com/j256/ormlite-android 图片缓存类库Fresco(by facebook): https://github.com/facebook/fresco 能用第三方库就用第三方库。别管是否稳定，是否被持续维护，因为，任何第三方库的作者，都能碾压刚入门的菜鸟，你绝对写不出比别人更好的代码了。 最后附上知乎上面点赞次数很高的一段话： 如果“从零开始”，用什么设计架构的问题属于想得太多做得太少的问题。 从零开始意味着一个项目的主要技术难点是基本功能实现。当每一个功能都需要考虑如何做到的时候，我觉得一般人都没办法考虑如何做好。 因为，所有的优化都是站在最上层进行统筹规划。在这之前，你必须对下层的每一个模块都非常熟悉，进而提炼可复用的代码、规划逻辑流程。 所以，如果真的是从零开始，别想太多了 参考文献： 1、http://blog.csdn.net/luyi325xyz/article/details/43085409 2、http://blog.csdn.net/napolunyishi/article/details/22722345 3、https://www.zhihu.com/question/27645587/answer/37579829 4、http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0202/2397.html 5、http://www.tuicool.com/articles/VJZrYb 6、https://www.zhihu.com/question/27645587 7、http://blog.csdn.net/luyi325xyz/article/details/43482123 8、https://www.zhihu.com/question/30976423 9、http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0313/2599.html 10、http://www.2cto.com/kf/201506/405766.html 11、https://www.zhihu.com/question/19766132 12、http://www.cnblogs.com/artech/archive/2010/03/25/1696205.html 13、https://segmentfault.com/a/1190000003927200 14、http://blog.csdn.net/knxw0001/article/details/39637273 版权声明 周鸿博]]></content>
      <categories>
        <category>Android</category>
        <category>设计架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发总结(思维导图)]]></title>
    <url>%2Fposts%2F737b202d.html</url>
    <content type="text"><![CDATA[概述结合自己的理解，用 xmind（思维导图工具） 总结了 Android 应用开发的一些知识点，方便快速梳理整体的知识体系。]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制详解攻略，您值得拥有]]></title>
    <url>%2Fposts%2F92ff150b.html</url>
    <content type="text"><![CDATA[前言转自：https://blog.csdn.net/carson_ho/article/details/54136311 Android事件分发机制是Android开发者必须了解的基础 网上有大量关于Android事件分发机制的文章，但存在一些问题：内容不全、思路不清晰、无源码分析、简单问题复杂化等等 今天，我将全面总结Android的事件分发机制，我能保证这是市面上的最全面、最清晰、最易懂的 本文秉着“结论先行、详细分析在后”的原则，即先让大家感性认识，再通过理性分析从而理解问题； 所以，请各位读者先记住结论，再往下继续看分析； 文章较长，阅读需要较长时间，建议收藏等充足时间再进行阅读 目录 1. 基础认知1.1 事件分发的对象是谁？答：点击事件（Touch事件） 定义当用户触摸屏幕时（View 或 ViewGroup派生的控件），将产生点击事件（Touch事件） Touch事件的相关细节（发生触摸的位置、时间等）被封装成MotionEvent对象 事件类型（4种） 事件类型 具体动作 MotionEvent.ACTION_DOWN 按下View（所有事件的开始） MotionEvent.ACTION_UP 抬起View（与DOWN对应） MotionEvent.ACTION_MOVE 滑动View MotionEvent.ACTION_CANCEL 结束事件（非人为原因） 特别说明：事件列 从手指接触屏幕 至 手指离开屏幕，这个过程产生的一系列事件 注：一般情况下，事件列都是以DOWN事件开始、UP事件结束，中间有无数的MOVE事件，如下图： 即当一个点击事件（MotionEvent ）产生后，系统需把这个事件传递给一个具体的 View 去处理。 1.2 事件分发的本质答：将点击事件（MotionEvent）传递到某个具体的View &amp; 处理的整个过程 即 事件传递的过程 = 分发过程。 1.3 事件在哪些对象之间进行传递？答：Activity、ViewGroup、View Android的UI界面由Activity、ViewGroup、View 及其派生类组成 1.4 事件分发的顺序即 事件传递的顺序：Activity -&gt; ViewGroup -&gt; View 即：1个点击事件发生后，事件先传到Activity、再传到ViewGroup、最终再传到 View 1.5 事件分发过程由哪些方法协作完成？答：dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent() 下文会对这3个方法进行详细介绍 1.6 总结 至此，相信大家已经对 Android的事件分发有了感性的认知 下面，我将详细介绍Android事件分发机制 2. 事件分发机制 源码分析 请谨记：Android事件分发流程 = Activity -&gt; ViewGroup -&gt; View 即：1个点击事件发生后，事件先传到Activity、再传到ViewGroup、最终再传到 View 从上可知，要想充分理解Android分发机制，本质上是要理解： Activity对点击事件的分发机制 ViewGroup对点击事件的分发机制 View对点击事件的分发机制 下面，我将通过源码，全面解析 事件分发机制 即按顺序讲解：Activity事件分发机制、ViewGroup事件分发机制、View事件分发机制 2.1 Activity的事件分发机制当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发 2.1.1 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 源码分析：Activity.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; // 一般事件列开始都是DOWN事件 = 按下事件，故此处基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); // -&gt;&gt;分析1 &#125; // -&gt;&gt;分析2 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; // 若getWindow().superDispatchTouchEvent(ev)的返回true // 则Activity.dispatchTouchEvent（）就返回true，则方法结束。即 ：该点击事件停止往下传递 &amp; 事件传递过程结束 // 否则：继续往下调用Activity.onTouchEvent &#125; // -&gt;&gt;分析4 return onTouchEvent(ev); &#125;/** * 分析1：onUserInteraction() * 作用：实现屏保功能 * 注： * a. 该方法为空方法 * b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 */ public void onUserInteraction() &#123; &#125; // 回到最初的调用原处/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow() = 获取Window类的对象 * b. Window类是抽象类，其唯一实现类 = PhoneWindow类；即此处的Window类对象 = PhoneWindow类对象 * c. Window类的superDispatchTouchEvent() = 1个抽象方法，由子类PhoneWindow类实现 */ @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); // mDecor = 顶层View（DecorView）的实例对象 // -&gt;&gt; 分析3 &#125;/** * 分析3：mDecor.superDispatchTouchEvent(event) * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); // 调用父类的方法 = ViewGroup的dispatchTouchEvent() // 即 将事件传递到ViewGroup去处理，详细请看ViewGroup的事件分发机制 &#125; // 回到最初的调用原处/** * 分析4：Activity.onTouchEvent（） * 定义：属于顶层View（DecorView） * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup */ public boolean onTouchEvent(MotionEvent event) &#123; // 当一个点击事件未被Activity下任何一个View接收 / 处理时 // 应用场景：处理发生在Window边界外的触摸事件 // -&gt;&gt; 分析5 if (mWindow.shouldCloseOnTouch(this, event)) &#123; finish(); return true; &#125; return false; // 即 只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕 &#125;/** * 分析5：mWindow.shouldCloseOnTouch(this, event) */ public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123; // 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等 if (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != null) &#123; return true; &#125; return false; // 返回true：说明事件在边界外，即 消费事件 // 返回false：未消费（默认）&#125;// 回到分析4调用原处 2.1.2 总结 当一个点击事件发生时，从Activity的事件分发开始（Activity.dispatchTouchEvent()） 方法总结 那么，ViewGroup的dispatchTouchEvent()什么时候返回true / false？请继续往下看ViewGroup事件的分发机制 2.2 ViewGroup事件的分发机制从上面Activity事件分发机制可知，ViewGroup事件分发机制从dispatchTouchEvent()开始 2.2.1 源码分析 Android 5.0后，ViewGroup.dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同； 本文为了让读者容易理解，故采用Android 5.0前的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 源码分析：ViewGroup.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... // 仅贴出关键代码 // 重点分析1：ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件 if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; // 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent（）修改 // 判断值2： !onInterceptTouchEvent(ev) = 对onInterceptTouchEvent()返回值取反 // a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部 // b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断 // c. 关于onInterceptTouchEvent() -&gt;&gt;分析1 ev.setAction(MotionEvent.ACTION_DOWN); final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; // 重点分析2 // 通过for循环，遍历了当前ViewGroup下的所有子View for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); // 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View // 若是，则进入条件判断内部 if (frame.contains(scrolledXInt, scrolledYInt)) &#123; final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; // 条件判断的内部调用了该View的dispatchTouchEvent() // 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制） if (child.dispatchTouchEvent(ev)) &#123; mMotionTarget = child; return true; // 调用子View的dispatchTouchEvent后是有返回值的 // 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立 // 于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出 // 即把ViewGroup的点击事件拦截掉 &#125; &#125; &#125; &#125; &#125; &#125; boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; final View target = mMotionTarget; // 重点分析3 // 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true） if (target == null) &#123; ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; &#125; return super.dispatchTouchEvent(ev); // 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent() // 因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（）） // 此处需与上面区别：子View的dispatchTouchEvent（） &#125; ... &#125;/** * 分析1：ViewGroup.onInterceptTouchEvent() * 作用：是否拦截事件 * 说明： * a. 返回true = 拦截，即事件停止往下传递（需手动设置，即复写onInterceptTouchEvent（），从而让其返回true） * b. 返回false = 不拦截（默认） */ public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; // 回到调用原处 2.2.2 总结 结论：Android事件分发总是先传递到ViewGroup、再传递到View 过程：当点击了某个控件时 核心方法总结 2.2.3 Demo讲解 布局如下 测试代码 布局文件：activity_main.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/my_layout" android:layout_width="match_parent" android:layout_height="match_parent" xmlns:app="http://schemas.android.com/apk/res-auto" android:focusableInTouchMode="true" android:orientation="vertical"&gt; &lt;Button android:id="@+id/button1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮1" /&gt; &lt;Button android:id="@+id/button2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮2" /&gt;&lt;/LinearLayout&gt; 核心代码：MainActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * ViewGroup布局（myLayout）中有2个子View = 2个按钮 */ public class MainActivity extends AppCompatActivity &#123; Button button1,button2; ViewGroup myLayout; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1 = (Button)findViewById(R.id.button1); button2 = (Button)findViewById(R.id.button2); myLayout = (LinearLayout)findViewById(R.id.my_layout); // 1.为ViewGroup布局设置监听事件 myLayout.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了ViewGroup"); &#125; &#125;); // 2. 为按钮1设置监听事件 button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了button1"); &#125; &#125;); // 3. 为按钮2设置监听事件 button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.d("TAG", "点击了button2"); &#125; &#125;); &#125;&#125; 结果测试 从上面的测试结果发现： 点击Button时，执行Button.onClick()，但ViewGroupLayout注册的onTouch（）不会执行 只有点击空白区域时，才会执行ViewGroupLayout的onTouch（） 结论：Button的onClick()将事件消费掉了，因此事件不会再继续向下传递。 2.3 View事件的分发机制从上面ViewGroup事件分发机制知道，View事件分发机制从dispatchTouchEvent()开始 2.3.1 源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 源码分析：View.dispatchTouchEvent（） */ public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event); &#125; // 说明：只有以下3个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent() // 1. mOnTouchListener != null // 2. (mViewFlags &amp; ENABLED_MASK) == ENABLED // 3. mOnTouchListener.onTouch(this, event) // 下面对这3个条件逐个分析/** * 条件1：mOnTouchListener != null * 说明：mOnTouchListener变量在View.setOnTouchListener（）方法里赋值 */ public void setOnTouchListener(OnTouchListener l) &#123; mOnTouchListener = l; // 即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空）&#125; /** * 条件2：(mViewFlags &amp; ENABLED_MASK) == ENABLED * 说明： * a. 该条件是判断当前点击的控件是否enable * b. 由于很多View默认enable，故该条件恒定为true *//** * 条件3：mOnTouchListener.onTouch(this, event) * 说明：即 回调控件注册Touch事件时的onTouch（）；需手动复写设置，具体如下（以按钮Button为例） */ button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; return false; &#125; &#125;); // 若在onTouch（）返回true，就会让上述三个条件全部成立，从而使得View.dispatchTouchEvent（）直接返回true，事件分发结束 // 若在onTouch（）返回false，就会使得上述三个条件不全部成立，从而使得View.dispatchTouchEvent（）中跳出If，执行onTouchEvent(event) 接下来，我们继续看：onTouchEvent(event)的源码分析 详情请看注释 Android 5.0后 View.onTouchEvent()源码发生了变化（更加复杂），但原理相同； 本文为了让读者更好理解，所以采用Android 5.0前的版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * 源码分析：View.onTouchEvent（） */ public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; // 若该控件可点击，则进入switch判断中 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; // a. 若当前的事件 = 抬起View（主要分析） case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; ...// 经过种种判断，此处省略 // 执行performClick() -&gt;&gt;分析1 performClick(); break; // b. 若当前的事件 = 按下View case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; // c. 若当前的事件 = 结束事件（非人为原因） case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; // d. 若当前的事件 = 滑动View case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; break; &#125; // 若该控件可点击，就一定返回true return true; &#125; // 若该控件不可点击，就一定返回false return false; &#125;/** * 分析1：performClick（） */ public boolean performClick() &#123; if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; // 只要我们通过setOnClickListener（）为控件View注册1个点击事件 // 那么就会给mOnClickListener变量赋值（即不为空） // 则会往下回调onClick（） &amp; performClick（）返回true &#125; return false; &#125; 2.3.2 总结 每当控件被点击时： 注：onTouch（）的执行 先于 onClick（） 核心方法总结 2.3.3 Demo讲解下面我将用Demo验证上述的结论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 结论验证1：在回调onTouch()里返回false */ // 1. 通过OnTouchListener()复写onTouch()，从而手动设置返回false button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return false; &#125; &#125;); // 2. 通过 OnClickListener（）为控件设置点击事件，为mOnClickListener变量赋值（即不为空），从而往下回调onClick（） button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;);/** * 结论验证2：在回调onTouch()里返回true */ // 1. 通过OnTouchListener()复写onTouch()，从而手动设置返回true button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return true; &#125; &#125;); // 2. 通过 OnClickListener（）为控件设置点击事件，为mOnClickListener变量赋值（即不为空） // 但由于dispatchTouchEvent（）返回true，即事件不再向下传递，故不调用onClick()） button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;); 测试结果 2.4 总结 若您已经看到此处，那么恭喜你，你已经能非常熟悉掌握Android的事件分发机制了 即：Activity、ViewGroup、View 的事件分发机制 3. 工作流程 总结 在本节中，我将结合源码，梳理出1个事件分发的工作流程总结，具体如下： 左侧虚线：具备相关性 &amp; 逐层返回 以角色为核心的图解说明 以方法为核心的图解说明 4. 核心方法总结 已知事件分发过程的核心方法为：dispatchTouchEvent()、onInterceptTouchEvent() 和 onTouchEvent() 下面，我将结合总结的工作流程，再次详细讲解该3个方法 4.1 dispatchTouchEvent() 简介 返回情况说明 情况1：默认 情况2：返回true 情况3：返回false 4.2 onInterceptTouchEvent() 简介 注：Activity、View都无该方法 返回情况说明 情况1：true 情况2：false（默认） 4.3 onTouchEvent() 简介 返回情况说明 情况1：返回true 情况2：返回false（default） 4.4 三者关系下面，我用一段伪代码来阐述上述3个方法的关系 &amp; 事件传递规则 1234567891011121314151617181920212223242526/** * 点击事件产生后 */ // 步骤1：调用dispatchTouchEvent（） public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; //代表 是否会消费事件 // 步骤2：判断是否拦截事件 if (onInterceptTouchEvent(ev)) &#123; // a. 若拦截，则将该事件交给当前View进行处理 // 即调用onTouchEvent (）方法去处理点击事件 consume = onTouchEvent (ev) ; &#125; else &#123; // b. 若不拦截，则将该事件传递到下层 // 即 下层元素的dispatchTouchEvent（）就会被调用，重复上述过程 // 直到点击事件被最终处理为止 consume = child.dispatchTouchEvent (ev) ; &#125; // 步骤3：最终返回通知 该事件是否被消费（接收 &amp; 处理） return consume; &#125; 5. 常见的事件分发场景下面，我将通过实例说明常见的事件传递情况 &amp; 流程 5.1 背景描述 讨论的布局如下： 情景 用户先触摸到屏幕上View C上的某个点（图中黄区） Action_DOWN事件在此处产生 用户移动手指 最后离开屏幕 5.2 一般的事件传递情况一般的事件传递场景有： 默认情况 处理事件 拦截DOWN事件 拦截后续事件（MOVE、UP） 场景1：默认 即不对控件里的方法（dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent()）进行重写 或 更改返回值 那么调用的是这3个方法的默认实现：调用下层的方法 &amp; 逐层返回 事件传递情况：（呈U型） 1.从上往下调用dispatchTouchEvent() Activity A -&gt;&gt; ViewGroup B -&gt;&gt; View C2.从下往上调用onTouchEvent() View C -&gt;&gt; ViewGroup B -&gt;&gt; Activity A 注：虽然ViewGroup B的onInterceptTouchEvent（）对DOWN事件返回了false，但后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent() 这一点与onTouchEvent（）的行为是不一样的：不再传递 &amp; 接收该事件列的其他事件 场景2：处理事件设View C希望处理该点击事件，即：设置View C为可点击的（Clickable） 或 复写其onTouchEvent（）返回true 最常见的：设置Button按钮来响应点击事件 事件传递情况：（如下图） DOWN事件被传递给C的onTouchEvent方法，该方法返回true，表示处理该事件 因为View C正在处理该事件，那么DOWN事件将不再往上传递给ViewGroup B 和 Activity A的onTouchEvent()； 该事件列的其他事件（Move、Up）也将传递给View C的onTouchEvent() 会逐层往dispatchTouchEvent() 返回，最终事件分发结束 场景3：拦截DOWN事件假设ViewGroup B希望处理该点击事件，即ViewGroup B复写了onInterceptTouchEvent()返回true、onTouchEvent()返回true事件传递情况：（如下图） DOWN事件被传递给ViewGroup B的onInterceptTouchEvent()，该方法返回true，表示拦截该事件，即自己处理该事件（事件不再往下传递） 调用自身的onTouchEvent()处理事件（DOWN事件将不再往上传递给Activity A的onTouchEvent()） 该事件列的其他事件（Move、Up）将直接传递给ViewGroup B的onTouchEvent() 注： 该事件列的其他事件（Move、Up）将不会再传递给ViewGroup B的onInterceptTouchEvent（）；因：该方法一旦返回一次true，就再也不会被调用 逐层往dispatchTouchEvent() 返回，最终事件分发结束 场景4：拦截DOWN的后续事件结论 若 ViewGroup 拦截了一个半路的事件（如MOVE），该事件将会被系统变成一个CANCEL事件 &amp; 传递给之前处理该事件的子View； 该事件不会再传递给ViewGroup 的onTouchEvent() 只有再到来的事件才会传递到ViewGroup的onTouchEvent() 场景描述ViewGroup B 无拦截DOWN事件（还是View C来处理DOWN事件），但它拦截了接下来的MOVE事件 即 DOWN事件传递到View C的onTouchEvent（），返回了true 实例讲解 在后续到来的MOVE事件，ViewGroup B 的onInterceptTouchEvent（）返回true拦截该MOVE事件，但该事件并没有传递给ViewGroup B ；这个MOVE事件将会被系统变成一个CANCEL事件传递给View C的onTouchEvent（） 后续又来了一个MOVE事件，该MOVE事件才会直接传递给ViewGroup B 的onTouchEvent() 后续事件将直接传递给ViewGroup B 的onTouchEvent()处理，而不会再传递给ViewGroup B 的onInterceptTouchEvent（），因该方法一旦返回一次true，就再也不会被调用了。 View C再也不会收到该事件列产生的后续事件 至此，关于Android常见的事件传递情况 &amp; 流程已经讲解完毕。 6. 额外知识6.1 Touch事件的后续事件（MOVE、UP）层级传递 6.1 Touch事件的后续事件（MOVE、UP）层级传递 若给控件注册了Touch事件，每次点击都会触发一系列action事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP等） 当dispatchTouchEvent（）事件分发时，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP） 即如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE、ACTION_UP事件都不会执行从上面对事件分发机制分析知： dispatchTouchEvent()、 onTouchEvent() 消费事件、终结事件传递（返回true） 而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用 请记住：接收了ACTION_DOWN事件的函数不一定能收到后续事件（ACTION_MOVE、ACTION_UP）这里给出ACTION_MOVE和ACTION_UP事件的传递结论： 结论1若对象（Activity、ViewGroup、View）的dispatchTouchEvent()分发事件后消费了事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE 、 ACTION_UP事件传递方向 结论2若对象（Activity、ViewGroup、View）的onTouchEvent()处理了事件（返回true），那么ACTION_MOVE、ACTION_UP的事件从上往下传到该View后就不再往下传递，而是直接传给自己的onTouchEvent()&amp; 结束本次事件传递过程。 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE、ACTION_UP事件传递方向 6.2 onTouch()和onTouchEvent()的区别 该2个方法都是在View.dispatchTouchEvent（）中调用 但onTouch（）优先于onTouchEvent执行；若手动复写在onTouch（）中返回true（即 将事件消费掉），将不会再执行onTouchEvent（） 注：若1个控件不可点击（即非enable），那么给它注册onTouch事件将永远得不到执行，具体原因看如下代码 12345678// &amp;&amp;为短路与，即如果前面条件为false，将不再往下执行// 故：onTouch（）能够得到执行需2个前提条件： // 1. mOnTouchListener的值不能为空 // 2. 当前点击的控件必须是enable的mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)// 对于该类控件，若需监听它的touch事件，就必须通过在该控件中重写onTouchEvent（）来实现12345678 7. 总结 通过阅读本文，相信您已经可以全面了解Android事件分发机制 与Android事件分发最相关的知识：自定义View系列文章自定义View基础 - 最易懂的自定义View原理系列（1）自定义View Measure过程 - 最易懂的自定义View原理系列（2）自定义View Layout过程 - 最易懂的自定义View原理系列（3）自定义View Draw过程- 最易懂的自定义View原理系列（4） 接下来我将继续介绍与Android事件分发最相关的知识：自定义View，有兴趣可以继续关注Carson_Ho的安卓开发笔记]]></content>
      <categories>
        <category>Android</category>
        <category>源码解析</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwitchHosts!]]></title>
    <url>%2Fposts%2F1bc98c52.html</url>
    <content type="text"><![CDATA[SwitchHosts! 英文 主页：https://oldj.github.io/SwitchHosts/ 这是一个用于快速切换 hosts 文件的小程序，基于 Electron 开发，同时使用了 React、Ant Design 以及 CodeMirror 等框架/库。 截图 功能特性 快速切换 hosts hosts 文件语法高亮 在线 hosts 方案 系统托盘图标快速切换 macOS: 支持 Alfred workflow 快速切换 安装下载安装你可以直接下载源码到本地运行或编辑，或者在下面下载可执行版本： SwitchHosts! 下载地址1（GitHub release） SwitchHosts! 下载地址2（百度网盘） brew在 macOS 上，也可以使用 brew cast 安装，命令如下： 1brew cask install switchhosts 感谢 @gobinathm、@iamybj 更新 brew cask 版本。 文件备份SwitchHosts! 的数据文件在 ~/.SwitchHosts 目录下（Windows 用户为个人主目录下的 .SwitchHosts 目录下），其中 ~/.SwitchHosts/data.json 是 hosts 数据文件，~/.SwitchHosts/prefereces.json 是配置信息。 运行/打包方法环境配置 安装 Node.js 环境； 在根目录 ./ 下，运行 npm install 命令，安装开发依赖库； 在 ./app 目录下，运行 npm install 命令，安装 App 运行依赖库； 12npm installcd app &amp;&amp; npm install &amp;&amp; cd .. 构建及运行 在 ./ 目录下，运行 npm run dll 命令，构建公共文件（仅需在第一次构建或公共库发生改变时执行）； 在 ./ 目录下，运行 npm run build 命令，构建所需文件； 在 ./ 目录下，运行 npm start 命令，即可运行程序。 1234567891011# create dll filenpm run dll# buildnpm run build# startnpm start# or start in developer modenpm run dev 打包发布 建议使用 electron-packager 进行打包 12# install electron-packager for use from clinpm install electron-packager -g 在 ./ 目录下，运行 npm run pack 命令，打包后的文件位于 ./dist 目录； 首次执行此命令可能需要花费较多时间（需要下载对应的构建文件），也可先手动下载对应的发布版本（淘宝镜像），手动保存到 ~/.electron 目录下。更多信息请参考 Electron 文档。 123456# packnpm run pack # the packed files will be in ./dist# 也可以只打包特定平台的版本，如npm run pack-mac # pack for macOS, the packed files will be in ./distnpm run pack-win # pack for Windows, the packed files will be in ./dist 打包完成后，可运行以下命令将生成的程序压缩为 zip 文件。 12# zipnpm run zip # the zipped files will be in ./dist 更新历史v3.3 2017-05-30 引入 Ant Design 重写部分 UI 组件 2017-04-03 支持通过 Alfred 快速切换（下载 workflow） 2017-04-01 代码重构，增加「分组」功能 v3.2 2016-09-06 使用 Electron 打包，增加 Windows 版下载。 v3.1 2016-04-29 更新自动清除 DNS 缓存功能 #90。 2016-01-15 搜索时增加模糊搜索支持（eg. go*le matches google）及正则支持（eg. /go.*le matches google）。 2016-01-10 远程方案可以设置自动更新时间。 2015-12-26 实现 Tray 菜单切换、Dock 图标隐藏、方案导入导出等功能。 2015-12-20 从 Electron 切换至 MacGap 。 v3.0 2015-11-30 完成 3.0 版基本功能。 v2.0 2013-02-06 解决 Linux/Mac 下没有修改系统 hosts 文件权限的问题。 2012-12-27 启动时检查是否为单一实例，禁止同时运行多个实例。 2012-11-16 接受 @charlestang 网友的 pull request，同时参考了 @allenm 的修改，实现了 Common Hosts 功能。 2012-11-09 简单优化：Common Hosts 不允许删除，不允许“切换到”，将右键菜单相关条目禁用，允许更换图标颜色。修复新增在线方案时，url 框默认禁用的小 bug。 2012-10-09 增加 hosts 方案拖拽排序功能。 2012-10-05 修复在中文目录下程序无法正常启动的问题。 2012-09-30 初步完成 0.2.0 版。 v1.0 2011-12-14 允许输入超长的 hosts 方案。 2011-10-09 发布 0.1.6 版，修复若干 bug，增加自动检查最新版本的功能。 2011-09-29 发布 0.1.5 版，新增 hosts 内容语法高亮。 2011-09-28 发布 0.1.4 版，新增“添加”、“删除”按钮；hosts 内容修改后自动保存；修复若干 bug。 2011-09-19 发布 0.1.3 版，修复若干 bug。 2011-09-15 发布 0.1.2 版，添加主面板，可以在主面板上对 hosts 进行增加、删除、编辑、重命名等操作。 2011-09-02 发布 0.1.0 版，完成基本功能。 版权本程序完全免费，并基于 MIT 协议开源。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout完全解析,快来优化你的布局吧]]></title>
    <url>%2Fposts%2Fa495ccb1.html</url>
    <content type="text"><![CDATA[Demo地址：ConstraintLayout 一、概述ConstraintLayout出现有一段时间了，不过一直没有特别去关注，也多多少少看了一些文字介绍，多数都是对使用可视化布局拖拽，个人对拖拽一直不看好，直到前段时间看到该文： 解析ConstraintLayout的性能优势 非常详尽的介绍了ConstraintLayout的性能优势，于是乎开始学习了一下ConstraintLayout。 本文的重点不在与可视化界面的学习，而在于如何手写各类约束布局属性。对于可视化界面学习推荐： Android新特性介绍，ConstraintLayout完全解析 下面开始进入正题，大家都知道，当布局嵌套深入比较深的时候，往往会伴随着一些性能问题。所以很多时候我们建议使用RelativeLayout或者GridLayout来简化掉布局的深度。 而对于简化布局深度，ConstraintLayout几乎可以做到极致，接下来我们通过实例来尽可能将所有常见的属性一步步的介绍清楚。 首先需要引入我们的ConstraintLayout，在build.gradle中加入： 1compile 'com.android.support.constraint:constraint-layout:1.0.2' 二、来编写一个Feed Item我们先看一个简单的新闻列表中常见的feed item。 看到这样的布局，大家条件反射应该就是使用RelativeLayout来做，当然了，本案例我们使用ConstraintLayout来写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#11ff0000" tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:id="@+id/tv1" android:layout_width="140dp" android:layout_height="86dp" android:layout_marginLeft="12dp" android:layout_marginTop="12dp" android:background="#fd3" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;TextView android:id="@+id/tv2" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginRight="12dp" android:text="马云:一年交税170多亿马云:一年交税170多亿马云:一年交税170多亿" android:textColor="#000000" android:textSize="16dp" app:layout_constraintLeft_toRightOf="@id/tv1" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="@id/tv1" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginTop="12dp" android:text="8分钟前" android:textColor="#333" android:textSize="12dp" app:layout_constraintLeft_toRightOf="@id/tv1" app:layout_constraintBottom_toBottomOf="@id/tv1" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 看上面的布局，我们好像看到了几个模式的属性： 首先是tv1，有两个没见过的属性： app:layout_constraintLeft_toLeftOf=&quot;parent&quot; 从字面上看，指的是让该控件的左侧与父布局对齐，当我们希望控件A与控件B左侧对齐时，就可以使用该属性。 1app:layout_constraintLeft_toLeftOf="@id/viewB" 类似的还有个相似的属性为： app:layout_constraintLeft_toRightOf 很好理解，即当前属性的左侧在谁的右侧，当我们希望控件A在控件B的右侧时，可以设置： 1app:layout_constraintLeft_toRightOf="@id/viewB" 与之类似的还有几个属性： layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintBaseline_toBaselineOf 类推就可以了。 现在在头看刚才的布局： 123456789101112131415tv1设置了：app:layout_constraintLeft_toLeftOf="parent"app:layout_constraintTop_toTopOf="parent"tv2设置了：app:layout_constraintLeft_toRightOf="@id/tv1"app:layout_constraintRight_toRightOf="parent"app:layout_constraintTop_toTopOf="@id/tv1"tv3设置了：app:layout_constraintLeft_toRightOf="@id/tv1"app:layout_constraintBottom_toBottomOf="@id/tv1" 按照我们刚才的理解，再次的解读下： tv1应该是在父布局的左上角； tv2在tv1的右侧，tv2的右侧和父布局对其，tv2和tv1顶部对齐； tv3在tv1的右侧，tv3和tv1底部对其。 到这里，大家可以看到，目前我们已经可以控制任何一个控件与其他控件间的相对位置了，以及与parent间的相对位置。 和RL的差异大家是不是觉得目前来看和RelativeLayout特别像？ 其实还是有很明显的区别的，我们通过一个例子来看一下： 123456789101112131415161718&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/id_btn01" android:layout_width="100dp" android:text="Btn01" android:layout_height="wrap_content" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_toRightOf="@id/id_btn01" android:text="Btn02" android:layout_alignParentRight="true" /&gt;&lt;/RelativeLayout&gt; 那么经过我们刚才的学习，把： layout_toRightOf=&quot;@id/id_btn01&quot;，layout_alignParentRight=&quot;true&quot; 分别替换为： app:layout_constraintLeft_toRightOf=&quot;@id/id_btn01&quot;，app:layout_constraintRight_toRightOf=&quot;parent&quot; 是不是觉得so easy ，但是我们看一下效果图： 是不是和预期有一定的区别，假设你将Btn02的宽度设置的非常大，你会发现更加诡异的事情： 你会发现Btn02，好像疯了一样，我们设置的在btn01右侧，和与parent右侧对齐完全失效了！！！ 别怕，接下来就让你认识到为什么这个控件叫做“Constraint”Layout。 在当控件有自己设置的宽度，例如warp_content、固定值时，我们为控件添加的都是约束“Constraint”，这个约束有点像橡皮筋一样会拉这个控件，但是并不会改变控件的尺寸（RL很明显不是这样的）。 例如上例，当btn02的宽度较小时，我们为其左侧设置了一个约束（btn01右侧），右侧设置了一个约束（parent右侧对其），当两个约束同时生效的时候（你可以认为两边都是相同的一个拉力），btn02会居中。 当btn02特别大的时候，依然是这两个力，那么会发生什么？会造成左侧和右侧超出的距离一样大。 那么现在大家肯定有些疑问： 怎么样才能和上面的RL一样，宽度刚好占据剩下的距离呢（btn01右侧到屏幕右侧的距离）？ 这个问题，问得很好，我们刚才所有的尝试都是在控件自身拥有特定的宽度情况下执行的；那么如果希望控件的宽度根据由约束来控件，不妨去掉这个特定的宽度，即设置为0试试？ 对！当我们将btn02的宽度设置为0时，一切又变得很完美。 那么这里，你可能会问0值是什么含义，其实在ConstraintLayout中0代表：MATCH_CONSTRAINT，看到这个常量，是不是瞬间觉得好理解了一点。 最后一个问题，MATCH_PARENT哪去了? 看官网的解释： Important: MATCH_PARENT is not supported for widgets contained in a ConstraintLayout, though similar behavior can be defined by using MATCH_CONSTRAINT with the corresponding left/right or top/bottom constraints being set to “parent”.` 所以你可以认为：在ConstraintLayout中已经不支持MATCH_PARENT这个值了，你可以通过MATCH_CONSTRAINT配合约束实现类似的效果。 好了，到这里，目前我们已经看到其已经和RelativeLayout势均力敌了，接下来我们看一下RL做不到的特性。 三、增加一个banner我们现在以往在这个feed item顶部添加一个banner，宽度为占据整个屏幕，宽高比为16：6。 这里尴尬了，在之前的做法，很难在布局中设置宽高比，一般我们都需要在代码中显示的去操作，那么如果你用了ConstraintLayout，它就支持。 看一眼如何支持： 12345678910111213141516171819202122&lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:id="@+id/banner" android:layout_width="0dp" android:layout_height="0dp" android:background="#765" android:gravity="center" android:text="Banner" app:layout_constraintDimensionRatio="H,16:6" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" /&gt; &lt;TextView android:id="@+id/tv1" app:layout_constraintTop_toBottomOf="@id/banner" &gt;&lt;/TextView&gt; ...&lt;/...&gt; 我们添加了一个banner，还记得我们刚才所说的么，不要使用match_parent了，而是设置match_contraint，即0，让约束来控制布局宽高。 所以我们设置了宽、高都是match_contraint，然后这两个属性： 12app:layout_constraintLeft_toLeftOf="parent"app:layout_constraintRight_toRightOf="parent" 让我们的宽度充满整个父布局，在添加一个： 1app:layout_constraintDimensionRatio="16:6" 该属性指的是宽高比，所以16：6就可以完成我们的需求。 好了看下效果图： 这个宽高比属性，还支持这样的写法： 12app:layout_constraintDimensionRatio="W,16:6"app:layout_constraintDimensionRatio="H,16:6" 可以自己试验下。 好了，到这里，我们又新增了一个属性，还是个非常实用的属性。 那么，我们继续，再看一个似曾相识的功能。 四、增加几个Tab现在我们希望在底部增加3个tab，均分。是不是想到了LinearLayout和weight。 没错！ConstraintLayout也支持类似的属性。 虽然我知道，但是写到这我还是有点小惊喜~~ 看下如何实现： 12345678910111213141516171819202122232425262728293031323334&lt;TextView android:id="@+id/tab1" android:layout_width="0dp" android:layout_height="30dp" android:background="#f67" android:gravity="center" android:text="Tab1" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toLeftOf="@+id/tab2" /&gt;&lt;TextView android:id="@+id/tab2" android:layout_width="0dp" android:layout_height="30dp" android:background="#A67" android:gravity="center" android:text="Tab2" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/tab1" app:layout_constraintRight_toLeftOf="@+id/tab3" /&gt;&lt;TextView android:id="@+id/tab3" android:layout_width="0dp" android:layout_height="30dp" android:background="#767" android:gravity="center" android:text="Tab3" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintLeft_toRightOf="@id/tab2" app:layout_constraintRight_toRightOf="parent" /&gt; 我们增加3个textview来冒充tab。我们看横向的依赖，3个tab两两设置了约束（即你在我们的左边，我在你的右边），最外层的设置了parent约束；再加上我们把宽度都设置为了match_constraint，so，这样我们就完成了3个tab等分。 看一眼效果图： 你可能会说，LL配合weight更加灵活，可以单个设置占据的比例。 对，没错，我们也支持，我不是还没说完么。 现在我们可以给每个tab设置一个属性： 1app:layout_constraintHorizontal_weight 看到这个名字，应该就明白了吧，假设我们分别设置值为2，1，1。 效果图为： 是不是很惊喜，别急，刚才你说我不如LL，现在我要让你再看一些LL配合weight做不到的。 这里需要借助几张官网上的图了： 刚才我们说了，3个tab两两设置了依赖，即类似下图： 横向的相当于组成了一个链(Chains)。在这个链的最左侧的元素成为链头，我们可以在其身上设置一些属性，来决定这个链的展示效果： 该属性为： 1layout_constraintHorizontal_chainStyle 我们已经见过一种效果了，即按照weight等分，可以成为weighted chain。设置条件为： chainStyle=”spread”，所有控件宽度设置为match_constraint，因为默认就是spread，所以我们没有显示设置。 其取值还可以为： packed spread_inside 我还是分别显示一下吧： spread + 宽度非0 spread + 宽度为0，且可以通过weight控制分配比例（上例） spread_inside + 宽度非0 packed + 宽度非0 好了，差不多了，我们可以在横向或者纵向组成一个Chain，然后在Chain head设置chainStyle来搞一些事情。 官网有个图： 前四个我们都演示了，最后一个设计到一个新的bias属性，别急，咱们慢慢说~~ 好了，到这里，我们再次见证了ConstraintLayout的强大。 我们最后再看一个例子。 五、增加浮动按钮一个很常见的功能，我们现在希望在右下角增加一个浮动按钮。 看下如何实现： 12345678910111213141516&lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;TextView android:layout_width="60dp" android:layout_height="60dp" android:background="#612" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintHorizontal_bias="0.9" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintVertical_bias="0.9" /&gt;&lt;/....&gt; 我们在最后追加一个TextView冒充我们的浮动按钮。可以看到我们设置了固定值，被设置约束为右下角。 正常情况我们可以通过margin来设置与右侧与底部的距离。 但是这里我们尝试使用量个新的属性： 12layout_constraintHorizontal_biaslayout_constraintVertical_bias 即设置上下两侧间隙比例分别为90%与10%。这个很好理解，我们之前说了，再没有bias这个属性的时候，这两侧的拉力大小是一样的，但是你可以通过bias来控制哪一侧的力要大一些明白了么 所以，该属性可以用于约束之前，控制两侧的“拉力”。 我们看一下效果图： 那么到这里，ConstraintLayout的属性我们基本上介绍完了： 我们看一下： 1234567891011121314151617181920212223242526272829303132333435layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOflayout_constraintRight_toLeftOflayout_constraintRight_toRightOflayout_constraintTop_toTopOflayout_constraintTop_toBottomOflayout_constraintBottom_toTopOflayout_constraintBottom_toBottomOf# 即文章的baseline对齐layout_constraintBaseline_toBaselineOf# 与left,right类似layout_constraintStart_toEndOf layout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOf# margin不需要解释android:layout_marginStartandroid:layout_marginEndandroid:layout_marginLeftandroid:layout_marginTopandroid:layout_marginRightandroid:layout_marginBottomlayout_constraintHorizontal_bias layout_constraintVertical_bias layout_constraintHorizontal_chainStylelayout_constraintVertical_chainStylelayout_constraintVertical_weightGuideline 好像，还有个比较特殊的，叫Guideline。 好吧，继续~ 六、尝试使用Guidelineandroid.support.constraint.Guideline该类比较简单，主要用于辅助布局，即类似为辅助线，横向的、纵向的。该布局是不会显示到界面上的。 所以其有个属性为： android:orientation取值为”vertical”和”horizontal”. 除此以外，还差个属性，决定该辅助线的位置： layout_constraintGuide_begin layout_constraintGuide_end layout_constraintGuide_percent 可以通过上面3个属性其中之一来确定属性值位置。 begin=30dp，即可认为距离顶部30dp的地方有个辅助线，根据orientation来决定是横向还是纵向。 end=30dp，即为距离底部。percent=0.8即为距离顶部80%。 好了，下面看一个例子，刚才我们的浮点按钮，我决定通过两根辅助线来定位，一根横向距离底部80%，一个纵向距离顶部80%，浮点按钮就定位在他们交叉的地方。 123456789101112131415161718192021222324252627&lt;android.support.constraint.ConstraintLayout ... tools:context="com.zhy.constrantlayout_learn.MainActivity"&gt; &lt;android.support.constraint.Guideline android:id="@+id/guideline_h" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="horizontal" app:layout_constraintGuide_percent="0.8" /&gt; &lt;android.support.constraint.Guideline android:id="@+id/guideline_w" android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" app:layout_constraintGuide_percent="0.8" /&gt; &lt;TextView android:layout_width="60dp" android:layout_height="60dp" android:background="#612" app:layout_constraintLeft_toRightOf="@id/guideline_w" app:layout_constraintTop_toBottomOf="@id/guideline_h" /&gt;&lt;/....&gt; 我感觉都不用解释了~~看眼效果图吧： 到此，属性基本上讲完啦~ 可以看到，上述相当复杂的一个布局，在ConstraintLayout中完全没有嵌套！ 六、总结本文通过实际的按钮，基本上介绍了ConstraintLayout所支持的所有的属性，全文没有提及拖拽，因为当界面复杂之后，想要完美的拖拽实在是太难了，而且谁也不期望，看不懂拖拽完成后的布局属性吧~ 所以，我建议还是尽可能手写，通过本文这样一个流程，虽然支持的属性有20多个，但是分类后并不难记，难记也可以拿出本文翻一翻~ 好了，思考了半天，如何通过一个案例介绍完所有的属性，总体来说还是完成了，给自己点个赞。 转载于：张鸿洋的博客]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑马灯MarqueeView（支持任何View）]]></title>
    <url>%2Fposts%2F553b92de.html</url>
    <content type="text"><![CDATA[类似TextView的android:ellipsize=”marquee”的跑马灯效果 任意View都可实现 源码：MarqueeView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.zm.marqueeview;import android.content.Context;import android.util.AttributeSet;import android.view.LayoutInflater;import android.view.MotionEvent;import android.view.View;import android.view.WindowManager;import android.widget.HorizontalScrollView;import android.widget.LinearLayout;/** * 跑马灯MarqueeView */public class MarqueeView extends HorizontalScrollView implements Runnable &#123; private Context context; private LinearLayout mainLayout;//跑马灯滚动部分 private int scrollSpeed = 5;//滚动速度 private int scrollDirection = LEFT_TO_RIGHT;//滚动方向 private int currentX;//当前x坐标 private int viewMargin = 100;//View间距 private int viewWidth;//View总宽度 private int screenWidth;//屏幕宽度 public static final int LEFT_TO_RIGHT = 1; public static final int RIGHT_TO_LEFT = 2; public MarqueeView(Context context) &#123; this(context, null); &#125; public MarqueeView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MarqueeView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); this.context = context; initView(); &#125; void initView() &#123; WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE); screenWidth = wm.getDefaultDisplay().getWidth(); mainLayout = (LinearLayout) LayoutInflater.from(context).inflate(R.layout.scroll_content, null); this.addView(mainLayout); &#125; public void addViewInQueue(View view) &#123; LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.setMargins(viewMargin, 0, 0, 0); view.setLayoutParams(lp); mainLayout.addView(view); view.measure(0, 0);//测量view viewWidth = viewWidth + view.getMeasuredWidth() + viewMargin; &#125; //开始滚动 public void startScroll() &#123; removeCallbacks(this); currentX = (scrollDirection == LEFT_TO_RIGHT ? viewWidth : -screenWidth); post(this); &#125; //停止滚动 public void stopScroll() &#123; removeCallbacks(this); &#125; //设置View间距 public void setViewMargin(int viewMargin) &#123; this.viewMargin = viewMargin; &#125; //设置滚动速度 public void setScrollSpeed(int scrollSpeed) &#123; this.scrollSpeed = scrollSpeed; &#125; //设置滚动方向 默认从左向右 public void setScrollDirection(int scrollDirection) &#123; this.scrollDirection = scrollDirection; &#125; @Override public void run() &#123; switch (scrollDirection) &#123; case LEFT_TO_RIGHT: mainLayout.scrollTo(currentX, 0); currentX--; if (-currentX &gt;= screenWidth) &#123; mainLayout.scrollTo(viewWidth, 0); currentX = viewWidth; &#125; break; case RIGHT_TO_LEFT: mainLayout.scrollTo(currentX, 0); currentX++; if (currentX &gt;= viewWidth) &#123; mainLayout.scrollTo(-screenWidth, 0); currentX = -screenWidth; &#125; break; default: break; &#125; postDelayed(this, 50 / scrollSpeed); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google推荐的图片加载库Glide介绍]]></title>
    <url>%2Fposts%2F6abab605.html</url>
    <content type="text"><![CDATA[英文原文 Introduction to Glide, Image Loader Library for Android, recommended by Google 在泰国举行的谷歌开发者论坛上，谷歌为我们介绍了一个名叫 Glide 的图片加载库，作者是bumptech。这个库被广泛的运用在google的开源项目中，包括2014年google I/O大会上发布的官方app。它的成功让我非常感兴趣。我花了一整晚的时间把玩，决定分享一些自己的经验。在开始之前我想说， Glide 和 Picasso 有90%的相似度，准确的说，就是Picasso的克隆版本。但是在细节上还是有不少区别的。 导入库 Glide 和 Picasso 都在jcenter上。在项目中添加依赖非常简单： Glide1234dependencies &#123; compile 'com.github.bumptech.glide:glide:3.5.2' compile 'com.android.support:support-v4:22.0.0'&#125; Picasso123dependencies &#123; compile 'com.squareup.picasso:picasso:2.5.1'&#125; 虽然两者看起来一样，但是Glide更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。 同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我建议传参的时候传递Activity 和 Fragment给Glide，而不是Context。 默认Bitmap格式是RGB_565下面是加载图片时和Picasso的比较（1920x1080 像素的图片加载到768x432的ImageView中） 可以看到Glide加载的图片质量要差于Picasso（ps：我看不出来哈），为什么？这是因为Glide默认的Bitmap格式是RGB_565 ，比ARGB_8888格式的内存开销要小一半。下面是Picasso在ARGB8888下与Glide在RGB565下的内存开销图（应用自身占用了8m，因此以8为基准线比较）： 如果你对默认的RGB_565效果还比较满意，可以不做任何事，但是如果你觉得难以接受，可以创建一个新的GlideModule将Bitmap格式转换到ARGB_8888： 12345678910111213public class GlideConfiguration implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; // Apply options to the builder here. builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; // register ModelLoaders here. &#125; &#125; 同时在AndroidManifest.xml中将GlideModule定义为meta-data 1&lt;meta-data android:name="com.inthecheesefactory.lab.glidepicasso.GlideConfiguration" android:value="GlideModule"/&gt; 这样看起来就会好很多。我们再来看看内存开销图，这次貌似Glide花费了两倍于上次的内存，但是Picasso的内存开销仍然远大于Glide。 原因在于Picasso是加载了全尺寸的图片到内存，然后让GPU来实时重绘大小。而Glide加载的大小和ImageView的大小是一致的，因此更小。当然，Picasso也可以指定加载的图片大小的： 1234Picasso.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .resize(768, 432) .into(ivImgPicasso); 但是问题在于你需要主动计算ImageView的大小，或者说你的ImageView大小是具体的值（而不是wrap_content），你也可以这样： 12345Picasso.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .fit() .centerCrop() .into(ivImgPicasso); 现在Picasso的内存开销就和Glide差不多了。 虽然内存开销差距不到，但是在这个问题上Glide完胜Picasso。因为Glide可以自动计算出任意情况下的ImageView大小。 Image质量的细节这是将ImageView还原到真实大小时的比较。 你可以看到，Glide加载的图片没有Picasso那么平滑，我还没有找到一个可以直观改变图片大小调整算法的方法。但是这并不算什么坏事，因为很难察觉。 磁盘缓存Picasso和Glide在磁盘缓存策略上有很大的不同。Picasso缓存的是全尺寸的，而Glide缓存的是跟ImageView尺寸相同的。 上面提到的平滑度的问题依然存在，而且如果加载的是RGB565图片，那么缓存中的图片也是RGB565。我尝试将ImageView调整成不同大小，但不管大小如何Picasso只缓存一个全尺寸的。Glide则不同，它会为每种大小的ImageView缓存一次。尽管一张图片已经缓存了一次，但是假如你要在另外一个地方再次以不同尺寸显示，需要重新下载，调整成新尺寸的大小，然后将这个尺寸的也缓存起来。具体说来就是：假如在第一个页面有一个200x200的ImageView，在第二个页面有一个100x100的ImageView，这两个ImageView本来是要显示同一张图片，却需要下载两次。不过，你可以改变这种行为，让Glide既缓存全尺寸又缓存其他尺寸： 1234Glide.with(this) .load("http://nuuneoi.com/uploads/source/playstore/cover.jpg") .diskCacheStrategy(DiskCacheStrategy.ALL) .into(ivImgGlide); 下次在任何ImageView中加载图片的时候，全尺寸的图片将从缓存中取出，重新调整大小，然后缓存。Glide的这种方式优点是加载显示非常快。而Picasso的方式则因为需要在显示之前重新调整大小而导致一些延迟，即便你添加了这段代码来让其立即显示： 12// Picasso.noFade(); Picasso和Glide各有所长，你根据自己的需求选择合适的。对我而言，我更喜欢Glide，因为它远比Picasso快，虽然需要更大的空间来缓存。（从上图也可以看出，Glide加载速度远快于Picasso） 特性你可以做到几乎和Picasso一样多的事情，代码也几乎一样。 Image Resizing12345// Picasso.resize(300, 200); //Glide.override(300, 200); Center Cropping12345// Picasso.centerCrop(); // Glide.centerCrop(); Transforming12345// Picasso.transform(new CircleTransform()) // Glide.transform(new CircleTransform(context)) 设置占位图或者加载错误图1234567// Picasso.placeholder(R.drawable.placeholder).error(R.drawable.imagenotfound) // Glide.placeholder(R.drawable.placeholder).error(R.drawable.imagenotfound) 几乎和Picasso一样，从Picasso转换到Glide对你来说就是小菜一碟。 有什么Glide可以做而Picasso做不到Glide可以加载GIF动态图，而Picasso不能。 同时因为Glide和Activity/Fragment的生命周期是一致的，因此gif的动画也会自动的随着Activity/Fragment的状态暂停、重放。Glide 的缓存在gif这里也是一样，调整大小然后缓存。但是从我的一次测试结果来看Glide 动画会消费太多的内存，因此谨慎使用。除了gif动画之外，Glide还可以将任何的本地视频解码成一张静态图片。还有一个特性是你可以配置图片显示的动画，而Picasso只有一种动画：fading in。最后一个是可以使用thumbnail()产生一个你所加载图片的thumbnail。其实还有一些特性，不过不是非常重要，比如将图像转换成字节数组等。 配置有许多可以配置的选项，比如大小，缓存的磁盘位置，最大缓存空间，位图格式等等。可以在这个页面查看这些配置Configuration 。 库的大小Picasso (v2.5.1)的大小约118kb，而Glide (v3.5.2)的大小约430kb。 Anyway 312KB difference might not be that significant.不过312kb的差距并不是很重要。Picasso和Glide的方法个数分别是840和2678个。 必须指出，对于DEX文件65535个方法的限制来说，2678是一个相当大的数字了。建议在使用Glide的时候开启ProGuard。 总结Glide和Picasso都是非常完美的库。Glide加载图像以及磁盘缓存的方式都要优于Picasso，速度更快，并且Glide更有利于减少OutOfMemoryError的发生，GIF动画是Glide的杀手锏。不过Picasso的图片质量更高。你更喜欢哪个呢？虽然我使用了很长时间的Picasso，但是我得承认现在我更喜欢Glide。我的建议是使用Glide，但是将Bitmap格式换成 ARGB_8888、让Glide缓存同时缓存全尺寸和改变尺寸两种。]]></content>
      <categories>
        <category>Android</category>
        <category>Glide</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 完美修改应用包名]]></title>
    <url>%2Fposts%2F9b574dca.html</url>
    <content type="text"><![CDATA[我们平时新建项目有些朋友可能当时就是随意写的一个包名，然后在项目过程中， 又感觉这个包名不太好，所以就要对包名进行修改。 修改最外层包名 修改中间层包名 看到没有，我们只需要在setting里面，把 compact empty middle packages 这个选项去掉，这样，我们的包的层次结构就分开了，这个时候我们就可以根据自己的需要去做相应的修改了。 新增：Studio 3.0 之后，setting 中的选项名字该成了 Hide empty middle packages 另外说明一点，在 Studio 里面我们的 getPackageName 对应的是 applicationId , 而manifest 的那个package，在这里的作用其实是为了引用内部资源文件，以及保证 Activity 等源文件的路径正确而已，所以，在 Studio 中修改发布程序包名，则只需要在 build 文件中修改 applicationId 就可以了。 补充在 Studio 3.0 还有一种可直接通过 Androidmenifest 修改部分包名的方法（亲测过）。这里就不上图了。语言给大家描述一下，有什么问题可以博客下方留言。 修改流程如下：进入 Androidmanifest.xml 文件，找到 package 名称，选中需要修改的部分。比如原包名为com.zm.android如果需要修改中间的 zm ，那么我们就选中 zm ,依次进行 右键 - &gt; Refactor -&gt; Rename , (Mac 快捷键为 fn + shift+F6)然后选择 Rename package , 输入要修改目标的名称 ，直接点击 Refactor , 左下方继续点击 Do Refactor , 等待修改成功~！]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿支付宝首页应用管理(拖拽排序，添加删除)]]></title>
    <url>%2Fposts%2Fed9fc033.html</url>
    <content type="text"><![CDATA[MenuManage-Imitate-Alipay仿支付宝首页应用管理(拖拽排序，添加删除) 效果图 Download Demo]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debug.keystore的SHA1和MD5]]></title>
    <url>%2Fposts%2F1a48ee1.html</url>
    <content type="text"><![CDATA[切换到debug.keystore目录1cd ~/.android/ 查看debug.keystore的SHA1和MD5接着输入如下命令 1keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android 结果如下图]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android解决qq分享后返回程序出现的Bug]]></title>
    <url>%2Fposts%2Fa03cc66a.html</url>
    <content type="text"><![CDATA[问题：当我们使用qq分享时，分享成功后选择留在qq,这个时候按home键，回到手机主界面，在点击回到我的app,这个时候会出现界面显示出来了，但是任何事件都不响应，即按钮没反应。 分析：这个时候回到我们的app时，会发现activity的生命周期只走了 onRestart()—onStart(),走到这里就结束了，onResume()并没有执行，所以界面不响应 这个时候我们又会发现qq分享用到的的一个AssistActivity 它的生命周期：.: –onActivityResult()—onStart()—onResume() 结论：至此，我们发现了原因，是这个AssistActivity的问题。 解决：我们可以在我们程序的onStart()方法判断一下，如果这个AssistActivity处在栈顶就把它清除掉。 123456789101112131415161718192021222324252627@Overrideprotected void onStart() &#123; super.onStart(); Log.i("---share----", "-----start"); if(isNeedRestart())&#123; Intent intent = new Intent(context, this.getClass()); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); //清除栈顶的activity intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);//不显示多余的动画，假装没有重新启动 //记得带需要的参数 startActivity(intent); &#125;&#125;private boolean isNeedRestart()&#123; ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; tasks = am.getRunningTasks(1); if (!tasks.isEmpty()) &#123; ComponentName topActivity = tasks.get(0).topActivity; ActivityManager.RunningTaskInfo taskInfo = tasks.get(0); if (topActivity.getPackageName().equals(context.getPackageName())) &#123; // 若当前栈顶界面是AssistActivity，则需要手动关闭 if (topActivity.getClassName().equals("com.tencent.connect.common.AssistActivity")) return true; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-仪表盘控件仿芝麻信用]]></title>
    <url>%2Fposts%2F8a91974c.html</url>
    <content type="text"><![CDATA[前言由于项目需要使用到仪表盘图表，所以就本着一贯的操作流程就来github上面找，结果发现很多图表或者不是我需要的或者扩展性不强，所以就自己动手写了一个扩展性较强的，希望能帮助到有需要的人。（不过本人能力有限，有不足的地方还请见谅） 效果来源：Github传送门 先定个小目标由于每个公司的UI肯定都有不同的想法，设计出来的效果图也千奇百怪。所以我一开始的想法是能写一个基类的仪表盘图表，不需要懂得太多的自定义View知识也能做出UI所需要的效果。 我就想尝试着能不能自己写一个，万一能帮助到其他人呢。（梦想还是要有的） 所以我就抽取了一个BaseDashboardView类，并实现了三个Style的仪表盘图表。而这三个仪表盘除去一些画笔的初始化和参数的设置，绘制的代码都在70行内。下面就来看一下如何定义一个自己的仪表盘图表吧。 然后去做吧创建一个View然后去继承 BaseDashboardView 这时需要实现以下方法： 123456789protected abstract void initView();protected abstract void initArcRect(float left, float top, float right, float bottom);protected abstract void drawArc(Canvas canvas, float arcStartAngle, float arcSweepAngle);protected abstract void drawProgressArc(Canvas canvas, float arcStartAngle, float progressSweepAngle);protected abstract void drawText(Canvas canvas, int value, String valueLevel, String currentTime); 然后让我们来看看每个方法都是什么用的。 initView() 就是初始化设置，如创建画笔等。 initArcRect(float left, float top, float right, float bottom) 在我们绘制圆弧的时候可以传入Rect对象来确定圆弧的绘制范围，需要这里就是给我们初始化圆弧的区域的。 如:mRectArc = new RectF(left, top, right, bottom); drawArc(Canvas canvas, float arcStartAngle, float arcSweepAngle)这是就是开始正式的绘制背景圆弧了，arcStartAngle表示圆弧的起始角度，arcSweepAngle表示圆环一共多少度。我们通过刚才的Rect就可以绘制出一个圆弧如：canvas.drawArc(mRectOuterArc, arcStartAngle, arcSweepAngle, false, mPaintArc);但是要主要画笔的样式要设置为Paint.Style.STROKE drawProgressArc(Canvas canvas, float arcStartAngle, float progressSweepAngle)而这里是绘制进度圆弧的地方，progressSweepAngle进度的幅度已经在BaseDashboardView中计算好，只需要通过drawArc中的一样绘制个圆弧就行。 drawText(Canvas canvas, int value, String valueLevel, String currentTime)在这里可以把文字绘制到你想要他出现的地方就OK拉。数据已经在BaseDashboardView中处理过，直接绘制就可以。 由于很多逻辑的计算和动画都是在BaseDashboardView中去实现，所以我们只需要实现这几个方法，然后实现一些绘制的逻辑就可以咯。如果在绘制方面有什么问题的可以查看一下3个样式的DashboardView，如果是对底层的计算有兴趣的可以看一下BaseDashboardView。 接下来就去扩展这里主要说一个方法setCalibration(int[] calibrationNumberText, String[] calibrationBetweenText,int largeCalibrationBetweenNumber) 然后主要说一下calibrationNumberText和calibrationBetweenText参数，他们的初始默认值是 int[]{350, 550, 600, 650, 700, 950}和String[]{&quot;较差&quot;, &quot;中等&quot;, &quot;良好&quot;, &quot;优秀&quot;, &quot;极好&quot;} 那这样其实组成了一个区间 350 较差 550 中等 600 良好 650 优秀 700 极好 950 他的意思为350-550的为较差，其他依次类推，但是每个区间的大小是不一样的，较差的区间为550-350=200，而中等区间为650-550=50。但是每个区间在图表上显示的区域大小确实相同的。那么在计算进度幅度的时候需要区别计算。 而我的实现方式是首先判断当前value在第几个区间中，如当前value=575。那么通过循环的方式可以知道当前value处在550和600之间。然后通过 (575 - 550) / (600 - 550)公式计算出当前值在这个区间内占的百分比。然后通过每个区间的角度算出当前进度条的幅度。 而除了刻度的扩展其实还有很多其他的可配置项，可以通过github进行查看。 公共方法介绍12345678910111213141516171819202122232425262728293031323334353637//设置当前数值 value:数值 isAnim:是否开启东湖 reset:是否从头开始进行动画setValue(int value, boolean isAnim, boolean reset)//设置动画时长 (默认为2.5秒)setProgressAnimTime(long time)//设置圆弧角度 //arcStartAngle:起始角度 (默认值: 165)//arcSweepAngle:圆弧度数 (默认值: 210)setArcAngle(float arcStartAngle,float arcSweepAngle)&#123;//设置刻度属性//calibrationNumberText 每个大刻度对应的数值 (默认值: int[]&#123;350, 550, 600, 650, 700, 950&#125;)//calibrationBetweenText 每个大刻度中间的文字 (默认值: String[]&#123;"较差", "中等", "良好", "优秀", "极好"&#125;)//largeCalibrationBetweenNumber 两个大刻度中间有多少个小刻度 (默认值: 3)setCalibration(int[] calibrationNumberText, String[] calibrationBetweenText,int largeCalibrationBetweenNumber)//设置日期格式化的格式 (默认值: yyyy-MM-dd)setDatePattern(String pattern)//设置时间的显示格式 格式(如: 评估时间：&#123;date&#125;) &#123;date&#125;为占位符setDateStrPattern(String pattern)//设置数值等级的模板 格式(如: 信用&#123;level&#125;) &#123;level&#125;为占位符setValueLevelPattern(String pattern)//设置数值的画笔属性 (默认值: 60sp white)setValuePaint(float spSize, @ColorInt int color)//设置数值等级的画笔属性 (默认值: 25sp white)setValueLevelPaint(float spSize, @ColorInt int color)//设置日期对应的画笔属性 (默认值: 10sp white)setDatePaint(float spSize, @ColorInt int color)//设置中间文字中间的间距 (默认值: 7dp)setTextSpacing(int spacingDp) Style 1 1234567891011121314151617181920212223242526//设置圆环之间的距离 (默认值: 15dp)setArcSpacing(float dpSize)//设置外环的画笔属性 (默认值: 3dp Color.argb(80, 255, 255, 255))setOuterArcPaint(float dpSize, @ColorInt int color)//设置内环的画笔属性(默认值: 10dp Color.argb(80, 255, 255, 255))setInnerArcPaint(float dpSize, @ColorInt int color)//设置进度条的颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressArcColor(@ColorInt int color)//设置进度条的点的画笔属性 (默认值: 3dp white)setProgressPointPaint(float dpRadiusSize,@ColorInt int color)//设置大刻度的画笔属性 (默认值: 2dp Color.argb(200, 255, 255, 255))setLargeCalibrationPaint(float dpSize, @ColorInt int color)//设置小刻度的画笔属性 (默认值: 0.5dp Color.argb(100, 255, 255, 255))setSmallCalibrationPaint(float dpSize, @ColorInt int color)//设置刻度文字的画笔属性 (默认值: 10sp white)setCalibrationTextPaint(float spSize, @ColorInt int color)//设置大刻度中间的数值等级的画笔属性 (默认值: 10sp white)setCalibrationBetweenTextPaint(float spSize, @ColorInt int color) Style 2 12345678//设置圆环颜色 (默认值: Color.argb(120, 255, 255, 255))setArcColor(@ColorInt int color)//设置进度圆环的颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressColor(@ColorInt int color)//设置圆环的刻度大小 (默认值: 2.5dp)setArcCalibrationSize(int dpSize) Style 3 1234567891011121314151617181920212223//设置圆环之间的距离 (默认值: 10dp)setArcSpacing(float dpSize)//设置外环的画笔属性 (默认值: 1.5dp Color.argb(80, 255, 255, 255))setOuterArcPaint(float dpSize, @ColorInt int color)//设置外环的进度颜色 (默认值: Color.argb(200, 255, 255, 255))setProgressOuterArcColor(@ColorInt int color)//设置内环的画笔属性 (默认值: 1.5dp Color.argb(50, 255, 255, 255))setInnerArcPaint(float dpSize, @ColorInt int color)//设置内环的进度颜色 (默认值: Color.argb(170, 255, 255, 255))setProgressInnerArcPaint(@ColorInt int color)//设置内环实线和虚线状态 (默认值: float[] &#123; 10, 10 &#125;)setInnerArcPathEffect(float[] intervals)//设置进度点的画笔属性 (默认值: 3dp white)setProgressPointPaint(float dpRadiusSize,@ColorInt int color)//设置指示器颜色 (默认值: Color.argb(200, 255, 255, 255))setIndicatorPaint(@ColorInt int color)]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中多线程切换的几种方法]]></title>
    <url>%2Fposts%2Ffbda19a9.html</url>
    <content type="text"><![CDATA[我们知道，多线程是Android开发中必现的场景，很多原生API和开源项目都有多线程的内容，这里简单总结和探讨一下常见的多线程切换方式。我们先回顾一下Java多线程的几个基础内容，然后再分析总结一些经典代码中对于线程切换的实现方式。 几点基础多线程切换，大概可以切分为这样几个内容：如何开启多个线程，如何定义每个线程的任务，如何在线程之间互相通信。 ThreadThread可以解决开启多个线程的问题。Thread是Java中实现多线程的线程类，每个Thread对象都可以启动一个新的线程，注意是可以启动，也可以不启动新线程： 12thread.run();//不启动新线程，在当前线程执行thread.start();//启动新线程。 另外就是Thread存在线程优先级问题，如果为Thread设置较高的线程优先级，就有机会获得更多的CPU资源，注意这里也是有机会，优先级高的Thread不是必然会先于其他Thread执行，只是系统会倾向于给它分配更多的CPU。默认情况下，新建的Thread和当前Thread的线程优先级一致。设置线程优先级有两种方式： 12thread.setPriority(Thread.MAX_PRIORITY);//1~10，通过线程设置Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);//-20~19，通过进程设置 这两种设置方式是相对独立的，在Android中，一般建议通过Process进程设置优先级。 ThreadPoolThread本身是需要占用内存的，开启/销毁过量的工作线程会造成过量的资源损耗，这种场景我们一般会通过对资源的复用来进行优化，针对IO资源我们会做IO复用（例如Http的KeepAlive），针对内存我们会做内存池复用（例如Fresco的内存池），针对CPU资源，我们一般会做线程复用，也就是线程池。所以，在Android开发中，一般不会直接开启大量的Thread，而是会使用ThreadPool来复用线程。 RunnableRunnable主要解决如何定义每个线程的工作任务的问题。Runnable是Java中实现多线程的接口，相对Thread而言，Runnable接口更容易扩展（不需要单继承），而且，Thread本身也是一种Runnable： 1public class Thread implements Runnable &#123; 相比Thread而言，Runnable不关注如何调度线程，只关心如何定义要执行的工作任务，所以在实际开发中，多使用Runnable接口完成多线程开发。 CallableCallable和Runnable基本类似，但是Callable可以返回执行结果。 线程间通信Thread和Runnable能实现切换到另一个线程工作（Runnable需要额外指派工作线程），但它们完成任务后就会退出，并不注重如何在线程间实现通信，所以切换线程时，还需要在线程间通信，这就需要一些线程间通信机制。 Future一般来说，如果要做简单的通信，我们最常用的是通过接口回调来实现。Future就是这样一种接口，它可以部分地解决线程通信的问题，Future接口定义了done、canceled等回调函数，当工作线程的任务完成时，它会（在工作线程中）通过回调告知我们，我们再采用其他手段通知其他线程。 123456mFuture = new FutureTask&lt;MyBizClass&gt;(runnable) &#123; @Override protected void done() &#123; ...//还是在工作线程里 &#125;&#125;; ConditionCondition其实是和Lock一起使用的，但如果把它视为一种线程间通信的工具，也说的通。因为，Condition本身定位就是一种多线程间协调通信的工具，Condition可以在某些条件下，唤醒等待线程。 1234567 Lock lock = new ReentrantLock(); Condition notFull = lock.newCondition(); //定义Lock的Condition... while (count == items.length) notFull.await();//等待condition的状态... notFull.signal();//达到condition的状态 Handler其实，最完整的线程间通信机制，也是我们最熟悉的线程间通信机制，莫过于Handler通信机制，Handler利用线程封闭的ThreadLocal维持一个消息队列，Handler的核心是通过这个消息队列来传递Message，从而实现线程间通信。 AsyncTask的多线程切换回顾完多线程的几个基础概念，先来看看简单的多线程切换，Android自带的AsyncTask。AsyncTask主要在doInBackground函数中定义工作线程的工作内容，在其他函数中定义主线程的工作内容，例如onPostExecute，这里面必然涉及两个问题：1.如何实现把doInBackground抛给工作线程2.如何实现把onPostExecute抛给主线程其实非常简单，我们先看第一个 1.如何实现把doInBackground抛给工作线程在使用AsyncTask时，我们一般会创建一个基于AsyncTask的扩展类或匿名类，在其中实现几个抽象函数，例如： 1234567891011private class MyTask extends AsyncTask&lt;String, Object, Long&gt; &#123; @Override protected void onPreExecute() &#123;... &#125; @Override protected Long doInBackground(String... params) &#123;... &#125; @Override protected void onProgressUpdate(Object... values) &#123;... &#125; @Override protected void onPostExecute(Long aLong) &#123;... &#125; @Override protected void onCancelled() &#123;... &#125; 然后，我们会实例化这个AsyncTask： 1MyTask mTask = new MyTask(); 在AsyncTask源码中，我们看到，构造函数里会创建一个WorkerRunnable： 123456public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;//这是一个Callable public Result call() throws Exception &#123; ... result = doInBackground(mParams);//在工作线程中执行 ... WorkerRunnable实际上是一个Callable对象，所以，doInBackground是被包在一个Callable对象中了，这个Callable还会被继续包装，最终被交给一个线程池去执行： 12345Runnable mActive;...if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive);//交给线程池执行&#125; 梳理一下，大致过程为：定义doInBackground–&gt;被一个Callable调用–&gt;层层包为一个Runnable–&gt;交给线程池执行。这样就解决了第一个问题，如何实现把doInBackground抛给工作线程。我们再来看第二个问题。 2.如何实现把onPostExecute抛给主线程首先，我们要知道工作任务何时执行完毕，就需要在工作完成时触发一个接口回调，也就是前面说过的Future，还是看AsyncTask源码： 123456789101112131415public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; ... &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123;//Future的回调 try &#123; postResultIfNotInvoked(get());//get()是FutureTask接口函数 ... &#125; &#125;; &#125; 这样，我们就知道可以处理onPostExecute函数了，但是，我们还需要把它抛给主线程，主要源码如下： 1234567891011121314151617181920212223242526272829303132//mWorker、mFuture和都会指向postResult函数private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125;//getHandler()会指向InternalHandlerprivate static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper());//指向MainLooper &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]);//通过handler机制，回到主线程，调用finish函数 ...&#125;//在Handler中，最终会在主线程中调用finishprivate void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result);//调用onPostExecute接口函数 &#125; mStatus = Status.FINISHED;&#125; 从源码可以看到，其实AsyncTask还是通过Handler机制，把任务抛给了主线程。 总体来说，AsyncTask的多线程任务是通过线程池实现的工作线程，在完成任务后利用Future的done回调来通知任务完成，并通过handler机制通知主线程去执行onPostExecute等回调函数。 EventBus的多线程切换EventBus会为每个订阅事件注册一个目标线程，所以需要从发布事件的线程中，根据注册信息，实时切换到目标线程中，所以，这是个很典型的多线程切换场景。根据EventBus源码，多线程切换的主要判断代码如下： 123456789101112131415161718192021222324switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event);//直接在当前线程执行 break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event);//在当前主线程执行 &#125; else &#123; mainThreadPoster.enqueue(subscription, event);//当然不是主线程，交给主线程执行 &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event);//当前线程为主线程，交给工作线程 &#125; else &#123; invokeSubscriber(subscription, event);//直接在当前工作线程执行 &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event);//异步执行 break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);&#125; 所以，在EventBus里，如果需要做线程间切换，主要是抛给不同的任务队列，实现线程间切换。从任务队列判断，切换目标包括主线程Poster、backgroundPoster和asyncPoster这样三种。我们先看任务队列的设计： 任务队列因为EventBus不能判断有哪些任务会并行，所以它采用了队列的设计，多线程任务（EventBus的事件）会先进入队列，然后再处理队列中的工作任务，这是典型的生产–消费场景。主线程Poster、backgroundPoster和asyncPoster都是任务队列的不同实现。 主线程Poster负责处理主线程的mainThreadPoster是Handler的子类： 1234567891011121314final class HandlerPoster extends Handler &#123;... void enqueue(Subscription subscription, Object event) &#123; ... synchronized (this) &#123;//因为主线程只有一个，需要线程安全 queue.enqueue(pendingPost); ... if (!sendMessage(obtainMessage())) &#123;//作为handler发送消息 ... //在主线程中处理消息 @Override public void handleMessage(Message msg) &#123; ...&#125; 从源码可以看出，这个Poster其实是一个Handler，它采用了哪个线程的消息队列，就决定了它能和哪个线程通信，我们确认一下： 123EventBus(EventBusBuilder builder) &#123; ... mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);//获取主线程的MainLooper 所以，EventBus是扩展了一个Handler，作为主线程的Handler，通过Handler消息机制实现的多线程切换。当然，这个Handler本事，又多了一层queue。 backgroundPoster和asyncPosterbackgroundPoster和asyncPoster其实都是使用了EventBus的线程池，默认是个缓存线程池： 1private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool(); 所以，backgroundPoster和asyncPoster都是把任务交给线程池处理，这样实现的多线程切换。不过，backgroundPoster和asyncPoster也有一些不同，我们知道，在newCachedThreadPool中，最大线程数就是Integer的最大值，相当于不设上限，所以可以尽可能多的启动线程，asyncPoster就是这样做的，enqueu和run都没做同步，为每个事件单独开启新线程处理。而在backgroundPoster中，可以尽量复用线程，主要方法是在run的时候，做个1秒的等待： 1234@Overridepublic void run() &#123; ... PendingPost pendingPost = queue.poll(1000);//允许等待1秒 因为做了这一秒的挂起等待，在enqueue和run时，都需要用synchronized (this) 来确保线程安全。 另外，其实这里面还有个很重要的用法，就是Executors.newCachedThreadPool()中的SynchronousQueue： 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());//用于辅助线程切换的阻塞队列&#125; 这个SynchronousQueue，在OkHttp中也使用了： 12345678//okhttp3.Dispatcher源码public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false));//用于辅助线程切换的阻塞队列 &#125; return executorService;&#125; SynchronousQueue与普通队列不同，不是数据等线程，而是线程等数据，这样每次向SynchronousQueue里传入数据时，都会立即交给一个线程执行，这样可以提高数据得到处理的速度。 总的来看，EventBus还是采用线程池实现工作线程，采用handler机制通知到主线程。不同在于，它采用的queue的队列方式来管理所有的跨线程请求，而且它利用了SynchronousQueue阻塞队列来辅助实现线程切换。 RxJava的多线程切换其实在多线程管理这方面，RxJava的线程管理能力是非常令人赞叹的。RxJava的主要概念是工作流，它可以把一序列工作流定义在一个线程类型上： 123myWorkFlow.getActResponse(myParam) .subscribeOn(Schedulers.io())//指定线程 .xxx//其他操作 这个构建工作流的过程其实挺复杂的，不过如果我们只看线程操作这部分，其实流程非常清晰，我们追踪一下subscribeOn的源码（RxJava2）： 12345678910//进入subscribeOnpublic final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return subscribeOn(scheduler, !(this instanceof FlowableCreate));&#125;//继续进入subscribeOnpublic final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler, boolean requestOn) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new FlowableSubscribeOn&lt;T&gt;(this, scheduler, requestOn));&#125; 然后，进入FlowableSubscribeOn类 1234567891011121314//进入FlowableSubscribeOn类 public FlowableSubscribeOn(Flowable&lt;T&gt; source, Scheduler scheduler, boolean nonScheduledRequests) &#123; ... this.scheduler = scheduler; ...&#125;@Overridepublic void subscribeActual(final Subscriber&lt;? super T&gt; s) &#123; Scheduler.Worker w = scheduler.createWorker();//根据参数值，如Schedulers.io()创建worker final SubscribeOnSubscriber&lt;T&gt; sos = new SubscribeOnSubscriber&lt;T&gt;(s, w, source, nonScheduledRequests);//根据worker创建SubscribeOnSubscriber s.onSubscribe(sos); w.schedule(sos);&#125; 这个SubscribeOnSubscriber是个内部类： 1234567891011 SubscribeOnSubscriber(Subscriber&lt;? super T&gt; actual, Scheduler.Worker worker, Publisher&lt;T&gt; source, boolean requestOn) &#123; ... this.worker = worker; ... &#125;... void requestUpstream(final long n, final Subscription s) &#123; ... worker.schedule(new Request(s, n));//worker会安排如何执行runnable（Request是一个runnable） ... &#125; 而这个worker，其实就是我们输入的线程参数，如Schedulers.io()，这个io是这样定义的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//io.reactivex.schedulers.Schedulers源码 static &#123; SINGLE = RxJavaPlugins.initSingleScheduler(new SingleTask()); COMPUTATION = RxJavaPlugins.initComputationScheduler(new ComputationTask()); IO = RxJavaPlugins.initIoScheduler(new IOTask()); TRAMPOLINE = TrampolineScheduler.instance(); NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask()); &#125;... static final class IOTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return IoHolder.DEFAULT; &#125; &#125; static final class NewThreadTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return NewThreadHolder.DEFAULT; &#125; &#125; static final class SingleTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return SingleHolder.DEFAULT; &#125; &#125; static final class ComputationTask implements Callable&lt;Scheduler&gt; &#123; @Override public Scheduler call() throws Exception &#123; return ComputationHolder.DEFAULT; &#125; &#125;... static final class SingleHolder &#123; static final Scheduler DEFAULT = new SingleScheduler(); &#125; static final class ComputationHolder &#123; static final Scheduler DEFAULT = new ComputationScheduler(); &#125; static final class IoHolder &#123; static final Scheduler DEFAULT = new IoScheduler(); &#125; static final class NewThreadHolder &#123; static final Scheduler DEFAULT = new NewThreadScheduler(); &#125; 这里的IO，最终会指向一个Scheduler，如IoScheduler： 1234567891011121314//io.reactivex.internal.schedulers.IoScheduler源码... static final class EventLoopWorker extends Scheduler.Worker &#123;//Scheduler.Worker的实现类 ... @NonNull @Override public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) &#123; if (tasks.isDisposed()) &#123; // don't schedule, we are unsubscribed return EmptyDisposable.INSTANCE; &#125; return threadWorker.scheduleActual(action, delayTime, unit, tasks);//交给线程池 &#125; 这样，Scheculer中的具体任务就交给了某个线程池来处理。 需要特别说明的是，RxJava中调用Android主线程(AndroidSchedulers.mainThread)，其实还是使用了Handler机制： 123public final class AndroidSchedulers &#123; ... static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper())); 这个HandlerScheduler其实就是实现了Scheduler和Scheduler.Worker内部类。 123456789101112final class HandlerScheduler extends Scheduler &#123;private final Handler handler;HandlerScheduler(Handler handler) &#123; this.handler = handler;&#125;private static final class HandlerWorker extends Worker &#123; ... @Override public Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; ... handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); 总的来看，RxJava的多线程切换其实是利用了Scheculer.Worker这个内部类，把任务交给Scheculer的Worker去做，而这个Scheculer的Worker是根据定义的线程来实现了不同的线程池，其实还是交给线程池去处理了。至于主线程，RxJava也是使用了Handler机制。 总结小小总结一下，基本上来说，Android中的多线程切换，主要使用Runnable和Callable来定义工作内容，使用线程池来实现异步并行，使用Handler机制来通知主线程，有些场景下会视情况需要，使用Future的接口回调，使用SynchronousQueue阻塞队列等。 原文链接：mp.weixin.qq.com]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android珍藏】推荐10个炫酷的开源库]]></title>
    <url>%2Fposts%2F78b41fa0.html</url>
    <content type="text"><![CDATA[前言技术群里面经常有人问到一些炫酷的UI效果实现方法，有时候我都是给一个相同或者相似效果的Github链接，有同学私信给我说，大佬，怎么这些效果你都能找到？你是怎么搜索的，或者有其他什么秘方？会利用Google、百度等搜索工具搜索是一方面，另一个重要的方面是：记录搜藏，当看到一个炫酷的效果的时候，记得收藏起来，记录到自己云笔记或者收藏夹里，看得多了，印象就比较深刻，当遇到类似效果的时候，到自己记录收藏的地方找就是了。今天为大家推荐我所收藏的一些炫酷实用的效果的开源库（选择其中10个）。 1、 DiscreteScrollView简介： DiscreteScrollView是基于RecyclerView 实现的一个横向滑动列表，当前Item显示在屏幕中央并且可以左右滑动，有点像ViewPager,但是可以快速滑动。提供了简单的API来实现炫酷的动画效果。 效果展示： 2、MaterialViewPager简介： 和名字一样，Material Design 效果的ViewPager, 效果很nice,请看gif 效果展示(有多重模式)： Titlebar Logo Fading Logo Hide Logo and Toolbar Sticky Toolbar Transparent Toolbar Standard 3、BoomMenu简介： 传统的菜单是不是看得有些厌倦了，boom ….爆炸效果的菜单了解一下？功能强大、效果炫酷，有很多种模式。 效果展示： 4、LayoutManagerGroup简介： 自定义RecyclerView 的LayoutManager实现几种炫酷的效果。 效果展示： EchelonLayoutManager SkidRightLayoutManager SlideLayoutManager 5、Android-SpinKit简介： Android 自定义View 的方式实现的各种炫酷的动画，特别精致和优美，以前专门写文章介绍过。 效果展示： 6、Matisse简介： Matisse是知乎开源的一个本地选择照片和视频的库，UI设计得非常精美。有如特性： 可以在Fragment/Activity 中使用 选择照片的格式包括：PNG、JPEG 、GIF.视频格式包括：MPEG, MP4 支持不同的主题并且可以自定义主题 支持不同的图片加载方式（Picasso、Glide等） 自定义过滤规则 效果展示： Zhihu Style Dracula Style Preview 7、CosmoCalendar简介： 一个高度自定义的日历库，UI精美，支持多种模式。 效果展示： 单个日期选择 多个日期选择 选择一个范围日期 自定义 8、CardStackView简介： 三种炫酷的列表卡片滑动动画，分别为：alldown, updown, updownstack 效果展示： 9、CalendarExaple简介： 这是一个高仿钉钉和小米的日历控件，支持快速滑动，界面缓存。想要定制化UI，使用起来非常简单，就像使用ListView一样 一些特点： 可以自定义日历控件UI 支持快速滑动 支持农历和阳历 界面UI缓存和日历数据缓存 扩展view支持listView的滑动 效果展示： 10、MZBannerView简介： 仿魅族BannerView,图片轮播控件,支持多种模式切换：普通ViewPager使用，普通Banner使用，仿魅族Banner使用。 效果展示： 结尾在我们平时的工作、学习中，要养成记笔记的好习惯、好记性不如烂笔头。平时自己遇到一些炫酷的效果，我都喜欢记录到笔记中，遇到相似的需求就好找了。本文这些炫酷的效果有兴趣的可以去对应的Github 查看使用方式，试试效果，都挺赞的。]]></content>
      <categories>
        <category>Android</category>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网易严选App感受Weex开发]]></title>
    <url>%2Fposts%2F926ca595.html</url>
    <content type="text"><![CDATA[此处是 demo 源码：https://github.com/zwwill/yanxuan-weex-demo 不得不说，使用 Weex 开发 app 对于我们纯前端人员来说，是件「很爽」的事情，只要你熟悉了他的语法，基本可以做到一周上手写 app。极其适合交互要求不高，时间紧迫，人手不足的同构开发需求。 但是，当然有但是，如果你想写出一个完美的 app，你就需要在性能优化上下很大的功夫，包括动画的优化，过场的优化，图片的优化，细节的打磨等等，再者，就是你需要掌握或者「能写」一些原生的代码，不然有些功能你是实现不了的，比如 status bar 的属性更改，开场动画的制作，内存的回收，webview 的监听等等。 下面我们具体讲讲入门知识 Weex 提供了多端一致的技术方案。 首先，Weex 的开发和 web 开发体验可以说是几乎一样。包括语法设计和工程链路等。 其次，Weex 的组件、模块设计都是 iOS、Android、Web 的开发者共同讨论出来的，有一定的通用性和普遍性。 Weex 开发同一份代码，可以在不同的端上分别执行，避免了多端的重复研发成本。 在同构这条路上，Weex 比 React Native做得更彻底，他「几乎」做到了，「你来使用 vue 写一个webapp，我顺便给你编译成了 ios 和 android 的原生 app」 至于为什么要造这个轮子，官方给了以下说法 1、今天在技术社区有大量的 web 开发者，Weex 可以赋能更多的 web 开发者构建高性能和高体验的移动应用。2、Web 开发本身具有非常强的高效率和灵活性，这和 Weex 想解决的移动端动态性问题不谋而合。3、Web 标准和开发体验是很多顶尖而优秀的科技公司共同讨论和建设的结果，本身的设计和理念都有极高的品质保障4、同时 Weex 也希望可以借此机会努力为标准贡献一点自己的微薄之力。5、Web 是一种标准化的技术，标准本身就是一种力量，基于标准、尊重标准、贴近标准都意味着拥有更多的可能性。6、Web 今天的生态和社区是非常繁荣的，有很多成熟的工具、库、工程体系、最佳实践可以使用、引入和借鉴。 在我看来，Weex 其实是 Alibaba 团队提高生产效率的产物，在淘宝这类要求多端统一迭代快速的部门，三端约定一种便于统一的规范，在加上时间的发酵，渐渐的就有了此类脚手架的雏形，同时在脸书 React Native 开源带来的极大轰动后，自己也坐不住了吧^_^ 好了，闲话就说到这，下面就来让我们解剖一下WEEX的优劣良莠。 预科入门 Weex 前需要了解以下知识，这样能帮助你更快的掌握Node：《Node.js 教程》Vue：《Vue.js官方教程》ES6：《ECMAScript 6 入门》再者就是 ios 和 android 开发语法的入门和编辑器的使用 环境系统环境要求IOS : MacOS, 黑苹果Android :MacOS, Linux, Windows 配置环境你可以参考官方文档安装必须的依赖环境 http://weex.apache.org/cn/guide/set-up-env.html，也可以直接安装以下环境 node npm weex-toolkit Xcode 安装 Xcode IDE 和 Xcode 的命令行工具（IOS 开发依赖） Android Studio 下载必须的插件： a) JDK1.8+b) Show Package Detailsc) Android SDK Build Toolsd) Android Support Repository 配置基础环境：a) ANDROID_HOME （如运行是遇到问题可参考此文 http://www.jianshu.com/p/a77396301b22）b) JAVA_HOME Hello Weex官方文档上的入门 Hello world 是 web 端的，紧接着介绍了如何「集成 Weex 到已有应用」 但是，身为一个 web 前端开发者，如果你不懂原生语音的话，介绍这些并不能起到很好的引导作用，因为web前端开发者都有「一统前端界」的野心（Web+Android+IOS），「寄人篱下」只能是暂时的。 快速创建并运行一个纯 Weex App 对于「纯」前端同学来说，才是有意思的事儿。但： 为什么文档要这么设计也是跟Weex的定位有关的，读完下文后续你就慢慢懂了，后面我将做总结解释 如果你在官方教程里没有找到创建工程的教程，可以阅读此文《Weex 快速创建工程 Hello World》 Vue NativeWeex 在迭代的过程中选择了于 Vue 2.0 握手，因为该版本的 Vue 加入了 Virtual-DOM 和预编译器的设计，使得该框架在运行时能够脱离 HTML 和 CSS 解析，只依赖 JavaScript，如此，Vue 在和 Weex 合作后，便获得了使用 JS 预编译原生的组件 UI 的能力。 同 React Native 一样，有人也将 Weex 叫做 Vue Native。 如果你对 Vue 还不了解，可以先学习【预科】部分推荐的《Vue.js 官方教程》。 那么接下来我们讲讲，Vue 在 Weex 中的不同 Vue 在 Weex 中的不同虽说 Weex 使用 Vue 语言写的，但毕竟是需要在不同平台间运行的，虽然大部分语法都有支持，但是依然有部分语法是不同的 语法差异1、“html标签”目前 Weex 支持了基本的容器 (div)、文本 (text)、图片 (image)、视频 (video) 等组件，注意是组件，而不是标签，虽然使用起来跟 html 标签很像，至于其他标签基本可以使用以上组件组合而成。 2、Weex 环境中没有 DOM因为 Weex 解析 vue 得到的并不是 dom，而是原生布局树 3、支持有限的事件并不支持 Web 中所有的事件类型，详情请参考《通用事件》 4、没有 BOM 但可以调用原生 API在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。《clipboard 剪切板》《navigator 导航控制》《storage 本地存储 》为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块，具体的扩展方法请参考《iOS 扩展》 和《Android 扩展》。 样式差异Weex 中的样式是由原生渲染器解析的，出于性能和功能复杂度的考虑，Weex 对 CSS 的特性做了一些取舍1、Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。2、组件级别的作用域，为了保持 web 和 Native 的一致性，需要&lt;style scoped&gt;写法3、支持了基本的盒模型和 flexbox 布局，详情可参考Weex 通用样式文档。但是需要注意的是， 不支持display: none;可用opacity: 0;代替，（opacity&lt;=0.01时，元素可点透） 样式属性暂不支持简写（提高解析效率） flex 布局需要注意 web 的兼容性 css 不支持 3D 变换 Weex 开发&amp;调试Vue 语法举个栗子，以下是严选App Demo首页的简化代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;text class=&quot;iconfont&quot;&gt;&lt;/text&gt; &lt;home-header&gt;&lt;/home-header&gt; &lt;scroller class=&quot;main-list&quot; offset-accuracy=&quot;300px&quot;&gt; &lt;refresher&gt;&lt;/refresher&gt; &lt;div class=&quot;cell-button&quot; @click=&quot;jumpWeb(&apos;https://m.you.163.com&apos;)&quot;&gt; &lt;yx-slider :imageList=&quot;YXBanners&quot; &gt;&lt;/yx-slider&gt; &lt;/div&gt; &lt;div class=&quot;cell-button&quot;&gt; &lt;block-1 :title=&quot;block1.title&quot; :items=&quot;block1.items&quot;&gt;&lt;/block-1&gt; &lt;/div&gt; &lt;/scroller&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .iconfont &#123; font-family:iconfont; &#125; .main-list&#123; position: fixed; top: 168px; bottom: 90px; left: 0; right: 0; &#125;&lt;/style&gt;&lt;script&gt; var navigator = weex.requireModule(&apos;navigator&apos;); import util from &apos;../../src/assets/util&apos;; import Header from &apos;../components/Header.vue&apos;; import refresher from &apos;../components/refresh.vue&apos;; import YXSlider from &apos;../components/YXSlider.vue&apos;; import Block1 from &apos;../components/Block1.vue&apos;; export default &#123; components: &#123; &apos;home-header&apos;: Header, &apos;refresher&apos;: refresher, &apos;yx-slider&apos;: YXSlider, &apos;block-1&apos;: Block1 &#125;, data () &#123; return &#123; YXBanners: [ &#123; title: &apos;&apos;, src: &apos;http://doc.zwwill.com/yanxuan/imgs/banner-1.jpg&apos;&#125;, &#123; title: &apos;&apos;, src: &apos;http://doc.zwwill.com/yanxuan/imgs/banner-2.jpg&apos;&#125;, &#123; title: &apos;&apos;, src: &apos;http://doc.zwwill.com/yanxuan/imgs/banner-3.jpg&apos;&#125; ] &#125; &#125;, methods: &#123; jumpWeb (_url) &#123; const url = this.$getConfig().bundleUrl; navigator.push(&#123; url: util.setBundleUrl(url, &apos;page/web.js?weburl=&apos;+_url) , animated: &quot;true&quot; &#125;); &#125; &#125; &#125;&lt;/script&gt; 如果以上代码脱离工程单独出现，基本上是无法得知他是 Weex 工程。此处可切实感受到 Weex 的 web 开发体验 名存实亡的&lt;标签/&gt;1234567&lt;template&gt; &lt;div&gt; &lt;text v-for=&quot;(v, i) in list&quot; class=&quot;text&quot;&gt;&#123;&#123;v&#125;&#125;&lt;/text&gt; &lt;image style=&quot;&quot; src=&quot;&quot;&gt;&lt;/image&gt; &lt;video class=&quot;video&quot; :src=&quot;src&quot; autoplay controls @start=&quot;onstart&quot; @pause=&quot;onpause&quot; @finish=&quot;onfinish&quot; @fail=&quot;onfail&quot;&gt;&lt;/video&gt; &lt;/div&gt;&lt;/template&gt; Weex 工程中常用的标签有&lt;div /&gt;，&lt;text /&gt;，&lt;image /&gt;，&lt;video /&gt;（组件另算），由此四种标签基本可以满足绝大多数场景的需求，虽说此标签同 web 工程下的标签用法一致，但此处的标签已不再是我们前端口中常提的 html 标签，而且名存实亡的 Weex 标签，确切讲是 Weex 组件。 通过weex-loader、vue-loader、weex-vue-render的解析最终转换输出的便是实际的组件，有此设计只是为了完成「web开发体验」的目标。但是我们身为上层的开发人员要清楚自己每天「把玩」的到底是个什么「鬼」。 阉割版 CSS其实用阉割版来形容 Weex 的 css 支持度并不合适，但如果从「web开发体验」的角度来衡量，那么这个形容词也是可以理解的。（此处对 Weex 寄有厚望^_^） 单位Weex 中的所有 css 属性值的单位均为 px，也可省略不写，系统会默认为 px 单位。 选择器Weex 中只支持单个类名选择器，不支持关系选择器，也不支持属性选择器。 123456789101112/* 支持单个类名选择器 */.one-class &#123; font-size: 36px;&#125;/* 不支持关系选择器 */.parent &gt; .child &#123; padding-top: 10px;&#125;/* 不支持属性选择器，不支持 `v-cloak` 指令 */[v-cloak] &#123; color: #FF6600;&#125; 这个只是对样式定义的限制，不影响样式类名的使用，在标签中可以添加多个样式类名，如： 123&lt;template&gt; &lt;div class=&quot;one two three&quot;&gt;&lt;div&gt;&lt;/template&gt; 盒模型weex支持css基本的盒模型结构，但需要注意的是 box-sizing 属性值默认为 border-box margin，padding，border等属性暂不支持合并简写 FlexBoxWeex 中对 flexbox 布局支持度很高，但依然有部分属性并不支持，如 align-items:baseline;、align-content:space-around;、align-self:wrap_reverse;等。 具体 Weex 对 flexbox 的支持和布局算法，可通过此文进行了解由 FlexBox 算法强力驱动的 Weex 布局引擎，此处便不再赘述。 显隐性在 Weex 的 ios 和 android 端，并不支持 display 属性。 因此，不能使用 display:none; 来控制元素的显隐性，所以 vue 语法中的 v-show 条件渲染是不生效的。 我们可以使用 v-if 代替，或者用 opacity:0; 来模拟。 需要注意的是，ios和android端并不能使用 opacity:0; 来完全模拟 visibility: hidden;，因为，当opacity 的只小于等于 0.01 时，native 控件便会消失，占位空间还在，但用户无法进行交互操作，点击时会发生点透效果。 CSS 3Weex 支持 css3 属性，虽然支持并不够，但相较 React Native 的「不能用」已经是强大很多了。 以下几种属性我们在开发前需要知道她的支持度 transform：目前只支持 2D 转换 transition：v0.16.0+ 的 SDK 版本支持css过度动画，可根据情况配合内建组件 animation 实现动画交互 linear-gradient：目前只支持双色渐变色 font-family：Weex 目前只支持 ttf 和 woff 字体格式的自定义字体 第三方工具库由于使用了增强版的 webpak 打包工具 weexpack，支持第三方框架也是件自然而然的事情。 常用的有 vuex、vue-router 等，可根据项目实际情况引入需要的第三方工具库 npm 包管理npm 包管理是前端开发朋友们再熟悉不过的包管理方式了。这也是为什么 React Native 和 Weex 都选择这种管理方式的原因。 以下是本工程的 package.json 文件，这里就不做讲解了，不熟悉的朋友点这里-&gt;NPM 使用介绍 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;name&quot;: &quot;yanxuan-weex&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a weex project&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;build_plugin&quot;: &quot;webpack --config ./tools/webpack.config.plugin.js --color&quot;, &quot;dev&quot;: &quot;weex-builder src dist -w&quot;, &quot;serve&quot;: &quot;webpack-dev-server --config webpack.dev.js -p --open&quot; &#125;, &quot;keywords&quot;: [&quot;weex&quot;], &quot;author&quot;: &quot;zwwill&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.4.2&quot;, &quot;vue-router&quot;: &quot;^2.7.0&quot;, &quot;vuex&quot;: &quot;^2.1.1&quot;, &quot;vuex-router-sync&quot;: &quot;^4.3.0&quot;, &quot;weex-html5&quot;: &quot;^0.4.1&quot;, &quot;weex-vue-render&quot;: &quot;^0.11.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.21.0&quot;, &quot;babel-loader&quot;: &quot;^6.2.4&quot;, &quot;babel-plugin-add-module-exports&quot;: &quot;^0.2.1&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.9.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.9.0&quot;, &quot;babel-runtime&quot;: &quot;^6.9.2&quot;, &quot;css-loader&quot;: &quot;^0.26.1&quot;, &quot;history&quot;: &quot;^4.7.2&quot;, &quot;quick-local-ip&quot;: &quot;^1.0.7&quot;, &quot;vue-loader&quot;: &quot;^13.0.4&quot;, &quot;vue-template-compiler&quot;: &quot;^2.4.2&quot;, &quot;webpack&quot;: &quot;^2.7.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.4.2&quot;, &quot;weex-builder&quot;: &quot;^0.2.7&quot;, &quot;weex-loader&quot;: &quot;^0.4.5&quot;, &quot;weex-router&quot;: &quot;0.0.1&quot; &#125;&#125; UI 尺寸适配Weex 容器默认的显示宽度 (viewport) 是 750px，页面中的所有组件都会以 750px 作为满屏宽度。 这很像移动设备的逻辑像，比如 iPhone 6 的物理像素宽为 750，逻辑像素 Type iPhone 3G iPhone 4 iPhone 6 iPhone 6Plus 物理像素 320x480 640x960 750x1134 1080x1920 逻辑像素 320x480 320x480 375x667 414x736 像素比 @1x @2x @2x @3x 类比在 Weex 中，如果所有的显示宽度都是用默认值 750，那么显示出来的实际像素信息为 Type iPhone 3G iPhone 4 iPhone 6 iPhone 6Plus 物理像素 320x480 640x960 750x1134 1080x1920 显示像素 750x1125 750x1125 750x1134 750x1333 像素比 @0.427x @0.85x @1x @1.44x 所以我们在使用 Weex 做 UI 适配时就没有所谓的 @2x 图和 @3x 图，所有的尺寸都是Weex帮我们根据750 作为基数宽做的缩放。 当然，Weex 提供了改变此显示宽度的 API，setViewport，通过此方法可以改变页面的显示宽度，可以实现每个页面根据自己的需求改变基数逻辑尺寸 因此对于一些固定的 icon，不建议使用普通的静态图片或者雪碧图，这里建议使用矢量的字体图片，有以下优点： 适量图不会变糊 使用方便，通过 css 的字号控制大小，不用适配机型和屏幕尺寸 引用 ttf 文件，体积小，且容易更新 本地调试Weex 的调试方式有多种，如果说RN的调试模式是解放了原生开发的调试，那么 Weex 的调试方式可以说是赋予了 web 模式调试原生应用的能力。 方法一此方法多用于解决 bug，检测控件的布局问题 1234# 调试单个页面$ weex debug your_weex.vue# 调试整个工程$weex debug your/path -e App.vue 执行调试命令后，会将指定的文件打包成 JSBundle，并启动一个 weex Devtool 服务（http://localhost:8088可访问，如下图），同时将 JSBundle 文件传递至该服务跟路径下的weex文件夹内（http://localhost:8088/weex/App.js，实际是下图右边二维码的的内容）。 使用 Weex Playground App 扫下左二维码进入调试模，见下图 再次扫码右方二维码，点击【inspector】即可进入调试模式。 每一个控件都是相同的数据结构 1&lt;view class=&quot;WXText&quot; frame=&quot;&#123;&#123;0,0&#125;,&#123;414,736&#125;&#125;&quot; hidden=&quot;NO&quot; alpha=&quot;1&quot; opaque=&quot;YES&quot;&gt;&lt;/view&gt; class：代表原声空间类型 frame：表示空间的坐标和大小 hidden：代表显隐性，css中visibility设置的值 alpha：不透明度，css中opacity设置的值 opaque：默认为YES，打开绘图系统性能优化的开关，即不去计算多透明块重合后的真正颜色，从而减小GPU的压力，weex中具体有没有地方可以设置这个开关暂时不清楚，有猎奇心的朋友可以研究下。 方法二此方法多用于开发调试，试试观察结果 1$ weex your_weex.vue 如果出现 access 权限报错，使用管理员指令 1$ sudo weex your_weex.vue 此时本地同时启动一个watch的服务器用于检查代码变更，自动重新构建 JSBundle，视觉同步刷新。 上图看到的效果即为H5页面的效果，我们一般在整个单页编写完成后在使用 Weex Playground App 扫码查看真机效果，或者你也可以在编写的同时使用真机观察代码的运行效果，每次重新构建包到重绘的速度还是很快的。 但前提是你要保证，你的手机和电脑的连在同一个局域网下，并且使用IP访问。 Weex 的原理 虽然说，Weex 可以抹平三端开发的差异，但是知其然也应知其所以然使用起来才能游刃有余。 打包熟悉 React Native 的人都知道， React Native 的发布实际上就是发布一个 JSBundle，Weex 也是这样，但不同的是，Weex 将工程进行分包，发布多个 JSBundle。因为 Weex 是单页独立开发的，每个页面都将通过 Weex 打包器将 vue/we 页面打包成一个单独的 JSBundle，这样的好处在于减少单个 bundle 包的大小，使其变的足够小巧轻量，提高增量更新的效率。 123456# 仅打包$ npm run build# 打包+构建$ weex build ios# 打包+构建+安装执行$ weex run ios 以上三种均会触发 Weex 对工程进行打包。在我们执行了以上打包命令后，所有的工程文件将被单独打成一个独立的 JSBundle，如下： 打包后的 JSBundle 有两种格式 12345678910# 由.vue文件打包出来的包格式（简写），使用 vue 2.0 语法编写// &#123; &quot;framework&quot;: &quot;Vue&quot;&#125; /******/ (function(modules) &#123; ......./******/ &#125;)# 由.we文件打包出来的包格式（简写），使用 weex 语法编写// &#123; &quot;framework&quot;: &quot;Weex&quot; &#125;/******/ (function(modules) &#123; ......./******/ &#125;) 不同的头部是要告诉使用什么语法解析此JSBundle。 至此，我们准备「热更新的包」就已经准备完毕了，接下就是发包执行了。 发包打包后的 JSBundle 一般发布到发包服务器上，客户端从服务器更新包后即可在下次启动执行新的版本，而无需重新下载 app，因为运行依赖的 WeexSDK 已经存在于客户端了，除非新包依赖于新的 SDK，这也是热更新的基本原理。 【WeexSDK】包括 【JS Framework】JSBundle 的执行环境 【JS-Native Bridge】中间件或者叫通讯桥梁，也叫【Weex Runtime】 【Native Render Engine】解析 js 端发出的指令做原生控件布局渲染 执行Weex 的 iOS 和 Android 客户端的【JSFramework】中都会运行一个 JavaScript 引擎，来执行 JS bundle，同时向各端的渲染层发送规范化的指令，调度客户端的渲染和其它各种能力。iOS 下选择了 JavaScriptCore 内核，而在 Android 下选择了 UC 提供的 v8 内核（RN两端都是JavaScriptCore 内核）。 JSBundle 被 push 到客户端后就会在 JSFramework 中执行，最终输出三端可读性的 VNode 节点，数据结构简化如下： 1234567891011121314151617181920212223242526&#123; tag: &apos;div&apos;, data: &#123; staticStyle: &#123; justifyContent: &apos;center&apos; &#125; &#125;, children: [&#123; tag: &apos;text&apos;, data: &#123; staticClass: &apos;txt&apos; &#125;, context: &#123; $options: &#123; style: &#123; freestyle: &#123; textAlign: &apos;center&apos;, fontSize: 200 &#125; &#125; &#125; &#125;, children: [&#123; tag: &apos;&apos;, text: &apos;文字&apos; &#125;] &#125;]&#125; 有了统一的 VNode 节点，各端即可根据自己的方法解析渲染原生UI了，之前的所有操作都是一致的，包括文件格式、打包编译过程、模板指令、组件的生命周期、数据绑定等。 然而由于目标执行环境不同（浏览器和 Weex 容器），在渲染真实原生 UI 的时候调用的接口也不同。 此过程发生在【Weex SDK】的【Weex Runtime】中。 最总【Weex Runtime】发起渲染指令callNative({...})有RenderEngine完成渲染 总结一下 Weex 文件分包打包成单个 JSBundle 文件 发布到发包服务器上，通过热更新 push 到用户的客户端，交由【Weex SDK】执行解析 SDK 中的【JS Framework】执行 Bundle 脚本生成 Virtual DOM Virtual DOM 经由各端执行环境【Weex Runtime】解析翻译成执行指令 【Native RenderEngine】接收到指令后执行渲染操作，作出渲染出完整的界面 官方配图： 扩充配图： Weex 的工作模式1. 全页模式目前支持单页使用或整个 App 使用 Weex 开发（还不完善，需要开发 Router 和生命周期管理）。 本文先行的严选 demo 便是使用第二种全屏模式，使用 Weex 开发整个 App，期间触碰到 Weex 的在此模式下诸多不足，如 StatusBar 控制、Tab 切换、开场动画自定义、3DTouch、 Widget 等等原生的特色功能没有现成的 API，需要我们自己扩展，甚至扩展不了。因此并不能完全“灭掉”原生。 所以，目前在阿里内部使用较多的是此模式中的单页模式，这也是为什么官方文档在介绍原理后就直接奔入集成到原生应用的主题上去了。 2. Native Component 模式把 Weex 当作一个 iOS/Android 组件来使用，类比 ImageView。这类需求遍布手淘主链路，如首页、主搜结果、交易组件化等，这类 Native 页面主体已经很稳定，但是局部动态化需求旺盛导致频繁发版，解决这类问题也是 Weex 的重点。 3. H5 Component 模式在 H5 种使用 Weex，类比 WVC。一些较复杂或特殊的 H5 页面短期内无法完全转为 Weex 全页模式（或RN），比如互动类页面、一些复杂频道页等。这个痛点的解决办法是：在现有的H5页面上做微调，引入Native 解决长列表内存暴增、滚动不流畅、动画/手势体验差等问题。 另外，WVC 将会融入到 Weex 中，成为 Weex 的 H5 Components 模式。 严选 App Demo 实现过程中的感想Vue-Router &amp; Tab 由于 Weex 没有封装 Tab 的组件，因此笔者使用了很多方法来实现Tab切换的功能。 1、vue-router：router 思想方便管理，但是每次切换都是新的实例，没有tab模式2、opacity、visablity：此处需要注意，Weex的渲染机制和web是有区别的，对夫层设置 opacity 或者visiablity隐藏是无法同时隐藏定位为position:fixed; 的子元素。3、position、transform：改变 tab 层的位置，此方法在定位为 position:fixed; 的子元素上依然无效。 image &amp; iconfontWeex 中所有的静态资源基本都是网络资源，包括图片、字体图片等，所以使用 iconfont 图标是再合适不过的了。 此 demo 中所有的 icon 均使用 的iconfont。 此处强烈推荐一个站点 www.iconfont.cn。 在此平台你可以找到几乎所有你需要的 icon，你也可以上传自己的 icon 到自己创建的项目中。同时该系统还提供生成ttf、woff 资源，并且做了 cdn 加速和 gzip 压缩，是不是跟 Weex很配呢？ 不过也有风险，就是，如果哪天阿里不在维护并回收该平台的资源了，你的 app 可能就会变成这样，全是方框，或者 padding 掉你 H5 的页面 当然，这种及情况出现的几率很小，如果你是一个大公司，你手上有更好的资源急速方案，那就自己保存吧。 webview UIWebView是我们开发App常用的一个控件，不过Weex帮我们封装好的API明显时不够用的，目前只有pagestart、pagefinish、error，并没有封装像RN那样的onShouldStartLoadWithRequest拦截地址请求的API，在我看来，这有些不合理，并不清楚轮子的制造者是什么意图。 性能性能是一个大课题，在此就不做展开了，只稍微提及一些我们开发需要注意的几点 性能影响点：UI更新&gt;UI事件响应&gt;后台运算 合理优化过场&amp;动画，过场和 console 容易引起 app crash 需要注意 降低 js &lt;-&gt; native 的通信频率 优化list结构，降低重排重绘压力 把优先级低且耗时较长的工作推后处理 Weex 的现状Weex 解决了的我的发布我做主（热更新）脚本语言天生自带“热更新”，Weex 针对 React Native 的热更新策略做了优化，将 WeexSDK 事先绑到了客户端上，并且对 JSBundle 进行分包增量更新，大大提高了热更新的效率。 但优点也是缺点，如果新包依赖于心的 SDK，此情况下，我们需要发布还有新 SDK 的 app 到应用市场，用户也须从市场更新此 app。不够随着 WeexSDK 版本的稳定后，相信此策略的优势就会凸显出来。 性能问题Weex 是一种轻量级、可扩展、高性能框架。集成也很方便，可以直接在 HTML5 页面嵌入，也可嵌在原生UI中。由于和 React Native 一样，都会调用 Native 端的原生控件，所以在性能上比 Hybrid 高出一个层次。 统一三端虽说这是一个大胆的实践，但对于大前端社区的统一有着推动作用，显然阿里在这一方面已经迈出了第一步。基本解决了三端同等需求导致资源浪费的痛点。 但后期可能会出现这种现象，开发一个三端的 App 会从原来的个人变成四个人，多出来的那一个人负责开发 Weex 单页。 意思就是，三端统一的不够彻底，但就目前的环境下，这一句是最优方案了，却是提高了开发效率。大前端将来将如何一统三国我们且行且观望吧。 做游戏对于一些交互视觉统一且没有很大的性能需求的游戏，Weex 还是可以胜任的。 近期笔者将尝试发布一款纯Weex构建的益智小游戏，敬请期待。 朋友们可以用这个demo体验下 Weex 版扫雷游戏开发 Weex “暂时”放弃的虽然说大一统事件百利的事，但并非无一害。 差异化对于一些有差异化完美体验追求的项目就只能收敛或者放弃了。 独立的 bug 修复对于三端同时上线，一端存在 bug 的情况，Weex 并不能保证做到牵一发而不动全身。 个性化功能比如安卓的波纹按钮、3DTouch、 Widget、iWatch版本等，目前这些功能还是没有的，不知道以后 Weex是否将其加入到官方文档中。 声明以上均为个人见解，不代表官方。如有不当之处还望指正。 参考[ 1 ] Weex官方文档 - http://weex.apache.org/cn/references/[ 2 ] 场景研读 - Native 性能稳定性极致优化 - https://yq.aliyun.com/articles/69005[ 3 ] 门柳 - 详解 Weex JS Framework 的编译过程 - https://yq.aliyun.com/articles/59935?spm=5176.8067842.tagmain.66.1QA1fL[ 4 ] 阿里百川 - 深度揭秘阿里移动端高性能动态化方案Weex - https://segmentfault.com/a/1190000005031818[ 5 ] 一缕殇流化隐半边冰霜 - Weex 是如何在 iOS 客户端上跑起来的 - http://www.jianshu.com/p/41cde2c62b81 转载请标明出处作者：木羽 zwwill首发地址：https://github.com/zwwill/blo…]]></content>
      <categories>
        <category>前端</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 在Android端的实践]]></title>
    <url>%2Fposts%2F31c875b0.html</url>
    <content type="text"><![CDATA[ShowPage ShowPage ShowPage 什么是weex Write Once, Run Everywhere Weex能够完美兼顾性能与动态性，让移动开发者通过简捷的前端语法写出Native级别的性能体验，并支持iOS、安卓、YunOS及Web等多端部署。真正实现一次撰写，多平台运行。 Weex 提供了多端一致的技术方案。 首先 web 开发体验在各端当中是相同的。包括语法设计和工程链路。 其次，Weex 的组件、模块设计都是 iOS、Android、Web 的开发者共同讨论出来的，有一定的通用性和普遍性。 Weex 开发同一份代码，可以在不同的端上分别执行，避免了多端的重复研发成本。 在同构这条路上，WEEX比ReactNative做得更彻底，他“几乎”做到了，“你来使用vue写一个webapp，我顺便给你编译成了ios和android的原生app” 为什么要用weex东西是好东西，对于电商这类经常需要变动 APP 界面的尤其适用。看看天猫、淘宝首页你就知道了。但一定不会适用于所有人，需求千变万化，总有框架照顾不到的地方。我在下面也列几张我们用weex后的首页。 用原生如何实现？当我没用weex的时候，我想：这还非得用weex，我用native也能实现。我接不同的type展现不同的UI不就行了。这当然可以了，我始终相信一点，需求通过不同的技术手段都可以实现，只是实现方式的简易程度和灵活度的差别。 用weex的优势？首先，weex是组件化的。什么是组件化？很好理解，他的每一块儿都是独立，我们只需根据不同的类型，将不同的组件组合在一起就行了，耦合度很低，当一个组件出问题不会影响其他组件渲染。但如果我用原生写，肯定是一页，然后根据不同的数据，展现出来，可能一个数据出错，我这一整页都是空白的。其次，weex还有一个好处，可以热更新这个页面，假如：线上时突然又想新增一种组件样式（例如banner吧），这个时候原生界面肯定说：等下个版本迭代给你新加。但weex就可以直接新增一种组件，然后发一个热更新文件，让原生加载新的js文件即可。 Android 嵌入weex集成weex有两种模式，一种是源码集成，另一种sdk依赖。这里没有坑，就按照接入文档接入就行，有一点注意一下，用源码依赖可以拿到最新版本，但通过源码依赖拿的版本就会落后一些，但比较稳定。 12345678910111213141516171819dependencies &#123; implementation fileTree(dir: &apos;../module_common/libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:27.1.1&apos; //router implementation &apos;com.alibaba:arouter-api:1.3.1&apos; annotationProcessor &apos;com.alibaba:arouter-compiler:1.1.4&apos; implementation &apos;com.alibaba:fastjson:1.2.31&apos; implementation &apos;com.google.code.gson:gson:2.8.5&apos; implementation &apos;com.github.bumptech.glide:glide:4.8.0&apos; annotationProcessor &apos;com.github.bumptech.glide:compiler:4.3.0&apos; implementation &apos;com.taobao.android:weex_sdk:0.20.3.0-beta@aar&apos; // 接入 weex inspector implementation &apos;com.taobao.android:weex_inspector:0.20.3.0-beta@aar&apos; implementation &apos;com.squareup.okhttp3:okhttp:3.10.0&apos; implementation &apos;com.squareup.okhttp:okhttp:2.3.0&apos; implementation &apos;com.squareup.okhttp:okhttp-ws:2.3.0&apos;&#125; 实现一个ImageAdapter接入weex后需要自己实现一个ImageAdapter，用于展示图片，我是基于glide框架的，当然也可以选择基于fresco，picasso等等。 12345678910111213141516171819202122232425262728293031323334353637383940414243import android.text.TextUtils;import android.widget.ImageView;import com.bumptech.glide.Glide;import com.taobao.weex.WXSDKManager;import com.taobao.weex.adapter.IWXImgLoaderAdapter;import com.taobao.weex.common.WXImageStrategy;import com.taobao.weex.dom.WXImageQuality;public class ImageAdapter implements IWXImgLoaderAdapter &#123; @Override public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) &#123; //实现自己的图片下载。 WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (view == null || view.getLayoutParams() == null) &#123; return; &#125; if (TextUtils.isEmpty(url)) &#123; view.setImageBitmap(null); return; &#125; String temp = url; if (url.startsWith("//")) &#123; temp = "http:" + url; &#125; if (view.getLayoutParams().width &lt;= 0 || view.getLayoutParams().height &lt;= 0) &#123; return; &#125; if (view != null &amp;&amp; view.getContext() != null) &#123; try &#123; Glide.with(view.getContext()).load(temp).into(view); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, 0); &#125;&#125; weex加载方式文档说只说了通过file的形式加载js文件，其实我们也可以通过URL的方式渲染，当我们调试的时候就需要连接服务器进行修改，也就是通过URL方式加载。 1234//根据URL渲染mInstance.renderByUrl(getPageName(), url, options, jsonInitData, WXRenderStrategy.APPEND_ONCE);//根据文件渲染mWXSDKInstance.render(name, WXFileUtils.loadAsset(name+".js", this), null, null, WXRenderStrategy.APPEND_ASYNC); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184/** * weex 基础容器类 */public abstract class BaseWeexContainerActivity extends AppCompatActivity implements IWXRenderListener, IWeexPageRefresh &#123; private static final String TAG = BaseWeexContainerActivity.class.getSimpleName(); protected String mBundleUrl; private FrameLayout mContainer; protected WXSDKInstance mWXSDKInstance; /** 网络异常页面 */ private View mEmptyView; /** Loading页面 */ private View mLoadingView; private Handler mHandler = new Handler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.weex_activity_container); mContainer = findViewById(R.id.container); mLoadingView = findViewById(R.id.loading_view); mEmptyView = findViewById(R.id.empty_view); initListeners(); &#125; private void initListeners() &#123; mEmptyView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (!WeexBaseUtil.isInternetConnected(BaseWeexContainerActivity.this)) &#123; ToastUtil.showShort(BaseWeexContainerActivity.this, R.string.net_error); &#125; else &#123; mLoadingView.setVisibility(View.VISIBLE); mEmptyView.setVisibility(View.GONE); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; loadWeexPage(TAG, mBundleUrl); &#125; &#125;, 100); &#125; &#125; &#125;); &#125; protected void loadWeexPage(String pageName, String bundleUrl) &#123; if (!TextUtils.isEmpty(bundleUrl)) &#123; mBundleUrl = bundleUrl; createWeexInstance(); /** * pageName:自定义，一个标示符号。 * url:远程bundle JS的下载地址 * options:初始化时传入WEEX的参数，比如 bundle JS地址 * flag:渲染策略。WXRenderStrategy.APPEND_ASYNC:异步策略先返回外层View，其他View渲染完成后调用onRenderSuccess。 * WXRenderStrategy.APPEND_ONCE 所有控件渲染完后后一次性返回。 */ Map&lt;String, Object&gt; options = new HashMap&lt;&gt;(); options.put(WXSDKInstance.BUNDLE_URL, mBundleUrl); String jsonData = WeexBaseUtil.convertHttpRequestParamData(mBundleUrl); // 获取缓存文件名 final String filename = JsCacheTool.getCacheFilename(mBundleUrl); // 检测缓存文件是否存在 if (JsCacheTool.checkCacheExist(mBundleUrl)) &#123; // 存在，读取缓存 String template = JsCacheTool.loadLocalCacheData(filename); mWXSDKInstance.render(pageName, template, options, jsonData, WXRenderStrategy.APPEND_ASYNC); &#125; else &#123; // 缓存不存在，异步从服务器拉取并缓存到本地 mWXSDKInstance.renderByUrl(pageName, mBundleUrl, options, jsonData, WXRenderStrategy.APPEND_ASYNC); JsCacheTool.downloadCacheToFileAsync(mBundleUrl, filename, null); &#125; &#125; &#125; protected void refreshPage() &#123; if (!TextUtils.isEmpty(mBundleUrl)) &#123; createWeexInstance(); Map&lt;String, Object&gt; options = new HashMap&lt;&gt;(); options.put(WXSDKInstance.BUNDLE_URL, mBundleUrl); String jsonData = WeexBaseUtil.convertHttpRequestParamData(mBundleUrl); mWXSDKInstance.renderByUrl(mWXSDKInstance.getWXPerformance().pageName, mBundleUrl, options, jsonData, WXRenderStrategy.APPEND_ASYNC); &#125; &#125; @Override public void onStart() &#123; super.onStart(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityStart(); &#125; &#125; @Override public void onResume() &#123; super.onResume(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override public void onPause() &#123; super.onPause(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override public void onStop() &#123; super.onStop(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (mWXSDKInstance != null) &#123; mWXSDKInstance.onActivityDestroy(); &#125; destoryWeexInstance(); &#125; private void createWeexInstance() &#123; destoryWeexInstance(); if (mWXSDKInstance == null) &#123; mWXSDKInstance = new WXSDKInstance(BaseWeexContainerActivity.this); mWXSDKInstance.registerRenderListener(this); &#125; &#125; private void destoryWeexInstance() &#123; if (mWXSDKInstance != null) &#123; mWXSDKInstance.registerRenderListener(null); mWXSDKInstance.destroy(); mWXSDKInstance = null; &#125; &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; mLoadingView.setVisibility(View.GONE); mEmptyView.setVisibility(View.GONE); if (mContainer != null) &#123; mContainer.removeAllViews(); mContainer.addView(view); &#125; &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; mLoadingView.setVisibility(View.GONE); mEmptyView.setVisibility(View.GONE); &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; mLoadingView.setVisibility(View.GONE); mEmptyView.setVisibility(View.GONE); &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; mLoadingView.setVisibility(View.GONE); mEmptyView.setVisibility(View.VISIBLE); if (WXErrorCode.WX_ERR_JS_FRAMEWORK.getErrorCode().equalsIgnoreCase(errCode)) &#123; ToastUtil.showShort(BaseWeexContainerActivity.this, R.string.weex_create_instance_error); &#125; else if (WXErrorCode.WX_DEGRAD_ERR_NETWORK_CHECK_CONTENT_LENGTH_FAILED.getErrorCode().equalsIgnoreCase(errCode)) &#123; ToastUtil.showShort(BaseWeexContainerActivity.this, R.string.weex_network_error); &#125; else if (WXErrorCode.WX_DEGRAD_ERR_BUNDLE_CONTENTTYPE_ERROR.getErrorCode().equalsIgnoreCase(errCode)) &#123; ToastUtil.showShort(BaseWeexContainerActivity.this, R.string.weex_user_intercept_error); &#125; &#125;&#125; Android 嵌入weex devtools调试工具1：先通过npm install 安装项目依赖。之后运行npm run dev和npm run serve2：运行weex debug，就会开启一个chrome 的 inspect/debug 工具3：完成上面两个步骤，服务端就相当于配置成功了，之后我们只需要在我们的代码中配好相应的库，完善代码就可以了 Android 实现热调试功能Android调试功能很简单就可以实现，但是热调试功能却花我一些时间。什么是热调试功能呢？当我修改服务器的代码，通过刷新浏览器，APP端数据也会跟着改变，这就是热调试。热调试功能是如何工作的呢？其实当我刷新时，会在APP的广播接收器接到相应的指令，此时我们重新reload相应的js文件即可。 1234567891011121314151617181920212223242526272829public void registerBroadcastReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; mBroadcastReceiver = receiver != null ? receiver : new DefaultBroadcastReceiver(); if (filter == null) &#123; filter = new IntentFilter(); &#125; filter.addAction(IWXDebugProxy.ACTION_DEBUG_INSTANCE_REFRESH); filter.addAction(WXSDKEngine.JS_FRAMEWORK_RELOAD); LocalBroadcastManager.getInstance(getApplicationContext()) .registerReceiver(mBroadcastReceiver, filter); if (mReloadListener == null) &#123; setReloadListener(new WxReloadListener() &#123; @Override public void onReload() &#123; createWeexInstance(); renderPage(); &#125; &#125;); &#125; if (mRefreshListener == null) &#123; setRefreshListener(new WxRefreshListener() &#123; @Override public void onRefresh() &#123; createWeexInstance(); renderPage(); &#125; &#125;); &#125; &#125; weex上手还是比较容易的，希望每个人都有一直学习的热情与能力~]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 中使用Vue.js]]></title>
    <url>%2Fposts%2F937a42e9.html</url>
    <content type="text"><![CDATA[只含有运行时的构建版本 平台的差异 执行环境 DOM 样式 事件 Web 渲染器 单文件组件 编译目标 使用weex-loader 支持的功能 全局配置 全局 API 选项 生命周期钩子 实例属性 实例方法 模板指令 特殊属性 内置组件 在 WeexSDK v0.10.0 （发布于 2016 年 2 月 17 日）以及后续的版本中，集成了 v2 版本的 Vue.js。Vue 是一套构建用户界面的渐进式框架，详情请参阅其官方网站。 如果没有特别指示，文章中的 “Vue.js” 或者 “Vue” 都指的是 v2 版本的 Vue。 只含有运行时的构建版本如果你熟悉 Vue.js，你应该知道 Vue.js 有两种构建版本: 运行时 + 编译器 与 只包含运行时。它们之间的区别在于编译器是否需要能够在运行时编译 template 选项。由于运行时构建版本比完整版本的构建版本轻约 30%（Vue 官方估算），为了更好的性能和更小的代码体积，Weex 集成的是运行时版本的 Vue。 具体来说，差异如下： 定义组件时不支持 template 选项。 不支持使用 x-templates。 不支持使用 Vue.compile。 平台的差异Vue.js 最初是为 Web 平台设计的。虽然可以基于Weex开发原生应用程序，但是仍然存在许多Weex 与 Web 平台的差异。 与 Web 平台的主要差异是: 执行环境、DOM、样式和事件。 执行环境Weex 主要用于编写多页的应用程序，每个页面都对应了原生开发中的 View 或者 Activity，并且保持自己的上下文。即使 Weex 的所有页面都使用的都是同一个 Javascript 引擎的实例(virtual machine)，每个页面是执行环境也是互相隔离的（基于 Sandbox 技术）。 使用 BroadcastChannel 可以实现跨页通信。 具体来讲，每个页面的 Vue 变量都是不同的实例，即使是写在 Vue 上的“全局”配置（Vue.config.xxx）也只会影响 Weex 上的单个页面。 在此基础上，一些 Vue 的 SPA （单页面应用）技术，如 Vuex 和 vue-router 也将单页内生效。更通俗地说，“页面”概念在 SPA 技术中是虚拟的，但在 Weex 上却是真实的。即便如此，Vuex 和 vue-router 都是独立的库，都有自己的概念和使用场景，仍然可以在 Weex 里使用 Vuex 和 vue-router。 DOM因为在 Android 和 iOS 上没有 DOM（Document Object Model），如果你要手动操作和生成 DOM 元素的话可能会遇到一些兼容性问题。在你使用现代前端框架的情况下，操作数据与组件而不是生成的元素是一个比较好的做法。 一些与 DOM 相关的特性，比如 v-html，vm.$el，template 选项，在不同的平台上可能无法获得相同的反应。 准确来说，vm.$el属性类型在web环境下是HTMLElement，但是在移动端并没有这个类型。实际上，它是一个由 Weex 文档对象模型 定义的特殊数据结构。 样式样式表和 CSS 规则是由 Weex js 框架和原生渲染引擎管理的。要实现完整的 CSS 对象模型（CSSOM：CSS Object Model）并支持所有的 CSS 规则是非常困难的，而且没有这个必要。 出现性能考虑，Weex 目前只支持单个类选择器，并且只支持 CSS 规则的子集。详情请参阅 通用样式 与 文本样式。 在 Weex 里， 每一个 Vue 组件的样式都是 scoped。 事件目前在 Weex 里不支持事件冒泡和捕获，因此 Weex 原生组件不支持事件修饰符，例如.prevent，.capture，.stop，.self 。 此外，按键修饰符以及系统修饰键 例如 .enter，.tab，.ctrl，.shift 在移动端基本没有意义，在 Weex 中也不支持。 Web 渲染器如果你想在网络上呈现你的页面，你需要 weex-vue-render 来实现它。 weex-vue-render是 Vue DSL 的 Web 渲染器， 它在 Web 上实现了 Weex 的内置组件和内置模块。详情请参阅这里。 单文件组件Vue 中的单文件组件（即*.vue文件）是一种特殊的文件格式，扩展名为.vue。这个模板会在构建时便于到render函数里。 此外，所有的编辑器里都支持一个好的语法高亮插件。 在 Weex 中使用单个文件组件语法是一种很好的做法。 TIP 在 Weex 中使用 Vue 的单个文件组件语法是一种最佳实践。 因为针对 Weex 的 Web 平台的编译工具并不一样，如果你直接写的 render 函数，则绕过了 weex-loader 编译模板的过程，这样的话你需要自行处理平台差异的细节。 编译目标因为平台的差异以及为了提高网络性能，*.vue文件需要用两种不同的方式来编译： 对于 Web 平台来说，你可以用任何正式的方式来编译源文件，例如 使用 Webpack + vue-loader 或者 Browserify + vueify 来编译*.vue文件。 对于安卓与 iOS 平台来说， 你需要使用 weex-loader 来编译*.vue文件。 不同的平台使用不同的bundles，可以充分利用平台原有的特性，减少构建时的兼容性代码。但是源代码仍然是一样的，唯一的区别是编译它的方法。 使用weex-loaderweex-loader 是一个 webpack 的 loader，它能把*.vue文件转化为简单的javascript 模块用于安卓以及 iOS 平台。所有的特性和配置都是跟 vue-loader 一样的。 需要注意的是，如果 Webpack 的 entry 配置项是一个 *.vue 文件的话，你仍需要传递一个额外的 entry 参数作为标记。 1234567891011121314const webpackConfig = &#123; // Add the entry parameter for the .vue file entry: './path/to/App.vue?entry=true' /* ... */ use: &#123; loaders: [&#123; // matches the .vue file path which contains the entry parameter test: /\.vue(\?^^]+)?$/, loaders: ['weex-loader'] &#125;] &#125;&#125; 如果你现在用的是.js文件做入口文件，你不需要写那些额外的参数。 推荐 webpack 配置的入口文件使用 javascript 文件。 123&#123; entry: './path/to/entry.js'&#125; TIP 无论什么情况下都使用 javascript 文件作为入口文件。 支持的功能全局配置 Vue “全局”配置只会影响 Weex 上的单一页面，配置不会在不同的 Weex 页面之间共享。 Vue 全局配置 是否支持 说明 Vue.config.silent 支持 - Vue.config.optionMergeStrategies 支持 - Vue.config.devtools 不支持 只在 Web 环境下支持 Vue.config.errorHandler 支持 - Vue.config.warnHandler 支持 - Vue.config.ignoredElements 支持 不推荐 Vue.config.keyCodes 不支持 在移动端无用 Vue.config.performance 不支持 与 devtools 一样 Vue.config.productionTip 支持 - 全局 API Vue 全局 API 是否支持 说明 Vue.extend 支持 - Vue.nextTick 支持 - Vue.set 支持 - Vue.delete 支持 - Vue.directive 支持 - Vue.filter 支持 - Vue.component 支持 - Vue.use 支持 - Vue.mixin 支持 - Vue.version 支持 - Vue.compile 不支持 Weex 用的是 只包含运行时构建 选项 Vue 选项 是否支持 说明 data 支持 - props 支持 - propsData 支持 - computed 支持 - methods 支持 - watch 支持 - el 支持 在移动端el的值是无意义的 template 不支持 Weex 用的是 只包含运行时构建 render 支持 不推荐 renderError 支持 - directives 支持 - filters 支持 - components 支持 - parent 支持 不推荐 mixins 支持 - extends 支持 - provide/inject 支持 不推荐 name 支持 - delimiters 支持 不推荐 functional 支持 - model 支持 - inheritAttrs 支持 - comments 不支持 - 生命周期钩子Vue 组件的实例生命周期钩子将在特定的阶段发出，详情请参考 Vue 组件的生命周期图示。 Vue 生命周期钩子 是否支持 说明 beforeCreate 支持 - created 支持 - beforeMount 支持 - mounted 支持 和 Web 端不完全一样（下文有详解） beforeUpdate 支持 - updated 支持 - activated 不支持 不支持&lt;keep-alive&gt; deactivated 不支持 不支持&lt;keep-alive&gt; beforeDestroy 支持 - destroyed 支持 - errorCaptured 支持 在 Vue 2.5.0+， Weex SDK 0.18+ 中新增 关于 “mounted” 生命周期 和浏览不同的是，Weex 的渲染流程是异步的，而且渲染出来的结果都是原生系统中的 View，这些数据都无法被 javascript 直接获取到。因此在 Weex 上，Vue 的 mounted 生命周期在当前组件的 virtual-dom (Vue 里的 VNode) 构建完成后就会触发，此时相应的原生视图未必已经渲染完成。 实例属性 Vue 实例属性 是否支持 说明 vm.$data 支持 - vm.$props 支持 - vm.$el 支持 移动端没有HTMLElement vm.$options 支持 - vm.$parent 支持 - vm.$root 支持 - vm.$children 支持 - vm.$slots 支持 - vm.$scopedSlots 支持 - vm.$refs 支持 - vm.$isServer 支持 永远是false vm.$attrs 支持 - vm.$listeners 支持 - 实例方法 Vue 实例方法 是否支持 说明 vm.$watch() 支持 - vm.$set() 支持 - vm.$delete() 支持 - vm.$on() 支持 - vm.$once() 支持 - vm.$off() 支持 - vm.$emit() 支持 - vm.$mount() 不支持 你不需要手动安装 Vue 实例 vm.$forceUpdate() 支持 - vm.$nextTick() 支持 - vm.$destroy() 支持 - 模板指令 Vue 指令 是否支持 说明 v-text 支持 - v-html 不支持 Weex 中没有 HTML 解析器，这不是很好的实现 v-show 不支持 不支持 display: none; v-if 支持 - v-else 支持 - v-else-if 支持 - v-for 支持 - v-on 支持 不支持事件修饰符 v-bind 支持 - v-model 支持 - v-pre 支持 - v-cloak 不支持 只支持单类名选择器 v-once 支持 - 特殊属性 Vue 特殊属性 是否支持 说明 key 支持 - ref 支持 - slot 支持 - slot-scope 支持 在 Vue 2.5.0+， Weex SDK 0.18+ 中新增 scope 支持 不推荐 is 支持 - 内置组件 Vue 内置组件 是否支持 说明 component 支持 - transition 不支持 在移动端 enter 与 leave 的概念可能有点不同， 并且 Weex 不支持display: none; transition-group 不支持 跟 transition 一样 keep-alive 不支持 移动端的原生组件不能被前端缓存 slot 支持 -]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 和 Web 的平台差异]]></title>
    <url>%2Fposts%2Fb78de55a.html</url>
    <content type="text"><![CDATA[Weex 是一个跨平台解决方案，Web 平台只是其一种运行环境，除此之外还可以在 Android 和 iOS 客户端中运行。原生开发平台和 Web 平台之间的差异，在功能和开发体验上都有一些差异。 Weex 环境中没有 DOMDOM（Document Object Model），即文档对象模型，是 HTML 和 XML 文档的编程接口，是 Web 中的概念。Weex 的运行环境以原生应用为主，在 Android 和 iOS 环境中渲染出来的是原生的组件，不是 DOM Element。 不支持 DOM 操作原生环境中不支持 Web API，没有 Element 、Event 、File 等对象，详细列表可以参考 Web APIs on MDN。不支持选中元素，如 document.getElementById 、 document.querySelector 等；当然也不支持基于 DOM API 的程序库（如 jQuery）。 有限的事件类型Weex 支持在标签上绑定事件，和在浏览器中的写法一样，但是 Weex 中的事件是由原生组件捕获并触发的，行为和浏览器中有所不同，事件中的属性也和 Web 中有差异。 支持 Web 中的事件类型，详情请参考《通用事件》。 不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。 Weex 环境中没有 BOMBOM（Browser Object Model），即浏览器对象模型，是浏览器环境为 javascript 提供的接口。Weex 在原生端并不基于浏览器运行，不支持浏览器提供的 BOM 接口。 没有 window 、screen 对象Weex 中并未提供浏览器中的 window 和 screen 对象，不支持使用全局变量。如果是想要获取设备的屏幕或环境信息，可以使用 WXEnvironment 变量。 1WXEnvironment weexVersion: WeexSDK 的版本。 appName: 应用的名称。 appVersion: 应用的版本。 platform: 运行平台，可能的值是 Web 、Android 、iOS 之一。 osName: 系统的名称。 osVersion: 系统版本。 deviceWidth: 设备宽度。 deviceHeight: 设备高度。 没有 document 对象在浏览器中 document 表示了当前活动的文档模型，在 Android 和 iOS 环境中并没有这个对象，也不支持与其相关的 DOM 操作。 没有 history 、location 、navigator 对象 history 保存了当前页面的历史记录，并且提供了前进后退操作。 location 记录了当前页面 URL 相关的信息。 navigator 记录了当前浏览器中的信息。 这些接口与浏览器自身的实现有关，可以控制页面的前进后退并且获取状态信息。虽然在 Android 和 iOS 中也有“历史”和“导航”的概念，但是它是用于多个管理视图之间的跳转的。换句话说，在浏览器中执行“前进”、“后退”仍然会处于同一个页签中，在原生应用中“前进”、“后退”则会真实的跳转到其他页面。 此外 Weex 也提供了 navigator 模块来操作页面的跳转，使用方法参考《navigator 导航控制》。 能够调用移动设备原生 API在 Weex 中能够调用移动设备原生 API，使用方法是通过注册、调用模块来实现。其中有一些模块是 Weex 内置的，如 clipboard 、 navigator 、storage 等。 《clipboard 剪切板》 《navigator 导航控制》 《storage 本地存储 》 为了保持框架的通用性，Weex 内置的原生模块有限，不过 Weex 提供了横向扩展的能力，可以扩展原生模块。 有些接口在浏览器环境中也存在，不过在使用时应该注意浏览器的兼容性；如剪贴板功能，出于安全性考虑，绝大多数浏览器都限制其使用。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 集成到Android应用]]></title>
    <url>%2Fposts%2F10965f08.html</url>
    <content type="text"><![CDATA[在执行以下步骤之前，请先确认您的Android开发环境是ok的。 JAVA环境, jdk7+ Android Studio NDK r16、Cmake 3.9.0+ (可选项：如果需要编译WEEX源码，需要NDK环境支持) 1. 设置gradle依赖1234567891011dependencies &#123; ... // weex sdk and fastjson compile &apos;com.taobao.android:weex_sdk:0.20.0.2@aar&apos; compile &apos;com.alibaba:fastjson:1.1.46.android&apos; //support library dependencies compile &apos;com.android.support:recyclerview-v7:23.1.1&apos; compile &apos;com.android.support:support-v4:23.1.1&apos; compile &apos;com.android.support:appcompat-v7:23.1.1&apos;&#125; 2. 配置混淆规则混淆规则如下，建议参考最新的源码配置 12345-keep class com.taobao.weex.bridge.** &#123; *; &#125;-keep class com.taobao.weex.layout.** &#123; *; &#125;-keep class com.taobao.weex.WXSDKEngine &#123; *; &#125;-keep class com.taobao.weex.base.SystemMessageHandler &#123; *; &#125;-dontwarn com.taobao.weex.bridge.** 3. 声明权限在AndroidManifest.xml中声明权限 1234567//网络&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;//sd卡读写&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 4. 初始化sdk1234567InitConfig config = new InitConfig.Builder() //图片库接口 .setImgAdapter(new FrescoImageAdapter()) //网络库接口 .setHttpAdapter(new InterceptWXHttpAdapter()) .build();WXSDKEngine.initialize(applicationContext,config); demo初始化源码 其它扩展配置看这里 5. 创建WXSDKInstanceWXSDKInstance是weex渲染页面的基本单元， 通过instance.render(url)拉取bundle， 在回调IWXRenderListener的onViewCreated返回创建的view， 将返回的view 添加到Activity的view上（rootView） 参见源码: WXPageActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MainActivity extends AppCompatActivity implements IWXRenderListener &#123; WXSDKInstance mWXSDKInstance; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mWXSDKInstance = new WXSDKInstance(this); mWXSDKInstance.registerRenderListener(this); /** * bundleUrl source http://dotwe.org/vue/38e202c16bdfefbdb88a8754f975454c */ String pageName = "WXSample"; String bundleUrl = "http://dotwe.org/raw/dist/38e202c16bdfefbdb88a8754f975454c.bundle.wx"; mWXSDKInstance.renderByUrl(pageName, bundleUrl, null, null,WXRenderStrategy.APPEND_ASYNC); &#125; @Override public void onViewCreated(WXSDKInstance instance, View view) &#123; setContentView(view); &#125; @Override public void onRenderSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onRefreshSuccess(WXSDKInstance instance, int width, int height) &#123; &#125; @Override public void onException(WXSDKInstance instance, String errCode, String msg) &#123; &#125; @Override protected void onResume() &#123; super.onResume(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityResume(); &#125; &#125; @Override protected void onPause() &#123; super.onPause(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityPause(); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityStop(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mWXSDKInstance!=null)&#123; mWXSDKInstance.onActivityDestroy(); &#125; &#125;&#125; 6. 运行app运行app，您将会看到一个 hello world 页面。 Hello World Demo 源码 提示: 点击二维码, 可以看到最终编译的代码产物。 7. 扩展Android能力Weex 提供了能力扩展机制，可以根据自己的业务进行定制自己的功能。 主要分为： Module 扩展， 非 UI 的特定功能。例如 sendHttp、openURL 等。 Component 扩展， 实现特别功能的 Native 控件。例如：RichTextview，RefreshListview 等。 Adapter 扩展， Weex 对一些基础功能实现了统一的接口，可实现这些接口来定制自己的业务。例如：图片下载等。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 创建一个app]]></title>
    <url>%2Fposts%2Ffccf4639.html</url>
    <content type="text"><![CDATA[以下步骤假设您已经了解了 Node.js 和 npm 的基本知识。如果对它们不熟悉，可以访问 https://docs.npmjs.com/ 来了解更多关于 npm 的用法。 Weex 提供了一个命令行工具 weex-toolkit 来帮助开发者使用 Weex。它可以用来快速创建一个空项目、初始化 iOS 和 Android 开发环境、调试、安装插件等操作。 目前 weex-toolkit 只支持创建 Vue.js 的项目。创建 Rax 的项目可以使用 rax-cli，参考 Rax 的官方网站 了解其用法。 初始化请确保你已经安装了 Node.js，然后全局安装 weex-toolkit。 1npm install weex-toolkit -g 这条命令会向你命令行环境中注册一个 weex 命令。你可以用 weex create 命令来创建一个空的模板项目： 1weex create awesome-app 命令执行完以后，在当前目录的 awesome-app 文件夹里就有了一个空的 Weex + Vue.js 项目。 开发下一步就是进入刚刚创建的文件夹，并且安装依赖，然后执行 npm start： 123cd awesome-appnpm installnpm start 然后工具会启动一个本地的 web 服务，监听 8081 端口。你可以打开 http://localhost:8081 查看页面在 Web 下的渲染效果。 源代码在 src/ 目录中，你可以像一个普通的 Vue.js 项目一样来开发. 除此之外，你还可以打开 http://localhost:8081/preview.html 开启一个预览页面，它会把 web 端的页面放在一个 iframe 中渲染，而且在右侧生成一个二维码。用 Weex playground app 扫描这个二维码可以看到页面在手机上渲染的真实效果。 编译和运行默认情况下 weex create 命令并不初始化 iOS 和 Android 项目，你可以通过执行 weex platform add 来添加特定平台的项目。 12weex platform add iosweex platform add android 由于网络环境的不同，安装过程可能需要一些时间，请耐心等待。如果安装失败，请确保自己的网络环境畅通。 为了能在本地机器上打开 Android 和 iOS 项目，你应该配置好客户端的开发环境。对于 iOS，你应该安装并且配置好 Xcode。对于 Android，你应该安装并且配置好 Android Studio。当开发环境准备就绪后，运行下面的命令，可以在模拟器或真实设备上启动应用： 123weex run iosweex run androidweex run web 调试weex-toolkit 还提供了强大的调试功能，只需要执行： 1weex debug 这条命令会启动一个调试服务，并且在 Chrome （目前只支持基于 V8 引擎的桌面浏览器） 中打开调试页面。详细用法请参考 weex-toolkit 的文档。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex 设置开发环境]]></title>
    <url>%2Fposts%2F55bbc4a4.html</url>
    <content type="text"><![CDATA[使用 Weex Online Editor 对 Weex 尝鲜是一个不错的选择，但如果你想更专业的开发 Weex，下面教你如何搭建本地开发环境进行 Weex 开发。 安装依赖Weex 官方提供了weex-toolkit 的脚手架工具来辅助开发和调试。 首先，你需要 Node.js 和 Weex CLi。 安装 Node.js 方式多种多样，最简单的方式是在 Node.js 官网 下载可执行程序直接安装即可。 更多安装方式可参考 Node.js 官方信息 ::: Tip 通常，安装了 Node.js 环境，npm 包管理工具也随之安装了。因此，直接使用 npm 来安装 weex-toolkit, 你也可以通过 yarn 来进行安装。 国内的开发者推荐将npm镜像切换至 Taobao NPM 镜像。 ::: 运行下面的命令安装最新的beta版本工具： 12$ npm install -g weex-toolkit@beta$ weex -v // 查看当前weex工具版本 安装结束后你可以直接使用 weex help 命令验证是否安装成功，它会显示 weex 支持的所有指令，同时，你也可以通过 weex doctor 命令检查你的本地开发环境。 初始化项目然后初始化 Weex 项目： 1$ weex create awesome-project 执行完命令后，在 awesome-project 目录中已经为我们生成了标准项目结构。 开发进入项目所在路径，如果你在生成项目的时候选择了自动安装依赖，在进入项目后只需直接运行 npm start 就可以将项目完整跑起来，否则，你需要预先在项目中运行一下 npm install 安装项目所需依赖。 关于 Weex 语法部分，你可以直接参考 Vue Guide]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是 Weex ？]]></title>
    <url>%2Fposts%2F96214312.html</url>
    <content type="text"><![CDATA[Weex 是使用流行的 Web 开发体验来开发高性能原生应用的框架。“Weex” 的发音是 /wiːks/, 和 “Weeks“ 同音。 Write Once, Run EverywhereWeex 致力于使开发者能基于通用跨平台的 Web 开发语言和开发经验，来构建 Android、iOS 和 Web 应用。简单来说，在集成了 WeexSDK 之后，你可以使用 JavaScript 语言和前端开发经验来开发移动应用。 Weex 渲染引擎与 DSL 语法层是分开的，Weex 并不强依赖任何特定的前端框架。目前 Vue.js 和 Rax 这两个前端框架被广泛应用于 Weex 页面开发，同时 Weex 也对这两个前端框架提供了最完善的支持。Weex 的另一个主要目标是跟进流行的 Web 开发技术并将其和原生开发的技术结合，实现开发效率和运行性能的高度统一。在开发阶段，一个 Weex 页面就像开发普通网页一样；在运行时，Weex 页面又充分利用了各种操作系统的原生组件和能力。 概述想初步了解 Weex 其实非常简单。 安装 WeexPlayground. 在 Playground 里，你可以打开各种示例。 访问 Weex online playground. 在这个网站上，你可以浏览、修改、新建各种基于 Vue.js 的单页面例子，并用 WeexPlayground 应用扫码查看实时效果。 这里有一个使用 Weex 和 Vue.js 开发的最简单的例子。你可以大致了解 Weex 是如何工作的。 在 &lt;template&gt; 部分，包含了 &lt;div&gt; 元素，这个被广泛应用于 Web 页面中，在 Weex 里它也是一个通用的容器。&lt;text&gt;元素就和普通的 HTML 不太一样了，它提供了显示文本的能力，在 Weex 上，所有文本必须放在 &lt;text&gt; 标签中。 在 &lt;style&gt; 部分，你可以定义各种 CSS 样式。需要注意的是，这些样式在 Weex 里只能作用于当前组件，scoped。 原生组件在上面的例子中，&lt;div&gt; 和 &lt;text&gt; 在移动端上渲染出来的都是原生组件，充分利用了操作系统组件的能力与渲染速度。 Weex 提供了一套基础的内置组件。你可以对这些基础组件进行封装、组合形成自己的组件；也可以创建自己的全新组件来包装操作系统提供的地图、视频等功能。可以访问 扩展 iOS 能力 和 扩展 Android 能力来了解如何去实现自定义组件。 在框架内部，Weex 使用原生组件来渲染，并尽可能保持多平台一致性。但在不同平台上，或多或少会有一些渲染、行为上的差异。比如对于 `` 组件，在不同平台上的视觉效果是不一致的。 原生模块对于那些不依赖于 UI 组件的功能，Weex 将它们包装成多个 模块，比如 动画模块。在前端代码中，使用 weex.requireModule(&#39;xxx&#39;) 引入一个模块，之后就可以调用它提供的各种方法。Weex 模块包装了网络、存储、剪切板、导航等各种功能供前端调用。比如你可以使用 stream 模块来获取 Vue.js 的 Star 数量。 Weex 已经提供了不少内置模块，同时也支持将 App 特有的功能包装成自定义模块提供给前端调用。如果想了解怎么做，可以浏览以下文档。 扩展 Web 组件 扩展 Android 能力 扩展 iOS 能力 一次编写，处处运行Weex 的目标就是使用开发者基于一份代码，编写出可以运行在 iOS，Android 和 Web 上的应用，并最大化地提高开发效率和简化测试、构建、发布流程。 有一些场景，你可能仍然需要写一些平台相关的代码。Weex 提供 WXEnvironment 用来获取 Weex 运行的环境变量，浏览 Weex 环境变量，了解更多。 使用前端框架Weex 应用需要依赖前端框架来编写，但 Weex 并没有绑定、限制在特定的框架上。目前 Vue.js 和 Rax 是最广泛应用于 Weex 开发的前端框架，也是目前功能最全、最稳定的方案。 Vue.js 是一个不断进化中的前端框架。 Rax 是提供类 React 语法和兼容性的前端框架。 Vue.js 和 Rax 都已经集成到 Weex 中，并默认提供。 将自己喜欢的前端框架和 Weex 进行结合是可以的，但并不是那么容易。我们也在不断开发和简化这种接入工作，如果想了解如何做，或有任何想法可以和我们联系。你也可以先阅读一下 使用前端框架 这篇文档了解它是做什么的。]]></content>
      <categories>
        <category>Android</category>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Weex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通讯录获取/添加信息 AddressBook]]></title>
    <url>%2Fposts%2Fe1546149.html</url>
    <content type="text"><![CDATA[源码：AddressBook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.example.zm.addressbook;import android.content.ContentResolver;import android.content.ContentUris;import android.content.Context;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.provider.ContactsContract;import android.text.TextUtils;import android.util.Log;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.InputStream;import java.util.ArrayList;import java.util.List;public class ContactUtil &#123; /** * 获取联系人信息，并把数据转换成json数据 * * @return * @throws JSONException */ public static String getContactInfo(Context context) throws JSONException &#123; JSONObject contactData = null; JSONObject jsonObject = null; JSONArray jsonArray = null; JSONObject jsonObject2 = null; JSONArray jsonArray2 = null; contactData = new JSONObject(); jsonArray = new JSONArray(); String mimetype = ""; int oldrid = -1; int contactId = -1; // 1.查询通讯录所有联系人信息，通过id排序，我们看下android联系人的表就知道，所有的联系人的数据是由RAW_CONTACT_ID来索引开的 // 所以，先获取所有的人的RAW_CONTACT_ID Cursor cursor = context.getContentResolver().query(ContactsContract.Data.CONTENT_URI, null, null, null, ContactsContract.Data.RAW_CONTACT_ID); contactData.put("userId", "11111"); while (cursor.moveToNext()) &#123; contactId = cursor.getInt(cursor.getColumnIndex(ContactsContract.Data.RAW_CONTACT_ID)); if (oldrid != contactId) &#123; jsonObject = new JSONObject(); jsonArray2 = new JSONArray(); jsonArray.put(jsonObject); oldrid = contactId; &#125; mimetype = cursor.getString(cursor.getColumnIndex(ContactsContract.Data.MIMETYPE)); // 取得mimetype类型,扩展的数据都在这个类型里面 Bitmap headPhoto = getHighPhoto(contactId + "", context.getContentResolver()); if (null == headPhoto) &#123; jsonObject.put("headImageUrl", ""); &#125; else &#123; jsonObject.put("headImageUrl", headPhoto); &#125; // 名字 if (ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME)); String firstName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.FAMILY_NAME)); String lastname = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.StructuredName.GIVEN_NAME)); String trueName = firstName + lastname; if (TextUtils.isEmpty(trueName)) &#123; jsonObject.put("trueName", ""); &#125; else &#123; jsonObject.put("trueName", trueName); &#125; &#125; // 昵称 if (ContactsContract.CommonDataKinds.Nickname.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Nickname.DISPLAY_NAME)); String nickName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Nickname.NAME)); if (TextUtils.isEmpty(nickName)) &#123; jsonObject.put("nickName", ""); &#125; else &#123; jsonObject.put("nickName", nickName); &#125; &#125; List&lt;AddressBookMoudle.ContactBook&gt; contactList = new ArrayList&lt;AddressBookMoudle.ContactBook&gt;(); // 1.2 获取各种电话信息 if (ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; int phoneType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.TYPE)); // 手机 // 个人电话 if (phoneType == ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE) &#123; String mobile = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); AddressBookMoudle.ContactBook contactBook = new AddressBookMoudle.ContactBook(); contactBook.setContact(mobile); contactBook.setContactType("0"); contactList.add(contactBook); &#125; &#125; // Email if (ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; String mobileEmail = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Email.DATA)); AddressBookMoudle.ContactBook contactBook = new AddressBookMoudle.ContactBook(); contactBook.setContact(mobileEmail); contactBook.setContactType("1"); contactList.add(contactBook); &#125; if (contactList.size() &gt; 0) &#123; for (int i = 0; i &lt; contactList.size(); i++) &#123; jsonObject2 = new JSONObject(); jsonObject2.put("contact", contactList.get(i).getContact()); jsonObject2.put("contactType", contactList.get(i).getContactType()); jsonArray2.put(jsonObject2); &#125; jsonObject.put("contactList", jsonArray2); &#125; // 查找event地址 if (ContactsContract.CommonDataKinds.Event.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; // 取出时间类型 int eventType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Event.TYPE)); // 生日 if (eventType == ContactsContract.CommonDataKinds.Event.TYPE_BIRTHDAY) &#123; String birthday = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Event.START_DATE)); if (TextUtils.isEmpty(birthday)) &#123; jsonObject.put("birthDay", ""); &#125; else &#123; jsonObject.put("birthDay", birthday); &#125; &#125; &#125; // 获取组织信息 if (ContactsContract.CommonDataKinds.Organization.CONTENT_ITEM_TYPE.equals(mimetype)) &#123; // 取出组织类型 int orgType = cursor.getInt(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.TYPE)); // 单位 if (orgType == ContactsContract.CommonDataKinds.Organization.TYPE_CUSTOM) &#123; // if (orgType == // Organization.TYPE_WORK) // &#123; String company = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.COMPANY)); if (TextUtils.isEmpty(company)) &#123; jsonObject.put("company", ""); &#125; else &#123; jsonObject.put("company", company); &#125; String jobTitle = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.TITLE)); if (TextUtils.isEmpty(jobTitle)) &#123; jsonObject.put("jobtitle", ""); &#125; else &#123; jsonObject.put("jobtitle", jobTitle); &#125; String department = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Organization.DEPARTMENT)); if (TextUtils.isEmpty(department)) &#123; jsonObject.put("department", ""); &#125; else &#123; jsonObject.put("department", department); &#125; &#125; &#125; &#125; cursor.close(); contactData.put("addressBookList", jsonArray); Log.i("contactData", contactData.toString()); return contactData.toString(); &#125; /** * 获取联系人高清头像 * * @param people_id 联系人ID * @param cr 调用容器 * @return 联系人的高清头像 */ public static Bitmap getHighPhoto(String people_id, ContentResolver cr) &#123; Uri uri = ContentUris.withAppendedId(ContactsContract.Contacts.CONTENT_URI, Long.parseLong(people_id)); InputStream input = ContactsContract.Contacts.openContactPhotoInputStream(cr, uri, true); if (input == null) &#123; return null; &#125; return BitmapFactory.decodeStream(input); &#125;&#125; 123456789101112131415161718&#123; "userId": "11111", "addressBookList": [&#123; "headImageUrl": "", "trueName": "张三", "company": "北京xxx有限公司", "jobtitle": "研发工程师", "department": "", "contactList": [&#123; "contact": "185 0000 1234", "contactType": "0" &#125;, &#123; "contact": "zhangsan@163.com", "contactType": "1" &#125;], "birthDay": "2018-03-25" &#125;]&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_VSCode快捷键]]></title>
    <url>%2Fposts%2F550c573.html</url>
    <content type="text"><![CDATA[官方快捷键 全局 快捷键 描述 Command + Shift + P / F1 显示命令面板 Command + P 快速打开 Command + Shift + N 打开新窗口 Command + W 关闭窗口 基本 快捷键 描述 Command + X 剪切（未选中文本的情况下，剪切光标所在行） Command + C 复制（未选中文本的情况下，复制光标所在行） Option + Shift + F 格式化 Option + Up 向上移动行 Option + Down 向下移动行 Option + Shift + Up 向上复制行 Option + Shift + Down 向下复制行 Command + Shift + K 删除行 Command + Enter 下一行插入 Command + Shift + Enter 上一行插入 Command + Shift + \ 跳转到匹配的括号 Command + [ 减少缩进 Command + ] 增加缩进 Home 跳转至行首 End 跳转到行尾 Command + Up 跳转至文件开头 Command + Down 跳转至文件结尾 Ctrl + PgUp 按行向上滚动 Ctrl + PgDown 按行向下滚动 Command + PgUp 按屏向上滚动 Command + PgDown 按屏向下滚动 Command + Shift + [ 折叠代码块 Command + Shift + ] 展开代码块 Command + K Command + [ 折叠全部子代码块 Command + K Command + ] 展开全部子代码块 Command + K Command + 0 折叠全部代码块 Command + K Command + J 展开全部代码块 Command + K Command + C 添加行注释 Command + K Command + U 移除行注释 Command + / 添加、移除行注释 Option + Shift + A 添加、移除块注释 Option + Z 自动换行、取消自动换行 查找替换 快捷键 描述 Command + F 查找 Command + Option + F 替换 Command + G 查找下一个 Command + Shift + G 查找上一个 Option + Enter 选中所有匹配项 Command + D 向下选中相同内容 Command + K Command + D 移除前一个向下选中相同内容 多光标与选择 快捷键 描述 Option + 点击 插入多个光标 Command + Option + Up 向上插入光标 Command + Option + Down 向下插入光标 Command + U 撤销上一个光标操作 Option + Shift + I 在所选行的行尾插入光标 Command + I 选中当前行 Command + Shift + L 选中所有与当前选中内容相同部分 Command + F2 选中所有与当前选中单词相同的单词 Command + Ctrl + Shift + Left 折叠选中 Command + Ctrl + Shift + Right 展开选中 Alt + Shift + 拖动鼠标 选中代码块 Command + Shift + Option + Up 列选择 向上 Command + Shift + Option + Down 列选择 向下 Command + Shift + Option + Left 列选择 向左 Command + Shift + Option + Right 列选择 向右 Command + Shift + Option + PgUp 列选择 向上翻页 Command + Shift + Option + PgDown 列选择 向下翻页 进阶 快捷键 描述 Ctrl + Space 打开建议 Command + Shift + Space 参数提示 Tab Emmet 插件缩写补全 Option + Shift + F 格式化 Command + K Command + F 格式化选中内容 F12 跳转到声明位置 Option + F12 查看具体声明内容 Command + K F12 分屏查看具体声明内容 Command + . 快速修复 Shift + F12 显示引用 F2 重命名符号 Command + Shift + . 替换为上一个值 Command + Shift + , 替换为下一个值 Command + K Command + X 删除行尾多余空格 Command + K M 更改文件语言 导航 快捷键 描述 Command + T 显示所有符号 Ctrl + G 跳转至某行 Command + P 跳转到某个文件 Command + Shift + O 跳转到某个符号 Command + Shift + M 打开问题面板 F8 下一个错误或警告位置 Shift + F8 上一个错误或警告位置 Ctrl + Shift + Tab 编辑器历史记录 Ctrl + - 后退 Ctrl + Shift + - 前进 Ctrl + Shift + M Tab 切换焦点 编辑器管理 快捷键 描述 Command + W 关闭编辑器 Command + K F 关闭文件夹 Command + \ 编辑器分屏 Command + 1 切换到第一分组 Command + 2 切换到第二分组 Command + 3 切换到第三分组 Command + K Command + Left 切换到上一分组 Command + K Command + Right 切换到下一分组 Command + K Command + Shift + Left 左移编辑器 Command + K Command + Shift + Right 右移编辑器 Command + K Left 激活左侧编辑组 Command + K Right 激活右侧编辑组 文件管理 快捷键 描述 Command + N 新建文件 Command + O 打开文件 Command + S 保存文件 Command + Shift + S 另存为 Command + Option + S 全部保存 Command + W 关闭 Command + K Command + W 全部关闭 Command + Shift + T 重新打开被关闭的编辑器 Command + K Enter 保持打开 Ctrl + Tab 打开下一个 Ctrl + Shift + Tab 打开上一个 Command + K P 复制当前文件路径 Command + K R 在资源管理器中查看当前文件 Command + K O 新窗口打开当前文件 显示 快捷键 描述 Command + Ctrl + F 全屏、退出全屏 Command + Option + 1 切换编辑器分屏方式（横、竖） Command + + 放大 Command + - 缩小 Command + B 显示、隐藏侧边栏 Command + Shift + E 显示资源管理器 或 切换焦点 Command + Shift + F 显示搜索框 Ctrl + Shift + G 显示Git面板 Command + Shift + D 显示调试面板 Command + Shift + X 显示插件面板 Command + Shift + H 全局搜索替换 Command + Shift + J 显示、隐藏高级搜索 Command + Shift + C 打开新终端 Command + Shift + U 显示输出面板 Command + Shift + V Markdown预览窗口 Command + K V 分屏显示 Markdown预览窗口 调试 快捷键 描述 F9 设置 或 取消断点 F5 开始 或 继续 F11 进入 Shift + F11 跳出 F10 跳过 Command + K Command + I 显示悬停信息 集成终端 快捷键 描述 Ctrl + ` 显示终端 Ctrl + Shift + ` 新建终端 Command + Up 向上滚动 Command + Down 向下滚动 PgUp 向上翻页 PgDown 向下翻页 Command + Home 滚动到顶部 Command + End 滚动到底部]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ANR问题总结]]></title>
    <url>%2Fposts%2Fe812f6c7.html</url>
    <content type="text"><![CDATA[在实际情况中，当Android项目的用户量特别大时候，一些细小的问题也会被放大，ANR问题就是一个典型的例子。 一些ANR问题只会发生在用户实际使用的情景，当系统资源比较紧张等一些特殊情况下才会遇到，而这些ANR问题有很大一部分是因为我们的代码不合理导致，这就需要我们定位问题，修复问题，并且在以后的代码设计中尽量避免这些不合理。 最近工作中集中分析了项目的大量的用户自动上报的ANR问题日志，虽然网上ANR相关的文章已经很多了，在这里还是做一个总结。 提纲一. 什么情况下会出现ANR 二. ANR机制的原理 三. 如何分析ANR问题 四. 如何避免ANR问题 一.什么情况下会出现ANR问题：ANR(Application Not responding)。Android中，主线程(UI线程)如果在规定时内没有处理完相应工作，就会出现ANR。 具体来说，ANR会在以下几种情况中出现： 输入事件(按键和触摸事件)5s内没被处理: Input event dispatching timed out BroadcastReceiver的事件(onRecieve方法)在规定时间内没处理完(前台广播为10s，后台广播为60s)：Timeout of broadcast BroadcastRecord 07-27 19:18:47.448 1707 1766 W BroadcastQueue: Receiver during timeout: ResolveInfo{ccd831e com.example.qintong.myapplication/.MyBroadCastReciever m=0x108000} 07-27 19:18:47.502 3513 3728 I WtEventController: ANR com.example.qintong.myapplication 7573 service 前台20s后台200s未完成启动 Timeout executing service ContentProvider的publish在10s内没进行完：timeout publishing content providers 在android文档(https://developer.android.com/training/articles/perf-anr.html)中，只写了第一种和第二种情况，而根据源码和实际的实验，我们能发现service的启动和provider的publish同样会造成anr问题。 这里需要注意的是，在后三种情况，以BroadcastReviever为例，在onRecieve()方法执行10秒内没发生第一种ANR(也就是在这个过程中没有输入事件或输入事件还没到5s)才会发生Receiver timeout，否则将先发生事件无相应ANR，所以onRecieve()是有可能执行不到10s就发生ANR的，所以不要在onRecieve()方法里面干活，service的onCreate()和ContentProvider的onCreate()也一样，他们都是主线程的，不要在这些方法里干活，这个会在本文最后再细说。 二.ANR机制的实现原理：文章：http://gityuan.com/2016/07/02/android-anr/从源码角度详细的分析了ANR机制实现的原理。对于上一章讲到的1-4中情况，分别找到了其源码中是如何实现的，对于每一种大概原理如下：1.在进行相关操作调用hander.sendMessageAtTime()发送一个ANR的消息，延时时间为ANR发生的时间(如前台Service是当前时间20s之后)。2.进行相关的操作3.操作结束后向remove掉该条message。如果相关的操作在规定时间没有执行完成，该条message将被handler取出并执行，就发生了ANR。 下面以BroadcastReceiver为例详细介绍： BroadcastQueue.processNextBroadcast() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 final void processNextBroadcast(boolean fromMsg) &#123; ... synchronized (mService) &#123; ... do &#123; if (mOrderedBroadcasts.size() == 0) &#123; ... if (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123; long now = SystemClock.uptimeMillis(); if ((numReceivers &gt; 0) &amp;&amp; (now &gt; r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) &#123; //1.发送延时消息 broadcastTimeoutLocked(false); // forcibly finish this broadcast forceReceive = true; r.state = BroadcastRecord.IDLE; &#125; &#125; if (r.state != BroadcastRecord.IDLE) &#123; if (DEBUG_BROADCAST) Slog.d(TAG, "processNextBroadcast(" + mQueueName + ") called when not idle (state=" + r.state + ")"); return; &#125; if (r.receivers == null || r.nextReceiver &gt;= numReceivers || r.resultAbort || forceReceive) &#123; // No more receivers for this broadcast! Send the final // result if requested... if (r.resultTo != null) &#123; try &#123; //2. 处理广播消息 performReceiveLocked(r.callerApp, r.resultTo, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, false, false, r.userId); // Set this to null so that the reference // (local and remote) isn't kept in the mBroadcastHistory. r.resultTo = null; &#125; catch (RemoteException e) &#123; ... &#125; &#125; //3.取消延时消息 cancelBroadcastTimeoutLocked(); ... &#125; &#125; while (r == null) ; ... &#125; &#125;&#125; 1.发送延时消息：broadcastTimeoutLocked(false)： 123456789101112131415161718192021final void broadcastTimeoutLocked(boolean fromMsg) &#123;... long now = SystemClock.uptimeMillis(); if (fromMsg) &#123; if (mService.mDidDexOpt) &#123; // Delay timeouts until dexopt finishes. mService.mDidDexOpt = false; long timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod; setBroadcastTimeoutLocked(timeoutTime); return; &#125; if (!mService.mProcessesReady) &#123; return; &#125; long timeoutTime = r.receiverTime + mTimeoutPeriod; if (timeoutTime &gt; now) &#123; setBroadcastTimeoutLocked(timeoutTime); return; &#125; &#125; 他调用了setBroadcastTimeoutLocked(long timeoutTime): 1234567final void setBroadcastTimeoutLocked(long timeoutTime) &#123; if (! mPendingBroadcastTimeoutMessage) &#123; Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this); mHandler.sendMessageAtTime(msg, timeoutTime); mPendingBroadcastTimeoutMessage = true; &#125;&#125; 传入setBroadcastTimeoutLocked(long timeoutTime)的时间xxx + mTimeoutPeriod，mTimeoutPeriod就是onRecieve()可以执行的时间，在BroadcastQueue初始化时候被赋值，前台队列为10s后台队列为60s： ActivityManagerService.java: 1234567891011public ActivityManagerService(Context systemContext) &#123; ... static final int BROADCAST_FG_TIMEOUT = 10 * 1000; static final int BROADCAST_BG_TIMEOUT = 60 * 1000; ... mFgBroadcastQueue = new BroadcastQueue(this, mHandler, "foreground", BROADCAST_FG_TIMEOUT, false); mBgBroadcastQueue = new BroadcastQueue(this, mHandler, "background", BROADCAST_BG_TIMEOUT, true); ...&#125; performReceiveLocked()为广播的实际处理，就不展开了 cancelBroadcastTimeoutLocked() ： 该方法的主要工作是当service启动完成，则移除服务超时消息SERVICE_TIMEOUT_MSG。 123456final void cancelBroadcastTimeoutLocked() &#123; if (mPendingBroadcastTimeoutMessage) &#123; mHandler.removeMessages(BROADCAST_TIMEOUT_MSG, this); mPendingBroadcastTimeoutMessage = false; &#125;&#125; 三.如何分析ANR问题：从前文可以明确，ANR问题是由于主线程的任务在规定时间内没处理完任务，而造成这种情况的原因大致会有一下几点： 主线程在做一些耗时的工作 主线程被其他线程锁 cpu被其他进程占用，该进程没被分配到足够的cpu资源。 判断一个ANR属于哪种情况便是分析ANR问题的关键。那么拿到一个anr的日志，应该如何分析呢？ 在发生ANR的时候，系统会收集ANR相关的信息提供给开发者：首先在Log中有ANR相关的信息，其次会收集ANR时的CPU使用情况，还会收集trace信息，也就是当时各个线程的执行情况。trace文件保存到了/data/anr/traces.txt中，此外，ANR前后该进程打印出的log也有一定价值。一般来说可以按一下思路来分析： 从log中找到ANR反生的信息：可以从log中搜索“ANR in”或“am_anr”，会找到ANR发生的log，该行会包含了ANR的时间、进程、是何种ANR等信息，如果是BroadcastReceiver的ANR可以怀疑BroadCastReceiver.onRecieve()的问题，如果的Service或Provider就怀疑是否其onCreate()的问题。 在该条log之后会有CPU usage的信息，表明了CPU在ANR前后的用量（log会表明截取ANR的时间），从各种CPU Usage信息中大概可以分析如下几点： (1). 如果某些进程的CPU占用百分比较高，几乎占用了所有CPU资源，而发生ANR的进程CPU占用为0%或非常低，则认为CPU资源被占用，进程没有被分配足够的资源，从而发生了ANR。这种情况多数可以认为是系统状态的问题，并不是由本应用造成的。 (2). 如果发生ANR的进程CPU占用较高，如到了80%或90%以上，则可以怀疑应用内一些代码不合理消耗掉了CPU资源，如出现了死循环或者后台有许多线程执行任务等等原因，这就要结合trace和ANR前后的log进一步分析了。 (3). 如果CPU总用量不高，该进程和其他进程的占用过高，这有一定概率是由于某些主线程的操作就是耗时过长，或者是由于主进程被锁造成的。 除了上述的情况(1)以外，分析CPU usage之后，确定问题需要我们进一步分析trace文件。trace文件记录了发生ANR前后该进程的各个线程的stack。对我们分析ANR问题最有价值的就是其中主线程的stack，一般主线程的trace可能有如下几种情况： (1). 主线程是running或者native而对应的栈对应了我们应用中的函数，则很有可能就是执行该函数时候发生了超时。 (2). 主线程被block:非常明显的线程被锁，这时候可以看是被哪个线程锁了，可以考虑优化代码。如果是死锁问题，就更需要及时解决了。 (3). 由于抓trace的时刻很有可能耗时操作已经执行完了（ANR -&gt; 耗时操作执行完毕 -&gt;系统抓trace），这时候的trace就没有什么用了，主线程的stack就是这样的： 123456789101112131415161718192021"main" prio=5 tid=1 Native | group="main" sCount=1 dsCount=0 obj=0x757855c8 self=0xb4d76500 | sysTid=3276 nice=0 cgrp=default sched=0/0 handle=0xb6ff5b34 | state=S schedstat=( 50540218363 186568972172 209049 ) utm=3290 stm=1764 core=3 HZ=100 | stack=0xbe307000-0xbe309000 stackSize=8MB | held mutexes= kernel: (couldn't read /proc/self/task/3276/stack) native: #00 pc 0004099c /system/lib/libc.so (__epoll_pwait+20) native: #01 pc 00019f63 /system/lib/libc.so (epoll_pwait+26) native: #02 pc 00019f71 /system/lib/libc.so (epoll_wait+6) native: #03 pc 00012ce7 /system/lib/libutils.so (_ZN7android6Looper9pollInnerEi+102) native: #04 pc 00012f63 /system/lib/libutils.so (_ZN7android6Looper8pollOnceEiPiS1_PPv+130) native: #05 pc 00086abd /system/lib/libandroid_runtime.so (_ZN7android18NativeMessageQueue8pollOnceEP7_JNIEnvP8_jobjecti+22) native: #06 pc 0000055d /data/dalvik-cache/arm/system@framework@boot.oat (Java_android_os_MessageQueue_nativePollOnce__JI+96) at android.os.MessageQueue.nativePollOnce(Native method) at android.os.MessageQueue.next(MessageQueue.java:323) at android.os.Looper.loop(Looper.java:138) at android.app.ActivityThread.main(ActivityThread.java:5528) at java.lang.reflect.Method.invoke!(Native method) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:740) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:630) 当然这种情况很有可能是由于该进程的其他线程消耗掉了CPU资源，这就需要分析其他线程的trace以及ANR前后该进程自己输出的log了。 四.如何降低ANR的概率：有一些操作是很危险的，非常容易发生ANR，在写代码时候一定要避免： 主线程读取数据：在Android中主线程去读取数据是非常不好的，Android是不允许主线程从网络读数据的，但系统允许主线程从数据库或者其他地方获取数据，但这种操作ANR风险很大，也会造成掉帧等，影响用户体验。 （1）. 避免在主线程query provider，首先这会比较耗时，另外这个操作provider那一方的进程如果挂掉了或者正在启动，我们应用的query就会很长时间不会返回，我们应该在其他线程中执行数据库query、provider的query等获取数据的操作。 （2）. sharePreference的调用：针对sharePreference的优化点有很多，文章http://weishu.me/2016/10/13/sharedpreference-advices/ 详细介绍了几点sharepreference使用时候的注意事项。首先sharePreference的commit()方法是同步的，apply()方法一般是异步执行的。所以在主线程不要用其commit()，用apply()替换。其次sharePreference的写是全量写而非增量写，所以尽量都修改完同一apply，避免改一点apply一次(apply()方法在Activity stop的时候主线程会等待写入完成，提交多次就很容易卡)。并且存储文本也不宜过大，这样会很慢。另外，如果写入的是json或者xml，由于需要加和删转义符号，速度会比较慢。 不要在broadcastReciever的onRecieve()方法中干活，这一点很容易被忽略，尤其应用在后台的时候。为避免这种情况，一种解决方案是直接开的异步线程执行，但此时应用可能在后台，系统优先级较低，进程很容易被系统杀死，所以可以选择开个IntentService去执行相应操作，即使是后台Service也会提高进程优先级，降低被杀可能性。 各个组件的生命周期函数都不应该有太耗时的操作，即使对于后台Service或者ContentProvider来讲，应用在后台运行时候其onCreate()时候不会有用户输入引起事件无响应ANR，但其执行时间过长也会引起Service的ANR和ContentProvider的ANR。 尽量避免主线程的被锁的情况，在一些同步的操作主线程有可能被锁，需要等待其他线程释放相应锁才能继续执行，这样会有一定的ANR风险，对于这种情况有时也可以用异步线程来执行相应的逻辑。另外， 我们要避免死锁的发生(主线程被死锁基本就等于要发生ANR了)。]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_SDK版本号与APILevel的对应关系]]></title>
    <url>%2Fposts%2F46f6283e.html</url>
    <content type="text"><![CDATA[一、Android各版本对应的SDK版本 平台版本 API VERSION_CODE 备注 Android 9.0 28 Android P Preview（9.0） 平台亮点 Android 8.1 27 Oreo（8.1） 平台亮点 Android 8.0 26 Oreo（8.0） 平台亮点 Android 7.1 25 Nougat（牛轧糖） 平台亮点 Android 7.0 24 N（牛轧糖） 平台亮点 Android 6.0 23 M（棉花糖） 平台亮点 Android 5.1 22 LOLLIPOP_MR1（棒棒糖） 平台亮点 Android 5.0 21 LOLLIPOP （棒棒糖） Android 4.4W 20 KITKAT_WATCH（奇巧巧克力） 仅限 KitKat for Wearables Android 4.4 19 KITKAT （奇巧巧克力） 平台亮点 Android 4.3 18 JELLY_BEAN_MR2（果冻豆） 平台亮点 Android 4.2、4.2.2 17 JELLY_BEAN_MR1（果冻豆） 平台亮点 Android 4.1、4.1.1 16 JELLY_BEAN （果冻豆） 平台亮点 Android 4.0.3、4.0.4 15 ICE_CREAM_SANDWICH_MR1（冰激凌三明治） 平台亮点 Android 4.0、4.0.1、4.0.2 14 ICE_CREAM_SANDWICH（冰激凌三明治） Android 3.2 13 HONEYCOMB_MR2 （蜂巢） Android 3.1.x 12 HONEYCOMB_MR1（蜂巢） 平台亮点 Android 3.0.x 11 HONEYCOMB （蜂巢） 平台亮点 Android 2.3.4 Android 2.3.3 10 GINGERBREAD_MR1（姜饼） 平台亮点 Android 2.3.2 Android 2.3.1 Android 2.3 9 GINGERBREAD（姜饼） Android 2.2.x 8 FROYO（冻酸奶） 平台亮点 Android 2.1.x 7 ECLAIR_MR1 （埃克拉） 平台亮点 Android 2.0.1 6 ECLAIR_0_1（埃克拉） Android 2.0 5 ECLAIR（埃克拉） Android 1.6 4 DONUT（甜甜圈） 平台亮点 Android 1.5 3 CUPCAKE（纸杯蛋糕） 平台亮点 Android 1.1 2 BASE_1_1 Android 1.0 1 BASE 二、Android各版本的市场占有率和对应JDK版本 Version Codename API Distribution 2.3.3 - 2.3.7 Gingerbread 10 0.3% 4.0.3 - 4.0.4 Ice Cream Sandwich 15 0.4% 4.1.x Jelly Bean 16 1.5% 4.2.x Jelly Bean 17 2.2% 4.3 Jelly Bean 18 0.6% 4.4 KitKat 19 10.3% 5.0 Lollipop 21 4.8% 5.1 Lollipop 22 17.6% 6.0 Marshmallow 23 25.5% 7.0 Nougat 24 22.9% 7.1 Nougat 25 8.2% 8.0 Oreo 26 4.9% 8.1 Oreo 27 0.8% 以 7 天为周期收集的数据（截止于 2018 年 1 月 8 日）。 未显示任何分布份额不足 0.1% 的版本。 三、屏幕尺寸和密度 ldpi mdpi tvdpi hdpi xhdpi xxhdpi Total Small 0.4% 0.1% 0.5% Normal 0.9% 0.3% 27.3% 39.3% 23.3% 91.1% Large 2.4% 1.5% 0.4% 0.7% 0.5% 5.5% Xlarge 1.8% 0.6% 0.5% 2.9% Total 0.4% 5.1% 1.8% 28.3% 40.5% 23.9% 以 7 天为周期收集的数据（截止于 2018 年 1 月 8 日）。 未显示任何分布份额不足 0.1% 的屏幕配置。 数据来源：Android信息中心]]></content>
      <categories>
        <category>Android</category>
        <category>Android Tips</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SDK</tag>
        <tag>API</tag>
        <tag>Android Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2Fposts%2F423abe9e.html</url>
    <content type="text"><![CDATA[常用git命令切换到git路径 1$ cd &lt;folder&gt; git命令 描述 git branch 查看本地分支 git branch -r 查看远程分支 git branch zm-develop 建立本地分支 git push origin zm-develop:zm-develop 将本地新的分支推送到git远程分支 git fetch origin zm-develop:zm-develop 拉取远程分支并创建本地分支 git fetch origin zm-develop:zm-develop 拉取远程分支并创建本地分支 git checkout zm-develop 切换到本地分支 git remote -v 查看当前在哪一个远程仓库 git branch -d zm-develop 删除分支zm-develop git config –list 查看配置信息 git status 查看项目状态信息 git log 查看提交日志 git reset –hard commit_id 完成撤销,同时将代码恢复到前一commit_id 对应的版本 git reset commit_id 完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[版本号比较versionCompare]]></title>
    <url>%2Fposts%2Fd2f8db9f.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 版本号比较versionCompare方法，java实现 * if v1 &gt; v2 , return 1; * if v1 &lt; v2 , return 2; * if equal , return 0; * input error ,return -1; */public class Test &#123; public static void main(String[] versions) &#123; int result1 = versionCompare("0.1.5", "0.1.5"); System.out.print("resultCode1:" + result1); int result2 = versionCompare("0.2.5", "0.1.5"); System.out.print("resultCode1:" + result2); int result3 = versionCompare("0.1.4", "0.1.5"); System.out.print("resultCode1:" + result3); int result4 = versionCompare("0.1.5c测试", "0.1.5"); System.out.print("resultCode1:" + result4); &#125; public static int versionCompare(String v1, String v2) &#123; Pattern pattern = Pattern.compile("\\d+(\\.\\d+)*"); if (!pattern.matcher(v1).matches() || !pattern.matcher(v2).matches()) &#123; return -1; &#125; String[] str1 = v1.split("\\."); String[] str2 = v2.split("\\."); int length = str1.length &lt; str2.length ? str1.length : str2.length; for (int i = 0; i &lt; length; i++) &#123; int diff = Integer.valueOf(str1[i]) - Integer.valueOf(str2[i]); if (diff == 0) &#123; continue; &#125; else &#123; return diff &gt; 0 ? 1 : 2; &#125; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>代码片段</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android颜色透明度设置]]></title>
    <url>%2Fposts%2F54d6d461.html</url>
    <content type="text"><![CDATA[颜色简介Android中的颜色值通常遵循RGB/ARGB标准，使用时通常以“#”字符开头，以16进制表示。常用的颜色值格式为： #RGB #ARGB #RRGGBB #AARRGGBB其中，ARGB 依次代表透明度（alpha）、红色(red)、绿色(green)、蓝色(blue)。以颜色值 #FF99CC00 为例，FF 是透明度，99 是红色值， CC 是绿色值， 00 是蓝色值。透明度 透明度分为256阶（0-255），计算机上用16进制表示为（00-ff）。透明就是0阶，不透明就是255阶,如果50%透明就是127阶（256的一半当然是128，但因为是从0开始，所以实际上是127）。 透明度 和 不透明度 是两个概念， 它们加起来是1，或者100%. ARGB 中的透明度alpha，表示的是不透明度。 如何换算 UI给出的颜色是#FFFFFF，透明度为40%。 换算过程： 将透明度转换成不透明度(转换方式参考“透明度”，第2条) 。不透明度为60% 不透明度乘以255。 我们得到结果：153 将计算结果转换成16进制。得到最终的不透明度：99 将不透明度和颜色值拼接成ARGB格式。得到最终的颜色值： #99FFFFFF 干货 说明：半透明颜色值不同于平时使用的颜色，半透明颜色值共8位，前2位是透明度，后6位是颜色。 参数 透明度 16进制表示 不透明 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 半透明 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 全透明 0% 00 举例： 全透明：#00000000 半透明：#80000000 不透明：#FF000000 白色半透明：#80FFFFFF 红色30%透明：#4Dca0d0d]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>color</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_iTerm2命令行工具]]></title>
    <url>%2Fposts%2Fc16bcf6c.html</url>
    <content type="text"><![CDATA[下载地址item 实用命令 多窗口切换 command + T 同个窗口横向分屏 command + d 同个窗口，竖向分屏 command + shift + d 搜索 command + f 直接打开文件 按住command键并点击文件名 自动复制 直接双击需要复制的文字，即可自动复制]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
        <tag>iTem2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_OSX快捷键以及命令行]]></title>
    <url>%2Fposts%2F81828d81.html</url>
    <content type="text"><![CDATA[Mac OSX 快捷键 快捷键 描述 ctrl+shift 快速放大dock的图标会暂时放大，而如果你开启了dock放大 Command+Option+W 将所有窗口关闭 Command+W 将当前窗口关闭(可以关闭Safari标签栏,很实用) Command+Option+M 将所有窗口最小化 Command+Q 关闭当前应用程序(相当于Dock鼠标右键推出.很实用) Command+M 将目前使用的窗口最小化 Command+H 隐藏当前窗口或者软件 Command＋tab 为切换当前工作任务 Control＋Command＋S 切换控制条的显示和隐藏 Command＋i 常规信息（显示及设置图标属性） Command＋delete 移到废纸篓（删除） Optionion+鼠标 拖图像或文件夹可以将图像或文件夹拷贝到其它文件夹中，而不是移动 Command+Shift+backspace 清空废纸篓(再加上option一起按能跳过确认对话框) Command+N 键可以建立新文件夹 “return”或“enter”或“O”键可以打开所选项目 Command+Option+esc 键可以强行退出死机程序 Command+Shift+3 截图(当前屏幕) Command+Shift+4 截图(自由选取范围) Option＋F12 关机窗口(能选择关机、重起、睡眠) Command+1 以图标方式显示 Command+2 以分栏方式显示 Command+3 以列表方式显示 Command+4 以Cover Flow方式显示 return或enter 键可以编辑所选图像或文件夹的名称 Mac OSX 命令行目录操作命令名 |功能描述 |使用举例—|:–: |mkdir | 创建一个目录 | mkdir dirnamermdir | 删除一个目录 | rmdir dirnamemvdir | 移动或重命名一个目录 | mvdir dir1 dir2cd | 改变当前目录 | cd dirnamepwd | 显示当前目录的路径名 | pwdls | 显示当前目录的内容 | ls -la 文件操作命令名 |功能描述 |使用举例—|:–: |cat | 显示或连接文件 | cat filenameod | 显示非文本文件的内容 | od -c filenamecp | 复制文件或目录 | cp file1 file2rm | 删除文件或目录 | rm filenamemv | 改变文件名或所在目录 | mv file1 file2find | 使用匹配表达式查找文件 | find . -name “*.c” -printfile | 显示文件类型 | file filename 选择操作命令名 |功能描述 |使用举例—|:–: |head | 显示文件的最初几行 | head -20 filenametail | 显示文件的最后几行 | tail -15 filenamecut | 显示文件每行中的某些域 | cut -f1,7 -d: /etc/passwdcolrm | 从标准输入中删除若干列 | colrm 8 20 file2diff | 比较并显示两个文件的差异 | diff file1 file2sort | 排序或归并文件 | sort -d -f -u file1uniq | 去掉文件中的重复行 | uniq file1 file2comm | 显示两有序文件的公共和非公共行 | comm file1 file2wc | 统计文件的字符数、词数和行数 | wc filenamenl | 给文件加上行号 | nl file1 &gt;file2 进程操作命令名 |功能描述 |使用举例—|:–: |ps | 显示进程当前状态 | ps ukill | 终止进程 | kill -9 30142 时间操作命令名 |功能描述 |使用举例—|:–: |date | 显示系统的当前日期和时间 | datecal | 显示日历 | cal 8 1996time | 统计程序的执行时间 | time a.out 网络与通信操作命令名 |功能描述 |使用举例—|:–: |telnet | 远程登录 | telnet hpc.sp.net.edu.cnrlogin | 远程登录 | rlogin hostname -l usernamersh | 在远程主机执行指定命令 | rsh f01n03 dateftp | 在本地主机与远程主机之间传输文件 | ftpftp.sp.net.edu.cnrcp | 在本地主机与远程主机 之间复制文件 | rcp file1 host1:file2ping | 给一个网络主机发送 回应请求 | ping hpc.sp.net.edu.cnmail | 阅读和发送电子邮件 | mailwrite | 给另一用户发送报文 | write username pts/1mesg | 允许或拒绝接收报文 | mesg n Korn Shell 命令命令名 |功能描述 |使用举例—|:–: |history | 列出最近执行过的 几条命令及编号 | historyr | 重复执行最近执行过的 某条命令 | r -2alias | 给某个命令定义别名 | alias del=rm -iunalias | 取消对某个别名的定义 | unalias del 其它命令命令名 |功能描述 |使用举例—|:–: |uname | 显示操作系统的有关信息 | uname -aclear | 清除屏幕或窗口内容 | clearenv | 显示当前所有设置过的环境变量 | envwho | 列出当前登录的所有用户 | whowhoami | 显示当前正进行操作的用户名 | whoamitty | 显示终端或伪终端的名称 | ttystty | 显示或重置控制键定义 | stty -adu | 查询磁盘使用情况 | du -k subdirdf /tmp | 显示文件系统的总空间和可用空间w | 显示当前系统活动的总信息]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端快捷键]]></title>
    <url>%2Fposts%2Fc7dcd830.html</url>
    <content type="text"><![CDATA[常用的快捷键 快捷键 描述 Ctrl + a 跳到行首 Ctrl + e 跳到行尾 Ctrl + b 光标往回(Backward)移动一个字符位置 Ctrl + c 取消当前行输入的命令 Ctrl + d 删除一个字符，相当于通常的Delete键 Ctrl + f 光标向前(Forward)移动一个字符位置 Ctrl + h 退格删除一个字符，相当于通常的Backspace键 Ctrl + k 删除光标之前到行尾的字符 Ctrl + l 清屏，相当于执行clear命令 Ctrl + u 删除光标之前到行首的字符 Ctrl + p 调出命令历史中的前一条（Previous）命令，相当于通常的上箭头 Ctrl + n 调出命令历史中的下一条（Next）命令，相当于通常的上箭头 Ctrl + r 显示：号提示，根据用户输入查找相关历史命令 Ctrl + w 删除从光标位置前到当前所处单词（Word）的开头 Ctrl + y 粘贴最后一次被删除的单词 Alt + d 删除从光标位置到当前所处单词的末尾 Command + K 清屏 Command + T 新建标签 Command +W 关闭当前标签页 Command + S 保存终端输出 Command + D 垂直分水平分隔当前标签页 Command + shift + {或} 向左/向右切换标签]]></content>
      <categories>
        <category>快捷键</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改NexT_Pisces主题内容区宽度]]></title>
    <url>%2Fposts%2F88baa841.html</url>
    <content type="text"><![CDATA[默认的宽度觉得有点窄，想改宽一点，手动修改样式在source/css/_schemes/Picses/_layout.styl文件末尾添加如下代码。 12345678910111213141516171819202122232425262728293031323334// 以下为新增代码header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125;]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建博客]]></title>
    <url>%2Fposts%2Feb656981.html</url>
    <content type="text"><![CDATA[准备工作 Hexo：快速、简洁且高效的博客框架,官网有中文文档 NexT：Hexo 适用的主题 LeanCloud：数据库(可不用) GitHub：博客就发布在 GitPage 安装&amp;配置 Hexo安装 Hexo全局安装 Hexo 官方的脚手架 1$ npm install -g hexo-cli 然后初始化博客，并安装依赖包 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install &lt;folder&gt; 就是博客的本地文件夹 配置 Hexo网站配置： /_config.yml 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区(默认为电脑时区) avatar(此参数需自己添加) 网站头像地址 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的链接格式 :year/:month/:day/:title/ 网站存放在子目录如果您的网站存放在子目录中，例如http://yoursite.com/blog，则请将您的 url 设为http://yoursite.com/blog 并把root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public _posts_dir 默认文件夹，这个文件夹用于存放生成的站点文件。 _posts tag_dir 标签文件夹 tags category_dir 分类文件夹 categories archive_dir 归档文件夹 archives about_dir 关于我们文件夹 about CNAME 域名文件(zhangmiao.space) code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为 false 时禁用主题 deploy 部署部分的设置 更多网站参数参考：https://hexo.io/zh-cn/docs/configuration.html 添加站内搜索安装 hexo-generator-searchdb 1$ npm install hexo-generator-searchdb --save 网站配置： /_config.yml 新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 测试 Hexo新建文章运行命令新建一篇文章 1$ hexo new [layout] &lt;title&gt; 启动服务123$ hexo server 或$ hexo s 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 启动服务器。默认情况下，访问网址为：http://localhost:4000/。 部署网站123$ hexo deploy 或$ $ hexo d 选项 描述 -g, –generate 部署之前预先生成静态文件 清除1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 更多命令参考：https://hexo.io/zh-cn/docs/commands.html 安装&amp;配置 NexT 主题安装 NexT 主题使用 git 克隆最新版本 12$ cd &lt;folder&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 或者直接将 hexo-theme-next 下载下来放到 Hexo 站点目录下的 [themes/next] 目录中 启用 NexT 主题网站配置： /_config.yml搜索theme关键字，并将其值更改为 next 1theme: next 验证 NexT 主题 最好先使用 hexo clean 清除 Hexo 的缓存。 运行 hexo server 启动本地站点。此时即可使用浏览器访问 http://localhost:4000 ，检查站点是否正确运行。 主题设定主题配置： /theme/next/_config.yml搜索scheme 关键字，选择使用的主题样式，将你需用启用的 scheme 前面注释 # 去掉并将其他两个 scheme 加上注释即可。 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 123#scheme: Muse#scheme: Mistscheme: Pisces 设置 菜单主题配置： /theme/next/_config.yml 搜索 menu 关键字 设置 头像主题配置： /theme/next/_config.yml 新增字段avatar,值设置成头像的链接地址 设置 作者名称主题配置： /theme/next/_config.yml 搜索 author 关键字 设置 描述主题配置： /theme/next/_config.yml 搜索 description 关键字 设置 首页列表是否显示 阅读更多主题配置： /theme/next/_config.yml 搜索auto_excerpt 关键字 将 enable 设置为true length 设置为期望截取保留的文章长度 集成第三方服务主题配置： /theme/next/_config.yml 参考：http://theme-next.iissnan.com/third-party-services.html 创建 GitHub创建好账号之后，先创建一个仓库New repository进入 Settings ，找到下方的 GitHub Pages ，点击Choose a theme选择主题（这个无所谓，最后都会被替换），Source指向的就是 GitPage 站点所在的分支。 GitHub 会给分配一个二级域名，GitHub 昵称+github.io 部署网站安装hexo-deployer-git 1$ npm install hexo-deployer-git --save 配置网站配置： /_config.yml 搜索 deploy 关键字 type：git repo：github 提交地址 branch：提交分支 部署123$ hexo deploy 或$ hexo d 如果想在部署之前预先生成下静态文件，可以使用： 123$ hexo deploy -g 或$ hexo d --generate $ hexo deploy -g与$ hexo generate -d的效果其实是相同的 本地站点不要放在 Git 上，否则执行 deploy 的时候会把本地站点提交上去]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
